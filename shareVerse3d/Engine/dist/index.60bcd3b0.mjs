var CV = Object.defineProperty;
var TV = (n, e, t) => e in n ? CV(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var V = (n, e, t) => (TV(n, typeof e != "symbol" ? e + "" : e, t), t);
import Gt, { useState as Yr, useEffect as Tv, useRef as zr, useMemo as KM, useLayoutEffect as In, useContext as cy } from "react";
import SL from "react-dom";
const ML = -1, uy = 0, fb = 1, pb = 2, JM = 3, QM = 4, eE = 5, tE = 6, EL = 7, CL = 8, CT = typeof self == "object" ? self : globalThis, PV = (n, e) => {
  const t = (r, s) => (n.set(s, r), r), i = (r) => {
    if (n.has(r))
      return n.get(r);
    const [s, o] = e[r];
    switch (s) {
      case uy:
      case ML:
        return t(o, r);
      case fb: {
        const a = t([], r);
        for (const l of o)
          a.push(i(l));
        return a;
      }
      case pb: {
        const a = t({}, r);
        for (const [l, c] of o)
          a[i(l)] = i(c);
        return a;
      }
      case JM:
        return t(new Date(o), r);
      case QM: {
        const { source: a, flags: l } = o;
        return t(new RegExp(a, l), r);
      }
      case eE: {
        const a = t(/* @__PURE__ */ new Map(), r);
        for (const [l, c] of o)
          a.set(i(l), i(c));
        return a;
      }
      case tE: {
        const a = t(/* @__PURE__ */ new Set(), r);
        for (const l of o)
          a.add(i(l));
        return a;
      }
      case EL: {
        const { name: a, message: l } = o;
        return t(new CT[a](l), r);
      }
      case CL:
        return t(BigInt(o), r);
      case "BigInt":
        return t(Object(BigInt(o)), r);
    }
    return t(new CT[s](o), r);
  };
  return i;
}, TT = (n) => PV(/* @__PURE__ */ new Map(), n)(0), Zh = "", { toString: AV } = {}, { keys: RV } = Object, Jp = (n) => {
  const e = typeof n;
  if (e !== "object" || !n)
    return [uy, e];
  const t = AV.call(n).slice(8, -1);
  switch (t) {
    case "Array":
      return [fb, Zh];
    case "Object":
      return [pb, Zh];
    case "Date":
      return [JM, Zh];
    case "RegExp":
      return [QM, Zh];
    case "Map":
      return [eE, Zh];
    case "Set":
      return [tE, Zh];
  }
  return t.includes("Array") ? [fb, t] : t.includes("Error") ? [EL, t] : [pb, t];
}, R0 = ([n, e]) => n === uy && (e === "function" || e === "symbol"), kV = (n, e, t, i) => {
  const r = (o, a) => {
    const l = i.push(o) - 1;
    return t.set(a, l), l;
  }, s = (o) => {
    if (t.has(o))
      return t.get(o);
    let [a, l] = Jp(o);
    switch (a) {
      case uy: {
        let d = o;
        switch (l) {
          case "bigint":
            a = CL, d = o.toString();
            break;
          case "function":
          case "symbol":
            if (n)
              throw new TypeError("unable to serialize " + l);
            d = null;
            break;
          case "undefined":
            return r([ML], o);
        }
        return r([a, d], o);
      }
      case fb: {
        if (l)
          return r([l, [...o]], o);
        const d = [], p = r([a, d], o);
        for (const m of o)
          d.push(s(m));
        return p;
      }
      case pb: {
        if (l)
          switch (l) {
            case "BigInt":
              return r([l, o.toString()], o);
            case "Boolean":
            case "Number":
            case "String":
              return r([l, o.valueOf()], o);
          }
        if (e && "toJSON" in o)
          return s(o.toJSON());
        const d = [], p = r([a, d], o);
        for (const m of RV(o))
          (n || !R0(Jp(o[m]))) && d.push([s(m), s(o[m])]);
        return p;
      }
      case JM:
        return r([a, o.toISOString()], o);
      case QM: {
        const { source: d, flags: p } = o;
        return r([a, { source: d, flags: p }], o);
      }
      case eE: {
        const d = [], p = r([a, d], o);
        for (const [m, v] of o)
          (n || !(R0(Jp(m)) || R0(Jp(v)))) && d.push([s(m), s(v)]);
        return p;
      }
      case tE: {
        const d = [], p = r([a, d], o);
        for (const m of o)
          (n || !R0(Jp(m))) && d.push(s(m));
        return p;
      }
    }
    const { message: c } = o;
    return r([a, { name: l, message: c }], o);
  };
  return s;
}, PT = (n, { json: e, lossy: t } = {}) => {
  const i = [];
  return kV(!(e || t), !!e, /* @__PURE__ */ new Map(), i)(n), i;
}, LV = typeof structuredClone == "function" ? (n, e) => e && ("json" in e || "lossy" in e) ? TT(PT(n, e)) : structuredClone(n) : (n, e) => TT(PT(n, e)), Bs = (n, e, t) => n[e] = t;
"structuredClone" in window || Bs(window, "structuredClone", LV);
function DV(n) {
  if (n = Math.trunc(n) || 0, n < 0 && (n += this.length), !(n < 0 || n >= this.length))
    return this[n];
}
const IV = Reflect.getPrototypeOf(Int8Array);
for (const n of [Array, String, IV])
  "at" in n.prototype || Object.defineProperty(n.prototype, "at", {
    value: DV,
    writable: !0,
    enumerable: !1,
    configurable: !0
  });
var sl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function OV(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var lr = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(n, e) {
  (function() {
    var t, i = "4.17.21", r = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", a = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", c = 500, d = "__lodash_placeholder__", p = 1, m = 2, v = 4, b = 1, x = 2, y = 1, S = 2, C = 4, M = 8, T = 16, P = 32, D = 64, I = 128, k = 256, O = 512, B = 30, Y = "...", G = 800, K = 16, A = 1, J = 2, xe = 3, se = 1 / 0, oe = 9007199254740991, Q = 17976931348623157e292, ce = 0 / 0, te = 4294967295, ee = te - 1, Re = te >>> 1, ye = [
      ["ary", I],
      ["bind", y],
      ["bindKey", S],
      ["curry", M],
      ["curryRight", T],
      ["flip", O],
      ["partial", P],
      ["partialRight", D],
      ["rearg", k]
    ], Se = "[object Arguments]", Ee = "[object Array]", gt = "[object AsyncFunction]", qe = "[object Boolean]", Ze = "[object Date]", je = "[object DOMException]", st = "[object Error]", Ie = "[object Function]", Le = "[object GeneratorFunction]", L = "[object Map]", fe = "[object Number]", ae = "[object Null]", $ = "[object Object]", j = "[object Promise]", re = "[object Proxy]", Te = "[object RegExp]", Ce = "[object Set]", F = "[object String]", U = "[object Symbol]", he = "[object Undefined]", me = "[object WeakMap]", Ae = "[object WeakSet]", Ve = "[object ArrayBuffer]", $e = "[object DataView]", Me = "[object Float32Array]", lt = "[object Float64Array]", Ye = "[object Int8Array]", ht = "[object Int16Array]", Xe = "[object Int32Array]", Mt = "[object Uint8Array]", At = "[object Uint8ClampedArray]", Bt = "[object Uint16Array]", pe = "[object Uint32Array]", ot = /\b__p \+= '';/g, De = /\b(__p \+=) '' \+/g, tt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Qe = /&(?:amp|lt|gt|quot|#39);/g, Ft = /[&<>"']/g, An = RegExp(Qe.source), Hn = RegExp(Ft.source), es = /<%-([\s\S]+?)%>/g, Sn = /<%([\s\S]+?)%>/g, Yi = /<%=([\s\S]+?)%>/g, Gn = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ma = /^\w*$/, pr = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, le = /[\\^$.*+?()[\]{}|]/g, We = RegExp(le.source), et = /^\s+/, wt = /\s/, X = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ge = /\{\n\/\* \[wrapped with (.+)\] \*/, we = /,? & /, de = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, ke = /[()=,{}\[\]\/\s]/, it = /\\(\\)?/g, ct = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Et = /\w*$/, Ct = /^[-+]0x[0-9a-f]+$/i, Yt = /^0b[01]+$/i, Ot = /^\[object .+?Constructor\]$/, tn = /^0o[0-7]+$/i, zn = /^(?:0|[1-9]\d*)$/, ao = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ki = /($^)/, lo = /['\n\r\u2028\u2029\\]/g, Ji = "\\ud800-\\udfff", hn = "\\u0300-\\u036f", co = "\\ufe20-\\ufe2f", Qn = "\\u20d0-\\u20ff", vi = hn + co + Qn, ys = "\\u2700-\\u27bf", Fo = "a-z\\xdf-\\xf6\\xf8-\\xff", Ml = "\\xac\\xb1\\xd7\\xf7", Ci = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Hs = "\\u2000-\\u206f", El = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Qi = "A-Z\\xc0-\\xd6\\xd8-\\xde", Gs = "\\ufe0e\\ufe0f", yh = Ml + Ci + Hs + El, Ea = "['\u2019]", pg = "[" + Ji + "]", mg = "[" + yh + "]", xh = "[" + vi + "]", vg = "\\d+", Tx = "[" + ys + "]", np = "[" + Fo + "]", gg = "[^" + Ji + yh + vg + ys + Fo + Qi + "]", ip = "\\ud83c[\\udffb-\\udfff]", Px = "(?:" + xh + "|" + ip + ")", _g = "[^" + Ji + "]", Ca = "(?:\\ud83c[\\udde6-\\uddff]){2}", xs = "[\\ud800-\\udbff][\\udc00-\\udfff]", ws = "[" + Qi + "]", Cl = "\\u200d", rp = "(?:" + np + "|" + gg + ")", wh = "(?:" + ws + "|" + gg + ")", Sh = "(?:" + Ea + "(?:d|ll|m|re|s|t|ve))?", bg = "(?:" + Ea + "(?:D|LL|M|RE|S|T|VE))?", Tl = Px + "?", sp = "[" + Gs + "]?", Ax = "(?:" + Cl + "(?:" + [_g, Ca, xs].join("|") + ")" + sp + Tl + ")*", yg = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", xg = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", wg = sp + Tl + Ax, Mh = "(?:" + [Tx, Ca, xs].join("|") + ")" + wg, Rx = "(?:" + [_g + xh + "?", xh, Ca, xs, pg].join("|") + ")", Sg = RegExp(Ea, "g"), Mg = RegExp(xh, "g"), op = RegExp(ip + "(?=" + ip + ")|" + Rx + wg, "g"), kx = RegExp([
      ws + "?" + np + "+" + Sh + "(?=" + [mg, ws, "$"].join("|") + ")",
      wh + "+" + bg + "(?=" + [mg, ws + rp, "$"].join("|") + ")",
      ws + "?" + rp + "+" + Sh,
      ws + "+" + bg,
      xg,
      yg,
      vg,
      Mh
    ].join("|"), "g"), Lx = RegExp("[" + Cl + Ji + vi + Gs + "]"), Dx = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ix = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], ap = -1, Mn = {};
    Mn[Me] = Mn[lt] = Mn[Ye] = Mn[ht] = Mn[Xe] = Mn[Mt] = Mn[At] = Mn[Bt] = Mn[pe] = !0, Mn[Se] = Mn[Ee] = Mn[Ve] = Mn[qe] = Mn[$e] = Mn[Ze] = Mn[st] = Mn[Ie] = Mn[L] = Mn[fe] = Mn[$] = Mn[Te] = Mn[Ce] = Mn[F] = Mn[me] = !1;
    var Fn = {};
    Fn[Se] = Fn[Ee] = Fn[Ve] = Fn[$e] = Fn[qe] = Fn[Ze] = Fn[Me] = Fn[lt] = Fn[Ye] = Fn[ht] = Fn[Xe] = Fn[L] = Fn[fe] = Fn[$] = Fn[Te] = Fn[Ce] = Fn[F] = Fn[U] = Fn[Mt] = Fn[At] = Fn[Bt] = Fn[pe] = !0, Fn[st] = Fn[Ie] = Fn[me] = !1;
    var Nc = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    }, Ox = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, lp = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Eg = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Nx = parseFloat, zx = parseInt, Cg = typeof sl == "object" && sl && sl.Object === Object && sl, Fx = typeof self == "object" && self && self.Object === Object && self, Ni = Cg || Fx || Function("return this")(), cp = e && !e.nodeType && e, Ta = cp && !0 && n && !n.nodeType && n, Tg = Ta && Ta.exports === cp, up = Tg && Cg.process, ts = function() {
      try {
        var ve = Ta && Ta.require && Ta.require("util").types;
        return ve || up && up.binding && up.binding("util");
      } catch {
      }
    }(), Pg = ts && ts.isArrayBuffer, Ag = ts && ts.isDate, Rg = ts && ts.isMap, kg = ts && ts.isRegExp, Lg = ts && ts.isSet, hp = ts && ts.isTypedArray;
    function Br(ve, Oe, Pe) {
      switch (Pe.length) {
        case 0:
          return ve.call(Oe);
        case 1:
          return ve.call(Oe, Pe[0]);
        case 2:
          return ve.call(Oe, Pe[0], Pe[1]);
        case 3:
          return ve.call(Oe, Pe[0], Pe[1], Pe[2]);
      }
      return ve.apply(Oe, Pe);
    }
    function Bx(ve, Oe, Pe, ut) {
      for (var zt = -1, mn = ve == null ? 0 : ve.length; ++zt < mn; ) {
        var ei = ve[zt];
        Oe(ut, ei, Pe(ei), ve);
      }
      return ut;
    }
    function ns(ve, Oe) {
      for (var Pe = -1, ut = ve == null ? 0 : ve.length; ++Pe < ut && Oe(ve[Pe], Pe, ve) !== !1; )
        ;
      return ve;
    }
    function Dg(ve, Oe) {
      for (var Pe = ve == null ? 0 : ve.length; Pe-- && Oe(ve[Pe], Pe, ve) !== !1; )
        ;
      return ve;
    }
    function Ig(ve, Oe) {
      for (var Pe = -1, ut = ve == null ? 0 : ve.length; ++Pe < ut; )
        if (!Oe(ve[Pe], Pe, ve))
          return !1;
      return !0;
    }
    function er(ve, Oe) {
      for (var Pe = -1, ut = ve == null ? 0 : ve.length, zt = 0, mn = []; ++Pe < ut; ) {
        var ei = ve[Pe];
        Oe(ei, Pe, ve) && (mn[zt++] = ei);
      }
      return mn;
    }
    function zc(ve, Oe) {
      var Pe = ve == null ? 0 : ve.length;
      return !!Pe && Pa(ve, Oe, 0) > -1;
    }
    function dp(ve, Oe, Pe) {
      for (var ut = -1, zt = ve == null ? 0 : ve.length; ++ut < zt; )
        if (Pe(Oe, ve[ut]))
          return !0;
      return !1;
    }
    function Wt(ve, Oe) {
      for (var Pe = -1, ut = ve == null ? 0 : ve.length, zt = Array(ut); ++Pe < ut; )
        zt[Pe] = Oe(ve[Pe], Pe, ve);
      return zt;
    }
    function Bo(ve, Oe) {
      for (var Pe = -1, ut = Oe.length, zt = ve.length; ++Pe < ut; )
        ve[zt + Pe] = Oe[Pe];
      return ve;
    }
    function Pl(ve, Oe, Pe, ut) {
      var zt = -1, mn = ve == null ? 0 : ve.length;
      for (ut && mn && (Pe = ve[++zt]); ++zt < mn; )
        Pe = Oe(Pe, ve[zt], zt, ve);
      return Pe;
    }
    function Og(ve, Oe, Pe, ut) {
      var zt = ve == null ? 0 : ve.length;
      for (ut && zt && (Pe = ve[--zt]); zt--; )
        Pe = Oe(Pe, ve[zt], zt, ve);
      return Pe;
    }
    function Fc(ve, Oe) {
      for (var Pe = -1, ut = ve == null ? 0 : ve.length; ++Pe < ut; )
        if (Oe(ve[Pe], Pe, ve))
          return !0;
      return !1;
    }
    var Bc = Ch("length");
    function Pr(ve) {
      return ve.split("");
    }
    function Uc(ve) {
      return ve.match(de) || [];
    }
    function Ws(ve, Oe, Pe) {
      var ut;
      return Pe(ve, function(zt, mn, ei) {
        if (Oe(zt, mn, ei))
          return ut = mn, !1;
      }), ut;
    }
    function Eh(ve, Oe, Pe, ut) {
      for (var zt = ve.length, mn = Pe + (ut ? 1 : -1); ut ? mn-- : ++mn < zt; )
        if (Oe(ve[mn], mn, ve))
          return mn;
      return -1;
    }
    function Pa(ve, Oe, Pe) {
      return Oe === Oe ? Vx(ve, Oe, Pe) : Eh(ve, Uo, Pe);
    }
    function fp(ve, Oe, Pe, ut) {
      for (var zt = Pe - 1, mn = ve.length; ++zt < mn; )
        if (ut(ve[zt], Oe))
          return zt;
      return -1;
    }
    function Uo(ve) {
      return ve !== ve;
    }
    function Wn(ve, Oe) {
      var Pe = ve == null ? 0 : ve.length;
      return Pe ? mp(ve, Oe) / Pe : ce;
    }
    function Ch(ve) {
      return function(Oe) {
        return Oe == null ? t : Oe[ve];
      };
    }
    function oi(ve) {
      return function(Oe) {
        return ve == null ? t : ve[Oe];
      };
    }
    function pp(ve, Oe, Pe, ut, zt) {
      return zt(ve, function(mn, ei, pt) {
        Pe = ut ? (ut = !1, mn) : Oe(Pe, mn, ei, pt);
      }), Pe;
    }
    function is(ve, Oe) {
      var Pe = ve.length;
      for (ve.sort(Oe); Pe--; )
        ve[Pe] = ve[Pe].value;
      return ve;
    }
    function mp(ve, Oe) {
      for (var Pe, ut = -1, zt = ve.length; ++ut < zt; ) {
        var mn = Oe(ve[ut]);
        mn !== t && (Pe = Pe === t ? mn : Pe + mn);
      }
      return Pe;
    }
    function Aa(ve, Oe) {
      for (var Pe = -1, ut = Array(ve); ++Pe < ve; )
        ut[Pe] = Oe(Pe);
      return ut;
    }
    function vp(ve, Oe) {
      return Wt(Oe, function(Pe) {
        return [Pe, ve[Pe]];
      });
    }
    function Ng(ve) {
      return ve && ve.slice(0, Bg(ve) + 1).replace(et, "");
    }
    function Ur(ve) {
      return function(Oe) {
        return ve(Oe);
      };
    }
    function Vc(ve, Oe) {
      return Wt(Oe, function(Pe) {
        return ve[Pe];
      });
    }
    function Hc(ve, Oe) {
      return ve.has(Oe);
    }
    function Th(ve, Oe) {
      for (var Pe = -1, ut = ve.length; ++Pe < ut && Pa(Oe, ve[Pe], 0) > -1; )
        ;
      return Pe;
    }
    function Al(ve, Oe) {
      for (var Pe = ve.length; Pe-- && Pa(Oe, ve[Pe], 0) > -1; )
        ;
      return Pe;
    }
    function Ph(ve, Oe) {
      for (var Pe = ve.length, ut = 0; Pe--; )
        ve[Pe] === Oe && ++ut;
      return ut;
    }
    var zg = oi(Nc), Vo = oi(Ox);
    function Fg(ve) {
      return "\\" + Eg[ve];
    }
    function gp(ve, Oe) {
      return ve == null ? t : ve[Oe];
    }
    function Rl(ve) {
      return Lx.test(ve);
    }
    function Ah(ve) {
      return Dx.test(ve);
    }
    function kl(ve) {
      for (var Oe, Pe = []; !(Oe = ve.next()).done; )
        Pe.push(Oe.value);
      return Pe;
    }
    function Ho(ve) {
      var Oe = -1, Pe = Array(ve.size);
      return ve.forEach(function(ut, zt) {
        Pe[++Oe] = [zt, ut];
      }), Pe;
    }
    function Gc(ve, Oe) {
      return function(Pe) {
        return ve(Oe(Pe));
      };
    }
    function Go(ve, Oe) {
      for (var Pe = -1, ut = ve.length, zt = 0, mn = []; ++Pe < ut; ) {
        var ei = ve[Pe];
        (ei === Oe || ei === d) && (ve[Pe] = d, mn[zt++] = Pe);
      }
      return mn;
    }
    function Rh(ve) {
      var Oe = -1, Pe = Array(ve.size);
      return ve.forEach(function(ut) {
        Pe[++Oe] = ut;
      }), Pe;
    }
    function Ux(ve) {
      var Oe = -1, Pe = Array(ve.size);
      return ve.forEach(function(ut) {
        Pe[++Oe] = [ut, ut];
      }), Pe;
    }
    function Vx(ve, Oe, Pe) {
      for (var ut = Pe - 1, zt = ve.length; ++ut < zt; )
        if (ve[ut] === Oe)
          return ut;
      return -1;
    }
    function Ra(ve, Oe, Pe) {
      for (var ut = Pe + 1; ut--; )
        if (ve[ut] === Oe)
          return ut;
      return ut;
    }
    function Ll(ve) {
      return Rl(ve) ? Ug(ve) : Bc(ve);
    }
    function Ss(ve) {
      return Rl(ve) ? Gx(ve) : Pr(ve);
    }
    function Bg(ve) {
      for (var Oe = ve.length; Oe-- && wt.test(ve.charAt(Oe)); )
        ;
      return Oe;
    }
    var Hx = oi(lp);
    function Ug(ve) {
      for (var Oe = op.lastIndex = 0; op.test(ve); )
        ++Oe;
      return Oe;
    }
    function Gx(ve) {
      return ve.match(op) || [];
    }
    function Wx(ve) {
      return ve.match(kx) || [];
    }
    var ka = function ve(Oe) {
      Oe = Oe == null ? Ni : La.defaults(Ni.Object(), Oe, La.pick(Ni, Ix));
      var Pe = Oe.Array, ut = Oe.Date, zt = Oe.Error, mn = Oe.Function, ei = Oe.Math, pt = Oe.Object, js = Oe.RegExp, jx = Oe.String, rs = Oe.TypeError, Dl = Pe.prototype, Da = mn.prototype, ss = pt.prototype, kh = Oe["__core-js_shared__"], mr = Da.toString, En = ss.hasOwnProperty, Vg = 0, _p = function() {
        var u = /[^.]+$/.exec(kh && kh.keys && kh.keys.IE_PROTO || "");
        return u ? "Symbol(src)_1." + u : "";
      }(), Wc = ss.toString, Hg = mr.call(pt), Gg = Ni._, Wg = js(
        "^" + mr.call(En).replace(le, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), jc = Tg ? Oe.Buffer : t, uo = Oe.Symbol, qc = Oe.Uint8Array, bp = jc ? jc.allocUnsafe : t, Lh = Gc(pt.getPrototypeOf, pt), yp = pt.create, jg = ss.propertyIsEnumerable, Xc = Dl.splice, xp = uo ? uo.isConcatSpreadable : t, Il = uo ? uo.iterator : t, Wo = uo ? uo.toStringTag : t, Dh = function() {
        try {
          var u = tu(pt, "defineProperty");
          return u({}, "", {}), u;
        } catch {
        }
      }(), qx = Oe.clearTimeout !== Ni.clearTimeout && Oe.clearTimeout, wp = ut && ut.now !== Ni.Date.now && ut.now, qg = Oe.setTimeout !== Ni.setTimeout && Oe.setTimeout, Ih = ei.ceil, Ol = ei.floor, Oh = pt.getOwnPropertySymbols, Xg = jc ? jc.isBuffer : t, Nh = Oe.isFinite, $g = Dl.join, Xx = Gc(pt.keys, pt), ti = ei.max, tr = ei.min, $x = ut.now, Zx = Oe.parseInt, Sp = ei.random, Yx = Dl.reverse, zh = tu(Oe, "DataView"), $c = tu(Oe, "Map"), Mp = tu(Oe, "Promise"), jo = tu(Oe, "Set"), ho = tu(Oe, "WeakMap"), Zc = tu(pt, "create"), Fh = ho && new ho(), Ms = {}, Kx = nu(zh), Jx = nu($c), Qx = nu(Mp), ew = nu(jo), Ep = nu(ho), Bh = uo ? uo.prototype : t, Ia = Bh ? Bh.valueOf : t, Zg = Bh ? Bh.toString : t;
      function W(u) {
        if (fi(u) && !Vt(u) && !(u instanceof Jt)) {
          if (u instanceof os)
            return u;
          if (En.call(u, "__wrapped__"))
            return j3(u);
        }
        return new os(u);
      }
      var qo = function() {
        function u() {
        }
        return function(f) {
          if (!ai(f))
            return {};
          if (yp)
            return yp(f);
          u.prototype = f;
          var w = new u();
          return u.prototype = t, w;
        };
      }();
      function Yc() {
      }
      function os(u, f) {
        this.__wrapped__ = u, this.__actions__ = [], this.__chain__ = !!f, this.__index__ = 0, this.__values__ = t;
      }
      W.templateSettings = {
        escape: es,
        evaluate: Sn,
        interpolate: Yi,
        variable: "",
        imports: {
          _: W
        }
      }, W.prototype = Yc.prototype, W.prototype.constructor = W, os.prototype = qo(Yc.prototype), os.prototype.constructor = os;
      function Jt(u) {
        this.__wrapped__ = u, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = te, this.__views__ = [];
      }
      function tw() {
        var u = new Jt(this.__wrapped__);
        return u.__actions__ = cs(this.__actions__), u.__dir__ = this.__dir__, u.__filtered__ = this.__filtered__, u.__iteratees__ = cs(this.__iteratees__), u.__takeCount__ = this.__takeCount__, u.__views__ = cs(this.__views__), u;
      }
      function Cp() {
        if (this.__filtered__) {
          var u = new Jt(this);
          u.__dir__ = -1, u.__filtered__ = !0;
        } else
          u = this.clone(), u.__dir__ *= -1;
        return u;
      }
      function nw() {
        var u = this.__wrapped__.value(), f = this.__dir__, w = Vt(u), R = f < 0, z = w ? u.length : 0, q = Qz(0, z, this.__views__), ie = q.start, ue = q.end, _e = ue - ie, Fe = R ? ue : ie - 1, Ue = this.__iteratees__, Ge = Ue.length, at = 0, _t = tr(_e, this.__takeCount__);
        if (!w || !R && z == _e && _t == _e)
          return Yo(u, this.__actions__);
        var Lt = [];
        e:
          for (; _e-- && at < _t; ) {
            Fe += f;
            for (var Kt = -1, Dt = u[Fe]; ++Kt < Ge; ) {
              var nn = Ue[Kt], ln = nn.iteratee, Ps = nn.type, Hr = ln(Dt);
              if (Ps == J)
                Dt = Hr;
              else if (!Hr) {
                if (Ps == A)
                  continue e;
                break e;
              }
            }
            Lt[at++] = Dt;
          }
        return Lt;
      }
      Jt.prototype = qo(Yc.prototype), Jt.prototype.constructor = Jt;
      function Oa(u) {
        var f = -1, w = u == null ? 0 : u.length;
        for (this.clear(); ++f < w; ) {
          var R = u[f];
          this.set(R[0], R[1]);
        }
      }
      function Tp() {
        this.__data__ = Zc ? Zc(null) : {}, this.size = 0;
      }
      function iw(u) {
        var f = this.has(u) && delete this.__data__[u];
        return this.size -= f ? 1 : 0, f;
      }
      function rw(u) {
        var f = this.__data__;
        if (Zc) {
          var w = f[u];
          return w === l ? t : w;
        }
        return En.call(f, u) ? f[u] : t;
      }
      function sw(u) {
        var f = this.__data__;
        return Zc ? f[u] !== t : En.call(f, u);
      }
      function ow(u, f) {
        var w = this.__data__;
        return this.size += this.has(u) ? 0 : 1, w[u] = Zc && f === t ? l : f, this;
      }
      Oa.prototype.clear = Tp, Oa.prototype.delete = iw, Oa.prototype.get = rw, Oa.prototype.has = sw, Oa.prototype.set = ow;
      function fo(u) {
        var f = -1, w = u == null ? 0 : u.length;
        for (this.clear(); ++f < w; ) {
          var R = u[f];
          this.set(R[0], R[1]);
        }
      }
      function aw() {
        this.__data__ = [], this.size = 0;
      }
      function lw(u) {
        var f = this.__data__, w = Cs(f, u);
        if (w < 0)
          return !1;
        var R = f.length - 1;
        return w == R ? f.pop() : Xc.call(f, w, 1), --this.size, !0;
      }
      function cw(u) {
        var f = this.__data__, w = Cs(f, u);
        return w < 0 ? t : f[w][1];
      }
      function uw(u) {
        return Cs(this.__data__, u) > -1;
      }
      function hw(u, f) {
        var w = this.__data__, R = Cs(w, u);
        return R < 0 ? (++this.size, w.push([u, f])) : w[R][1] = f, this;
      }
      fo.prototype.clear = aw, fo.prototype.delete = lw, fo.prototype.get = cw, fo.prototype.has = uw, fo.prototype.set = hw;
      function po(u) {
        var f = -1, w = u == null ? 0 : u.length;
        for (this.clear(); ++f < w; ) {
          var R = u[f];
          this.set(R[0], R[1]);
        }
      }
      function dw() {
        this.size = 0, this.__data__ = {
          hash: new Oa(),
          map: new ($c || fo)(),
          string: new Oa()
        };
      }
      function Pp(u) {
        var f = y0(this, u).delete(u);
        return this.size -= f ? 1 : 0, f;
      }
      function fw(u) {
        return y0(this, u).get(u);
      }
      function pw(u) {
        return y0(this, u).has(u);
      }
      function mw(u, f) {
        var w = y0(this, u), R = w.size;
        return w.set(u, f), this.size += w.size == R ? 0 : 1, this;
      }
      po.prototype.clear = dw, po.prototype.delete = Pp, po.prototype.get = fw, po.prototype.has = pw, po.prototype.set = mw;
      function Na(u) {
        var f = -1, w = u == null ? 0 : u.length;
        for (this.__data__ = new po(); ++f < w; )
          this.add(u[f]);
      }
      function vw(u) {
        return this.__data__.set(u, l), this;
      }
      function gw(u) {
        return this.__data__.has(u);
      }
      Na.prototype.add = Na.prototype.push = vw, Na.prototype.has = gw;
      function Es(u) {
        var f = this.__data__ = new fo(u);
        this.size = f.size;
      }
      function _w() {
        this.__data__ = new fo(), this.size = 0;
      }
      function Xo(u) {
        var f = this.__data__, w = f.delete(u);
        return this.size = f.size, w;
      }
      function Yg(u) {
        return this.__data__.get(u);
      }
      function bw(u) {
        return this.__data__.has(u);
      }
      function yw(u, f) {
        var w = this.__data__;
        if (w instanceof fo) {
          var R = w.__data__;
          if (!$c || R.length < r - 1)
            return R.push([u, f]), this.size = ++w.size, this;
          w = this.__data__ = new po(R);
        }
        return w.set(u, f), this.size = w.size, this;
      }
      Es.prototype.clear = _w, Es.prototype.delete = Xo, Es.prototype.get = Yg, Es.prototype.has = bw, Es.prototype.set = yw;
      function Uh(u, f) {
        var w = Vt(u), R = !w && iu(u), z = !w && !R && Gl(u), q = !w && !R && !z && Xh(u), ie = w || R || z || q, ue = ie ? Aa(u.length, jx) : [], _e = ue.length;
        for (var Fe in u)
          (f || En.call(u, Fe)) && !(ie && (Fe == "length" || z && (Fe == "offset" || Fe == "parent") || q && (Fe == "buffer" || Fe == "byteLength" || Fe == "byteOffset") || Ga(Fe, _e))) && ue.push(Fe);
        return ue;
      }
      function Ap(u) {
        var f = u.length;
        return f ? u[qp(0, f - 1)] : t;
      }
      function Kg(u, f) {
        return x0(cs(u), $o(f, 0, u.length));
      }
      function xw(u) {
        return x0(cs(u));
      }
      function Rp(u, f, w) {
        (w !== t && !mo(u[f], w) || w === t && !(f in u)) && nr(u, f, w);
      }
      function Kc(u, f, w) {
        var R = u[f];
        (!(En.call(u, f) && mo(R, w)) || w === t && !(f in u)) && nr(u, f, w);
      }
      function Cs(u, f) {
        for (var w = u.length; w--; )
          if (mo(u[w][0], f))
            return w;
        return -1;
      }
      function Jg(u, f, w, R) {
        return Zo(u, function(z, q, ie) {
          f(R, z, w(z), ie);
        }), R;
      }
      function za(u, f) {
        return u && Ko(f, rr(f), u);
      }
      function ww(u, f) {
        return u && Ko(f, hs(f), u);
      }
      function nr(u, f, w) {
        f == "__proto__" && Dh ? Dh(u, f, {
          configurable: !0,
          enumerable: !0,
          value: w,
          writable: !0
        }) : u[f] = w;
      }
      function kp(u, f) {
        for (var w = -1, R = f.length, z = Pe(R), q = u == null; ++w < R; )
          z[w] = q ? t : t1(u, f[w]);
        return z;
      }
      function $o(u, f, w) {
        return u === u && (w !== t && (u = u <= w ? u : w), f !== t && (u = u >= f ? u : f)), u;
      }
      function as(u, f, w, R, z, q) {
        var ie, ue = f & p, _e = f & m, Fe = f & v;
        if (w && (ie = z ? w(u, R, z, q) : w(u)), ie !== t)
          return ie;
        if (!ai(u))
          return u;
        var Ue = Vt(u);
        if (Ue) {
          if (ie = tF(u), !ue)
            return cs(u, ie);
        } else {
          var Ge = Ar(u), at = Ge == Ie || Ge == Le;
          if (Gl(u))
            return g3(u, ue);
          if (Ge == $ || Ge == Se || at && !z) {
            if (ie = _e || at ? {} : N3(u), !ue)
              return _e ? Wz(u, ww(ie, u)) : Gz(u, za(ie, u));
          } else {
            if (!Fn[Ge])
              return z ? u : {};
            ie = nF(u, Ge, ue);
          }
        }
        q || (q = new Es());
        var _t = q.get(u);
        if (_t)
          return _t;
        q.set(u, ie), hT(u) ? u.forEach(function(Dt) {
          ie.add(as(Dt, f, w, Dt, u, q));
        }) : cT(u) && u.forEach(function(Dt, nn) {
          ie.set(nn, as(Dt, f, w, nn, u, q));
        });
        var Lt = Fe ? _e ? Vw : Uw : _e ? hs : rr, Kt = Ue ? t : Lt(u);
        return ns(Kt || u, function(Dt, nn) {
          Kt && (nn = Dt, Dt = u[nn]), Kc(ie, nn, as(Dt, f, w, nn, u, q));
        }), ie;
      }
      function Sw(u) {
        var f = rr(u);
        return function(w) {
          return Fa(w, u, f);
        };
      }
      function Fa(u, f, w) {
        var R = w.length;
        if (u == null)
          return !R;
        for (u = pt(u); R--; ) {
          var z = w[R], q = f[z], ie = u[z];
          if (ie === t && !(z in u) || !q(ie))
            return !1;
        }
        return !0;
      }
      function Lp(u, f, w) {
        if (typeof u != "function")
          throw new rs(o);
        return Yp(function() {
          u.apply(t, w);
        }, f);
      }
      function Jc(u, f, w, R) {
        var z = -1, q = zc, ie = !0, ue = u.length, _e = [], Fe = f.length;
        if (!ue)
          return _e;
        w && (f = Wt(f, Ur(w))), R ? (q = dp, ie = !1) : f.length >= r && (q = Hc, ie = !1, f = new Na(f));
        e:
          for (; ++z < ue; ) {
            var Ue = u[z], Ge = w == null ? Ue : w(Ue);
            if (Ue = R || Ue !== 0 ? Ue : 0, ie && Ge === Ge) {
              for (var at = Fe; at--; )
                if (f[at] === Ge)
                  continue e;
              _e.push(Ue);
            } else
              q(f, Ge, R) || _e.push(Ue);
          }
        return _e;
      }
      var Zo = w3(qs), Qg = w3(Np, !0);
      function Dp(u, f) {
        var w = !0;
        return Zo(u, function(R, z, q) {
          return w = !!f(R, z, q), w;
        }), w;
      }
      function Vh(u, f, w) {
        for (var R = -1, z = u.length; ++R < z; ) {
          var q = u[R], ie = f(q);
          if (ie != null && (ue === t ? ie === ie && !Ts(ie) : w(ie, ue)))
            var ue = ie, _e = q;
        }
        return _e;
      }
      function Nl(u, f, w, R) {
        var z = u.length;
        for (w = Xt(w), w < 0 && (w = -w > z ? 0 : z + w), R = R === t || R > z ? z : Xt(R), R < 0 && (R += z), R = w > R ? 0 : fT(R); w < R; )
          u[w++] = f;
        return u;
      }
      function Ip(u, f) {
        var w = [];
        return Zo(u, function(R, z, q) {
          f(R, z, q) && w.push(R);
        }), w;
      }
      function zi(u, f, w, R, z) {
        var q = -1, ie = u.length;
        for (w || (w = rF), z || (z = []); ++q < ie; ) {
          var ue = u[q];
          f > 0 && w(ue) ? f > 1 ? zi(ue, f - 1, w, R, z) : Bo(z, ue) : R || (z[z.length] = ue);
        }
        return z;
      }
      var Op = S3(), e0 = S3(!0);
      function qs(u, f) {
        return u && Op(u, f, rr);
      }
      function Np(u, f) {
        return u && e0(u, f, rr);
      }
      function Hh(u, f) {
        return er(f, function(w) {
          return Wa(u[w]);
        });
      }
      function Ba(u, f) {
        f = Vl(f, u);
        for (var w = 0, R = f.length; u != null && w < R; )
          u = u[Jo(f[w++])];
        return w && w == R ? u : t;
      }
      function zl(u, f, w) {
        var R = f(u);
        return Vt(u) ? R : Bo(R, w(u));
      }
      function ir(u) {
        return u == null ? u === t ? he : ae : Wo && Wo in pt(u) ? Jz(u) : hF(u);
      }
      function zp(u, f) {
        return u > f;
      }
      function Fp(u, f) {
        return u != null && En.call(u, f);
      }
      function t0(u, f) {
        return u != null && f in pt(u);
      }
      function Mw(u, f, w) {
        return u >= tr(f, w) && u < ti(f, w);
      }
      function Qc(u, f, w) {
        for (var R = w ? dp : zc, z = u[0].length, q = u.length, ie = q, ue = Pe(q), _e = 1 / 0, Fe = []; ie--; ) {
          var Ue = u[ie];
          ie && f && (Ue = Wt(Ue, Ur(f))), _e = tr(Ue.length, _e), ue[ie] = !w && (f || z >= 120 && Ue.length >= 120) ? new Na(ie && Ue) : t;
        }
        Ue = u[0];
        var Ge = -1, at = ue[0];
        e:
          for (; ++Ge < z && Fe.length < _e; ) {
            var _t = Ue[Ge], Lt = f ? f(_t) : _t;
            if (_t = w || _t !== 0 ? _t : 0, !(at ? Hc(at, Lt) : R(Fe, Lt, w))) {
              for (ie = q; --ie; ) {
                var Kt = ue[ie];
                if (!(Kt ? Hc(Kt, Lt) : R(u[ie], Lt, w)))
                  continue e;
              }
              at && at.push(Lt), Fe.push(_t);
            }
          }
        return Fe;
      }
      function Ew(u, f, w, R) {
        return qs(u, function(z, q, ie) {
          f(R, w(z), q, ie);
        }), R;
      }
      function ls(u, f, w) {
        f = Vl(f, u), u = U3(u, f);
        var R = u == null ? u : u[Jo($s(f))];
        return R == null ? t : Br(R, u, w);
      }
      function n0(u) {
        return fi(u) && ir(u) == Se;
      }
      function Cw(u) {
        return fi(u) && ir(u) == Ve;
      }
      function Bp(u) {
        return fi(u) && ir(u) == Ze;
      }
      function eu(u, f, w, R, z) {
        return u === f ? !0 : u == null || f == null || !fi(u) && !fi(f) ? u !== u && f !== f : Tw(u, f, w, R, eu, z);
      }
      function Tw(u, f, w, R, z, q) {
        var ie = Vt(u), ue = Vt(f), _e = ie ? Ee : Ar(u), Fe = ue ? Ee : Ar(f);
        _e = _e == Se ? $ : _e, Fe = Fe == Se ? $ : Fe;
        var Ue = _e == $, Ge = Fe == $, at = _e == Fe;
        if (at && Gl(u)) {
          if (!Gl(f))
            return !1;
          ie = !0, Ue = !1;
        }
        if (at && !Ue)
          return q || (q = new Es()), ie || Xh(u) ? D3(u, f, w, R, z, q) : Yz(u, f, _e, w, R, z, q);
        if (!(w & b)) {
          var _t = Ue && En.call(u, "__wrapped__"), Lt = Ge && En.call(f, "__wrapped__");
          if (_t || Lt) {
            var Kt = _t ? u.value() : u, Dt = Lt ? f.value() : f;
            return q || (q = new Es()), z(Kt, Dt, w, R, q);
          }
        }
        return at ? (q || (q = new Es()), Kz(u, f, w, R, z, q)) : !1;
      }
      function i0(u) {
        return fi(u) && Ar(u) == L;
      }
      function Up(u, f, w, R) {
        var z = w.length, q = z, ie = !R;
        if (u == null)
          return !q;
        for (u = pt(u); z--; ) {
          var ue = w[z];
          if (ie && ue[2] ? ue[1] !== u[ue[0]] : !(ue[0] in u))
            return !1;
        }
        for (; ++z < q; ) {
          ue = w[z];
          var _e = ue[0], Fe = u[_e], Ue = ue[1];
          if (ie && ue[2]) {
            if (Fe === t && !(_e in u))
              return !1;
          } else {
            var Ge = new Es();
            if (R)
              var at = R(Fe, Ue, _e, u, f, Ge);
            if (!(at === t ? eu(Ue, Fe, b | x, R, Ge) : at))
              return !1;
          }
        }
        return !0;
      }
      function r0(u) {
        if (!ai(u) || oF(u))
          return !1;
        var f = Wa(u) ? Wg : Ot;
        return f.test(nu(u));
      }
      function Pw(u) {
        return fi(u) && ir(u) == Te;
      }
      function Aw(u) {
        return fi(u) && Ar(u) == Ce;
      }
      function Rw(u) {
        return fi(u) && T0(u.length) && !!Mn[ir(u)];
      }
      function s0(u) {
        return typeof u == "function" ? u : u == null ? ds : typeof u == "object" ? Vt(u) ? Gp(u[0], u[1]) : o0(u) : MT(u);
      }
      function Vp(u) {
        if (!Zp(u))
          return Xx(u);
        var f = [];
        for (var w in pt(u))
          En.call(u, w) && w != "constructor" && f.push(w);
        return f;
      }
      function kw(u) {
        if (!ai(u))
          return uF(u);
        var f = Zp(u), w = [];
        for (var R in u)
          R == "constructor" && (f || !En.call(u, R)) || w.push(R);
        return w;
      }
      function Hp(u, f) {
        return u < f;
      }
      function Xs(u, f) {
        var w = -1, R = us(u) ? Pe(u.length) : [];
        return Zo(u, function(z, q, ie) {
          R[++w] = f(z, q, ie);
        }), R;
      }
      function o0(u) {
        var f = Gw(u);
        return f.length == 1 && f[0][2] ? F3(f[0][0], f[0][1]) : function(w) {
          return w === u || Up(w, u, f);
        };
      }
      function Gp(u, f) {
        return jw(u) && z3(f) ? F3(Jo(u), f) : function(w) {
          var R = t1(w, u);
          return R === t && R === f ? n1(w, u) : eu(f, R, b | x);
        };
      }
      function Gh(u, f, w, R, z) {
        u !== f && Op(f, function(q, ie) {
          if (z || (z = new Es()), ai(q))
            a0(u, f, ie, w, Gh, R, z);
          else {
            var ue = R ? R(Xw(u, ie), q, ie + "", u, f, z) : t;
            ue === t && (ue = q), Rp(u, ie, ue);
          }
        }, hs);
      }
      function a0(u, f, w, R, z, q, ie) {
        var ue = Xw(u, w), _e = Xw(f, w), Fe = ie.get(_e);
        if (Fe) {
          Rp(u, w, Fe);
          return;
        }
        var Ue = q ? q(ue, _e, w + "", u, f, ie) : t, Ge = Ue === t;
        if (Ge) {
          var at = Vt(_e), _t = !at && Gl(_e), Lt = !at && !_t && Xh(_e);
          Ue = _e, at || _t || Lt ? Vt(ue) ? Ue = ue : gi(ue) ? Ue = cs(ue) : _t ? (Ge = !1, Ue = g3(_e, !0)) : Lt ? (Ge = !1, Ue = _3(_e, !0)) : Ue = [] : Kp(_e) || iu(_e) ? (Ue = ue, iu(ue) ? Ue = pT(ue) : (!ai(ue) || Wa(ue)) && (Ue = N3(_e))) : Ge = !1;
        }
        Ge && (ie.set(_e, Ue), z(Ue, _e, R, q, ie), ie.delete(_e)), Rp(u, w, Ue);
      }
      function l0(u, f) {
        var w = u.length;
        if (!!w)
          return f += f < 0 ? w : 0, Ga(f, w) ? u[f] : t;
      }
      function c0(u, f, w) {
        f.length ? f = Wt(f, function(q) {
          return Vt(q) ? function(ie) {
            return Ba(ie, q.length === 1 ? q[0] : q);
          } : q;
        }) : f = [ds];
        var R = -1;
        f = Wt(f, Ur(kt()));
        var z = Xs(u, function(q, ie, ue) {
          var _e = Wt(f, function(Fe) {
            return Fe(q);
          });
          return { criteria: _e, index: ++R, value: q };
        });
        return is(z, function(q, ie) {
          return Hz(q, ie, w);
        });
      }
      function u0(u, f) {
        return Wp(u, f, function(w, R) {
          return n1(u, R);
        });
      }
      function Wp(u, f, w) {
        for (var R = -1, z = f.length, q = {}; ++R < z; ) {
          var ie = f[R], ue = Ba(u, ie);
          w(ue, ie) && Fl(q, Vl(ie, u), ue);
        }
        return q;
      }
      function h0(u) {
        return function(f) {
          return Ba(f, u);
        };
      }
      function jp(u, f, w, R) {
        var z = R ? fp : Pa, q = -1, ie = f.length, ue = u;
        for (u === f && (f = cs(f)), w && (ue = Wt(u, Ur(w))); ++q < ie; )
          for (var _e = 0, Fe = f[q], Ue = w ? w(Fe) : Fe; (_e = z(ue, Ue, _e, R)) > -1; )
            ue !== u && Xc.call(ue, _e, 1), Xc.call(u, _e, 1);
        return u;
      }
      function d0(u, f) {
        for (var w = u ? f.length : 0, R = w - 1; w--; ) {
          var z = f[w];
          if (w == R || z !== q) {
            var q = z;
            Ga(z) ? Xc.call(u, z, 1) : Rt(u, z);
          }
        }
        return u;
      }
      function qp(u, f) {
        return u + Ol(Sp() * (f - u + 1));
      }
      function Lw(u, f, w, R) {
        for (var z = -1, q = ti(Ih((f - u) / (w || 1)), 0), ie = Pe(q); q--; )
          ie[R ? q : ++z] = u, u += w;
        return ie;
      }
      function Xp(u, f) {
        var w = "";
        if (!u || f < 1 || f > oe)
          return w;
        do
          f % 2 && (w += u), f = Ol(f / 2), f && (u += u);
        while (f);
        return w;
      }
      function qt(u, f) {
        return $w(B3(u, f, ds), u + "");
      }
      function Dw(u) {
        return Ap($h(u));
      }
      function Iw(u, f) {
        var w = $h(u);
        return x0(w, $o(f, 0, w.length));
      }
      function Fl(u, f, w, R) {
        if (!ai(u))
          return u;
        f = Vl(f, u);
        for (var z = -1, q = f.length, ie = q - 1, ue = u; ue != null && ++z < q; ) {
          var _e = Jo(f[z]), Fe = w;
          if (_e === "__proto__" || _e === "constructor" || _e === "prototype")
            return u;
          if (z != ie) {
            var Ue = ue[_e];
            Fe = R ? R(Ue, _e, ue) : t, Fe === t && (Fe = ai(Ue) ? Ue : Ga(f[z + 1]) ? [] : {});
          }
          Kc(ue, _e, Fe), ue = ue[_e];
        }
        return u;
      }
      var f0 = Fh ? function(u, f) {
        return Fh.set(u, f), u;
      } : ds, Ow = Dh ? function(u, f) {
        return Dh(u, "toString", {
          configurable: !0,
          enumerable: !1,
          value: r1(f),
          writable: !0
        });
      } : ds;
      function _(u) {
        return x0($h(u));
      }
      function h(u, f, w) {
        var R = -1, z = u.length;
        f < 0 && (f = -f > z ? 0 : z + f), w = w > z ? z : w, w < 0 && (w += z), z = f > w ? 0 : w - f >>> 0, f >>>= 0;
        for (var q = Pe(z); ++R < z; )
          q[R] = u[R + f];
        return q;
      }
      function g(u, f) {
        var w;
        return Zo(u, function(R, z, q) {
          return w = f(R, z, q), !w;
        }), !!w;
      }
      function E(u, f, w) {
        var R = 0, z = u == null ? R : u.length;
        if (typeof f == "number" && f === f && z <= Re) {
          for (; R < z; ) {
            var q = R + z >>> 1, ie = u[q];
            ie !== null && !Ts(ie) && (w ? ie <= f : ie < f) ? R = q + 1 : z = q;
          }
          return z;
        }
        return N(u, f, ds, w);
      }
      function N(u, f, w, R) {
        var z = 0, q = u == null ? 0 : u.length;
        if (q === 0)
          return 0;
        f = w(f);
        for (var ie = f !== f, ue = f === null, _e = Ts(f), Fe = f === t; z < q; ) {
          var Ue = Ol((z + q) / 2), Ge = w(u[Ue]), at = Ge !== t, _t = Ge === null, Lt = Ge === Ge, Kt = Ts(Ge);
          if (ie)
            var Dt = R || Lt;
          else
            Fe ? Dt = Lt && (R || at) : ue ? Dt = Lt && at && (R || !_t) : _e ? Dt = Lt && at && !_t && (R || !Kt) : _t || Kt ? Dt = !1 : Dt = R ? Ge <= f : Ge < f;
          Dt ? z = Ue + 1 : q = Ue;
        }
        return tr(q, ee);
      }
      function ne(u, f) {
        for (var w = -1, R = u.length, z = 0, q = []; ++w < R; ) {
          var ie = u[w], ue = f ? f(ie) : ie;
          if (!w || !mo(ue, _e)) {
            var _e = ue;
            q[z++] = ie === 0 ? 0 : ie;
          }
        }
        return q;
      }
      function be(u) {
        return typeof u == "number" ? u : Ts(u) ? ce : +u;
      }
      function He(u) {
        if (typeof u == "string")
          return u;
        if (Vt(u))
          return Wt(u, He) + "";
        if (Ts(u))
          return Zg ? Zg.call(u) : "";
        var f = u + "";
        return f == "0" && 1 / u == -se ? "-0" : f;
      }
      function mt(u, f, w) {
        var R = -1, z = zc, q = u.length, ie = !0, ue = [], _e = ue;
        if (w)
          ie = !1, z = dp;
        else if (q >= r) {
          var Fe = f ? null : $z(u);
          if (Fe)
            return Rh(Fe);
          ie = !1, z = Hc, _e = new Na();
        } else
          _e = f ? [] : ue;
        e:
          for (; ++R < q; ) {
            var Ue = u[R], Ge = f ? f(Ue) : Ue;
            if (Ue = w || Ue !== 0 ? Ue : 0, ie && Ge === Ge) {
              for (var at = _e.length; at--; )
                if (_e[at] === Ge)
                  continue e;
              f && _e.push(Ge), ue.push(Ue);
            } else
              z(_e, Ge, w) || (_e !== ue && _e.push(Ge), ue.push(Ue));
          }
        return ue;
      }
      function Rt(u, f) {
        return f = Vl(f, u), u = U3(u, f), u == null || delete u[Jo($s(f))];
      }
      function an(u, f, w, R) {
        return Fl(u, f, w(Ba(u, f)), R);
      }
      function on(u, f, w, R) {
        for (var z = u.length, q = R ? z : -1; (R ? q-- : ++q < z) && f(u[q], q, u); )
          ;
        return w ? h(u, R ? 0 : q, R ? q + 1 : z) : h(u, R ? q + 1 : 0, R ? z : q);
      }
      function Yo(u, f) {
        var w = u;
        return w instanceof Jt && (w = w.value()), Pl(f, function(R, z) {
          return z.func.apply(z.thisArg, Bo([R], z.args));
        }, w);
      }
      function Ua(u, f, w) {
        var R = u.length;
        if (R < 2)
          return R ? mt(u[0]) : [];
        for (var z = -1, q = Pe(R); ++z < R; )
          for (var ie = u[z], ue = -1; ++ue < R; )
            ue != z && (q[z] = Jc(q[z] || ie, u[ue], f, w));
        return mt(zi(q, 1), f, w);
      }
      function Bl(u, f, w) {
        for (var R = -1, z = u.length, q = f.length, ie = {}; ++R < z; ) {
          var ue = R < q ? f[R] : t;
          w(ie, u[R], ue);
        }
        return ie;
      }
      function Ul(u) {
        return gi(u) ? u : [];
      }
      function Nw(u) {
        return typeof u == "function" ? u : ds;
      }
      function Vl(u, f) {
        return Vt(u) ? u : jw(u, f) ? [u] : W3(Rn(u));
      }
      var Fz = qt;
      function Hl(u, f, w) {
        var R = u.length;
        return w = w === t ? R : w, !f && w >= R ? u : h(u, f, w);
      }
      var v3 = qx || function(u) {
        return Ni.clearTimeout(u);
      };
      function g3(u, f) {
        if (f)
          return u.slice();
        var w = u.length, R = bp ? bp(w) : new u.constructor(w);
        return u.copy(R), R;
      }
      function zw(u) {
        var f = new u.constructor(u.byteLength);
        return new qc(f).set(new qc(u)), f;
      }
      function Bz(u, f) {
        var w = f ? zw(u.buffer) : u.buffer;
        return new u.constructor(w, u.byteOffset, u.byteLength);
      }
      function Uz(u) {
        var f = new u.constructor(u.source, Et.exec(u));
        return f.lastIndex = u.lastIndex, f;
      }
      function Vz(u) {
        return Ia ? pt(Ia.call(u)) : {};
      }
      function _3(u, f) {
        var w = f ? zw(u.buffer) : u.buffer;
        return new u.constructor(w, u.byteOffset, u.length);
      }
      function b3(u, f) {
        if (u !== f) {
          var w = u !== t, R = u === null, z = u === u, q = Ts(u), ie = f !== t, ue = f === null, _e = f === f, Fe = Ts(f);
          if (!ue && !Fe && !q && u > f || q && ie && _e && !ue && !Fe || R && ie && _e || !w && _e || !z)
            return 1;
          if (!R && !q && !Fe && u < f || Fe && w && z && !R && !q || ue && w && z || !ie && z || !_e)
            return -1;
        }
        return 0;
      }
      function Hz(u, f, w) {
        for (var R = -1, z = u.criteria, q = f.criteria, ie = z.length, ue = w.length; ++R < ie; ) {
          var _e = b3(z[R], q[R]);
          if (_e) {
            if (R >= ue)
              return _e;
            var Fe = w[R];
            return _e * (Fe == "desc" ? -1 : 1);
          }
        }
        return u.index - f.index;
      }
      function y3(u, f, w, R) {
        for (var z = -1, q = u.length, ie = w.length, ue = -1, _e = f.length, Fe = ti(q - ie, 0), Ue = Pe(_e + Fe), Ge = !R; ++ue < _e; )
          Ue[ue] = f[ue];
        for (; ++z < ie; )
          (Ge || z < q) && (Ue[w[z]] = u[z]);
        for (; Fe--; )
          Ue[ue++] = u[z++];
        return Ue;
      }
      function x3(u, f, w, R) {
        for (var z = -1, q = u.length, ie = -1, ue = w.length, _e = -1, Fe = f.length, Ue = ti(q - ue, 0), Ge = Pe(Ue + Fe), at = !R; ++z < Ue; )
          Ge[z] = u[z];
        for (var _t = z; ++_e < Fe; )
          Ge[_t + _e] = f[_e];
        for (; ++ie < ue; )
          (at || z < q) && (Ge[_t + w[ie]] = u[z++]);
        return Ge;
      }
      function cs(u, f) {
        var w = -1, R = u.length;
        for (f || (f = Pe(R)); ++w < R; )
          f[w] = u[w];
        return f;
      }
      function Ko(u, f, w, R) {
        var z = !w;
        w || (w = {});
        for (var q = -1, ie = f.length; ++q < ie; ) {
          var ue = f[q], _e = R ? R(w[ue], u[ue], ue, w, u) : t;
          _e === t && (_e = u[ue]), z ? nr(w, ue, _e) : Kc(w, ue, _e);
        }
        return w;
      }
      function Gz(u, f) {
        return Ko(u, Ww(u), f);
      }
      function Wz(u, f) {
        return Ko(u, I3(u), f);
      }
      function p0(u, f) {
        return function(w, R) {
          var z = Vt(w) ? Bx : Jg, q = f ? f() : {};
          return z(w, u, kt(R, 2), q);
        };
      }
      function Wh(u) {
        return qt(function(f, w) {
          var R = -1, z = w.length, q = z > 1 ? w[z - 1] : t, ie = z > 2 ? w[2] : t;
          for (q = u.length > 3 && typeof q == "function" ? (z--, q) : t, ie && Vr(w[0], w[1], ie) && (q = z < 3 ? t : q, z = 1), f = pt(f); ++R < z; ) {
            var ue = w[R];
            ue && u(f, ue, R, q);
          }
          return f;
        });
      }
      function w3(u, f) {
        return function(w, R) {
          if (w == null)
            return w;
          if (!us(w))
            return u(w, R);
          for (var z = w.length, q = f ? z : -1, ie = pt(w); (f ? q-- : ++q < z) && R(ie[q], q, ie) !== !1; )
            ;
          return w;
        };
      }
      function S3(u) {
        return function(f, w, R) {
          for (var z = -1, q = pt(f), ie = R(f), ue = ie.length; ue--; ) {
            var _e = ie[u ? ue : ++z];
            if (w(q[_e], _e, q) === !1)
              break;
          }
          return f;
        };
      }
      function jz(u, f, w) {
        var R = f & y, z = $p(u);
        function q() {
          var ie = this && this !== Ni && this instanceof q ? z : u;
          return ie.apply(R ? w : this, arguments);
        }
        return q;
      }
      function M3(u) {
        return function(f) {
          f = Rn(f);
          var w = Rl(f) ? Ss(f) : t, R = w ? w[0] : f.charAt(0), z = w ? Hl(w, 1).join("") : f.slice(1);
          return R[u]() + z;
        };
      }
      function jh(u) {
        return function(f) {
          return Pl(wT(xT(f).replace(Sg, "")), u, "");
        };
      }
      function $p(u) {
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return new u();
            case 1:
              return new u(f[0]);
            case 2:
              return new u(f[0], f[1]);
            case 3:
              return new u(f[0], f[1], f[2]);
            case 4:
              return new u(f[0], f[1], f[2], f[3]);
            case 5:
              return new u(f[0], f[1], f[2], f[3], f[4]);
            case 6:
              return new u(f[0], f[1], f[2], f[3], f[4], f[5]);
            case 7:
              return new u(f[0], f[1], f[2], f[3], f[4], f[5], f[6]);
          }
          var w = qo(u.prototype), R = u.apply(w, f);
          return ai(R) ? R : w;
        };
      }
      function qz(u, f, w) {
        var R = $p(u);
        function z() {
          for (var q = arguments.length, ie = Pe(q), ue = q, _e = qh(z); ue--; )
            ie[ue] = arguments[ue];
          var Fe = q < 3 && ie[0] !== _e && ie[q - 1] !== _e ? [] : Go(ie, _e);
          if (q -= Fe.length, q < w)
            return A3(
              u,
              f,
              m0,
              z.placeholder,
              t,
              ie,
              Fe,
              t,
              t,
              w - q
            );
          var Ue = this && this !== Ni && this instanceof z ? R : u;
          return Br(Ue, this, ie);
        }
        return z;
      }
      function E3(u) {
        return function(f, w, R) {
          var z = pt(f);
          if (!us(f)) {
            var q = kt(w, 3);
            f = rr(f), w = function(ue) {
              return q(z[ue], ue, z);
            };
          }
          var ie = u(f, w, R);
          return ie > -1 ? z[q ? f[ie] : ie] : t;
        };
      }
      function C3(u) {
        return Ha(function(f) {
          var w = f.length, R = w, z = os.prototype.thru;
          for (u && f.reverse(); R--; ) {
            var q = f[R];
            if (typeof q != "function")
              throw new rs(o);
            if (z && !ie && b0(q) == "wrapper")
              var ie = new os([], !0);
          }
          for (R = ie ? R : w; ++R < w; ) {
            q = f[R];
            var ue = b0(q), _e = ue == "wrapper" ? Hw(q) : t;
            _e && qw(_e[0]) && _e[1] == (I | M | P | k) && !_e[4].length && _e[9] == 1 ? ie = ie[b0(_e[0])].apply(ie, _e[3]) : ie = q.length == 1 && qw(q) ? ie[ue]() : ie.thru(q);
          }
          return function() {
            var Fe = arguments, Ue = Fe[0];
            if (ie && Fe.length == 1 && Vt(Ue))
              return ie.plant(Ue).value();
            for (var Ge = 0, at = w ? f[Ge].apply(this, Fe) : Ue; ++Ge < w; )
              at = f[Ge].call(this, at);
            return at;
          };
        });
      }
      function m0(u, f, w, R, z, q, ie, ue, _e, Fe) {
        var Ue = f & I, Ge = f & y, at = f & S, _t = f & (M | T), Lt = f & O, Kt = at ? t : $p(u);
        function Dt() {
          for (var nn = arguments.length, ln = Pe(nn), Ps = nn; Ps--; )
            ln[Ps] = arguments[Ps];
          if (_t)
            var Hr = qh(Dt), As = Ph(ln, Hr);
          if (R && (ln = y3(ln, R, z, _t)), q && (ln = x3(ln, q, ie, _t)), nn -= As, _t && nn < Fe) {
            var _i = Go(ln, Hr);
            return A3(
              u,
              f,
              m0,
              Dt.placeholder,
              w,
              ln,
              _i,
              ue,
              _e,
              Fe - nn
            );
          }
          var vo = Ge ? w : this, qa = at ? vo[u] : u;
          return nn = ln.length, ue ? ln = dF(ln, ue) : Lt && nn > 1 && ln.reverse(), Ue && _e < nn && (ln.length = _e), this && this !== Ni && this instanceof Dt && (qa = Kt || $p(qa)), qa.apply(vo, ln);
        }
        return Dt;
      }
      function T3(u, f) {
        return function(w, R) {
          return Ew(w, u, f(R), {});
        };
      }
      function v0(u, f) {
        return function(w, R) {
          var z;
          if (w === t && R === t)
            return f;
          if (w !== t && (z = w), R !== t) {
            if (z === t)
              return R;
            typeof w == "string" || typeof R == "string" ? (w = He(w), R = He(R)) : (w = be(w), R = be(R)), z = u(w, R);
          }
          return z;
        };
      }
      function Fw(u) {
        return Ha(function(f) {
          return f = Wt(f, Ur(kt())), qt(function(w) {
            var R = this;
            return u(f, function(z) {
              return Br(z, R, w);
            });
          });
        });
      }
      function g0(u, f) {
        f = f === t ? " " : He(f);
        var w = f.length;
        if (w < 2)
          return w ? Xp(f, u) : f;
        var R = Xp(f, Ih(u / Ll(f)));
        return Rl(f) ? Hl(Ss(R), 0, u).join("") : R.slice(0, u);
      }
      function Xz(u, f, w, R) {
        var z = f & y, q = $p(u);
        function ie() {
          for (var ue = -1, _e = arguments.length, Fe = -1, Ue = R.length, Ge = Pe(Ue + _e), at = this && this !== Ni && this instanceof ie ? q : u; ++Fe < Ue; )
            Ge[Fe] = R[Fe];
          for (; _e--; )
            Ge[Fe++] = arguments[++ue];
          return Br(at, z ? w : this, Ge);
        }
        return ie;
      }
      function P3(u) {
        return function(f, w, R) {
          return R && typeof R != "number" && Vr(f, w, R) && (w = R = t), f = ja(f), w === t ? (w = f, f = 0) : w = ja(w), R = R === t ? f < w ? 1 : -1 : ja(R), Lw(f, w, R, u);
        };
      }
      function _0(u) {
        return function(f, w) {
          return typeof f == "string" && typeof w == "string" || (f = Zs(f), w = Zs(w)), u(f, w);
        };
      }
      function A3(u, f, w, R, z, q, ie, ue, _e, Fe) {
        var Ue = f & M, Ge = Ue ? ie : t, at = Ue ? t : ie, _t = Ue ? q : t, Lt = Ue ? t : q;
        f |= Ue ? P : D, f &= ~(Ue ? D : P), f & C || (f &= ~(y | S));
        var Kt = [
          u,
          f,
          z,
          _t,
          Ge,
          Lt,
          at,
          ue,
          _e,
          Fe
        ], Dt = w.apply(t, Kt);
        return qw(u) && V3(Dt, Kt), Dt.placeholder = R, H3(Dt, u, f);
      }
      function Bw(u) {
        var f = ei[u];
        return function(w, R) {
          if (w = Zs(w), R = R == null ? 0 : tr(Xt(R), 292), R && Nh(w)) {
            var z = (Rn(w) + "e").split("e"), q = f(z[0] + "e" + (+z[1] + R));
            return z = (Rn(q) + "e").split("e"), +(z[0] + "e" + (+z[1] - R));
          }
          return f(w);
        };
      }
      var $z = jo && 1 / Rh(new jo([, -0]))[1] == se ? function(u) {
        return new jo(u);
      } : a1;
      function R3(u) {
        return function(f) {
          var w = Ar(f);
          return w == L ? Ho(f) : w == Ce ? Ux(f) : vp(f, u(f));
        };
      }
      function Va(u, f, w, R, z, q, ie, ue) {
        var _e = f & S;
        if (!_e && typeof u != "function")
          throw new rs(o);
        var Fe = R ? R.length : 0;
        if (Fe || (f &= ~(P | D), R = z = t), ie = ie === t ? ie : ti(Xt(ie), 0), ue = ue === t ? ue : Xt(ue), Fe -= z ? z.length : 0, f & D) {
          var Ue = R, Ge = z;
          R = z = t;
        }
        var at = _e ? t : Hw(u), _t = [
          u,
          f,
          w,
          R,
          z,
          Ue,
          Ge,
          q,
          ie,
          ue
        ];
        if (at && cF(_t, at), u = _t[0], f = _t[1], w = _t[2], R = _t[3], z = _t[4], ue = _t[9] = _t[9] === t ? _e ? 0 : u.length : ti(_t[9] - Fe, 0), !ue && f & (M | T) && (f &= ~(M | T)), !f || f == y)
          var Lt = jz(u, f, w);
        else
          f == M || f == T ? Lt = qz(u, f, ue) : (f == P || f == (y | P)) && !z.length ? Lt = Xz(u, f, w, R) : Lt = m0.apply(t, _t);
        var Kt = at ? f0 : V3;
        return H3(Kt(Lt, _t), u, f);
      }
      function k3(u, f, w, R) {
        return u === t || mo(u, ss[w]) && !En.call(R, w) ? f : u;
      }
      function L3(u, f, w, R, z, q) {
        return ai(u) && ai(f) && (q.set(f, u), Gh(u, f, t, L3, q), q.delete(f)), u;
      }
      function Zz(u) {
        return Kp(u) ? t : u;
      }
      function D3(u, f, w, R, z, q) {
        var ie = w & b, ue = u.length, _e = f.length;
        if (ue != _e && !(ie && _e > ue))
          return !1;
        var Fe = q.get(u), Ue = q.get(f);
        if (Fe && Ue)
          return Fe == f && Ue == u;
        var Ge = -1, at = !0, _t = w & x ? new Na() : t;
        for (q.set(u, f), q.set(f, u); ++Ge < ue; ) {
          var Lt = u[Ge], Kt = f[Ge];
          if (R)
            var Dt = ie ? R(Kt, Lt, Ge, f, u, q) : R(Lt, Kt, Ge, u, f, q);
          if (Dt !== t) {
            if (Dt)
              continue;
            at = !1;
            break;
          }
          if (_t) {
            if (!Fc(f, function(nn, ln) {
              if (!Hc(_t, ln) && (Lt === nn || z(Lt, nn, w, R, q)))
                return _t.push(ln);
            })) {
              at = !1;
              break;
            }
          } else if (!(Lt === Kt || z(Lt, Kt, w, R, q))) {
            at = !1;
            break;
          }
        }
        return q.delete(u), q.delete(f), at;
      }
      function Yz(u, f, w, R, z, q, ie) {
        switch (w) {
          case $e:
            if (u.byteLength != f.byteLength || u.byteOffset != f.byteOffset)
              return !1;
            u = u.buffer, f = f.buffer;
          case Ve:
            return !(u.byteLength != f.byteLength || !q(new qc(u), new qc(f)));
          case qe:
          case Ze:
          case fe:
            return mo(+u, +f);
          case st:
            return u.name == f.name && u.message == f.message;
          case Te:
          case F:
            return u == f + "";
          case L:
            var ue = Ho;
          case Ce:
            var _e = R & b;
            if (ue || (ue = Rh), u.size != f.size && !_e)
              return !1;
            var Fe = ie.get(u);
            if (Fe)
              return Fe == f;
            R |= x, ie.set(u, f);
            var Ue = D3(ue(u), ue(f), R, z, q, ie);
            return ie.delete(u), Ue;
          case U:
            if (Ia)
              return Ia.call(u) == Ia.call(f);
        }
        return !1;
      }
      function Kz(u, f, w, R, z, q) {
        var ie = w & b, ue = Uw(u), _e = ue.length, Fe = Uw(f), Ue = Fe.length;
        if (_e != Ue && !ie)
          return !1;
        for (var Ge = _e; Ge--; ) {
          var at = ue[Ge];
          if (!(ie ? at in f : En.call(f, at)))
            return !1;
        }
        var _t = q.get(u), Lt = q.get(f);
        if (_t && Lt)
          return _t == f && Lt == u;
        var Kt = !0;
        q.set(u, f), q.set(f, u);
        for (var Dt = ie; ++Ge < _e; ) {
          at = ue[Ge];
          var nn = u[at], ln = f[at];
          if (R)
            var Ps = ie ? R(ln, nn, at, f, u, q) : R(nn, ln, at, u, f, q);
          if (!(Ps === t ? nn === ln || z(nn, ln, w, R, q) : Ps)) {
            Kt = !1;
            break;
          }
          Dt || (Dt = at == "constructor");
        }
        if (Kt && !Dt) {
          var Hr = u.constructor, As = f.constructor;
          Hr != As && "constructor" in u && "constructor" in f && !(typeof Hr == "function" && Hr instanceof Hr && typeof As == "function" && As instanceof As) && (Kt = !1);
        }
        return q.delete(u), q.delete(f), Kt;
      }
      function Ha(u) {
        return $w(B3(u, t, $3), u + "");
      }
      function Uw(u) {
        return zl(u, rr, Ww);
      }
      function Vw(u) {
        return zl(u, hs, I3);
      }
      var Hw = Fh ? function(u) {
        return Fh.get(u);
      } : a1;
      function b0(u) {
        for (var f = u.name + "", w = Ms[f], R = En.call(Ms, f) ? w.length : 0; R--; ) {
          var z = w[R], q = z.func;
          if (q == null || q == u)
            return z.name;
        }
        return f;
      }
      function qh(u) {
        var f = En.call(W, "placeholder") ? W : u;
        return f.placeholder;
      }
      function kt() {
        var u = W.iteratee || s1;
        return u = u === s1 ? s0 : u, arguments.length ? u(arguments[0], arguments[1]) : u;
      }
      function y0(u, f) {
        var w = u.__data__;
        return sF(f) ? w[typeof f == "string" ? "string" : "hash"] : w.map;
      }
      function Gw(u) {
        for (var f = rr(u), w = f.length; w--; ) {
          var R = f[w], z = u[R];
          f[w] = [R, z, z3(z)];
        }
        return f;
      }
      function tu(u, f) {
        var w = gp(u, f);
        return r0(w) ? w : t;
      }
      function Jz(u) {
        var f = En.call(u, Wo), w = u[Wo];
        try {
          u[Wo] = t;
          var R = !0;
        } catch {
        }
        var z = Wc.call(u);
        return R && (f ? u[Wo] = w : delete u[Wo]), z;
      }
      var Ww = Oh ? function(u) {
        return u == null ? [] : (u = pt(u), er(Oh(u), function(f) {
          return jg.call(u, f);
        }));
      } : l1, I3 = Oh ? function(u) {
        for (var f = []; u; )
          Bo(f, Ww(u)), u = Lh(u);
        return f;
      } : l1, Ar = ir;
      (zh && Ar(new zh(new ArrayBuffer(1))) != $e || $c && Ar(new $c()) != L || Mp && Ar(Mp.resolve()) != j || jo && Ar(new jo()) != Ce || ho && Ar(new ho()) != me) && (Ar = function(u) {
        var f = ir(u), w = f == $ ? u.constructor : t, R = w ? nu(w) : "";
        if (R)
          switch (R) {
            case Kx:
              return $e;
            case Jx:
              return L;
            case Qx:
              return j;
            case ew:
              return Ce;
            case Ep:
              return me;
          }
        return f;
      });
      function Qz(u, f, w) {
        for (var R = -1, z = w.length; ++R < z; ) {
          var q = w[R], ie = q.size;
          switch (q.type) {
            case "drop":
              u += ie;
              break;
            case "dropRight":
              f -= ie;
              break;
            case "take":
              f = tr(f, u + ie);
              break;
            case "takeRight":
              u = ti(u, f - ie);
              break;
          }
        }
        return { start: u, end: f };
      }
      function eF(u) {
        var f = u.match(ge);
        return f ? f[1].split(we) : [];
      }
      function O3(u, f, w) {
        f = Vl(f, u);
        for (var R = -1, z = f.length, q = !1; ++R < z; ) {
          var ie = Jo(f[R]);
          if (!(q = u != null && w(u, ie)))
            break;
          u = u[ie];
        }
        return q || ++R != z ? q : (z = u == null ? 0 : u.length, !!z && T0(z) && Ga(ie, z) && (Vt(u) || iu(u)));
      }
      function tF(u) {
        var f = u.length, w = new u.constructor(f);
        return f && typeof u[0] == "string" && En.call(u, "index") && (w.index = u.index, w.input = u.input), w;
      }
      function N3(u) {
        return typeof u.constructor == "function" && !Zp(u) ? qo(Lh(u)) : {};
      }
      function nF(u, f, w) {
        var R = u.constructor;
        switch (f) {
          case Ve:
            return zw(u);
          case qe:
          case Ze:
            return new R(+u);
          case $e:
            return Bz(u, w);
          case Me:
          case lt:
          case Ye:
          case ht:
          case Xe:
          case Mt:
          case At:
          case Bt:
          case pe:
            return _3(u, w);
          case L:
            return new R();
          case fe:
          case F:
            return new R(u);
          case Te:
            return Uz(u);
          case Ce:
            return new R();
          case U:
            return Vz(u);
        }
      }
      function iF(u, f) {
        var w = f.length;
        if (!w)
          return u;
        var R = w - 1;
        return f[R] = (w > 1 ? "& " : "") + f[R], f = f.join(w > 2 ? ", " : " "), u.replace(X, `{
/* [wrapped with ` + f + `] */
`);
      }
      function rF(u) {
        return Vt(u) || iu(u) || !!(xp && u && u[xp]);
      }
      function Ga(u, f) {
        var w = typeof u;
        return f = f == null ? oe : f, !!f && (w == "number" || w != "symbol" && zn.test(u)) && u > -1 && u % 1 == 0 && u < f;
      }
      function Vr(u, f, w) {
        if (!ai(w))
          return !1;
        var R = typeof f;
        return (R == "number" ? us(w) && Ga(f, w.length) : R == "string" && f in w) ? mo(w[f], u) : !1;
      }
      function jw(u, f) {
        if (Vt(u))
          return !1;
        var w = typeof u;
        return w == "number" || w == "symbol" || w == "boolean" || u == null || Ts(u) ? !0 : Ma.test(u) || !Gn.test(u) || f != null && u in pt(f);
      }
      function sF(u) {
        var f = typeof u;
        return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? u !== "__proto__" : u === null;
      }
      function qw(u) {
        var f = b0(u), w = W[f];
        if (typeof w != "function" || !(f in Jt.prototype))
          return !1;
        if (u === w)
          return !0;
        var R = Hw(w);
        return !!R && u === R[0];
      }
      function oF(u) {
        return !!_p && _p in u;
      }
      var aF = kh ? Wa : c1;
      function Zp(u) {
        var f = u && u.constructor, w = typeof f == "function" && f.prototype || ss;
        return u === w;
      }
      function z3(u) {
        return u === u && !ai(u);
      }
      function F3(u, f) {
        return function(w) {
          return w == null ? !1 : w[u] === f && (f !== t || u in pt(w));
        };
      }
      function lF(u) {
        var f = E0(u, function(R) {
          return w.size === c && w.clear(), R;
        }), w = f.cache;
        return f;
      }
      function cF(u, f) {
        var w = u[1], R = f[1], z = w | R, q = z < (y | S | I), ie = R == I && w == M || R == I && w == k && u[7].length <= f[8] || R == (I | k) && f[7].length <= f[8] && w == M;
        if (!(q || ie))
          return u;
        R & y && (u[2] = f[2], z |= w & y ? 0 : C);
        var ue = f[3];
        if (ue) {
          var _e = u[3];
          u[3] = _e ? y3(_e, ue, f[4]) : ue, u[4] = _e ? Go(u[3], d) : f[4];
        }
        return ue = f[5], ue && (_e = u[5], u[5] = _e ? x3(_e, ue, f[6]) : ue, u[6] = _e ? Go(u[5], d) : f[6]), ue = f[7], ue && (u[7] = ue), R & I && (u[8] = u[8] == null ? f[8] : tr(u[8], f[8])), u[9] == null && (u[9] = f[9]), u[0] = f[0], u[1] = z, u;
      }
      function uF(u) {
        var f = [];
        if (u != null)
          for (var w in pt(u))
            f.push(w);
        return f;
      }
      function hF(u) {
        return Wc.call(u);
      }
      function B3(u, f, w) {
        return f = ti(f === t ? u.length - 1 : f, 0), function() {
          for (var R = arguments, z = -1, q = ti(R.length - f, 0), ie = Pe(q); ++z < q; )
            ie[z] = R[f + z];
          z = -1;
          for (var ue = Pe(f + 1); ++z < f; )
            ue[z] = R[z];
          return ue[f] = w(ie), Br(u, this, ue);
        };
      }
      function U3(u, f) {
        return f.length < 2 ? u : Ba(u, h(f, 0, -1));
      }
      function dF(u, f) {
        for (var w = u.length, R = tr(f.length, w), z = cs(u); R--; ) {
          var q = f[R];
          u[R] = Ga(q, w) ? z[q] : t;
        }
        return u;
      }
      function Xw(u, f) {
        if (!(f === "constructor" && typeof u[f] == "function") && f != "__proto__")
          return u[f];
      }
      var V3 = G3(f0), Yp = qg || function(u, f) {
        return Ni.setTimeout(u, f);
      }, $w = G3(Ow);
      function H3(u, f, w) {
        var R = f + "";
        return $w(u, iF(R, fF(eF(R), w)));
      }
      function G3(u) {
        var f = 0, w = 0;
        return function() {
          var R = $x(), z = K - (R - w);
          if (w = R, z > 0) {
            if (++f >= G)
              return arguments[0];
          } else
            f = 0;
          return u.apply(t, arguments);
        };
      }
      function x0(u, f) {
        var w = -1, R = u.length, z = R - 1;
        for (f = f === t ? R : f; ++w < f; ) {
          var q = qp(w, z), ie = u[q];
          u[q] = u[w], u[w] = ie;
        }
        return u.length = f, u;
      }
      var W3 = lF(function(u) {
        var f = [];
        return u.charCodeAt(0) === 46 && f.push(""), u.replace(pr, function(w, R, z, q) {
          f.push(z ? q.replace(it, "$1") : R || w);
        }), f;
      });
      function Jo(u) {
        if (typeof u == "string" || Ts(u))
          return u;
        var f = u + "";
        return f == "0" && 1 / u == -se ? "-0" : f;
      }
      function nu(u) {
        if (u != null) {
          try {
            return mr.call(u);
          } catch {
          }
          try {
            return u + "";
          } catch {
          }
        }
        return "";
      }
      function fF(u, f) {
        return ns(ye, function(w) {
          var R = "_." + w[0];
          f & w[1] && !zc(u, R) && u.push(R);
        }), u.sort();
      }
      function j3(u) {
        if (u instanceof Jt)
          return u.clone();
        var f = new os(u.__wrapped__, u.__chain__);
        return f.__actions__ = cs(u.__actions__), f.__index__ = u.__index__, f.__values__ = u.__values__, f;
      }
      function pF(u, f, w) {
        (w ? Vr(u, f, w) : f === t) ? f = 1 : f = ti(Xt(f), 0);
        var R = u == null ? 0 : u.length;
        if (!R || f < 1)
          return [];
        for (var z = 0, q = 0, ie = Pe(Ih(R / f)); z < R; )
          ie[q++] = h(u, z, z += f);
        return ie;
      }
      function mF(u) {
        for (var f = -1, w = u == null ? 0 : u.length, R = 0, z = []; ++f < w; ) {
          var q = u[f];
          q && (z[R++] = q);
        }
        return z;
      }
      function vF() {
        var u = arguments.length;
        if (!u)
          return [];
        for (var f = Pe(u - 1), w = arguments[0], R = u; R--; )
          f[R - 1] = arguments[R];
        return Bo(Vt(w) ? cs(w) : [w], zi(f, 1));
      }
      var gF = qt(function(u, f) {
        return gi(u) ? Jc(u, zi(f, 1, gi, !0)) : [];
      }), _F = qt(function(u, f) {
        var w = $s(f);
        return gi(w) && (w = t), gi(u) ? Jc(u, zi(f, 1, gi, !0), kt(w, 2)) : [];
      }), bF = qt(function(u, f) {
        var w = $s(f);
        return gi(w) && (w = t), gi(u) ? Jc(u, zi(f, 1, gi, !0), t, w) : [];
      });
      function yF(u, f, w) {
        var R = u == null ? 0 : u.length;
        return R ? (f = w || f === t ? 1 : Xt(f), h(u, f < 0 ? 0 : f, R)) : [];
      }
      function xF(u, f, w) {
        var R = u == null ? 0 : u.length;
        return R ? (f = w || f === t ? 1 : Xt(f), f = R - f, h(u, 0, f < 0 ? 0 : f)) : [];
      }
      function wF(u, f) {
        return u && u.length ? on(u, kt(f, 3), !0, !0) : [];
      }
      function SF(u, f) {
        return u && u.length ? on(u, kt(f, 3), !0) : [];
      }
      function MF(u, f, w, R) {
        var z = u == null ? 0 : u.length;
        return z ? (w && typeof w != "number" && Vr(u, f, w) && (w = 0, R = z), Nl(u, f, w, R)) : [];
      }
      function q3(u, f, w) {
        var R = u == null ? 0 : u.length;
        if (!R)
          return -1;
        var z = w == null ? 0 : Xt(w);
        return z < 0 && (z = ti(R + z, 0)), Eh(u, kt(f, 3), z);
      }
      function X3(u, f, w) {
        var R = u == null ? 0 : u.length;
        if (!R)
          return -1;
        var z = R - 1;
        return w !== t && (z = Xt(w), z = w < 0 ? ti(R + z, 0) : tr(z, R - 1)), Eh(u, kt(f, 3), z, !0);
      }
      function $3(u) {
        var f = u == null ? 0 : u.length;
        return f ? zi(u, 1) : [];
      }
      function EF(u) {
        var f = u == null ? 0 : u.length;
        return f ? zi(u, se) : [];
      }
      function CF(u, f) {
        var w = u == null ? 0 : u.length;
        return w ? (f = f === t ? 1 : Xt(f), zi(u, f)) : [];
      }
      function TF(u) {
        for (var f = -1, w = u == null ? 0 : u.length, R = {}; ++f < w; ) {
          var z = u[f];
          R[z[0]] = z[1];
        }
        return R;
      }
      function Z3(u) {
        return u && u.length ? u[0] : t;
      }
      function PF(u, f, w) {
        var R = u == null ? 0 : u.length;
        if (!R)
          return -1;
        var z = w == null ? 0 : Xt(w);
        return z < 0 && (z = ti(R + z, 0)), Pa(u, f, z);
      }
      function AF(u) {
        var f = u == null ? 0 : u.length;
        return f ? h(u, 0, -1) : [];
      }
      var RF = qt(function(u) {
        var f = Wt(u, Ul);
        return f.length && f[0] === u[0] ? Qc(f) : [];
      }), kF = qt(function(u) {
        var f = $s(u), w = Wt(u, Ul);
        return f === $s(w) ? f = t : w.pop(), w.length && w[0] === u[0] ? Qc(w, kt(f, 2)) : [];
      }), LF = qt(function(u) {
        var f = $s(u), w = Wt(u, Ul);
        return f = typeof f == "function" ? f : t, f && w.pop(), w.length && w[0] === u[0] ? Qc(w, t, f) : [];
      });
      function DF(u, f) {
        return u == null ? "" : $g.call(u, f);
      }
      function $s(u) {
        var f = u == null ? 0 : u.length;
        return f ? u[f - 1] : t;
      }
      function IF(u, f, w) {
        var R = u == null ? 0 : u.length;
        if (!R)
          return -1;
        var z = R;
        return w !== t && (z = Xt(w), z = z < 0 ? ti(R + z, 0) : tr(z, R - 1)), f === f ? Ra(u, f, z) : Eh(u, Uo, z, !0);
      }
      function OF(u, f) {
        return u && u.length ? l0(u, Xt(f)) : t;
      }
      var NF = qt(Y3);
      function Y3(u, f) {
        return u && u.length && f && f.length ? jp(u, f) : u;
      }
      function zF(u, f, w) {
        return u && u.length && f && f.length ? jp(u, f, kt(w, 2)) : u;
      }
      function FF(u, f, w) {
        return u && u.length && f && f.length ? jp(u, f, t, w) : u;
      }
      var BF = Ha(function(u, f) {
        var w = u == null ? 0 : u.length, R = kp(u, f);
        return d0(u, Wt(f, function(z) {
          return Ga(z, w) ? +z : z;
        }).sort(b3)), R;
      });
      function UF(u, f) {
        var w = [];
        if (!(u && u.length))
          return w;
        var R = -1, z = [], q = u.length;
        for (f = kt(f, 3); ++R < q; ) {
          var ie = u[R];
          f(ie, R, u) && (w.push(ie), z.push(R));
        }
        return d0(u, z), w;
      }
      function Zw(u) {
        return u == null ? u : Yx.call(u);
      }
      function VF(u, f, w) {
        var R = u == null ? 0 : u.length;
        return R ? (w && typeof w != "number" && Vr(u, f, w) ? (f = 0, w = R) : (f = f == null ? 0 : Xt(f), w = w === t ? R : Xt(w)), h(u, f, w)) : [];
      }
      function HF(u, f) {
        return E(u, f);
      }
      function GF(u, f, w) {
        return N(u, f, kt(w, 2));
      }
      function WF(u, f) {
        var w = u == null ? 0 : u.length;
        if (w) {
          var R = E(u, f);
          if (R < w && mo(u[R], f))
            return R;
        }
        return -1;
      }
      function jF(u, f) {
        return E(u, f, !0);
      }
      function qF(u, f, w) {
        return N(u, f, kt(w, 2), !0);
      }
      function XF(u, f) {
        var w = u == null ? 0 : u.length;
        if (w) {
          var R = E(u, f, !0) - 1;
          if (mo(u[R], f))
            return R;
        }
        return -1;
      }
      function $F(u) {
        return u && u.length ? ne(u) : [];
      }
      function ZF(u, f) {
        return u && u.length ? ne(u, kt(f, 2)) : [];
      }
      function YF(u) {
        var f = u == null ? 0 : u.length;
        return f ? h(u, 1, f) : [];
      }
      function KF(u, f, w) {
        return u && u.length ? (f = w || f === t ? 1 : Xt(f), h(u, 0, f < 0 ? 0 : f)) : [];
      }
      function JF(u, f, w) {
        var R = u == null ? 0 : u.length;
        return R ? (f = w || f === t ? 1 : Xt(f), f = R - f, h(u, f < 0 ? 0 : f, R)) : [];
      }
      function QF(u, f) {
        return u && u.length ? on(u, kt(f, 3), !1, !0) : [];
      }
      function eB(u, f) {
        return u && u.length ? on(u, kt(f, 3)) : [];
      }
      var tB = qt(function(u) {
        return mt(zi(u, 1, gi, !0));
      }), nB = qt(function(u) {
        var f = $s(u);
        return gi(f) && (f = t), mt(zi(u, 1, gi, !0), kt(f, 2));
      }), iB = qt(function(u) {
        var f = $s(u);
        return f = typeof f == "function" ? f : t, mt(zi(u, 1, gi, !0), t, f);
      });
      function rB(u) {
        return u && u.length ? mt(u) : [];
      }
      function sB(u, f) {
        return u && u.length ? mt(u, kt(f, 2)) : [];
      }
      function oB(u, f) {
        return f = typeof f == "function" ? f : t, u && u.length ? mt(u, t, f) : [];
      }
      function Yw(u) {
        if (!(u && u.length))
          return [];
        var f = 0;
        return u = er(u, function(w) {
          if (gi(w))
            return f = ti(w.length, f), !0;
        }), Aa(f, function(w) {
          return Wt(u, Ch(w));
        });
      }
      function K3(u, f) {
        if (!(u && u.length))
          return [];
        var w = Yw(u);
        return f == null ? w : Wt(w, function(R) {
          return Br(f, t, R);
        });
      }
      var aB = qt(function(u, f) {
        return gi(u) ? Jc(u, f) : [];
      }), lB = qt(function(u) {
        return Ua(er(u, gi));
      }), cB = qt(function(u) {
        var f = $s(u);
        return gi(f) && (f = t), Ua(er(u, gi), kt(f, 2));
      }), uB = qt(function(u) {
        var f = $s(u);
        return f = typeof f == "function" ? f : t, Ua(er(u, gi), t, f);
      }), hB = qt(Yw);
      function dB(u, f) {
        return Bl(u || [], f || [], Kc);
      }
      function fB(u, f) {
        return Bl(u || [], f || [], Fl);
      }
      var pB = qt(function(u) {
        var f = u.length, w = f > 1 ? u[f - 1] : t;
        return w = typeof w == "function" ? (u.pop(), w) : t, K3(u, w);
      });
      function J3(u) {
        var f = W(u);
        return f.__chain__ = !0, f;
      }
      function mB(u, f) {
        return f(u), u;
      }
      function w0(u, f) {
        return f(u);
      }
      var vB = Ha(function(u) {
        var f = u.length, w = f ? u[0] : 0, R = this.__wrapped__, z = function(q) {
          return kp(q, u);
        };
        return f > 1 || this.__actions__.length || !(R instanceof Jt) || !Ga(w) ? this.thru(z) : (R = R.slice(w, +w + (f ? 1 : 0)), R.__actions__.push({
          func: w0,
          args: [z],
          thisArg: t
        }), new os(R, this.__chain__).thru(function(q) {
          return f && !q.length && q.push(t), q;
        }));
      });
      function gB() {
        return J3(this);
      }
      function _B() {
        return new os(this.value(), this.__chain__);
      }
      function bB() {
        this.__values__ === t && (this.__values__ = dT(this.value()));
        var u = this.__index__ >= this.__values__.length, f = u ? t : this.__values__[this.__index__++];
        return { done: u, value: f };
      }
      function yB() {
        return this;
      }
      function xB(u) {
        for (var f, w = this; w instanceof Yc; ) {
          var R = j3(w);
          R.__index__ = 0, R.__values__ = t, f ? z.__wrapped__ = R : f = R;
          var z = R;
          w = w.__wrapped__;
        }
        return z.__wrapped__ = u, f;
      }
      function wB() {
        var u = this.__wrapped__;
        if (u instanceof Jt) {
          var f = u;
          return this.__actions__.length && (f = new Jt(this)), f = f.reverse(), f.__actions__.push({
            func: w0,
            args: [Zw],
            thisArg: t
          }), new os(f, this.__chain__);
        }
        return this.thru(Zw);
      }
      function SB() {
        return Yo(this.__wrapped__, this.__actions__);
      }
      var MB = p0(function(u, f, w) {
        En.call(u, w) ? ++u[w] : nr(u, w, 1);
      });
      function EB(u, f, w) {
        var R = Vt(u) ? Ig : Dp;
        return w && Vr(u, f, w) && (f = t), R(u, kt(f, 3));
      }
      function CB(u, f) {
        var w = Vt(u) ? er : Ip;
        return w(u, kt(f, 3));
      }
      var TB = E3(q3), PB = E3(X3);
      function AB(u, f) {
        return zi(S0(u, f), 1);
      }
      function RB(u, f) {
        return zi(S0(u, f), se);
      }
      function kB(u, f, w) {
        return w = w === t ? 1 : Xt(w), zi(S0(u, f), w);
      }
      function Q3(u, f) {
        var w = Vt(u) ? ns : Zo;
        return w(u, kt(f, 3));
      }
      function eT(u, f) {
        var w = Vt(u) ? Dg : Qg;
        return w(u, kt(f, 3));
      }
      var LB = p0(function(u, f, w) {
        En.call(u, w) ? u[w].push(f) : nr(u, w, [f]);
      });
      function DB(u, f, w, R) {
        u = us(u) ? u : $h(u), w = w && !R ? Xt(w) : 0;
        var z = u.length;
        return w < 0 && (w = ti(z + w, 0)), P0(u) ? w <= z && u.indexOf(f, w) > -1 : !!z && Pa(u, f, w) > -1;
      }
      var IB = qt(function(u, f, w) {
        var R = -1, z = typeof f == "function", q = us(u) ? Pe(u.length) : [];
        return Zo(u, function(ie) {
          q[++R] = z ? Br(f, ie, w) : ls(ie, f, w);
        }), q;
      }), OB = p0(function(u, f, w) {
        nr(u, w, f);
      });
      function S0(u, f) {
        var w = Vt(u) ? Wt : Xs;
        return w(u, kt(f, 3));
      }
      function NB(u, f, w, R) {
        return u == null ? [] : (Vt(f) || (f = f == null ? [] : [f]), w = R ? t : w, Vt(w) || (w = w == null ? [] : [w]), c0(u, f, w));
      }
      var zB = p0(function(u, f, w) {
        u[w ? 0 : 1].push(f);
      }, function() {
        return [[], []];
      });
      function FB(u, f, w) {
        var R = Vt(u) ? Pl : pp, z = arguments.length < 3;
        return R(u, kt(f, 4), w, z, Zo);
      }
      function BB(u, f, w) {
        var R = Vt(u) ? Og : pp, z = arguments.length < 3;
        return R(u, kt(f, 4), w, z, Qg);
      }
      function UB(u, f) {
        var w = Vt(u) ? er : Ip;
        return w(u, C0(kt(f, 3)));
      }
      function VB(u) {
        var f = Vt(u) ? Ap : Dw;
        return f(u);
      }
      function HB(u, f, w) {
        (w ? Vr(u, f, w) : f === t) ? f = 1 : f = Xt(f);
        var R = Vt(u) ? Kg : Iw;
        return R(u, f);
      }
      function GB(u) {
        var f = Vt(u) ? xw : _;
        return f(u);
      }
      function WB(u) {
        if (u == null)
          return 0;
        if (us(u))
          return P0(u) ? Ll(u) : u.length;
        var f = Ar(u);
        return f == L || f == Ce ? u.size : Vp(u).length;
      }
      function jB(u, f, w) {
        var R = Vt(u) ? Fc : g;
        return w && Vr(u, f, w) && (f = t), R(u, kt(f, 3));
      }
      var qB = qt(function(u, f) {
        if (u == null)
          return [];
        var w = f.length;
        return w > 1 && Vr(u, f[0], f[1]) ? f = [] : w > 2 && Vr(f[0], f[1], f[2]) && (f = [f[0]]), c0(u, zi(f, 1), []);
      }), M0 = wp || function() {
        return Ni.Date.now();
      };
      function XB(u, f) {
        if (typeof f != "function")
          throw new rs(o);
        return u = Xt(u), function() {
          if (--u < 1)
            return f.apply(this, arguments);
        };
      }
      function tT(u, f, w) {
        return f = w ? t : f, f = u && f == null ? u.length : f, Va(u, I, t, t, t, t, f);
      }
      function nT(u, f) {
        var w;
        if (typeof f != "function")
          throw new rs(o);
        return u = Xt(u), function() {
          return --u > 0 && (w = f.apply(this, arguments)), u <= 1 && (f = t), w;
        };
      }
      var Kw = qt(function(u, f, w) {
        var R = y;
        if (w.length) {
          var z = Go(w, qh(Kw));
          R |= P;
        }
        return Va(u, R, f, w, z);
      }), iT = qt(function(u, f, w) {
        var R = y | S;
        if (w.length) {
          var z = Go(w, qh(iT));
          R |= P;
        }
        return Va(f, R, u, w, z);
      });
      function rT(u, f, w) {
        f = w ? t : f;
        var R = Va(u, M, t, t, t, t, t, f);
        return R.placeholder = rT.placeholder, R;
      }
      function sT(u, f, w) {
        f = w ? t : f;
        var R = Va(u, T, t, t, t, t, t, f);
        return R.placeholder = sT.placeholder, R;
      }
      function oT(u, f, w) {
        var R, z, q, ie, ue, _e, Fe = 0, Ue = !1, Ge = !1, at = !0;
        if (typeof u != "function")
          throw new rs(o);
        f = Zs(f) || 0, ai(w) && (Ue = !!w.leading, Ge = "maxWait" in w, q = Ge ? ti(Zs(w.maxWait) || 0, f) : q, at = "trailing" in w ? !!w.trailing : at);
        function _t(_i) {
          var vo = R, qa = z;
          return R = z = t, Fe = _i, ie = u.apply(qa, vo), ie;
        }
        function Lt(_i) {
          return Fe = _i, ue = Yp(nn, f), Ue ? _t(_i) : ie;
        }
        function Kt(_i) {
          var vo = _i - _e, qa = _i - Fe, ET = f - vo;
          return Ge ? tr(ET, q - qa) : ET;
        }
        function Dt(_i) {
          var vo = _i - _e, qa = _i - Fe;
          return _e === t || vo >= f || vo < 0 || Ge && qa >= q;
        }
        function nn() {
          var _i = M0();
          if (Dt(_i))
            return ln(_i);
          ue = Yp(nn, Kt(_i));
        }
        function ln(_i) {
          return ue = t, at && R ? _t(_i) : (R = z = t, ie);
        }
        function Ps() {
          ue !== t && v3(ue), Fe = 0, R = _e = z = ue = t;
        }
        function Hr() {
          return ue === t ? ie : ln(M0());
        }
        function As() {
          var _i = M0(), vo = Dt(_i);
          if (R = arguments, z = this, _e = _i, vo) {
            if (ue === t)
              return Lt(_e);
            if (Ge)
              return v3(ue), ue = Yp(nn, f), _t(_e);
          }
          return ue === t && (ue = Yp(nn, f)), ie;
        }
        return As.cancel = Ps, As.flush = Hr, As;
      }
      var $B = qt(function(u, f) {
        return Lp(u, 1, f);
      }), ZB = qt(function(u, f, w) {
        return Lp(u, Zs(f) || 0, w);
      });
      function YB(u) {
        return Va(u, O);
      }
      function E0(u, f) {
        if (typeof u != "function" || f != null && typeof f != "function")
          throw new rs(o);
        var w = function() {
          var R = arguments, z = f ? f.apply(this, R) : R[0], q = w.cache;
          if (q.has(z))
            return q.get(z);
          var ie = u.apply(this, R);
          return w.cache = q.set(z, ie) || q, ie;
        };
        return w.cache = new (E0.Cache || po)(), w;
      }
      E0.Cache = po;
      function C0(u) {
        if (typeof u != "function")
          throw new rs(o);
        return function() {
          var f = arguments;
          switch (f.length) {
            case 0:
              return !u.call(this);
            case 1:
              return !u.call(this, f[0]);
            case 2:
              return !u.call(this, f[0], f[1]);
            case 3:
              return !u.call(this, f[0], f[1], f[2]);
          }
          return !u.apply(this, f);
        };
      }
      function KB(u) {
        return nT(2, u);
      }
      var JB = Fz(function(u, f) {
        f = f.length == 1 && Vt(f[0]) ? Wt(f[0], Ur(kt())) : Wt(zi(f, 1), Ur(kt()));
        var w = f.length;
        return qt(function(R) {
          for (var z = -1, q = tr(R.length, w); ++z < q; )
            R[z] = f[z].call(this, R[z]);
          return Br(u, this, R);
        });
      }), Jw = qt(function(u, f) {
        var w = Go(f, qh(Jw));
        return Va(u, P, t, f, w);
      }), aT = qt(function(u, f) {
        var w = Go(f, qh(aT));
        return Va(u, D, t, f, w);
      }), QB = Ha(function(u, f) {
        return Va(u, k, t, t, t, f);
      });
      function e8(u, f) {
        if (typeof u != "function")
          throw new rs(o);
        return f = f === t ? f : Xt(f), qt(u, f);
      }
      function t8(u, f) {
        if (typeof u != "function")
          throw new rs(o);
        return f = f == null ? 0 : ti(Xt(f), 0), qt(function(w) {
          var R = w[f], z = Hl(w, 0, f);
          return R && Bo(z, R), Br(u, this, z);
        });
      }
      function n8(u, f, w) {
        var R = !0, z = !0;
        if (typeof u != "function")
          throw new rs(o);
        return ai(w) && (R = "leading" in w ? !!w.leading : R, z = "trailing" in w ? !!w.trailing : z), oT(u, f, {
          leading: R,
          maxWait: f,
          trailing: z
        });
      }
      function i8(u) {
        return tT(u, 1);
      }
      function r8(u, f) {
        return Jw(Nw(f), u);
      }
      function s8() {
        if (!arguments.length)
          return [];
        var u = arguments[0];
        return Vt(u) ? u : [u];
      }
      function o8(u) {
        return as(u, v);
      }
      function a8(u, f) {
        return f = typeof f == "function" ? f : t, as(u, v, f);
      }
      function l8(u) {
        return as(u, p | v);
      }
      function c8(u, f) {
        return f = typeof f == "function" ? f : t, as(u, p | v, f);
      }
      function u8(u, f) {
        return f == null || Fa(u, f, rr(f));
      }
      function mo(u, f) {
        return u === f || u !== u && f !== f;
      }
      var h8 = _0(zp), d8 = _0(function(u, f) {
        return u >= f;
      }), iu = n0(function() {
        return arguments;
      }()) ? n0 : function(u) {
        return fi(u) && En.call(u, "callee") && !jg.call(u, "callee");
      }, Vt = Pe.isArray, f8 = Pg ? Ur(Pg) : Cw;
      function us(u) {
        return u != null && T0(u.length) && !Wa(u);
      }
      function gi(u) {
        return fi(u) && us(u);
      }
      function p8(u) {
        return u === !0 || u === !1 || fi(u) && ir(u) == qe;
      }
      var Gl = Xg || c1, m8 = Ag ? Ur(Ag) : Bp;
      function v8(u) {
        return fi(u) && u.nodeType === 1 && !Kp(u);
      }
      function g8(u) {
        if (u == null)
          return !0;
        if (us(u) && (Vt(u) || typeof u == "string" || typeof u.splice == "function" || Gl(u) || Xh(u) || iu(u)))
          return !u.length;
        var f = Ar(u);
        if (f == L || f == Ce)
          return !u.size;
        if (Zp(u))
          return !Vp(u).length;
        for (var w in u)
          if (En.call(u, w))
            return !1;
        return !0;
      }
      function _8(u, f) {
        return eu(u, f);
      }
      function b8(u, f, w) {
        w = typeof w == "function" ? w : t;
        var R = w ? w(u, f) : t;
        return R === t ? eu(u, f, t, w) : !!R;
      }
      function Qw(u) {
        if (!fi(u))
          return !1;
        var f = ir(u);
        return f == st || f == je || typeof u.message == "string" && typeof u.name == "string" && !Kp(u);
      }
      function y8(u) {
        return typeof u == "number" && Nh(u);
      }
      function Wa(u) {
        if (!ai(u))
          return !1;
        var f = ir(u);
        return f == Ie || f == Le || f == gt || f == re;
      }
      function lT(u) {
        return typeof u == "number" && u == Xt(u);
      }
      function T0(u) {
        return typeof u == "number" && u > -1 && u % 1 == 0 && u <= oe;
      }
      function ai(u) {
        var f = typeof u;
        return u != null && (f == "object" || f == "function");
      }
      function fi(u) {
        return u != null && typeof u == "object";
      }
      var cT = Rg ? Ur(Rg) : i0;
      function x8(u, f) {
        return u === f || Up(u, f, Gw(f));
      }
      function w8(u, f, w) {
        return w = typeof w == "function" ? w : t, Up(u, f, Gw(f), w);
      }
      function S8(u) {
        return uT(u) && u != +u;
      }
      function M8(u) {
        if (aF(u))
          throw new zt(s);
        return r0(u);
      }
      function E8(u) {
        return u === null;
      }
      function C8(u) {
        return u == null;
      }
      function uT(u) {
        return typeof u == "number" || fi(u) && ir(u) == fe;
      }
      function Kp(u) {
        if (!fi(u) || ir(u) != $)
          return !1;
        var f = Lh(u);
        if (f === null)
          return !0;
        var w = En.call(f, "constructor") && f.constructor;
        return typeof w == "function" && w instanceof w && mr.call(w) == Hg;
      }
      var e1 = kg ? Ur(kg) : Pw;
      function T8(u) {
        return lT(u) && u >= -oe && u <= oe;
      }
      var hT = Lg ? Ur(Lg) : Aw;
      function P0(u) {
        return typeof u == "string" || !Vt(u) && fi(u) && ir(u) == F;
      }
      function Ts(u) {
        return typeof u == "symbol" || fi(u) && ir(u) == U;
      }
      var Xh = hp ? Ur(hp) : Rw;
      function P8(u) {
        return u === t;
      }
      function A8(u) {
        return fi(u) && Ar(u) == me;
      }
      function R8(u) {
        return fi(u) && ir(u) == Ae;
      }
      var k8 = _0(Hp), L8 = _0(function(u, f) {
        return u <= f;
      });
      function dT(u) {
        if (!u)
          return [];
        if (us(u))
          return P0(u) ? Ss(u) : cs(u);
        if (Il && u[Il])
          return kl(u[Il]());
        var f = Ar(u), w = f == L ? Ho : f == Ce ? Rh : $h;
        return w(u);
      }
      function ja(u) {
        if (!u)
          return u === 0 ? u : 0;
        if (u = Zs(u), u === se || u === -se) {
          var f = u < 0 ? -1 : 1;
          return f * Q;
        }
        return u === u ? u : 0;
      }
      function Xt(u) {
        var f = ja(u), w = f % 1;
        return f === f ? w ? f - w : f : 0;
      }
      function fT(u) {
        return u ? $o(Xt(u), 0, te) : 0;
      }
      function Zs(u) {
        if (typeof u == "number")
          return u;
        if (Ts(u))
          return ce;
        if (ai(u)) {
          var f = typeof u.valueOf == "function" ? u.valueOf() : u;
          u = ai(f) ? f + "" : f;
        }
        if (typeof u != "string")
          return u === 0 ? u : +u;
        u = Ng(u);
        var w = Yt.test(u);
        return w || tn.test(u) ? zx(u.slice(2), w ? 2 : 8) : Ct.test(u) ? ce : +u;
      }
      function pT(u) {
        return Ko(u, hs(u));
      }
      function D8(u) {
        return u ? $o(Xt(u), -oe, oe) : u === 0 ? u : 0;
      }
      function Rn(u) {
        return u == null ? "" : He(u);
      }
      var I8 = Wh(function(u, f) {
        if (Zp(f) || us(f)) {
          Ko(f, rr(f), u);
          return;
        }
        for (var w in f)
          En.call(f, w) && Kc(u, w, f[w]);
      }), mT = Wh(function(u, f) {
        Ko(f, hs(f), u);
      }), A0 = Wh(function(u, f, w, R) {
        Ko(f, hs(f), u, R);
      }), O8 = Wh(function(u, f, w, R) {
        Ko(f, rr(f), u, R);
      }), N8 = Ha(kp);
      function z8(u, f) {
        var w = qo(u);
        return f == null ? w : za(w, f);
      }
      var F8 = qt(function(u, f) {
        u = pt(u);
        var w = -1, R = f.length, z = R > 2 ? f[2] : t;
        for (z && Vr(f[0], f[1], z) && (R = 1); ++w < R; )
          for (var q = f[w], ie = hs(q), ue = -1, _e = ie.length; ++ue < _e; ) {
            var Fe = ie[ue], Ue = u[Fe];
            (Ue === t || mo(Ue, ss[Fe]) && !En.call(u, Fe)) && (u[Fe] = q[Fe]);
          }
        return u;
      }), B8 = qt(function(u) {
        return u.push(t, L3), Br(vT, t, u);
      });
      function U8(u, f) {
        return Ws(u, kt(f, 3), qs);
      }
      function V8(u, f) {
        return Ws(u, kt(f, 3), Np);
      }
      function H8(u, f) {
        return u == null ? u : Op(u, kt(f, 3), hs);
      }
      function G8(u, f) {
        return u == null ? u : e0(u, kt(f, 3), hs);
      }
      function W8(u, f) {
        return u && qs(u, kt(f, 3));
      }
      function j8(u, f) {
        return u && Np(u, kt(f, 3));
      }
      function q8(u) {
        return u == null ? [] : Hh(u, rr(u));
      }
      function X8(u) {
        return u == null ? [] : Hh(u, hs(u));
      }
      function t1(u, f, w) {
        var R = u == null ? t : Ba(u, f);
        return R === t ? w : R;
      }
      function $8(u, f) {
        return u != null && O3(u, f, Fp);
      }
      function n1(u, f) {
        return u != null && O3(u, f, t0);
      }
      var Z8 = T3(function(u, f, w) {
        f != null && typeof f.toString != "function" && (f = Wc.call(f)), u[f] = w;
      }, r1(ds)), Y8 = T3(function(u, f, w) {
        f != null && typeof f.toString != "function" && (f = Wc.call(f)), En.call(u, f) ? u[f].push(w) : u[f] = [w];
      }, kt), K8 = qt(ls);
      function rr(u) {
        return us(u) ? Uh(u) : Vp(u);
      }
      function hs(u) {
        return us(u) ? Uh(u, !0) : kw(u);
      }
      function J8(u, f) {
        var w = {};
        return f = kt(f, 3), qs(u, function(R, z, q) {
          nr(w, f(R, z, q), R);
        }), w;
      }
      function Q8(u, f) {
        var w = {};
        return f = kt(f, 3), qs(u, function(R, z, q) {
          nr(w, z, f(R, z, q));
        }), w;
      }
      var eU = Wh(function(u, f, w) {
        Gh(u, f, w);
      }), vT = Wh(function(u, f, w, R) {
        Gh(u, f, w, R);
      }), tU = Ha(function(u, f) {
        var w = {};
        if (u == null)
          return w;
        var R = !1;
        f = Wt(f, function(q) {
          return q = Vl(q, u), R || (R = q.length > 1), q;
        }), Ko(u, Vw(u), w), R && (w = as(w, p | m | v, Zz));
        for (var z = f.length; z--; )
          Rt(w, f[z]);
        return w;
      });
      function nU(u, f) {
        return gT(u, C0(kt(f)));
      }
      var iU = Ha(function(u, f) {
        return u == null ? {} : u0(u, f);
      });
      function gT(u, f) {
        if (u == null)
          return {};
        var w = Wt(Vw(u), function(R) {
          return [R];
        });
        return f = kt(f), Wp(u, w, function(R, z) {
          return f(R, z[0]);
        });
      }
      function rU(u, f, w) {
        f = Vl(f, u);
        var R = -1, z = f.length;
        for (z || (z = 1, u = t); ++R < z; ) {
          var q = u == null ? t : u[Jo(f[R])];
          q === t && (R = z, q = w), u = Wa(q) ? q.call(u) : q;
        }
        return u;
      }
      function sU(u, f, w) {
        return u == null ? u : Fl(u, f, w);
      }
      function oU(u, f, w, R) {
        return R = typeof R == "function" ? R : t, u == null ? u : Fl(u, f, w, R);
      }
      var _T = R3(rr), bT = R3(hs);
      function aU(u, f, w) {
        var R = Vt(u), z = R || Gl(u) || Xh(u);
        if (f = kt(f, 4), w == null) {
          var q = u && u.constructor;
          z ? w = R ? new q() : [] : ai(u) ? w = Wa(q) ? qo(Lh(u)) : {} : w = {};
        }
        return (z ? ns : qs)(u, function(ie, ue, _e) {
          return f(w, ie, ue, _e);
        }), w;
      }
      function lU(u, f) {
        return u == null ? !0 : Rt(u, f);
      }
      function cU(u, f, w) {
        return u == null ? u : an(u, f, Nw(w));
      }
      function uU(u, f, w, R) {
        return R = typeof R == "function" ? R : t, u == null ? u : an(u, f, Nw(w), R);
      }
      function $h(u) {
        return u == null ? [] : Vc(u, rr(u));
      }
      function hU(u) {
        return u == null ? [] : Vc(u, hs(u));
      }
      function dU(u, f, w) {
        return w === t && (w = f, f = t), w !== t && (w = Zs(w), w = w === w ? w : 0), f !== t && (f = Zs(f), f = f === f ? f : 0), $o(Zs(u), f, w);
      }
      function fU(u, f, w) {
        return f = ja(f), w === t ? (w = f, f = 0) : w = ja(w), u = Zs(u), Mw(u, f, w);
      }
      function pU(u, f, w) {
        if (w && typeof w != "boolean" && Vr(u, f, w) && (f = w = t), w === t && (typeof f == "boolean" ? (w = f, f = t) : typeof u == "boolean" && (w = u, u = t)), u === t && f === t ? (u = 0, f = 1) : (u = ja(u), f === t ? (f = u, u = 0) : f = ja(f)), u > f) {
          var R = u;
          u = f, f = R;
        }
        if (w || u % 1 || f % 1) {
          var z = Sp();
          return tr(u + z * (f - u + Nx("1e-" + ((z + "").length - 1))), f);
        }
        return qp(u, f);
      }
      var mU = jh(function(u, f, w) {
        return f = f.toLowerCase(), u + (w ? yT(f) : f);
      });
      function yT(u) {
        return i1(Rn(u).toLowerCase());
      }
      function xT(u) {
        return u = Rn(u), u && u.replace(ao, zg).replace(Mg, "");
      }
      function vU(u, f, w) {
        u = Rn(u), f = He(f);
        var R = u.length;
        w = w === t ? R : $o(Xt(w), 0, R);
        var z = w;
        return w -= f.length, w >= 0 && u.slice(w, z) == f;
      }
      function gU(u) {
        return u = Rn(u), u && Hn.test(u) ? u.replace(Ft, Vo) : u;
      }
      function _U(u) {
        return u = Rn(u), u && We.test(u) ? u.replace(le, "\\$&") : u;
      }
      var bU = jh(function(u, f, w) {
        return u + (w ? "-" : "") + f.toLowerCase();
      }), yU = jh(function(u, f, w) {
        return u + (w ? " " : "") + f.toLowerCase();
      }), xU = M3("toLowerCase");
      function wU(u, f, w) {
        u = Rn(u), f = Xt(f);
        var R = f ? Ll(u) : 0;
        if (!f || R >= f)
          return u;
        var z = (f - R) / 2;
        return g0(Ol(z), w) + u + g0(Ih(z), w);
      }
      function SU(u, f, w) {
        u = Rn(u), f = Xt(f);
        var R = f ? Ll(u) : 0;
        return f && R < f ? u + g0(f - R, w) : u;
      }
      function MU(u, f, w) {
        u = Rn(u), f = Xt(f);
        var R = f ? Ll(u) : 0;
        return f && R < f ? g0(f - R, w) + u : u;
      }
      function EU(u, f, w) {
        return w || f == null ? f = 0 : f && (f = +f), Zx(Rn(u).replace(et, ""), f || 0);
      }
      function CU(u, f, w) {
        return (w ? Vr(u, f, w) : f === t) ? f = 1 : f = Xt(f), Xp(Rn(u), f);
      }
      function TU() {
        var u = arguments, f = Rn(u[0]);
        return u.length < 3 ? f : f.replace(u[1], u[2]);
      }
      var PU = jh(function(u, f, w) {
        return u + (w ? "_" : "") + f.toLowerCase();
      });
      function AU(u, f, w) {
        return w && typeof w != "number" && Vr(u, f, w) && (f = w = t), w = w === t ? te : w >>> 0, w ? (u = Rn(u), u && (typeof f == "string" || f != null && !e1(f)) && (f = He(f), !f && Rl(u)) ? Hl(Ss(u), 0, w) : u.split(f, w)) : [];
      }
      var RU = jh(function(u, f, w) {
        return u + (w ? " " : "") + i1(f);
      });
      function kU(u, f, w) {
        return u = Rn(u), w = w == null ? 0 : $o(Xt(w), 0, u.length), f = He(f), u.slice(w, w + f.length) == f;
      }
      function LU(u, f, w) {
        var R = W.templateSettings;
        w && Vr(u, f, w) && (f = t), u = Rn(u), f = A0({}, f, R, k3);
        var z = A0({}, f.imports, R.imports, k3), q = rr(z), ie = Vc(z, q), ue, _e, Fe = 0, Ue = f.interpolate || Ki, Ge = "__p += '", at = js(
          (f.escape || Ki).source + "|" + Ue.source + "|" + (Ue === Yi ? ct : Ki).source + "|" + (f.evaluate || Ki).source + "|$",
          "g"
        ), _t = "//# sourceURL=" + (En.call(f, "sourceURL") ? (f.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ap + "]") + `
`;
        u.replace(at, function(Dt, nn, ln, Ps, Hr, As) {
          return ln || (ln = Ps), Ge += u.slice(Fe, As).replace(lo, Fg), nn && (ue = !0, Ge += `' +
__e(` + nn + `) +
'`), Hr && (_e = !0, Ge += `';
` + Hr + `;
__p += '`), ln && (Ge += `' +
((__t = (` + ln + `)) == null ? '' : __t) +
'`), Fe = As + Dt.length, Dt;
        }), Ge += `';
`;
        var Lt = En.call(f, "variable") && f.variable;
        if (!Lt)
          Ge = `with (obj) {
` + Ge + `
}
`;
        else if (ke.test(Lt))
          throw new zt(a);
        Ge = (_e ? Ge.replace(ot, "") : Ge).replace(De, "$1").replace(tt, "$1;"), Ge = "function(" + (Lt || "obj") + `) {
` + (Lt ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (ue ? ", __e = _.escape" : "") + (_e ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ge + `return __p
}`;
        var Kt = ST(function() {
          return mn(q, _t + "return " + Ge).apply(t, ie);
        });
        if (Kt.source = Ge, Qw(Kt))
          throw Kt;
        return Kt;
      }
      function DU(u) {
        return Rn(u).toLowerCase();
      }
      function IU(u) {
        return Rn(u).toUpperCase();
      }
      function OU(u, f, w) {
        if (u = Rn(u), u && (w || f === t))
          return Ng(u);
        if (!u || !(f = He(f)))
          return u;
        var R = Ss(u), z = Ss(f), q = Th(R, z), ie = Al(R, z) + 1;
        return Hl(R, q, ie).join("");
      }
      function NU(u, f, w) {
        if (u = Rn(u), u && (w || f === t))
          return u.slice(0, Bg(u) + 1);
        if (!u || !(f = He(f)))
          return u;
        var R = Ss(u), z = Al(R, Ss(f)) + 1;
        return Hl(R, 0, z).join("");
      }
      function zU(u, f, w) {
        if (u = Rn(u), u && (w || f === t))
          return u.replace(et, "");
        if (!u || !(f = He(f)))
          return u;
        var R = Ss(u), z = Th(R, Ss(f));
        return Hl(R, z).join("");
      }
      function FU(u, f) {
        var w = B, R = Y;
        if (ai(f)) {
          var z = "separator" in f ? f.separator : z;
          w = "length" in f ? Xt(f.length) : w, R = "omission" in f ? He(f.omission) : R;
        }
        u = Rn(u);
        var q = u.length;
        if (Rl(u)) {
          var ie = Ss(u);
          q = ie.length;
        }
        if (w >= q)
          return u;
        var ue = w - Ll(R);
        if (ue < 1)
          return R;
        var _e = ie ? Hl(ie, 0, ue).join("") : u.slice(0, ue);
        if (z === t)
          return _e + R;
        if (ie && (ue += _e.length - ue), e1(z)) {
          if (u.slice(ue).search(z)) {
            var Fe, Ue = _e;
            for (z.global || (z = js(z.source, Rn(Et.exec(z)) + "g")), z.lastIndex = 0; Fe = z.exec(Ue); )
              var Ge = Fe.index;
            _e = _e.slice(0, Ge === t ? ue : Ge);
          }
        } else if (u.indexOf(He(z), ue) != ue) {
          var at = _e.lastIndexOf(z);
          at > -1 && (_e = _e.slice(0, at));
        }
        return _e + R;
      }
      function BU(u) {
        return u = Rn(u), u && An.test(u) ? u.replace(Qe, Hx) : u;
      }
      var UU = jh(function(u, f, w) {
        return u + (w ? " " : "") + f.toUpperCase();
      }), i1 = M3("toUpperCase");
      function wT(u, f, w) {
        return u = Rn(u), f = w ? t : f, f === t ? Ah(u) ? Wx(u) : Uc(u) : u.match(f) || [];
      }
      var ST = qt(function(u, f) {
        try {
          return Br(u, t, f);
        } catch (w) {
          return Qw(w) ? w : new zt(w);
        }
      }), VU = Ha(function(u, f) {
        return ns(f, function(w) {
          w = Jo(w), nr(u, w, Kw(u[w], u));
        }), u;
      });
      function HU(u) {
        var f = u == null ? 0 : u.length, w = kt();
        return u = f ? Wt(u, function(R) {
          if (typeof R[1] != "function")
            throw new rs(o);
          return [w(R[0]), R[1]];
        }) : [], qt(function(R) {
          for (var z = -1; ++z < f; ) {
            var q = u[z];
            if (Br(q[0], this, R))
              return Br(q[1], this, R);
          }
        });
      }
      function GU(u) {
        return Sw(as(u, p));
      }
      function r1(u) {
        return function() {
          return u;
        };
      }
      function WU(u, f) {
        return u == null || u !== u ? f : u;
      }
      var jU = C3(), qU = C3(!0);
      function ds(u) {
        return u;
      }
      function s1(u) {
        return s0(typeof u == "function" ? u : as(u, p));
      }
      function XU(u) {
        return o0(as(u, p));
      }
      function $U(u, f) {
        return Gp(u, as(f, p));
      }
      var ZU = qt(function(u, f) {
        return function(w) {
          return ls(w, u, f);
        };
      }), YU = qt(function(u, f) {
        return function(w) {
          return ls(u, w, f);
        };
      });
      function o1(u, f, w) {
        var R = rr(f), z = Hh(f, R);
        w == null && !(ai(f) && (z.length || !R.length)) && (w = f, f = u, u = this, z = Hh(f, rr(f)));
        var q = !(ai(w) && "chain" in w) || !!w.chain, ie = Wa(u);
        return ns(z, function(ue) {
          var _e = f[ue];
          u[ue] = _e, ie && (u.prototype[ue] = function() {
            var Fe = this.__chain__;
            if (q || Fe) {
              var Ue = u(this.__wrapped__), Ge = Ue.__actions__ = cs(this.__actions__);
              return Ge.push({ func: _e, args: arguments, thisArg: u }), Ue.__chain__ = Fe, Ue;
            }
            return _e.apply(u, Bo([this.value()], arguments));
          });
        }), u;
      }
      function KU() {
        return Ni._ === this && (Ni._ = Gg), this;
      }
      function a1() {
      }
      function JU(u) {
        return u = Xt(u), qt(function(f) {
          return l0(f, u);
        });
      }
      var QU = Fw(Wt), eV = Fw(Ig), tV = Fw(Fc);
      function MT(u) {
        return jw(u) ? Ch(Jo(u)) : h0(u);
      }
      function nV(u) {
        return function(f) {
          return u == null ? t : Ba(u, f);
        };
      }
      var iV = P3(), rV = P3(!0);
      function l1() {
        return [];
      }
      function c1() {
        return !1;
      }
      function sV() {
        return {};
      }
      function oV() {
        return "";
      }
      function aV() {
        return !0;
      }
      function lV(u, f) {
        if (u = Xt(u), u < 1 || u > oe)
          return [];
        var w = te, R = tr(u, te);
        f = kt(f), u -= te;
        for (var z = Aa(R, f); ++w < u; )
          f(w);
        return z;
      }
      function cV(u) {
        return Vt(u) ? Wt(u, Jo) : Ts(u) ? [u] : cs(W3(Rn(u)));
      }
      function uV(u) {
        var f = ++Vg;
        return Rn(u) + f;
      }
      var hV = v0(function(u, f) {
        return u + f;
      }, 0), dV = Bw("ceil"), fV = v0(function(u, f) {
        return u / f;
      }, 1), pV = Bw("floor");
      function mV(u) {
        return u && u.length ? Vh(u, ds, zp) : t;
      }
      function vV(u, f) {
        return u && u.length ? Vh(u, kt(f, 2), zp) : t;
      }
      function gV(u) {
        return Wn(u, ds);
      }
      function _V(u, f) {
        return Wn(u, kt(f, 2));
      }
      function bV(u) {
        return u && u.length ? Vh(u, ds, Hp) : t;
      }
      function yV(u, f) {
        return u && u.length ? Vh(u, kt(f, 2), Hp) : t;
      }
      var xV = v0(function(u, f) {
        return u * f;
      }, 1), wV = Bw("round"), SV = v0(function(u, f) {
        return u - f;
      }, 0);
      function MV(u) {
        return u && u.length ? mp(u, ds) : 0;
      }
      function EV(u, f) {
        return u && u.length ? mp(u, kt(f, 2)) : 0;
      }
      return W.after = XB, W.ary = tT, W.assign = I8, W.assignIn = mT, W.assignInWith = A0, W.assignWith = O8, W.at = N8, W.before = nT, W.bind = Kw, W.bindAll = VU, W.bindKey = iT, W.castArray = s8, W.chain = J3, W.chunk = pF, W.compact = mF, W.concat = vF, W.cond = HU, W.conforms = GU, W.constant = r1, W.countBy = MB, W.create = z8, W.curry = rT, W.curryRight = sT, W.debounce = oT, W.defaults = F8, W.defaultsDeep = B8, W.defer = $B, W.delay = ZB, W.difference = gF, W.differenceBy = _F, W.differenceWith = bF, W.drop = yF, W.dropRight = xF, W.dropRightWhile = wF, W.dropWhile = SF, W.fill = MF, W.filter = CB, W.flatMap = AB, W.flatMapDeep = RB, W.flatMapDepth = kB, W.flatten = $3, W.flattenDeep = EF, W.flattenDepth = CF, W.flip = YB, W.flow = jU, W.flowRight = qU, W.fromPairs = TF, W.functions = q8, W.functionsIn = X8, W.groupBy = LB, W.initial = AF, W.intersection = RF, W.intersectionBy = kF, W.intersectionWith = LF, W.invert = Z8, W.invertBy = Y8, W.invokeMap = IB, W.iteratee = s1, W.keyBy = OB, W.keys = rr, W.keysIn = hs, W.map = S0, W.mapKeys = J8, W.mapValues = Q8, W.matches = XU, W.matchesProperty = $U, W.memoize = E0, W.merge = eU, W.mergeWith = vT, W.method = ZU, W.methodOf = YU, W.mixin = o1, W.negate = C0, W.nthArg = JU, W.omit = tU, W.omitBy = nU, W.once = KB, W.orderBy = NB, W.over = QU, W.overArgs = JB, W.overEvery = eV, W.overSome = tV, W.partial = Jw, W.partialRight = aT, W.partition = zB, W.pick = iU, W.pickBy = gT, W.property = MT, W.propertyOf = nV, W.pull = NF, W.pullAll = Y3, W.pullAllBy = zF, W.pullAllWith = FF, W.pullAt = BF, W.range = iV, W.rangeRight = rV, W.rearg = QB, W.reject = UB, W.remove = UF, W.rest = e8, W.reverse = Zw, W.sampleSize = HB, W.set = sU, W.setWith = oU, W.shuffle = GB, W.slice = VF, W.sortBy = qB, W.sortedUniq = $F, W.sortedUniqBy = ZF, W.split = AU, W.spread = t8, W.tail = YF, W.take = KF, W.takeRight = JF, W.takeRightWhile = QF, W.takeWhile = eB, W.tap = mB, W.throttle = n8, W.thru = w0, W.toArray = dT, W.toPairs = _T, W.toPairsIn = bT, W.toPath = cV, W.toPlainObject = pT, W.transform = aU, W.unary = i8, W.union = tB, W.unionBy = nB, W.unionWith = iB, W.uniq = rB, W.uniqBy = sB, W.uniqWith = oB, W.unset = lU, W.unzip = Yw, W.unzipWith = K3, W.update = cU, W.updateWith = uU, W.values = $h, W.valuesIn = hU, W.without = aB, W.words = wT, W.wrap = r8, W.xor = lB, W.xorBy = cB, W.xorWith = uB, W.zip = hB, W.zipObject = dB, W.zipObjectDeep = fB, W.zipWith = pB, W.entries = _T, W.entriesIn = bT, W.extend = mT, W.extendWith = A0, o1(W, W), W.add = hV, W.attempt = ST, W.camelCase = mU, W.capitalize = yT, W.ceil = dV, W.clamp = dU, W.clone = o8, W.cloneDeep = l8, W.cloneDeepWith = c8, W.cloneWith = a8, W.conformsTo = u8, W.deburr = xT, W.defaultTo = WU, W.divide = fV, W.endsWith = vU, W.eq = mo, W.escape = gU, W.escapeRegExp = _U, W.every = EB, W.find = TB, W.findIndex = q3, W.findKey = U8, W.findLast = PB, W.findLastIndex = X3, W.findLastKey = V8, W.floor = pV, W.forEach = Q3, W.forEachRight = eT, W.forIn = H8, W.forInRight = G8, W.forOwn = W8, W.forOwnRight = j8, W.get = t1, W.gt = h8, W.gte = d8, W.has = $8, W.hasIn = n1, W.head = Z3, W.identity = ds, W.includes = DB, W.indexOf = PF, W.inRange = fU, W.invoke = K8, W.isArguments = iu, W.isArray = Vt, W.isArrayBuffer = f8, W.isArrayLike = us, W.isArrayLikeObject = gi, W.isBoolean = p8, W.isBuffer = Gl, W.isDate = m8, W.isElement = v8, W.isEmpty = g8, W.isEqual = _8, W.isEqualWith = b8, W.isError = Qw, W.isFinite = y8, W.isFunction = Wa, W.isInteger = lT, W.isLength = T0, W.isMap = cT, W.isMatch = x8, W.isMatchWith = w8, W.isNaN = S8, W.isNative = M8, W.isNil = C8, W.isNull = E8, W.isNumber = uT, W.isObject = ai, W.isObjectLike = fi, W.isPlainObject = Kp, W.isRegExp = e1, W.isSafeInteger = T8, W.isSet = hT, W.isString = P0, W.isSymbol = Ts, W.isTypedArray = Xh, W.isUndefined = P8, W.isWeakMap = A8, W.isWeakSet = R8, W.join = DF, W.kebabCase = bU, W.last = $s, W.lastIndexOf = IF, W.lowerCase = yU, W.lowerFirst = xU, W.lt = k8, W.lte = L8, W.max = mV, W.maxBy = vV, W.mean = gV, W.meanBy = _V, W.min = bV, W.minBy = yV, W.stubArray = l1, W.stubFalse = c1, W.stubObject = sV, W.stubString = oV, W.stubTrue = aV, W.multiply = xV, W.nth = OF, W.noConflict = KU, W.noop = a1, W.now = M0, W.pad = wU, W.padEnd = SU, W.padStart = MU, W.parseInt = EU, W.random = pU, W.reduce = FB, W.reduceRight = BB, W.repeat = CU, W.replace = TU, W.result = rU, W.round = wV, W.runInContext = ve, W.sample = VB, W.size = WB, W.snakeCase = PU, W.some = jB, W.sortedIndex = HF, W.sortedIndexBy = GF, W.sortedIndexOf = WF, W.sortedLastIndex = jF, W.sortedLastIndexBy = qF, W.sortedLastIndexOf = XF, W.startCase = RU, W.startsWith = kU, W.subtract = SV, W.sum = MV, W.sumBy = EV, W.template = LU, W.times = lV, W.toFinite = ja, W.toInteger = Xt, W.toLength = fT, W.toLower = DU, W.toNumber = Zs, W.toSafeInteger = D8, W.toString = Rn, W.toUpper = IU, W.trim = OU, W.trimEnd = NU, W.trimStart = zU, W.truncate = FU, W.unescape = BU, W.uniqueId = uV, W.upperCase = UU, W.upperFirst = i1, W.each = Q3, W.eachRight = eT, W.first = Z3, o1(W, function() {
        var u = {};
        return qs(W, function(f, w) {
          En.call(W.prototype, w) || (u[w] = f);
        }), u;
      }(), { chain: !1 }), W.VERSION = i, ns(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(u) {
        W[u].placeholder = W;
      }), ns(["drop", "take"], function(u, f) {
        Jt.prototype[u] = function(w) {
          w = w === t ? 1 : ti(Xt(w), 0);
          var R = this.__filtered__ && !f ? new Jt(this) : this.clone();
          return R.__filtered__ ? R.__takeCount__ = tr(w, R.__takeCount__) : R.__views__.push({
            size: tr(w, te),
            type: u + (R.__dir__ < 0 ? "Right" : "")
          }), R;
        }, Jt.prototype[u + "Right"] = function(w) {
          return this.reverse()[u](w).reverse();
        };
      }), ns(["filter", "map", "takeWhile"], function(u, f) {
        var w = f + 1, R = w == A || w == xe;
        Jt.prototype[u] = function(z) {
          var q = this.clone();
          return q.__iteratees__.push({
            iteratee: kt(z, 3),
            type: w
          }), q.__filtered__ = q.__filtered__ || R, q;
        };
      }), ns(["head", "last"], function(u, f) {
        var w = "take" + (f ? "Right" : "");
        Jt.prototype[u] = function() {
          return this[w](1).value()[0];
        };
      }), ns(["initial", "tail"], function(u, f) {
        var w = "drop" + (f ? "" : "Right");
        Jt.prototype[u] = function() {
          return this.__filtered__ ? new Jt(this) : this[w](1);
        };
      }), Jt.prototype.compact = function() {
        return this.filter(ds);
      }, Jt.prototype.find = function(u) {
        return this.filter(u).head();
      }, Jt.prototype.findLast = function(u) {
        return this.reverse().find(u);
      }, Jt.prototype.invokeMap = qt(function(u, f) {
        return typeof u == "function" ? new Jt(this) : this.map(function(w) {
          return ls(w, u, f);
        });
      }), Jt.prototype.reject = function(u) {
        return this.filter(C0(kt(u)));
      }, Jt.prototype.slice = function(u, f) {
        u = Xt(u);
        var w = this;
        return w.__filtered__ && (u > 0 || f < 0) ? new Jt(w) : (u < 0 ? w = w.takeRight(-u) : u && (w = w.drop(u)), f !== t && (f = Xt(f), w = f < 0 ? w.dropRight(-f) : w.take(f - u)), w);
      }, Jt.prototype.takeRightWhile = function(u) {
        return this.reverse().takeWhile(u).reverse();
      }, Jt.prototype.toArray = function() {
        return this.take(te);
      }, qs(Jt.prototype, function(u, f) {
        var w = /^(?:filter|find|map|reject)|While$/.test(f), R = /^(?:head|last)$/.test(f), z = W[R ? "take" + (f == "last" ? "Right" : "") : f], q = R || /^find/.test(f);
        !z || (W.prototype[f] = function() {
          var ie = this.__wrapped__, ue = R ? [1] : arguments, _e = ie instanceof Jt, Fe = ue[0], Ue = _e || Vt(ie), Ge = function(nn) {
            var ln = z.apply(W, Bo([nn], ue));
            return R && at ? ln[0] : ln;
          };
          Ue && w && typeof Fe == "function" && Fe.length != 1 && (_e = Ue = !1);
          var at = this.__chain__, _t = !!this.__actions__.length, Lt = q && !at, Kt = _e && !_t;
          if (!q && Ue) {
            ie = Kt ? ie : new Jt(this);
            var Dt = u.apply(ie, ue);
            return Dt.__actions__.push({ func: w0, args: [Ge], thisArg: t }), new os(Dt, at);
          }
          return Lt && Kt ? u.apply(this, ue) : (Dt = this.thru(Ge), Lt ? R ? Dt.value()[0] : Dt.value() : Dt);
        });
      }), ns(["pop", "push", "shift", "sort", "splice", "unshift"], function(u) {
        var f = Dl[u], w = /^(?:push|sort|unshift)$/.test(u) ? "tap" : "thru", R = /^(?:pop|shift)$/.test(u);
        W.prototype[u] = function() {
          var z = arguments;
          if (R && !this.__chain__) {
            var q = this.value();
            return f.apply(Vt(q) ? q : [], z);
          }
          return this[w](function(ie) {
            return f.apply(Vt(ie) ? ie : [], z);
          });
        };
      }), qs(Jt.prototype, function(u, f) {
        var w = W[f];
        if (w) {
          var R = w.name + "";
          En.call(Ms, R) || (Ms[R] = []), Ms[R].push({ name: f, func: w });
        }
      }), Ms[m0(t, S).name] = [{
        name: "wrapper",
        func: t
      }], Jt.prototype.clone = tw, Jt.prototype.reverse = Cp, Jt.prototype.value = nw, W.prototype.at = vB, W.prototype.chain = gB, W.prototype.commit = _B, W.prototype.next = bB, W.prototype.plant = xB, W.prototype.reverse = wB, W.prototype.toJSON = W.prototype.valueOf = W.prototype.value = SB, W.prototype.first = W.prototype.head, Il && (W.prototype[Il] = yB), W;
    }, La = ka();
    Ta ? ((Ta.exports = La)._ = La, cp._ = La) : Ni._ = La;
  }).call(sl);
})(lr, lr.exports);
const Mr = (n, e, t) => {
  if (!n.has(e)) {
    const i = t();
    return n.set(e, i), i;
  }
  return n.get(e);
}, NV = (n, e, t, i = []) => {
  if (!n.has(e)) {
    const r = new t(...i);
    return n.set(e, r), r;
  }
  return n.get(e);
}, hy = (n) => {
  throw new Error("unexpected value: " + n);
}, U_ = (n, e, t) => {
  var i, r;
  let s = n;
  const o = e.length - 1;
  for (let a = 0; a < o; ++a)
    s = (i = s[r = e[a]]) !== null && i !== void 0 ? i : s[r] = {};
  s[e[o]] = t;
}, mb = (n, e, t = /* @__PURE__ */ new WeakSet()) => {
  if (Array.isArray(n)) {
    if (t.has(n))
      return;
    t.add(n);
    for (let i = 0; i < n.length; ++i) {
      const r = n[i];
      e(i, r, n), mb(r, e, t);
    }
  } else if (n && typeof n == "object") {
    if (t.has(n))
      return;
    t.add(n);
    for (const [i, r] of Object.entries(n))
      e(i, r, n), mb(r, e, t);
  }
}, TL = (n, e) => {
  const t = n.indexOf(e);
  return t === -1 ? !1 : (n.splice(t, 1), !0);
}, dy = (n) => {
  const e = n.split(".");
  if (e.length === 1)
    return e;
  const t = e.pop();
  return [e.join("."), t];
}, PL = (n, e, t) => {
  let i, r = !1, s, o, a = t === "trailingPromise" ? new Promise((l) => o = l) : void 0;
  return (...l) => {
    if (s = l, r)
      return a != null ? a : i;
    r = !0, (t === "leading" || t === "both") && (i = n(...s));
    const c = () => {
      (t === "trailing" || t === "both" || t === "trailingPromise") && (i = n(...s), o == null || o(i), a = t === "trailingPromise" ? new Promise((d) => o = d) : void 0), r = !1;
    };
    return e > 0 ? setTimeout(c, e) : queueMicrotask(c), a != null ? a : i;
  };
}, No = (n, e = 0) => {
  let t = !1, i;
  return (...r) => {
    if (i = r, t)
      return;
    t = !0;
    const s = () => {
      t = !1, n(...i);
    };
    e === 0 ? queueMicrotask(s) : setTimeout(s, e);
  };
}, AL = (n) => {
  let e = !0;
  return queueMicrotask(() => e && n()), () => {
    e = !1;
  };
}, zV = (n, e) => {
  if (e === 0)
    return AL(n);
  const t = setTimeout(n, e);
  return () => clearTimeout(t);
}, nE = (n, e, t) => {
  let i, r, s, o, a = t === "trailingPromise" ? new Promise((l) => o = l) : void 0;
  return (...l) => (s = l, i ? i() : (t === "leading" || t === "both") && (r = n(...s)), i = zV(() => {
    (t === "trailing" || t === "both" || t === "trailingPromise") && (r = n(...s), o == null || o(r), a = t === "trailingPromise" ? new Promise((c) => o = c) : void 0), i = void 0;
  }, e), a != null ? a : r);
}, FV = /* @__PURE__ */ new WeakSet(), iE = (n) => {
  let e, t = !1;
  const i = (...r) => t ? e : (t = !0, e = n(...r));
  return FV.add(i), i;
}, th = (n, e) => {
  for (const t of e)
    for (const i of Object.getOwnPropertyNames(t.prototype))
      !(i in n.prototype) && Object.defineProperty(n.prototype, i, Object.getOwnPropertyDescriptor(t.prototype, i) || /* @__PURE__ */ Object.create(null));
}, BV = (n) => !!n, UV = (n) => {
  const e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
  return (i, ...r) => {
    var s;
    t.set(i, r), (s = e.get(i)) === null || s === void 0 || s(), e.set(i, AL(() => {
      n(...t.get(i)), e.delete(i);
    }));
  };
}, VV = (n) => n, RL = globalThis;
"__LINCODE_UTILS__" in RL && console.warn("multiple versions of @lincode/utils detected");
RL.__LINCODE_UTILS__ = !0;
class HV {
  constructor(e = void 0) {
    this._cb = e, this.done = void 0, this._value = void 0, this._callbacks = void 0, this._watched = void 0;
  }
  then(e) {
    var t;
    return this.done ? (e(this._value), GV) : (((t = this._callbacks) !== null && t !== void 0 ? t : this._callbacks = /* @__PURE__ */ new Set()).add(e), new Wu(() => this._callbacks.delete(e)));
  }
  watch(e) {
    var t;
    return this.done ? e._resolve(this._value) : (((t = this._watched) !== null && t !== void 0 ? t : this._watched = /* @__PURE__ */ new Set()).add(e), e.then(() => this._watched.delete(e)), e);
  }
  _resolve(e) {
    var t;
    if (this.done)
      return this;
    if (this.done = !0, this._value = e, (t = this._cb) === null || t === void 0 || t.call(this, e), this._callbacks)
      for (const i of this._callbacks)
        i(e);
    if (this._watched)
      for (const i of this._watched)
        i._resolve(e);
    return this;
  }
}
class Wu extends HV {
  constructor(e) {
    super(e);
  }
  cancel() {
    return this._resolve();
  }
}
const GV = new Wu().cancel(), kL = window;
"__LINCODE_PROMISELIKES__" in kL && console.warn("multiple versions of @lincode/promiselikes detected");
kL.__LINCODE_PROMISELIKES__ = !0;
class WV {
  constructor() {
    this.cbs = /* @__PURE__ */ new Set();
  }
  on(e) {
    return "state" in this && e(this.state), this.cbs.add(e), new Wu(() => this.cbs.delete(e));
  }
  once(e) {
    const t = new Wu();
    return t.watch(this.on((i) => {
      t.cancel(), e(i);
    })), t;
  }
  emit(e) {
    for (const t of this.cbs)
      t(e);
  }
  setState(e) {
    "state" in this && this.state === e || (this.state = e, this.emit(e));
  }
  getState() {
    return this.state;
  }
}
const jV = () => {
  const n = new WV();
  return [(s) => n.emit(s), (s, o) => o ? n.once(s) : n.on(s), (s) => n.setState(s), () => n.getState()];
}, qV = /* @__PURE__ */ new WeakSet(), Be = (n) => {
  const [, e, t, i] = jV();
  t(n);
  const r = (s) => {
    if (s) {
      const o = new Wu();
      return o.watch(e((a) => s(a, o))), o;
    }
    return i();
  };
  return qV.add(r), [t, r];
}, nh = (n, e) => (t) => {
  const i = e();
  i && n([...i, t]);
}, ih = (n, e) => (t) => {
  const i = e();
  i && n(i.filter((r) => r !== t));
}, LL = (n, e) => () => {
  const t = e();
  !t || (Array.isArray(t) ? n([...t]) : n({ ...t }));
}, XV = (n, e) => {
  const t = e();
  return t && typeof t == "object" && (mb(t, (i, r) => Object.freeze(r)), Object.freeze(t)), () => n(t);
}, fa = [], AT = (n) => {
  var e, t, i;
  const r = fa[fa.length - 1];
  return (e = (t = r.fiber)[i = r.count++]) !== null && e !== void 0 ? e : t[i] = n();
}, RT = (n) => {
  var e, t;
  const i = fa[fa.length - 1], r = i.count++;
  return (e = (t = i.fiber)[r]) !== null && e !== void 0 || (t[r] = n), [() => i.fiber[r], (s) => i.fiber[r] = s];
}, DL = (n, e, t, i, r, s) => {
  fa.push({ count: 0, fiber: t, handle: n });
  const o = i.map((c) => typeof c == "function" ? c() : c), a = !r || o.some((c, d) => c !== r[d]);
  a && typeof e == "function" && e();
  const l = a ? s() : void 0;
  return fa.pop(), [l, o, a];
}, fy = (n, e) => {
  const t = AT(() => fa[fa.length - 1].handle.watch(new Wu(() => {
    var b;
    return (b = r()) === null || b === void 0 ? void 0 : b();
  })));
  if (t.done)
    return t;
  const i = AT(() => []), [r, s] = RT(void 0), [o, a] = RT(void 0), l = r(), c = o();
  l && typeof l != "function" && console.warn("cleanup is not a function");
  const [d, p, m] = DL(t, l, i, e, c, n);
  return m && s(typeof d == "function" ? d : void 0), a(p), t;
}, ft = (n, e) => {
  const t = new Wu(() => setTimeout(() => r == null ? void 0 : r())), i = [];
  let r, s;
  const o = nE(() => {
    const [a, l, c] = DL(t, r, i, e, s, n);
    c && (r = typeof a == "function" ? a : void 0), s = l;
  }, 0, "trailing");
  o();
  for (const a of e)
    typeof a == "function" && t.watch(a(o));
  return t;
}, qm = (n) => {
  var e, t, i;
  const r = fa[fa.length - 1];
  return (e = (t = r.fiber)[i = r.count++]) !== null && e !== void 0 ? e : t[i] = {
    current: typeof n == "function" ? n() : n
  };
}, V_ = (n, e) => {
  const t = qm(n), i = qm(!0);
  return fy(() => {
    if (i.current) {
      i.current = !1;
      return;
    }
    t.current = n();
  }, e), t.current;
};
class Je {
  constructor(e) {
    [this.set, this.get] = Be(e);
  }
}
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const rh = "144", $V = 0, kT = 1, ZV = 2, IL = 1, OL = 2, bm = 3, ju = 0, cr = 1, Js = 2, Si = 0, Nd = 1, LT = 2, DT = 3, IT = 4, YV = 5, Ed = 100, KV = 101, JV = 102, OT = 103, NT = 104, QV = 200, e9 = 201, t9 = 202, n9 = 203, NL = 204, zL = 205, i9 = 206, r9 = 207, s9 = 208, o9 = 209, a9 = 210, FL = 0, BL = 1, u2 = 2, vb = 3, gb = 4, UL = 5, VL = 6, rE = 7, HL = 0, l9 = 1, c9 = 2, dl = 0, u9 = 1, h9 = 2, d9 = 3, GL = 4, f9 = 5, WL = 300, vf = 301, gf = 302, _b = 303, h2 = 304, py = 306, qu = 1e3, qr = 1001, d2 = 1002, kn = 1003, zT = 1004, FT = 1005, Zt = 1006, p9 = 1007, Pv = 1008, Mhe = 1008, Mi = 1009, m9 = 1010, v9 = 1011, jL = 1012, g9 = 1013, cc = 1014, Qs = 1015, $r = 1016, _9 = 1017, b9 = 1018, Tu = 1020, y9 = 1021, x9 = 1022, wr = 1023, sE = 1024, w9 = 1025, Pu = 1026, Xu = 1027, qL = 1028, S9 = 1029, XL = 1030, M9 = 1031, E9 = 1033, u1 = 33776, h1 = 33777, d1 = 33778, f1 = 33779, BT = 35840, UT = 35841, VT = 35842, HT = 35843, C9 = 36196, GT = 37492, WT = 37496, jT = 37808, qT = 37809, XT = 37810, $T = 37811, ZT = 37812, YT = 37813, KT = 37814, JT = 37815, QT = 37816, eP = 37817, tP = 37818, nP = 37819, iP = 37820, rP = 37821, sP = 36492, T9 = 2200, $L = 2201, P9 = 2202, bb = 2300, yb = 2301, p1 = 2302, Rd = 2400, kd = 2401, xb = 2402, oE = 2500, A9 = 2501, Ehe = 1, Che = 2, Ro = 3e3, Tt = 3001, io = 3200, Xm = 3201, my = 0, R9 = 1, nl = "srgb", wu = "srgb-linear", m1 = 7680, k9 = 519, f2 = 35044, p2 = "300 es", m2 = 1035;
class ga {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++)
        r[s].call(this, e);
      e.target = null;
    }
  }
}
const Rr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let oP = 1234567;
const Cm = Math.PI / 180, $m = 180 / Math.PI;
function to() {
  const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Rr[n & 255] + Rr[n >> 8 & 255] + Rr[n >> 16 & 255] + Rr[n >> 24 & 255] + "-" + Rr[e & 255] + Rr[e >> 8 & 255] + "-" + Rr[e >> 16 & 15 | 64] + Rr[e >> 24 & 255] + "-" + Rr[t & 63 | 128] + Rr[t >> 8 & 255] + "-" + Rr[t >> 16 & 255] + Rr[t >> 24 & 255] + Rr[i & 255] + Rr[i >> 8 & 255] + Rr[i >> 16 & 255] + Rr[i >> 24 & 255]).toLowerCase();
}
function Ui(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function aE(n, e) {
  return (n % e + e) % e;
}
function L9(n, e, t, i, r) {
  return i + (n - e) * (r - i) / (t - e);
}
function D9(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function Tm(n, e, t) {
  return (1 - t) * n + t * e;
}
function I9(n, e, t, i) {
  return Tm(n, e, 1 - Math.exp(-t * i));
}
function O9(n, e = 1) {
  return e - Math.abs(aE(n, e * 2) - e);
}
function N9(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n));
}
function z9(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10));
}
function F9(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function B9(n, e) {
  return n + Math.random() * (e - n);
}
function U9(n) {
  return n * (0.5 - Math.random());
}
function V9(n) {
  n !== void 0 && (oP = n);
  let e = oP += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function H9(n) {
  return n * Cm;
}
function G9(n) {
  return n * $m;
}
function v2(n) {
  return (n & n - 1) === 0 && n !== 0;
}
function ZL(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function wb(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function W9(n, e, t, i, r) {
  const s = Math.cos, o = Math.sin, a = s(t / 2), l = o(t / 2), c = s((e + i) / 2), d = o((e + i) / 2), p = s((e - i) / 2), m = o((e - i) / 2), v = s((i - e) / 2), b = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * d, l * p, l * m, a * c);
      break;
    case "YZY":
      n.set(l * m, a * d, l * p, a * c);
      break;
    case "ZXZ":
      n.set(l * p, l * m, a * d, a * c);
      break;
    case "XZX":
      n.set(a * d, l * b, l * v, a * c);
      break;
    case "YXY":
      n.set(l * v, a * d, l * b, a * c);
      break;
    case "ZYZ":
      n.set(l * b, l * v, a * d, a * c);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function cl(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function jn(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var Pm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD: Cm,
  RAD2DEG: $m,
  generateUUID: to,
  clamp: Ui,
  euclideanModulo: aE,
  mapLinear: L9,
  inverseLerp: D9,
  lerp: Tm,
  damp: I9,
  pingpong: O9,
  smoothstep: N9,
  smootherstep: z9,
  randInt: F9,
  randFloat: B9,
  randFloatSpread: U9,
  seededRandom: V9,
  degToRad: H9,
  radToDeg: G9,
  isPowerOfTwo: v2,
  ceilPowerOfTwo: ZL,
  floorPowerOfTwo: wb,
  setQuaternionFromProperEuler: W9,
  normalize: jn,
  denormalize: cl
});
class ze {
  constructor(e = 0, t = 0) {
    ze.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class ur {
  constructor() {
    ur.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, i, r, s, o, a, l, c) {
    const d = this.elements;
    return d[0] = e, d[1] = r, d[2] = a, d[3] = t, d[4] = s, d[5] = l, d[6] = i, d[7] = o, d[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[3], l = i[6], c = i[1], d = i[4], p = i[7], m = i[2], v = i[5], b = i[8], x = r[0], y = r[3], S = r[6], C = r[1], M = r[4], T = r[7], P = r[2], D = r[5], I = r[8];
    return s[0] = o * x + a * C + l * P, s[3] = o * y + a * M + l * D, s[6] = o * S + a * T + l * I, s[1] = c * x + d * C + p * P, s[4] = c * y + d * M + p * D, s[7] = c * S + d * T + p * I, s[2] = m * x + v * C + b * P, s[5] = m * y + v * M + b * D, s[8] = m * S + v * T + b * I, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], d = e[8];
    return t * o * d - t * a * c - i * s * d + i * a * l + r * s * c - r * o * l;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], d = e[8], p = d * o - a * c, m = a * l - d * s, v = c * s - o * l, b = t * p + i * m + r * v;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / b;
    return e[0] = p * x, e[1] = (r * c - d * i) * x, e[2] = (a * i - r * o) * x, e[3] = m * x, e[4] = (d * t - r * l) * x, e[5] = (r * s - a * t) * x, e[6] = v * x, e[7] = (i * l - c * t) * x, e[8] = (o * t - i * s) * x, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s), c = Math.sin(s);
    return this.set(
      i * l,
      i * c,
      -i * (l * o + c * a) + o + e,
      -r * c,
      r * l,
      -r * (-c * o + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  scale(e, t) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this;
  }
  rotate(e) {
    const t = Math.cos(e), i = Math.sin(e), r = this.elements, s = r[0], o = r[3], a = r[6], l = r[1], c = r[4], d = r[7];
    return r[0] = t * s + i * l, r[3] = t * o + i * c, r[6] = t * a + i * d, r[1] = -i * s + t * l, r[4] = -i * o + t * c, r[7] = -i * a + t * d, this;
  }
  translate(e, t) {
    const i = this.elements;
    return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
function YL(n) {
  for (let e = n.length - 1; e >= 0; --e)
    if (n[e] >= 65535)
      return !0;
  return !1;
}
function Zm(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function Au(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function H_(n) {
  return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const v1 = {
  [nl]: { [wu]: Au },
  [wu]: { [nl]: H_ }
}, go = {
  legacyMode: !0,
  get workingColorSpace() {
    return wu;
  },
  set workingColorSpace(n) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(n, e, t) {
    if (this.legacyMode || e === t || !e || !t)
      return n;
    if (v1[e] && v1[e][t] !== void 0) {
      const i = v1[e][t];
      return n.r = i(n.r), n.g = i(n.g), n.b = i(n.b), n;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(n, e) {
    return this.convert(n, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(n, e) {
    return this.convert(n, e, this.workingColorSpace);
  }
}, KL = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Fi = { r: 0, g: 0, b: 0 }, _o = { h: 0, s: 0, l: 0 }, k0 = { h: 0, s: 0, l: 0 };
function g1(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n;
}
function L0(n, e) {
  return e.r = n.r, e.g = n.g, e.b = n.b, e;
}
class xt {
  constructor(e, t, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = nl) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, go.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, i, r = wu) {
    return this.r = e, this.g = t, this.b = i, go.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, t, i, r = wu) {
    if (e = aE(e, 1), t = Ui(t, 0, 1), i = Ui(i, 0, 1), t === 0)
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t, o = 2 * i - s;
      this.r = g1(o, s, e + 1 / 3), this.g = g1(o, s, e), this.b = g1(o, s, e - 1 / 3);
    }
    return go.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = nl) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let s;
      const o = r[1], a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, go.toWorkingColorSpace(this, t), i(s[4]), this;
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, go.toWorkingColorSpace(this, t), i(s[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
            const l = parseFloat(s[1]) / 360, c = parseFloat(s[2]) / 100, d = parseFloat(s[3]) / 100;
            return i(s[4]), this.setHSL(l, c, d, t);
          }
          break;
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = r[1], o = s.length;
      if (o === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, go.toWorkingColorSpace(this, t), this;
      if (o === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, go.toWorkingColorSpace(this, t), this;
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = nl) {
    const i = KL[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Au(e.r), this.g = Au(e.g), this.b = Au(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = H_(e.r), this.g = H_(e.g), this.b = H_(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = nl) {
    return go.fromWorkingColorSpace(L0(this, Fi), e), Ui(Fi.r * 255, 0, 255) << 16 ^ Ui(Fi.g * 255, 0, 255) << 8 ^ Ui(Fi.b * 255, 0, 255) << 0;
  }
  getHexString(e = nl) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = wu) {
    go.fromWorkingColorSpace(L0(this, Fi), t);
    const i = Fi.r, r = Fi.g, s = Fi.b, o = Math.max(i, r, s), a = Math.min(i, r, s);
    let l, c;
    const d = (a + o) / 2;
    if (a === o)
      l = 0, c = 0;
    else {
      const p = o - a;
      switch (c = d <= 0.5 ? p / (o + a) : p / (2 - o - a), o) {
        case i:
          l = (r - s) / p + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / p + 2;
          break;
        case s:
          l = (i - r) / p + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = d, e;
  }
  getRGB(e, t = wu) {
    return go.fromWorkingColorSpace(L0(this, Fi), t), e.r = Fi.r, e.g = Fi.g, e.b = Fi.b, e;
  }
  getStyle(e = nl) {
    return go.fromWorkingColorSpace(L0(this, Fi), e), e !== nl ? `color(${e} ${Fi.r} ${Fi.g} ${Fi.b})` : `rgb(${Fi.r * 255 | 0},${Fi.g * 255 | 0},${Fi.b * 255 | 0})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(_o), _o.h += e, _o.s += t, _o.l += i, this.setHSL(_o.h, _o.s, _o.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  lerpHSL(e, t) {
    this.getHSL(_o), e.getHSL(k0);
    const i = Tm(_o.h, k0.h, t), r = Tm(_o.s, k0.s, t), s = Tm(_o.l, k0.l, t);
    return this.setHSL(i, r, s), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
xt.NAMES = KL;
let Yh;
class JL {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Yh === void 0 && (Yh = Zm("canvas")), Yh.width = e.width, Yh.height = e.height;
      const i = Yh.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Yh;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Zm("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height), s = r.data;
      for (let o = 0; o < s.length; o++)
        s[o] = Au(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Au(t[i] / 255) * 255) : t[i] = Au(t[i]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
class QL {
  constructor(e = null) {
    this.isSource = !0, this.uuid = to(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(_1(r[o].image)) : s.push(_1(r[o]));
      } else
        s = _1(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function _1(n) {
  return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? JL.getDataURL(n) : n.data ? {
    data: Array.from(n.data),
    width: n.width,
    height: n.height,
    type: n.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let j9 = 0;
class Wi extends ga {
  constructor(e = Wi.DEFAULT_IMAGE, t = Wi.DEFAULT_MAPPING, i = qr, r = qr, s = Zt, o = Pv, a = wr, l = Mi, c = 1, d = Ro) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: j9++ }), this.uuid = to(), this.name = "", this.source = new QL(e), this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new ze(0, 0), this.repeat = new ze(1, 1), this.center = new ze(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ur(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== WL)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case qu:
          e.x = e.x - Math.floor(e.x);
          break;
        case qr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case d2:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case qu:
          e.y = e.y - Math.floor(e.y);
          break;
        case qr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case d2:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
Wi.DEFAULT_IMAGE = null;
Wi.DEFAULT_MAPPING = WL;
class gn {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    gn.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return this.x = e, this.y = t, this.z = i, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements, c = l[0], d = l[4], p = l[8], m = l[1], v = l[5], b = l[9], x = l[2], y = l[6], S = l[10];
    if (Math.abs(d - m) < 0.01 && Math.abs(p - x) < 0.01 && Math.abs(b - y) < 0.01) {
      if (Math.abs(d + m) < 0.1 && Math.abs(p + x) < 0.1 && Math.abs(b + y) < 0.1 && Math.abs(c + v + S - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const M = (c + 1) / 2, T = (v + 1) / 2, P = (S + 1) / 2, D = (d + m) / 4, I = (p + x) / 4, k = (b + y) / 4;
      return M > T && M > P ? M < 0.01 ? (i = 0, r = 0.707106781, s = 0.707106781) : (i = Math.sqrt(M), r = D / i, s = I / i) : T > P ? T < 0.01 ? (i = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(T), i = D / r, s = k / r) : P < 0.01 ? (i = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(P), i = I / s, r = k / s), this.set(i, r, s, t), this;
    }
    let C = Math.sqrt((y - b) * (y - b) + (p - x) * (p - x) + (m - d) * (m - d));
    return Math.abs(C) < 1e-3 && (C = 1), this.x = (y - b) / C, this.y = (p - x) / C, this.z = (m - d) / C, this.w = Math.acos((c + v + S - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class On extends ga {
  constructor(e, t, i = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new gn(0, 0, e, t), this.scissorTest = !1, this.viewport = new gn(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    this.texture = new Wi(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : Zt, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null, this.samples = i.samples !== void 0 ? i.samples : 0;
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new QL(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class eD extends Wi {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = kn, this.minFilter = kn, this.wrapR = qr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class q9 extends Wi {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = kn, this.minFilter = kn, this.wrapR = qr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class X9 extends On {
  constructor(e, t, i, r = {}) {
    super(e, t, r), this.isWebGLMultipleRenderTargets = !0;
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++)
      this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let r = 0, s = this.texture.length; r < s; r++)
        this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = i;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, i = e.texture.length; t < i; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class Gi {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r;
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0], c = i[r + 1], d = i[r + 2], p = i[r + 3];
    const m = s[o + 0], v = s[o + 1], b = s[o + 2], x = s[o + 3];
    if (a === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = d, e[t + 3] = p;
      return;
    }
    if (a === 1) {
      e[t + 0] = m, e[t + 1] = v, e[t + 2] = b, e[t + 3] = x;
      return;
    }
    if (p !== x || l !== m || c !== v || d !== b) {
      let y = 1 - a;
      const S = l * m + c * v + d * b + p * x, C = S >= 0 ? 1 : -1, M = 1 - S * S;
      if (M > Number.EPSILON) {
        const P = Math.sqrt(M), D = Math.atan2(P, S * C);
        y = Math.sin(y * D) / P, a = Math.sin(a * D) / P;
      }
      const T = a * C;
      if (l = l * y + m * T, c = c * y + v * T, d = d * y + b * T, p = p * y + x * T, y === 1 - a) {
        const P = 1 / Math.sqrt(l * l + c * c + d * d + p * p);
        l *= P, c *= P, d *= P, p *= P;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = d, e[t + 3] = p;
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r], l = i[r + 1], c = i[r + 2], d = i[r + 3], p = s[o], m = s[o + 1], v = s[o + 2], b = s[o + 3];
    return e[t] = a * b + d * p + l * v - c * m, e[t + 1] = l * b + d * m + c * p - a * v, e[t + 2] = c * b + d * v + a * m - l * p, e[t + 3] = d * b - a * p - l * m - c * v, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, r) {
    return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const i = e._x, r = e._y, s = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(i / 2), d = a(r / 2), p = a(s / 2), m = l(i / 2), v = l(r / 2), b = l(s / 2);
    switch (o) {
      case "XYZ":
        this._x = m * d * p + c * v * b, this._y = c * v * p - m * d * b, this._z = c * d * b + m * v * p, this._w = c * d * p - m * v * b;
        break;
      case "YXZ":
        this._x = m * d * p + c * v * b, this._y = c * v * p - m * d * b, this._z = c * d * b - m * v * p, this._w = c * d * p + m * v * b;
        break;
      case "ZXY":
        this._x = m * d * p - c * v * b, this._y = c * v * p + m * d * b, this._z = c * d * b + m * v * p, this._w = c * d * p - m * v * b;
        break;
      case "ZYX":
        this._x = m * d * p - c * v * b, this._y = c * v * p + m * d * b, this._z = c * d * b - m * v * p, this._w = c * d * p + m * v * b;
        break;
      case "YZX":
        this._x = m * d * p + c * v * b, this._y = c * v * p + m * d * b, this._z = c * d * b - m * v * p, this._w = c * d * p - m * v * b;
        break;
      case "XZY":
        this._x = m * d * p - c * v * b, this._y = c * v * p - m * d * b, this._z = c * d * b + m * v * p, this._w = c * d * p + m * v * b;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, r = Math.sin(i);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], r = t[4], s = t[8], o = t[1], a = t[5], l = t[9], c = t[2], d = t[6], p = t[10], m = i + a + p;
    if (m > 0) {
      const v = 0.5 / Math.sqrt(m + 1);
      this._w = 0.25 / v, this._x = (d - l) * v, this._y = (s - c) * v, this._z = (o - r) * v;
    } else if (i > a && i > p) {
      const v = 2 * Math.sqrt(1 + i - a - p);
      this._w = (d - l) / v, this._x = 0.25 * v, this._y = (r + o) / v, this._z = (s + c) / v;
    } else if (a > p) {
      const v = 2 * Math.sqrt(1 + a - i - p);
      this._w = (s - c) / v, this._x = (r + o) / v, this._y = 0.25 * v, this._z = (l + d) / v;
    } else {
      const v = 2 * Math.sqrt(1 + p - i - a);
      this._w = (o - r) / v, this._x = (s + c) / v, this._y = (l + d) / v, this._z = 0.25 * v;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Ui(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0)
      return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, r = e._y, s = e._z, o = e._w, a = t._x, l = t._y, c = t._z, d = t._w;
    return this._x = i * d + o * a + r * c - s * l, this._y = r * d + o * l + s * a - i * c, this._z = s * d + o * c + i * l - r * a, this._w = o * d - i * a - r * l - s * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const i = this._x, r = this._y, s = this._z, o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
      return this._w = o, this._x = i, this._y = r, this._z = s, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const v = 1 - t;
      return this._w = v * o + t * this._w, this._x = v * i + t * this._x, this._y = v * r + t * this._y, this._z = v * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(l), d = Math.atan2(c, a), p = Math.sin((1 - t) * d) / c, m = Math.sin(t * d) / c;
    return this._w = o * p + this._w * m, this._x = i * p + this._x * m, this._y = r * p + this._y * m, this._z = s * p + this._z * m, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Z {
  constructor(e = 0, t = 0, i = 0) {
    Z.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(aP.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(aP.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, r = this.z, s = e.x, o = e.y, a = e.z, l = e.w, c = l * t + o * r - a * i, d = l * i + a * t - s * r, p = l * r + s * i - o * t, m = -s * t - o * i - a * r;
    return this.x = c * l + m * -s + d * -a - p * -o, this.y = d * l + m * -o + p * -s - c * -a, this.z = p * l + m * -a + c * -o - d * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, r = e.y, s = e.z, o = t.x, a = t.y, l = t.z;
    return this.x = r * l - s * a, this.y = s * o - i * l, this.z = i * a - r * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return b1.copy(this).projectOnVector(e), this.sub(b1);
  }
  reflect(e) {
    return this.sub(b1.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Ui(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2);
    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const b1 = /* @__PURE__ */ new Z(), aP = /* @__PURE__ */ new Gi();
class so {
  constructor(e = new Z(1 / 0, 1 / 0, 1 / 0), t = new Z(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0, i = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0;
    for (let l = 0, c = e.length; l < c; l += 3) {
      const d = e[l], p = e[l + 1], m = e[l + 2];
      d < t && (t = d), p < i && (i = p), m < r && (r = m), d > s && (s = d), p > o && (o = p), m > a && (a = m);
    }
    return this.min.set(t, i, r), this.max.set(s, o, a), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0, i = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0;
    for (let l = 0, c = e.count; l < c; l++) {
      const d = e.getX(l), p = e.getY(l), m = e.getZ(l);
      d < t && (t = d), p < i && (i = p), m < r && (r = m), d > s && (s = d), p > o && (o = p), m > a && (a = m);
    }
    return this.min.set(t, i, r), this.max.set(s, o, a), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = ru.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0)
      if (t && i.attributes != null && i.attributes.position !== void 0) {
        const s = i.attributes.position;
        for (let o = 0, a = s.count; o < a; o++)
          ru.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(ru);
      } else
        i.boundingBox === null && i.computeBoundingBox(), y1.copy(i.boundingBox), y1.applyMatrix4(e.matrixWorld), this.union(y1);
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++)
      this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, ru), ru.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Qp), D0.subVectors(this.max, Qp), Kh.subVectors(e.a, Qp), Jh.subVectors(e.b, Qp), Qh.subVectors(e.c, Qp), Wl.subVectors(Jh, Kh), jl.subVectors(Qh, Jh), su.subVectors(Kh, Qh);
    let t = [
      0,
      -Wl.z,
      Wl.y,
      0,
      -jl.z,
      jl.y,
      0,
      -su.z,
      su.y,
      Wl.z,
      0,
      -Wl.x,
      jl.z,
      0,
      -jl.x,
      su.z,
      0,
      -su.x,
      -Wl.y,
      Wl.x,
      0,
      -jl.y,
      jl.x,
      0,
      -su.y,
      su.x,
      0
    ];
    return !x1(t, Kh, Jh, Qh, D0) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !x1(t, Kh, Jh, Qh, D0)) ? !1 : (I0.crossVectors(Wl, jl), t = [I0.x, I0.y, I0.z], x1(t, Kh, Jh, Qh, D0));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return ru.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(ru).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Xa[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Xa[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Xa[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Xa[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Xa[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Xa[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Xa[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Xa[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Xa), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Xa = [
  /* @__PURE__ */ new Z(),
  /* @__PURE__ */ new Z(),
  /* @__PURE__ */ new Z(),
  /* @__PURE__ */ new Z(),
  /* @__PURE__ */ new Z(),
  /* @__PURE__ */ new Z(),
  /* @__PURE__ */ new Z(),
  /* @__PURE__ */ new Z()
], ru = /* @__PURE__ */ new Z(), y1 = /* @__PURE__ */ new so(), Kh = /* @__PURE__ */ new Z(), Jh = /* @__PURE__ */ new Z(), Qh = /* @__PURE__ */ new Z(), Wl = /* @__PURE__ */ new Z(), jl = /* @__PURE__ */ new Z(), su = /* @__PURE__ */ new Z(), Qp = /* @__PURE__ */ new Z(), D0 = /* @__PURE__ */ new Z(), I0 = /* @__PURE__ */ new Z(), ou = /* @__PURE__ */ new Z();
function x1(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    ou.fromArray(n, s);
    const a = r.x * Math.abs(ou.x) + r.y * Math.abs(ou.y) + r.z * Math.abs(ou.z), l = e.dot(ou), c = t.dot(ou), d = i.dot(ou);
    if (Math.max(-Math.max(l, c, d), Math.min(l, c, d)) > a)
      return !1;
  }
  return !0;
}
const $9 = /* @__PURE__ */ new so(), lP = /* @__PURE__ */ new Z(), O0 = /* @__PURE__ */ new Z(), w1 = /* @__PURE__ */ new Z();
class sh {
  constructor(e = new Z(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : $9.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    w1.subVectors(e, this.center);
    const t = w1.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), r = (i - this.radius) * 0.5;
      this.center.add(w1.multiplyScalar(r / i)), this.radius += r;
    }
    return this;
  }
  union(e) {
    return this.center.equals(e.center) === !0 ? O0.set(0, 0, 1).multiplyScalar(e.radius) : O0.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(lP.copy(e.center).add(O0)), this.expandByPoint(lP.copy(e.center).sub(O0)), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $a = /* @__PURE__ */ new Z(), S1 = /* @__PURE__ */ new Z(), N0 = /* @__PURE__ */ new Z(), ql = /* @__PURE__ */ new Z(), M1 = /* @__PURE__ */ new Z(), z0 = /* @__PURE__ */ new Z(), E1 = /* @__PURE__ */ new Z();
class Nf {
  constructor(e = new Z(), t = new Z(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, $a)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = $a.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : ($a.copy(this.direction).multiplyScalar(t).add(this.origin), $a.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    S1.copy(e).add(t).multiplyScalar(0.5), N0.copy(t).sub(e).normalize(), ql.copy(this.origin).sub(S1);
    const s = e.distanceTo(t) * 0.5, o = -this.direction.dot(N0), a = ql.dot(this.direction), l = -ql.dot(N0), c = ql.lengthSq(), d = Math.abs(1 - o * o);
    let p, m, v, b;
    if (d > 0)
      if (p = o * l - a, m = o * a - l, b = s * d, p >= 0)
        if (m >= -b)
          if (m <= b) {
            const x = 1 / d;
            p *= x, m *= x, v = p * (p + o * m + 2 * a) + m * (o * p + m + 2 * l) + c;
          } else
            m = s, p = Math.max(0, -(o * m + a)), v = -p * p + m * (m + 2 * l) + c;
        else
          m = -s, p = Math.max(0, -(o * m + a)), v = -p * p + m * (m + 2 * l) + c;
      else
        m <= -b ? (p = Math.max(0, -(-o * s + a)), m = p > 0 ? -s : Math.min(Math.max(-s, -l), s), v = -p * p + m * (m + 2 * l) + c) : m <= b ? (p = 0, m = Math.min(Math.max(-s, -l), s), v = m * (m + 2 * l) + c) : (p = Math.max(0, -(o * s + a)), m = p > 0 ? s : Math.min(Math.max(-s, -l), s), v = -p * p + m * (m + 2 * l) + c);
    else
      m = o > 0 ? -s : s, p = Math.max(0, -(o * m + a)), v = -p * p + m * (m + 2 * l) + c;
    return i && i.copy(this.direction).multiplyScalar(p).add(this.origin), r && r.copy(N0).multiplyScalar(m).add(S1), v;
  }
  intersectSphere(e, t) {
    $a.subVectors(e.center, this.origin);
    const i = $a.dot(this.direction), r = $a.dot($a) - i * i, s = e.radius * e.radius;
    if (r > s)
      return null;
    const o = Math.sqrt(s - r), a = i - o, l = i + o;
    return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l;
    const c = 1 / this.direction.x, d = 1 / this.direction.y, p = 1 / this.direction.z, m = this.origin;
    return c >= 0 ? (i = (e.min.x - m.x) * c, r = (e.max.x - m.x) * c) : (i = (e.max.x - m.x) * c, r = (e.min.x - m.x) * c), d >= 0 ? (s = (e.min.y - m.y) * d, o = (e.max.y - m.y) * d) : (s = (e.max.y - m.y) * d, o = (e.min.y - m.y) * d), i > o || s > r || ((s > i || i !== i) && (i = s), (o < r || r !== r) && (r = o), p >= 0 ? (a = (e.min.z - m.z) * p, l = (e.max.z - m.z) * p) : (a = (e.max.z - m.z) * p, l = (e.min.z - m.z) * p), i > l || a > r) || ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, $a) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    M1.subVectors(t, e), z0.subVectors(i, e), E1.crossVectors(M1, z0);
    let o = this.direction.dot(E1), a;
    if (o > 0) {
      if (r)
        return null;
      a = 1;
    } else if (o < 0)
      a = -1, o = -o;
    else
      return null;
    ql.subVectors(this.origin, e);
    const l = a * this.direction.dot(z0.crossVectors(ql, z0));
    if (l < 0)
      return null;
    const c = a * this.direction.dot(M1.cross(ql));
    if (c < 0 || l + c > o)
      return null;
    const d = -a * ql.dot(E1);
    return d < 0 ? null : this.at(d / o, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Pt {
  constructor() {
    Pt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, i, r, s, o, a, l, c, d, p, m, v, b, x, y) {
    const S = this.elements;
    return S[0] = e, S[4] = t, S[8] = i, S[12] = r, S[1] = s, S[5] = o, S[9] = a, S[13] = l, S[2] = c, S[6] = d, S[10] = p, S[14] = m, S[3] = v, S[7] = b, S[11] = x, S[15] = y, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Pt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(
      e.x,
      t.x,
      i.x,
      0,
      e.y,
      t.y,
      i.y,
      0,
      e.z,
      t.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, r = 1 / ed.setFromMatrixColumn(e, 0).length(), s = 1 / ed.setFromMatrixColumn(e, 1).length(), o = 1 / ed.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z, o = Math.cos(i), a = Math.sin(i), l = Math.cos(r), c = Math.sin(r), d = Math.cos(s), p = Math.sin(s);
    if (e.order === "XYZ") {
      const m = o * d, v = o * p, b = a * d, x = a * p;
      t[0] = l * d, t[4] = -l * p, t[8] = c, t[1] = v + b * c, t[5] = m - x * c, t[9] = -a * l, t[2] = x - m * c, t[6] = b + v * c, t[10] = o * l;
    } else if (e.order === "YXZ") {
      const m = l * d, v = l * p, b = c * d, x = c * p;
      t[0] = m + x * a, t[4] = b * a - v, t[8] = o * c, t[1] = o * p, t[5] = o * d, t[9] = -a, t[2] = v * a - b, t[6] = x + m * a, t[10] = o * l;
    } else if (e.order === "ZXY") {
      const m = l * d, v = l * p, b = c * d, x = c * p;
      t[0] = m - x * a, t[4] = -o * p, t[8] = b + v * a, t[1] = v + b * a, t[5] = o * d, t[9] = x - m * a, t[2] = -o * c, t[6] = a, t[10] = o * l;
    } else if (e.order === "ZYX") {
      const m = o * d, v = o * p, b = a * d, x = a * p;
      t[0] = l * d, t[4] = b * c - v, t[8] = m * c + x, t[1] = l * p, t[5] = x * c + m, t[9] = v * c - b, t[2] = -c, t[6] = a * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      const m = o * l, v = o * c, b = a * l, x = a * c;
      t[0] = l * d, t[4] = x - m * p, t[8] = b * p + v, t[1] = p, t[5] = o * d, t[9] = -a * d, t[2] = -c * d, t[6] = v * p + b, t[10] = m - x * p;
    } else if (e.order === "XZY") {
      const m = o * l, v = o * c, b = a * l, x = a * c;
      t[0] = l * d, t[4] = -p, t[8] = c * d, t[1] = m * p + x, t[5] = o * d, t[9] = v * p - b, t[2] = b * p - v, t[6] = a * d, t[10] = x * p + m;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Z9, e, Y9);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return Rs.subVectors(e, t), Rs.lengthSq() === 0 && (Rs.z = 1), Rs.normalize(), Xl.crossVectors(i, Rs), Xl.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Rs.x += 1e-4 : Rs.z += 1e-4, Rs.normalize(), Xl.crossVectors(i, Rs)), Xl.normalize(), F0.crossVectors(Rs, Xl), r[0] = Xl.x, r[4] = F0.x, r[8] = Rs.x, r[1] = Xl.y, r[5] = F0.y, r[9] = Rs.y, r[2] = Xl.z, r[6] = F0.z, r[10] = Rs.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[4], l = i[8], c = i[12], d = i[1], p = i[5], m = i[9], v = i[13], b = i[2], x = i[6], y = i[10], S = i[14], C = i[3], M = i[7], T = i[11], P = i[15], D = r[0], I = r[4], k = r[8], O = r[12], B = r[1], Y = r[5], G = r[9], K = r[13], A = r[2], J = r[6], xe = r[10], se = r[14], oe = r[3], Q = r[7], ce = r[11], te = r[15];
    return s[0] = o * D + a * B + l * A + c * oe, s[4] = o * I + a * Y + l * J + c * Q, s[8] = o * k + a * G + l * xe + c * ce, s[12] = o * O + a * K + l * se + c * te, s[1] = d * D + p * B + m * A + v * oe, s[5] = d * I + p * Y + m * J + v * Q, s[9] = d * k + p * G + m * xe + v * ce, s[13] = d * O + p * K + m * se + v * te, s[2] = b * D + x * B + y * A + S * oe, s[6] = b * I + x * Y + y * J + S * Q, s[10] = b * k + x * G + y * xe + S * ce, s[14] = b * O + x * K + y * se + S * te, s[3] = C * D + M * B + T * A + P * oe, s[7] = C * I + M * Y + T * J + P * Q, s[11] = C * k + M * G + T * xe + P * ce, s[15] = C * O + M * K + T * se + P * te, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], o = e[1], a = e[5], l = e[9], c = e[13], d = e[2], p = e[6], m = e[10], v = e[14], b = e[3], x = e[7], y = e[11], S = e[15];
    return b * (+s * l * p - r * c * p - s * a * m + i * c * m + r * a * v - i * l * v) + x * (+t * l * v - t * c * m + s * o * m - r * o * v + r * c * d - s * l * d) + y * (+t * c * p - t * a * v - s * o * p + i * o * v + s * a * d - i * c * d) + S * (-r * a * d - t * l * p + t * a * m + r * o * p - i * o * m + i * l * d);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], d = e[8], p = e[9], m = e[10], v = e[11], b = e[12], x = e[13], y = e[14], S = e[15], C = p * y * c - x * m * c + x * l * v - a * y * v - p * l * S + a * m * S, M = b * m * c - d * y * c - b * l * v + o * y * v + d * l * S - o * m * S, T = d * x * c - b * p * c + b * a * v - o * x * v - d * a * S + o * p * S, P = b * p * l - d * x * l - b * a * m + o * x * m + d * a * y - o * p * y, D = t * C + i * M + r * T + s * P;
    if (D === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const I = 1 / D;
    return e[0] = C * I, e[1] = (x * m * s - p * y * s - x * r * v + i * y * v + p * r * S - i * m * S) * I, e[2] = (a * y * s - x * l * s + x * r * c - i * y * c - a * r * S + i * l * S) * I, e[3] = (p * l * s - a * m * s - p * r * c + i * m * c + a * r * v - i * l * v) * I, e[4] = M * I, e[5] = (d * y * s - b * m * s + b * r * v - t * y * v - d * r * S + t * m * S) * I, e[6] = (b * l * s - o * y * s - b * r * c + t * y * c + o * r * S - t * l * S) * I, e[7] = (o * m * s - d * l * s + d * r * c - t * m * c - o * r * v + t * l * v) * I, e[8] = T * I, e[9] = (b * p * s - d * x * s - b * i * v + t * x * v + d * i * S - t * p * S) * I, e[10] = (o * x * s - b * a * s + b * i * c - t * x * c - o * i * S + t * a * S) * I, e[11] = (d * a * s - o * p * s - d * i * c + t * p * c + o * i * v - t * a * v) * I, e[12] = P * I, e[13] = (d * x * r - b * p * r + b * i * m - t * x * m - d * i * y + t * p * y) * I, e[14] = (b * a * r - o * x * r - b * i * l + t * x * l + o * i * y - t * a * y) * I, e[15] = (o * p * r - d * a * r + d * i * l - t * p * l - o * i * m + t * a * m) * I, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z;
    return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = 1 - i, o = e.x, a = e.y, l = e.z, c = s * o, d = s * a;
    return this.set(
      c * o + i,
      c * a - r * l,
      c * l + r * a,
      0,
      c * a + r * l,
      d * a + i,
      d * l - r * o,
      0,
      c * l - r * a,
      d * l + r * o,
      s * l * l + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(
      1,
      i,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, i) {
    const r = this.elements, s = t._x, o = t._y, a = t._z, l = t._w, c = s + s, d = o + o, p = a + a, m = s * c, v = s * d, b = s * p, x = o * d, y = o * p, S = a * p, C = l * c, M = l * d, T = l * p, P = i.x, D = i.y, I = i.z;
    return r[0] = (1 - (x + S)) * P, r[1] = (v + T) * P, r[2] = (b - M) * P, r[3] = 0, r[4] = (v - T) * D, r[5] = (1 - (m + S)) * D, r[6] = (y + C) * D, r[7] = 0, r[8] = (b + M) * I, r[9] = (y - C) * I, r[10] = (1 - (m + x)) * I, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = ed.set(r[0], r[1], r[2]).length();
    const o = ed.set(r[4], r[5], r[6]).length(), a = ed.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], bo.copy(this);
    const c = 1 / s, d = 1 / o, p = 1 / a;
    return bo.elements[0] *= c, bo.elements[1] *= c, bo.elements[2] *= c, bo.elements[4] *= d, bo.elements[5] *= d, bo.elements[6] *= d, bo.elements[8] *= p, bo.elements[9] *= p, bo.elements[10] *= p, t.setFromRotationMatrix(bo), i.x = s, i.y = o, i.z = a, this;
  }
  makePerspective(e, t, i, r, s, o) {
    const a = this.elements, l = 2 * s / (t - e), c = 2 * s / (i - r), d = (t + e) / (t - e), p = (i + r) / (i - r), m = -(o + s) / (o - s), v = -2 * o * s / (o - s);
    return a[0] = l, a[4] = 0, a[8] = d, a[12] = 0, a[1] = 0, a[5] = c, a[9] = p, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = m, a[14] = v, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, i, r, s, o) {
    const a = this.elements, l = 1 / (t - e), c = 1 / (i - r), d = 1 / (o - s), p = (t + e) * l, m = (i + r) * c, v = (o + s) * d;
    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -p, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -m, a[2] = 0, a[6] = 0, a[10] = -2 * d, a[14] = -v, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const ed = /* @__PURE__ */ new Z(), bo = /* @__PURE__ */ new Pt(), Z9 = /* @__PURE__ */ new Z(0, 0, 0), Y9 = /* @__PURE__ */ new Z(1, 1, 1), Xl = /* @__PURE__ */ new Z(), F0 = /* @__PURE__ */ new Z(), Rs = /* @__PURE__ */ new Z(), cP = /* @__PURE__ */ new Pt(), uP = /* @__PURE__ */ new Gi();
class oh {
  constructor(e = 0, t = 0, i = 0, r = oh.DefaultOrder) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements, s = r[0], o = r[4], a = r[8], l = r[1], c = r[5], d = r[9], p = r[2], m = r[6], v = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Ui(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-d, v), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(m, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Ui(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(a, v), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-p, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Ui(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-p, v), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;
      case "ZYX":
        this._y = Math.asin(-Ui(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(m, v), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(Ui(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-d, c), this._y = Math.atan2(-p, s)) : (this._x = 0, this._y = Math.atan2(a, v));
        break;
      case "XZY":
        this._z = Math.asin(-Ui(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(m, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-d, v), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return cP.makeRotationFromQuaternion(e), this.setFromRotationMatrix(cP, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return uP.setFromEuler(this), this.setFromQuaternion(uP, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
}
oh.DefaultOrder = "XYZ";
oh.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class lE {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let K9 = 0;
const hP = /* @__PURE__ */ new Z(), td = /* @__PURE__ */ new Gi(), Za = /* @__PURE__ */ new Pt(), B0 = /* @__PURE__ */ new Z(), em = /* @__PURE__ */ new Z(), J9 = /* @__PURE__ */ new Z(), Q9 = /* @__PURE__ */ new Gi(), dP = /* @__PURE__ */ new Z(1, 0, 0), fP = /* @__PURE__ */ new Z(0, 1, 0), pP = /* @__PURE__ */ new Z(0, 0, 1), e7 = { type: "added" }, mP = { type: "removed" };
class wn extends ga {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: K9++ }), this.uuid = to(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = wn.DefaultUp.clone();
    const e = new Z(), t = new oh(), i = new Gi(), r = new Z(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s), i._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new Pt()
      },
      normalMatrix: {
        value: new ur()
      }
    }), this.matrix = new Pt(), this.matrixWorld = new Pt(), this.matrixAutoUpdate = wn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = wn.DefaultMatrixWorldAutoUpdate, this.layers = new lE(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return td.setFromAxisAngle(e, t), this.quaternion.multiply(td), this;
  }
  rotateOnWorldAxis(e, t) {
    return td.setFromAxisAngle(e, t), this.quaternion.premultiply(td), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(dP, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(fP, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(pP, e);
  }
  translateOnAxis(e, t) {
    return hP.copy(e).applyQuaternion(this.quaternion), this.position.add(hP.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(dP, e);
  }
  translateY(e) {
    return this.translateOnAxis(fP, e);
  }
  translateZ(e) {
    return this.translateOnAxis(pP, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(Za.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? B0.copy(e) : B0.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), em.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Za.lookAt(em, B0, this.up) : Za.lookAt(B0, em, this.up), this.quaternion.setFromRotationMatrix(Za), r && (Za.extractRotation(r.matrixWorld), td.setFromRotationMatrix(Za), this.quaternion.premultiply(td.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(e7)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(mP)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(mP);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Za.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Za.multiply(e.parent.matrixWorld)), e.applyMatrix4(Za), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(em, e, J9), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(em, Q9, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, d = l.length; c < d; c++) {
            const p = l[c];
            s(e.shapes, p);
          }
        else
          s(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else
        r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries), l = o(e.materials), c = o(e.textures), d = o(e.images), p = o(e.shapes), m = o(e.skeletons), v = o(e.animations), b = o(e.nodes);
      a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), d.length > 0 && (i.images = d), p.length > 0 && (i.shapes = p), m.length > 0 && (i.skeletons = m), v.length > 0 && (i.animations = v), b.length > 0 && (i.nodes = b);
    }
    return i.object = r, i;
    function o(a) {
      const l = [];
      for (const c in a) {
        const d = a[c];
        delete d.metadata, l.push(d);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
wn.DefaultUp = /* @__PURE__ */ new Z(0, 1, 0);
wn.DefaultMatrixAutoUpdate = !0;
wn.DefaultMatrixWorldAutoUpdate = !0;
const yo = /* @__PURE__ */ new Z(), Ya = /* @__PURE__ */ new Z(), C1 = /* @__PURE__ */ new Z(), Ka = /* @__PURE__ */ new Z(), nd = /* @__PURE__ */ new Z(), id = /* @__PURE__ */ new Z(), vP = /* @__PURE__ */ new Z(), T1 = /* @__PURE__ */ new Z(), P1 = /* @__PURE__ */ new Z(), A1 = /* @__PURE__ */ new Z();
class ia {
  constructor(e = new Z(), t = new Z(), i = new Z()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), yo.subVectors(e, t), r.cross(yo);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    yo.subVectors(r, t), Ya.subVectors(i, t), C1.subVectors(e, t);
    const o = yo.dot(yo), a = yo.dot(Ya), l = yo.dot(C1), c = Ya.dot(Ya), d = Ya.dot(C1), p = o * c - a * a;
    if (p === 0)
      return s.set(-2, -1, -1);
    const m = 1 / p, v = (c * l - a * d) * m, b = (o * d - a * l) * m;
    return s.set(1 - v - b, b, v);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, Ka), Ka.x >= 0 && Ka.y >= 0 && Ka.x + Ka.y <= 1;
  }
  static getUV(e, t, i, r, s, o, a, l) {
    return this.getBarycoord(e, t, i, r, Ka), l.set(0, 0), l.addScaledVector(s, Ka.x), l.addScaledVector(o, Ka.y), l.addScaledVector(a, Ka.z), l;
  }
  static isFrontFacing(e, t, i, r) {
    return yo.subVectors(i, t), Ya.subVectors(e, t), yo.cross(Ya).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return yo.subVectors(this.c, this.b), Ya.subVectors(this.a, this.b), yo.cross(Ya).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ia.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ia.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, r, s) {
    return ia.getUV(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return ia.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ia.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, r = this.b, s = this.c;
    let o, a;
    nd.subVectors(r, i), id.subVectors(s, i), T1.subVectors(e, i);
    const l = nd.dot(T1), c = id.dot(T1);
    if (l <= 0 && c <= 0)
      return t.copy(i);
    P1.subVectors(e, r);
    const d = nd.dot(P1), p = id.dot(P1);
    if (d >= 0 && p <= d)
      return t.copy(r);
    const m = l * p - d * c;
    if (m <= 0 && l >= 0 && d <= 0)
      return o = l / (l - d), t.copy(i).addScaledVector(nd, o);
    A1.subVectors(e, s);
    const v = nd.dot(A1), b = id.dot(A1);
    if (b >= 0 && v <= b)
      return t.copy(s);
    const x = v * c - l * b;
    if (x <= 0 && c >= 0 && b <= 0)
      return a = c / (c - b), t.copy(i).addScaledVector(id, a);
    const y = d * b - v * p;
    if (y <= 0 && p - d >= 0 && v - b >= 0)
      return vP.subVectors(s, r), a = (p - d) / (p - d + (v - b)), t.copy(r).addScaledVector(vP, a);
    const S = 1 / (y + x + m);
    return o = x * S, a = m * S, t.copy(i).addScaledVector(nd, o).addScaledVector(id, a);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let t7 = 0;
class zo extends ga {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: t7++ }), this.uuid = to(), this.name = "", this.type = "Material", this.blending = Nd, this.side = ju, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = NL, this.blendDst = zL, this.blendEquation = Ed, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = vb, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = k9, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = m1, this.stencilZFail = m1, this.stencilZPass = m1, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Nd && (i.blending = this.blending), this.side !== ju && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = this.flatShading), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures), o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s)
        i[s] = t[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class vy extends zo {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new xt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = HL, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Ti = /* @__PURE__ */ new Z(), U0 = /* @__PURE__ */ new ze();
class Vi {
  constructor(e, t, i) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i === !0, this.usage = f2, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        U0.fromBufferAttribute(this, t), U0.applyMatrix3(e), this.setXY(t, U0.x, U0.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Ti.fromBufferAttribute(this, t), Ti.applyMatrix3(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ti.fromBufferAttribute(this, t), Ti.applyMatrix4(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ti.fromBufferAttribute(this, t), Ti.applyNormalMatrix(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ti.fromBufferAttribute(this, t), Ti.transformDirection(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = cl(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = jn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = cl(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = jn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = cl(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = jn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = cl(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = jn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = jn(t, this.array), i = jn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e *= this.itemSize, this.normalized && (t = jn(t, this.array), i = jn(i, this.array), r = jn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e *= this.itemSize, this.normalized && (t = jn(t, this.array), i = jn(i, this.array), r = jn(r, this.array), s = jn(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== f2 && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
  copyColorsArray() {
    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
  }
  copyVector2sArray() {
    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
  }
  copyVector3sArray() {
    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
  }
  copyVector4sArray() {
    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
  }
}
class tD extends Vi {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class nD extends Vi {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class en extends Vi {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let n7 = 0;
const Ys = /* @__PURE__ */ new Pt(), R1 = /* @__PURE__ */ new wn(), rd = /* @__PURE__ */ new Z(), ks = /* @__PURE__ */ new so(), tm = /* @__PURE__ */ new so(), sr = /* @__PURE__ */ new Z();
class qn extends ga {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: n7++ }), this.uuid = to(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (YL(e) ? nD : tD)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new ur().getNormalMatrix(e);
      i.applyNormalMatrix(s), i.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Ys.makeRotationFromQuaternion(e), this.applyMatrix4(Ys), this;
  }
  rotateX(e) {
    return Ys.makeRotationX(e), this.applyMatrix4(Ys), this;
  }
  rotateY(e) {
    return Ys.makeRotationY(e), this.applyMatrix4(Ys), this;
  }
  rotateZ(e) {
    return Ys.makeRotationZ(e), this.applyMatrix4(Ys), this;
  }
  translate(e, t, i) {
    return Ys.makeTranslation(e, t, i), this.applyMatrix4(Ys), this;
  }
  scale(e, t, i) {
    return Ys.makeScale(e, t, i), this.applyMatrix4(Ys), this;
  }
  lookAt(e) {
    return R1.lookAt(e), R1.updateMatrix(), this.applyMatrix4(R1.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(rd).negate(), this.translate(rd.x, rd.y, rd.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new en(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new so());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new Z(-1 / 0, -1 / 0, -1 / 0),
        new Z(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          ks.setFromBufferAttribute(s), this.morphTargetsRelative ? (sr.addVectors(this.boundingBox.min, ks.min), this.boundingBox.expandByPoint(sr), sr.addVectors(this.boundingBox.max, ks.max), this.boundingBox.expandByPoint(sr)) : (this.boundingBox.expandByPoint(ks.min), this.boundingBox.expandByPoint(ks.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new sh());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new Z(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (ks.setFromBufferAttribute(e), t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          tm.setFromBufferAttribute(a), this.morphTargetsRelative ? (sr.addVectors(ks.min, tm.min), ks.expandByPoint(sr), sr.addVectors(ks.max, tm.max), ks.expandByPoint(sr)) : (ks.expandByPoint(tm.min), ks.expandByPoint(tm.max));
        }
      ks.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        sr.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(sr));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s], l = this.morphTargetsRelative;
          for (let c = 0, d = a.count; c < d; c++)
            sr.fromBufferAttribute(a, c), l && (rd.fromBufferAttribute(e, c), sr.add(rd)), r = Math.max(r, i.distanceToSquared(sr));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = e.array, r = t.position.array, s = t.normal.array, o = t.uv.array, a = r.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Vi(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array, c = [], d = [];
    for (let B = 0; B < a; B++)
      c[B] = new Z(), d[B] = new Z();
    const p = new Z(), m = new Z(), v = new Z(), b = new ze(), x = new ze(), y = new ze(), S = new Z(), C = new Z();
    function M(B, Y, G) {
      p.fromArray(r, B * 3), m.fromArray(r, Y * 3), v.fromArray(r, G * 3), b.fromArray(o, B * 2), x.fromArray(o, Y * 2), y.fromArray(o, G * 2), m.sub(p), v.sub(p), x.sub(b), y.sub(b);
      const K = 1 / (x.x * y.y - y.x * x.y);
      !isFinite(K) || (S.copy(m).multiplyScalar(y.y).addScaledVector(v, -x.y).multiplyScalar(K), C.copy(v).multiplyScalar(x.x).addScaledVector(m, -y.x).multiplyScalar(K), c[B].add(S), c[Y].add(S), c[G].add(S), d[B].add(C), d[Y].add(C), d[G].add(C));
    }
    let T = this.groups;
    T.length === 0 && (T = [{
      start: 0,
      count: i.length
    }]);
    for (let B = 0, Y = T.length; B < Y; ++B) {
      const G = T[B], K = G.start, A = G.count;
      for (let J = K, xe = K + A; J < xe; J += 3)
        M(
          i[J + 0],
          i[J + 1],
          i[J + 2]
        );
    }
    const P = new Z(), D = new Z(), I = new Z(), k = new Z();
    function O(B) {
      I.fromArray(s, B * 3), k.copy(I);
      const Y = c[B];
      P.copy(Y), P.sub(I.multiplyScalar(I.dot(Y))).normalize(), D.crossVectors(k, Y);
      const K = D.dot(d[B]) < 0 ? -1 : 1;
      l[B * 4] = P.x, l[B * 4 + 1] = P.y, l[B * 4 + 2] = P.z, l[B * 4 + 3] = K;
    }
    for (let B = 0, Y = T.length; B < Y; ++B) {
      const G = T[B], K = G.start, A = G.count;
      for (let J = K, xe = K + A; J < xe; J += 3)
        O(i[J + 0]), O(i[J + 1]), O(i[J + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new Vi(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let m = 0, v = i.count; m < v; m++)
          i.setXYZ(m, 0, 0, 0);
      const r = new Z(), s = new Z(), o = new Z(), a = new Z(), l = new Z(), c = new Z(), d = new Z(), p = new Z();
      if (e)
        for (let m = 0, v = e.count; m < v; m += 3) {
          const b = e.getX(m + 0), x = e.getX(m + 1), y = e.getX(m + 2);
          r.fromBufferAttribute(t, b), s.fromBufferAttribute(t, x), o.fromBufferAttribute(t, y), d.subVectors(o, s), p.subVectors(r, s), d.cross(p), a.fromBufferAttribute(i, b), l.fromBufferAttribute(i, x), c.fromBufferAttribute(i, y), a.add(d), l.add(d), c.add(d), i.setXYZ(b, a.x, a.y, a.z), i.setXYZ(x, l.x, l.y, l.z), i.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let m = 0, v = t.count; m < v; m += 3)
          r.fromBufferAttribute(t, m + 0), s.fromBufferAttribute(t, m + 1), o.fromBufferAttribute(t, m + 2), d.subVectors(o, s), p.subVectors(r, s), d.cross(p), i.setXYZ(m + 0, d.x, d.y, d.z), i.setXYZ(m + 1, d.x, d.y, d.z), i.setXYZ(m + 2, d.x, d.y, d.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  merge() {
    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      sr.fromBufferAttribute(e, t), sr.normalize(), e.setXYZ(t, sr.x, sr.y, sr.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array, d = a.itemSize, p = a.normalized, m = new c.constructor(l.length * d);
      let v = 0, b = 0;
      for (let x = 0, y = l.length; x < y; x++) {
        a.isInterleavedBufferAttribute ? v = l[x] * a.data.stride + a.offset : v = l[x] * d;
        for (let S = 0; S < d; S++)
          m[b++] = c[v++];
      }
      return new Vi(m, d, p);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new qn(), i = this.index.array, r = this.attributes;
    for (const a in r) {
      const l = r[a], c = e(l, i);
      t.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [], c = s[a];
      for (let d = 0, p = c.length; d < p; d++) {
        const m = c[d], v = e(m, i);
        l.push(v);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const c in l)
        l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l], d = [];
      for (let p = 0, m = c.length; p < m; p++) {
        const v = c[p];
        d.push(v.toJSON(e.data));
      }
      d.length > 0 && (r[l] = d, s = !0);
    }
    s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = {
      center: a.center.toArray(),
      radius: a.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const c in r) {
      const d = r[c];
      this.setAttribute(c, d.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const d = [], p = s[c];
      for (let m = 0, v = p.length; m < v; m++)
        d.push(p[m].clone(t));
      this.morphAttributes[c] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, d = o.length; c < d; c++) {
      const p = o[c];
      this.addGroup(p.start, p.count, p.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const gP = /* @__PURE__ */ new Pt(), sd = /* @__PURE__ */ new Nf(), k1 = /* @__PURE__ */ new sh(), $l = /* @__PURE__ */ new Z(), Zl = /* @__PURE__ */ new Z(), Yl = /* @__PURE__ */ new Z(), L1 = /* @__PURE__ */ new Z(), D1 = /* @__PURE__ */ new Z(), I1 = /* @__PURE__ */ new Z(), V0 = /* @__PURE__ */ new Z(), H0 = /* @__PURE__ */ new Z(), G0 = /* @__PURE__ */ new Z(), W0 = /* @__PURE__ */ new ze(), j0 = /* @__PURE__ */ new ze(), q0 = /* @__PURE__ */ new ze(), O1 = /* @__PURE__ */ new Z(), X0 = /* @__PURE__ */ new Z();
class wi extends wn {
  constructor(e = new qn(), t = new vy()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
  raycast(e, t) {
    const i = this.geometry, r = this.material, s = this.matrixWorld;
    if (r === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(), k1.copy(i.boundingSphere), k1.applyMatrix4(s), e.ray.intersectsSphere(k1) === !1) || (gP.copy(s).invert(), sd.copy(e.ray).applyMatrix4(gP), i.boundingBox !== null && sd.intersectsBox(i.boundingBox) === !1))
      return;
    let o;
    const a = i.index, l = i.attributes.position, c = i.morphAttributes.position, d = i.morphTargetsRelative, p = i.attributes.uv, m = i.attributes.uv2, v = i.groups, b = i.drawRange;
    if (a !== null)
      if (Array.isArray(r))
        for (let x = 0, y = v.length; x < y; x++) {
          const S = v[x], C = r[S.materialIndex], M = Math.max(S.start, b.start), T = Math.min(a.count, Math.min(S.start + S.count, b.start + b.count));
          for (let P = M, D = T; P < D; P += 3) {
            const I = a.getX(P), k = a.getX(P + 1), O = a.getX(P + 2);
            o = $0(this, C, e, sd, l, c, d, p, m, I, k, O), o && (o.faceIndex = Math.floor(P / 3), o.face.materialIndex = S.materialIndex, t.push(o));
          }
        }
      else {
        const x = Math.max(0, b.start), y = Math.min(a.count, b.start + b.count);
        for (let S = x, C = y; S < C; S += 3) {
          const M = a.getX(S), T = a.getX(S + 1), P = a.getX(S + 2);
          o = $0(this, r, e, sd, l, c, d, p, m, M, T, P), o && (o.faceIndex = Math.floor(S / 3), t.push(o));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(r))
        for (let x = 0, y = v.length; x < y; x++) {
          const S = v[x], C = r[S.materialIndex], M = Math.max(S.start, b.start), T = Math.min(l.count, Math.min(S.start + S.count, b.start + b.count));
          for (let P = M, D = T; P < D; P += 3) {
            const I = P, k = P + 1, O = P + 2;
            o = $0(this, C, e, sd, l, c, d, p, m, I, k, O), o && (o.faceIndex = Math.floor(P / 3), o.face.materialIndex = S.materialIndex, t.push(o));
          }
        }
      else {
        const x = Math.max(0, b.start), y = Math.min(l.count, b.start + b.count);
        for (let S = x, C = y; S < C; S += 3) {
          const M = S, T = S + 1, P = S + 2;
          o = $0(this, r, e, sd, l, c, d, p, m, M, T, P), o && (o.faceIndex = Math.floor(S / 3), t.push(o));
        }
      }
  }
}
function i7(n, e, t, i, r, s, o, a) {
  let l;
  if (e.side === cr ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side !== Js, a), l === null)
    return null;
  X0.copy(a), X0.applyMatrix4(n.matrixWorld);
  const c = t.ray.origin.distanceTo(X0);
  return c < t.near || c > t.far ? null : {
    distance: c,
    point: X0.clone(),
    object: n
  };
}
function $0(n, e, t, i, r, s, o, a, l, c, d, p) {
  $l.fromBufferAttribute(r, c), Zl.fromBufferAttribute(r, d), Yl.fromBufferAttribute(r, p);
  const m = n.morphTargetInfluences;
  if (s && m) {
    V0.set(0, 0, 0), H0.set(0, 0, 0), G0.set(0, 0, 0);
    for (let b = 0, x = s.length; b < x; b++) {
      const y = m[b], S = s[b];
      y !== 0 && (L1.fromBufferAttribute(S, c), D1.fromBufferAttribute(S, d), I1.fromBufferAttribute(S, p), o ? (V0.addScaledVector(L1, y), H0.addScaledVector(D1, y), G0.addScaledVector(I1, y)) : (V0.addScaledVector(L1.sub($l), y), H0.addScaledVector(D1.sub(Zl), y), G0.addScaledVector(I1.sub(Yl), y)));
    }
    $l.add(V0), Zl.add(H0), Yl.add(G0);
  }
  n.isSkinnedMesh && (n.boneTransform(c, $l), n.boneTransform(d, Zl), n.boneTransform(p, Yl));
  const v = i7(n, e, t, i, $l, Zl, Yl, O1);
  if (v) {
    a && (W0.fromBufferAttribute(a, c), j0.fromBufferAttribute(a, d), q0.fromBufferAttribute(a, p), v.uv = ia.getUV(O1, $l, Zl, Yl, W0, j0, q0, new ze())), l && (W0.fromBufferAttribute(l, c), j0.fromBufferAttribute(l, d), q0.fromBufferAttribute(l, p), v.uv2 = ia.getUV(O1, $l, Zl, Yl, W0, j0, q0, new ze()));
    const b = {
      a: c,
      b: d,
      c: p,
      normal: new Z(),
      materialIndex: 0
    };
    ia.getNormal($l, Zl, Yl, b.normal), v.face = b;
  }
  return v;
}
class ah extends qn {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: i,
      widthSegments: r,
      heightSegments: s,
      depthSegments: o
    };
    const a = this;
    r = Math.floor(r), s = Math.floor(s), o = Math.floor(o);
    const l = [], c = [], d = [], p = [];
    let m = 0, v = 0;
    b("z", "y", "x", -1, -1, i, t, e, o, s, 0), b("z", "y", "x", 1, -1, i, t, -e, o, s, 1), b("x", "z", "y", 1, 1, e, i, t, r, o, 2), b("x", "z", "y", 1, -1, e, i, -t, r, o, 3), b("x", "y", "z", 1, -1, e, t, i, r, s, 4), b("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new en(c, 3)), this.setAttribute("normal", new en(d, 3)), this.setAttribute("uv", new en(p, 2));
    function b(x, y, S, C, M, T, P, D, I, k, O) {
      const B = T / I, Y = P / k, G = T / 2, K = P / 2, A = D / 2, J = I + 1, xe = k + 1;
      let se = 0, oe = 0;
      const Q = new Z();
      for (let ce = 0; ce < xe; ce++) {
        const te = ce * Y - K;
        for (let ee = 0; ee < J; ee++) {
          const Re = ee * B - G;
          Q[x] = Re * C, Q[y] = te * M, Q[S] = A, c.push(Q.x, Q.y, Q.z), Q[x] = 0, Q[y] = 0, Q[S] = D > 0 ? 1 : -1, d.push(Q.x, Q.y, Q.z), p.push(ee / I), p.push(1 - ce / k), se += 1;
        }
      }
      for (let ce = 0; ce < k; ce++)
        for (let te = 0; te < I; te++) {
          const ee = m + te + J * ce, Re = m + te + J * (ce + 1), ye = m + (te + 1) + J * (ce + 1), Se = m + (te + 1) + J * ce;
          l.push(ee, Re, Se), l.push(Re, ye, Se), oe += 6;
        }
      a.addGroup(v, oe, O), v += oe, m += se;
    }
  }
  static fromJSON(e) {
    return new ah(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function _f(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r;
    }
  }
  return e;
}
function Ir(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = _f(n[t]);
    for (const r in i)
      e[r] = i[r];
  }
  return e;
}
function r7(n) {
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n[t].clone());
  return e;
}
const gy = { clone: _f, merge: Ir };
var s7 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, o7 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Yn extends zo {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = s7, this.fragmentShader = o7, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = _f(e.uniforms), this.uniformsGroups = r7(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture ? t.uniforms[r] = {
        type: "t",
        value: o.toJSON(e).uuid
      } : o && o.isColor ? t.uniforms[r] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? t.uniforms[r] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? t.uniforms[r] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? t.uniforms[r] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? t.uniforms[r] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? t.uniforms[r] = {
        type: "m4",
        value: o.toArray()
      } : t.uniforms[r] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
    const i = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class _y extends wn {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Pt(), this.projectionMatrix = new Pt(), this.projectionMatrixInverse = new Pt();
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ni extends _y {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = $m * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Cm * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return $m * 2 * Math.atan(
      Math.tan(Cm * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, r, s, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Cm * 0.5 * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, c = o.fullHeight;
      s += o.offsetX * r / l, t -= o.offsetY * i / c, r *= o.width / l, i *= o.height / c;
    }
    const a = this.filmOffset;
    a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const od = 90, ad = 1;
class iD extends wn {
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i;
    const r = new ni(od, ad, e, t);
    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Z(1, 0, 0)), this.add(r);
    const s = new ni(od, ad, e, t);
    s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new Z(-1, 0, 0)), this.add(s);
    const o = new ni(od, ad, e, t);
    o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new Z(0, 1, 0)), this.add(o);
    const a = new ni(od, ad, e, t);
    a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Z(0, -1, 0)), this.add(a);
    const l = new ni(od, ad, e, t);
    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Z(0, 0, 1)), this.add(l);
    const c = new ni(od, ad, e, t);
    c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new Z(0, 0, -1)), this.add(c);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget, [r, s, o, a, l, c] = this.children, d = e.getRenderTarget(), p = e.toneMapping, m = e.xr.enabled;
    e.toneMapping = dl, e.xr.enabled = !1;
    const v = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, r), e.setRenderTarget(i, 1), e.render(t, s), e.setRenderTarget(i, 2), e.render(t, o), e.setRenderTarget(i, 3), e.render(t, a), e.setRenderTarget(i, 4), e.render(t, l), i.texture.generateMipmaps = v, e.setRenderTarget(i, 5), e.render(t, c), e.setRenderTarget(d), e.toneMapping = p, e.xr.enabled = m, i.texture.needsPMREMUpdate = !0;
  }
}
class cE extends Wi {
  constructor(e, t, i, r, s, o, a, l, c, d) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : vf, super(e, t, i, r, s, o, a, l, c, d), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class rD extends On {
  constructor(e, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i];
    this.texture = new cE(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Zt;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    }, r = new ah(5, 5, 5), s = new Yn({
      name: "CubemapFromEquirect",
      uniforms: _f(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: cr,
      blending: Si
    });
    s.uniforms.tEquirect.value = t;
    const o = new wi(r, s), a = t.minFilter;
    return t.minFilter === Pv && (t.minFilter = Zt), new iD(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const N1 = /* @__PURE__ */ new Z(), a7 = /* @__PURE__ */ new Z(), l7 = /* @__PURE__ */ new ur();
class gu {
  constructor(e = new Z(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = N1.subVectors(i, t).cross(a7.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const i = e.delta(N1), r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || l7.getNormalMatrix(e), r = this.coplanarPoint(N1).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ld = /* @__PURE__ */ new sh(), Z0 = /* @__PURE__ */ new Z();
class by {
  constructor(e = new gu(), t = new gu(), i = new gu(), r = new gu(), s = new gu(), o = new gu()) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes, i = e.elements, r = i[0], s = i[1], o = i[2], a = i[3], l = i[4], c = i[5], d = i[6], p = i[7], m = i[8], v = i[9], b = i[10], x = i[11], y = i[12], S = i[13], C = i[14], M = i[15];
    return t[0].setComponents(a - r, p - l, x - m, M - y).normalize(), t[1].setComponents(a + r, p + l, x + m, M + y).normalize(), t[2].setComponents(a + s, p + c, x + v, M + S).normalize(), t[3].setComponents(a - s, p - c, x - v, M - S).normalize(), t[4].setComponents(a - o, p - d, x - b, M - C).normalize(), t[5].setComponents(a + o, p + d, x + b, M + C).normalize(), this;
  }
  intersectsObject(e) {
    const t = e.geometry;
    return t.boundingSphere === null && t.computeBoundingSphere(), ld.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(ld);
  }
  intersectsSprite(e) {
    return ld.center.set(0, 0, 0), ld.radius = 0.7071067811865476, ld.applyMatrix4(e.matrixWorld), this.intersectsSphere(ld);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, r = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(i) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (Z0.x = r.normal.x > 0 ? e.max.x : e.min.x, Z0.y = r.normal.y > 0 ? e.max.y : e.min.y, Z0.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Z0) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      if (t[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function sD() {
  let n = null, e = !1, t = null, i = null;
  function r(s, o) {
    t(s, o), i = n.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (i = n.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      n.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(s) {
      t = s;
    },
    setContext: function(s) {
      n = s;
    }
  };
}
function c7(n, e) {
  const t = e.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function r(c, d) {
    const p = c.array, m = c.usage, v = n.createBuffer();
    n.bindBuffer(d, v), n.bufferData(d, p, m), c.onUploadCallback();
    let b;
    if (p instanceof Float32Array)
      b = 5126;
    else if (p instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t)
          b = 5131;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        b = 5123;
    else if (p instanceof Int16Array)
      b = 5122;
    else if (p instanceof Uint32Array)
      b = 5125;
    else if (p instanceof Int32Array)
      b = 5124;
    else if (p instanceof Int8Array)
      b = 5120;
    else if (p instanceof Uint8Array)
      b = 5121;
    else if (p instanceof Uint8ClampedArray)
      b = 5121;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + p);
    return {
      buffer: v,
      type: b,
      bytesPerElement: p.BYTES_PER_ELEMENT,
      version: c.version
    };
  }
  function s(c, d, p) {
    const m = d.array, v = d.updateRange;
    n.bindBuffer(p, c), v.count === -1 ? n.bufferSubData(p, 0, m) : (t ? n.bufferSubData(
      p,
      v.offset * m.BYTES_PER_ELEMENT,
      m,
      v.offset,
      v.count
    ) : n.bufferSubData(
      p,
      v.offset * m.BYTES_PER_ELEMENT,
      m.subarray(v.offset, v.offset + v.count)
    ), v.count = -1);
  }
  function o(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
  }
  function a(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const d = i.get(c);
    d && (n.deleteBuffer(d.buffer), i.delete(c));
  }
  function l(c, d) {
    if (c.isGLBufferAttribute) {
      const m = i.get(c);
      (!m || m.version < c.version) && i.set(c, {
        buffer: c.buffer,
        type: c.type,
        bytesPerElement: c.elementSize,
        version: c.version
      });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const p = i.get(c);
    p === void 0 ? i.set(c, r(c, d)) : p.version < c.version && (s(p.buffer, c, d), p.version = c.version);
  }
  return {
    get: o,
    remove: a,
    update: l
  };
}
class Av extends qn {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: i,
      heightSegments: r
    };
    const s = e / 2, o = t / 2, a = Math.floor(i), l = Math.floor(r), c = a + 1, d = l + 1, p = e / a, m = t / l, v = [], b = [], x = [], y = [];
    for (let S = 0; S < d; S++) {
      const C = S * m - o;
      for (let M = 0; M < c; M++) {
        const T = M * p - s;
        b.push(T, -C, 0), x.push(0, 0, 1), y.push(M / a), y.push(1 - S / l);
      }
    }
    for (let S = 0; S < l; S++)
      for (let C = 0; C < a; C++) {
        const M = C + c * S, T = C + c * (S + 1), P = C + 1 + c * (S + 1), D = C + 1 + c * S;
        v.push(M, T, D), v.push(T, P, D);
      }
    this.setIndex(v), this.setAttribute("position", new en(b, 3)), this.setAttribute("normal", new en(x, 3)), this.setAttribute("uv", new en(y, 2));
  }
  static fromJSON(e) {
    return new Av(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var u7 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, h7 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, d7 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, f7 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, p7 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, m7 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, v7 = "vec3 transformed = vec3( position );", g7 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, _7 = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, b7 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, y7 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, x7 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, w7 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, S7 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, M7 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, E7 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, C7 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, T7 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, P7 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, A7 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, R7 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, k7 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, L7 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, D7 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, I7 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, O7 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, N7 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", z7 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, F7 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, B7 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, U7 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, V7 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, H7 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, G7 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, W7 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, j7 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, q7 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, X7 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, $7 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, Z7 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Y7 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, K7 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
#define Material_LightProbeLOD( material )	(0)`, J7 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Q7 = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, eH = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, tH = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, nH = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, iH = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, rH = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, sH = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, oH = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, aH = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, lH = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, cH = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, uH = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, hH = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, dH = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, fH = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, pH = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, mH = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, vH = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, gH = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, _H = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, bH = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, yH = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, xH = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, wH = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, SH = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, MH = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, EH = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, CH = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, TH = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, PH = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, AH = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, RH = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, kH = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, LH = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, DH = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, IH = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, OH = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, NH = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, zH = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, FH = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, BH = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, UH = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, VH = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, HH = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, GH = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, WH = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, jH = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, qH = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, XH = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, $H = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, ZH = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, YH = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, KH = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, JH = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, QH = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, eG = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, tG = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, nG = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, iG = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, rG = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, sG = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, oG = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, aG = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const lG = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, cG = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, uG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, hG = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, dG = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, fG = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, pG = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, mG = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, vG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, gG = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, _G = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, bG = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, yG = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, xG = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wG = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, SG = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, MG = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, EG = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, CG = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, TG = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, PG = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, AG = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, RG = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, kG = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, LG = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, DG = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, IG = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, OG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, NG = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, zG = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, FG = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, BG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Nt = {
  alphamap_fragment: u7,
  alphamap_pars_fragment: h7,
  alphatest_fragment: d7,
  alphatest_pars_fragment: f7,
  aomap_fragment: p7,
  aomap_pars_fragment: m7,
  begin_vertex: v7,
  beginnormal_vertex: g7,
  bsdfs: _7,
  iridescence_fragment: b7,
  bumpmap_pars_fragment: y7,
  clipping_planes_fragment: x7,
  clipping_planes_pars_fragment: w7,
  clipping_planes_pars_vertex: S7,
  clipping_planes_vertex: M7,
  color_fragment: E7,
  color_pars_fragment: C7,
  color_pars_vertex: T7,
  color_vertex: P7,
  common: A7,
  cube_uv_reflection_fragment: R7,
  defaultnormal_vertex: k7,
  displacementmap_pars_vertex: L7,
  displacementmap_vertex: D7,
  emissivemap_fragment: I7,
  emissivemap_pars_fragment: O7,
  encodings_fragment: N7,
  encodings_pars_fragment: z7,
  envmap_fragment: F7,
  envmap_common_pars_fragment: B7,
  envmap_pars_fragment: U7,
  envmap_pars_vertex: V7,
  envmap_physical_pars_fragment: Q7,
  envmap_vertex: H7,
  fog_vertex: G7,
  fog_pars_vertex: W7,
  fog_fragment: j7,
  fog_pars_fragment: q7,
  gradientmap_pars_fragment: X7,
  lightmap_fragment: $7,
  lightmap_pars_fragment: Z7,
  lights_lambert_fragment: Y7,
  lights_lambert_pars_fragment: K7,
  lights_pars_begin: J7,
  lights_toon_fragment: eH,
  lights_toon_pars_fragment: tH,
  lights_phong_fragment: nH,
  lights_phong_pars_fragment: iH,
  lights_physical_fragment: rH,
  lights_physical_pars_fragment: sH,
  lights_fragment_begin: oH,
  lights_fragment_maps: aH,
  lights_fragment_end: lH,
  logdepthbuf_fragment: cH,
  logdepthbuf_pars_fragment: uH,
  logdepthbuf_pars_vertex: hH,
  logdepthbuf_vertex: dH,
  map_fragment: fH,
  map_pars_fragment: pH,
  map_particle_fragment: mH,
  map_particle_pars_fragment: vH,
  metalnessmap_fragment: gH,
  metalnessmap_pars_fragment: _H,
  morphcolor_vertex: bH,
  morphnormal_vertex: yH,
  morphtarget_pars_vertex: xH,
  morphtarget_vertex: wH,
  normal_fragment_begin: SH,
  normal_fragment_maps: MH,
  normal_pars_fragment: EH,
  normal_pars_vertex: CH,
  normal_vertex: TH,
  normalmap_pars_fragment: PH,
  clearcoat_normal_fragment_begin: AH,
  clearcoat_normal_fragment_maps: RH,
  clearcoat_pars_fragment: kH,
  iridescence_pars_fragment: LH,
  output_fragment: DH,
  packing: IH,
  premultiplied_alpha_fragment: OH,
  project_vertex: NH,
  dithering_fragment: zH,
  dithering_pars_fragment: FH,
  roughnessmap_fragment: BH,
  roughnessmap_pars_fragment: UH,
  shadowmap_pars_fragment: VH,
  shadowmap_pars_vertex: HH,
  shadowmap_vertex: GH,
  shadowmask_pars_fragment: WH,
  skinbase_vertex: jH,
  skinning_pars_vertex: qH,
  skinning_vertex: XH,
  skinnormal_vertex: $H,
  specularmap_fragment: ZH,
  specularmap_pars_fragment: YH,
  tonemapping_fragment: KH,
  tonemapping_pars_fragment: JH,
  transmission_fragment: QH,
  transmission_pars_fragment: eG,
  uv_pars_fragment: tG,
  uv_pars_vertex: nG,
  uv_vertex: iG,
  uv2_pars_fragment: rG,
  uv2_pars_vertex: sG,
  uv2_vertex: oG,
  worldpos_vertex: aG,
  background_vert: lG,
  background_frag: cG,
  cube_vert: uG,
  cube_frag: hG,
  depth_vert: dG,
  depth_frag: fG,
  distanceRGBA_vert: pG,
  distanceRGBA_frag: mG,
  equirect_vert: vG,
  equirect_frag: gG,
  linedashed_vert: _G,
  linedashed_frag: bG,
  meshbasic_vert: yG,
  meshbasic_frag: xG,
  meshlambert_vert: wG,
  meshlambert_frag: SG,
  meshmatcap_vert: MG,
  meshmatcap_frag: EG,
  meshnormal_vert: CG,
  meshnormal_frag: TG,
  meshphong_vert: PG,
  meshphong_frag: AG,
  meshphysical_vert: RG,
  meshphysical_frag: kG,
  meshtoon_vert: LG,
  meshtoon_frag: DG,
  points_vert: IG,
  points_frag: OG,
  shadow_vert: NG,
  shadow_frag: zG,
  sprite_vert: FG,
  sprite_frag: BG
}, Ke = {
  common: {
    diffuse: { value: /* @__PURE__ */ new xt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: /* @__PURE__ */ new ur() },
    uv2Transform: { value: /* @__PURE__ */ new ur() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: /* @__PURE__ */ new ze(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new xt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new xt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new ur() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new xt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new ze(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new ur() }
  }
}, ms = {
  basic: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.specularmap,
      Ke.envmap,
      Ke.aomap,
      Ke.lightmap,
      Ke.fog
    ]),
    vertexShader: Nt.meshbasic_vert,
    fragmentShader: Nt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.specularmap,
      Ke.envmap,
      Ke.aomap,
      Ke.lightmap,
      Ke.emissivemap,
      Ke.bumpmap,
      Ke.normalmap,
      Ke.displacementmap,
      Ke.fog,
      Ke.lights,
      {
        emissive: { value: /* @__PURE__ */ new xt(0) }
      }
    ]),
    vertexShader: Nt.meshlambert_vert,
    fragmentShader: Nt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.specularmap,
      Ke.envmap,
      Ke.aomap,
      Ke.lightmap,
      Ke.emissivemap,
      Ke.bumpmap,
      Ke.normalmap,
      Ke.displacementmap,
      Ke.fog,
      Ke.lights,
      {
        emissive: { value: /* @__PURE__ */ new xt(0) },
        specular: { value: /* @__PURE__ */ new xt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Nt.meshphong_vert,
    fragmentShader: Nt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.envmap,
      Ke.aomap,
      Ke.lightmap,
      Ke.emissivemap,
      Ke.bumpmap,
      Ke.normalmap,
      Ke.displacementmap,
      Ke.roughnessmap,
      Ke.metalnessmap,
      Ke.fog,
      Ke.lights,
      {
        emissive: { value: /* @__PURE__ */ new xt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Nt.meshphysical_vert,
    fragmentShader: Nt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.aomap,
      Ke.lightmap,
      Ke.emissivemap,
      Ke.bumpmap,
      Ke.normalmap,
      Ke.displacementmap,
      Ke.gradientmap,
      Ke.fog,
      Ke.lights,
      {
        emissive: { value: /* @__PURE__ */ new xt(0) }
      }
    ]),
    vertexShader: Nt.meshtoon_vert,
    fragmentShader: Nt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.bumpmap,
      Ke.normalmap,
      Ke.displacementmap,
      Ke.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Nt.meshmatcap_vert,
    fragmentShader: Nt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.points,
      Ke.fog
    ]),
    vertexShader: Nt.points_vert,
    fragmentShader: Nt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Nt.linedashed_vert,
    fragmentShader: Nt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.displacementmap
    ]),
    vertexShader: Nt.depth_vert,
    fragmentShader: Nt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.bumpmap,
      Ke.normalmap,
      Ke.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Nt.meshnormal_vert,
    fragmentShader: Nt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.sprite,
      Ke.fog
    ]),
    vertexShader: Nt.sprite_vert,
    fragmentShader: Nt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new ur() },
      t2D: { value: null }
    },
    vertexShader: Nt.background_vert,
    fragmentShader: Nt.background_frag
  },
  cube: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Nt.cube_vert,
    fragmentShader: Nt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Nt.equirect_vert,
    fragmentShader: Nt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.common,
      Ke.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Z() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Nt.distanceRGBA_vert,
    fragmentShader: Nt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Ir([
      Ke.lights,
      Ke.fog,
      {
        color: { value: /* @__PURE__ */ new xt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Nt.shadow_vert,
    fragmentShader: Nt.shadow_frag
  }
};
ms.physical = {
  uniforms: /* @__PURE__ */ Ir([
    ms.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: /* @__PURE__ */ new ze(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new xt(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: /* @__PURE__ */ new ze() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new xt(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: /* @__PURE__ */ new xt(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: Nt.meshphysical_vert,
  fragmentShader: Nt.meshphysical_frag
};
function UG(n, e, t, i, r, s) {
  const o = new xt(0);
  let a = r === !0 ? 0 : 1, l, c, d = null, p = 0, m = null;
  function v(x, y) {
    let S = !1, C = y.isScene === !0 ? y.background : null;
    C && C.isTexture && (C = e.get(C));
    const M = n.xr, T = M.getSession && M.getSession();
    T && T.environmentBlendMode === "additive" && (C = null), C === null ? b(o, a) : C && C.isColor && (b(C, 1), S = !0), (n.autoClear || S) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), C && (C.isCubeTexture || C.mapping === py) ? (c === void 0 && (c = new wi(
      new ah(1, 1, 1),
      new Yn({
        name: "BackgroundCubeMaterial",
        uniforms: _f(ms.cube.uniforms),
        vertexShader: ms.cube.vertexShader,
        fragmentShader: ms.cube.fragmentShader,
        side: cr,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(P, D, I) {
      this.matrixWorld.copyPosition(I.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(c)), c.material.uniforms.envMap.value = C, c.material.uniforms.flipEnvMap.value = C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1, (d !== C || p !== C.version || m !== n.toneMapping) && (c.material.needsUpdate = !0, d = C, p = C.version, m = n.toneMapping), c.layers.enableAll(), x.unshift(c, c.geometry, c.material, 0, 0, null)) : C && C.isTexture && (l === void 0 && (l = new wi(
      new Av(2, 2),
      new Yn({
        name: "BackgroundMaterial",
        uniforms: _f(ms.background.uniforms),
        vertexShader: ms.background.vertexShader,
        fragmentShader: ms.background.fragmentShader,
        side: ju,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(l)), l.material.uniforms.t2D.value = C, C.matrixAutoUpdate === !0 && C.updateMatrix(), l.material.uniforms.uvTransform.value.copy(C.matrix), (d !== C || p !== C.version || m !== n.toneMapping) && (l.material.needsUpdate = !0, d = C, p = C.version, m = n.toneMapping), l.layers.enableAll(), x.unshift(l, l.geometry, l.material, 0, 0, null));
  }
  function b(x, y) {
    t.buffers.color.setClear(x.r, x.g, x.b, y, s);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(x, y = 1) {
      o.set(x), a = y, b(o, a);
    },
    getClearAlpha: function() {
      return a;
    },
    setClearAlpha: function(x) {
      a = x, b(o, a);
    },
    render: v
  };
}
function VG(n, e, t, i) {
  const r = n.getParameter(34921), s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = i.isWebGL2 || s !== null, a = {}, l = y(null);
  let c = l, d = !1;
  function p(A, J, xe, se, oe) {
    let Q = !1;
    if (o) {
      const ce = x(se, xe, J);
      c !== ce && (c = ce, v(c.object)), Q = S(A, se, xe, oe), Q && C(A, se, xe, oe);
    } else {
      const ce = J.wireframe === !0;
      (c.geometry !== se.id || c.program !== xe.id || c.wireframe !== ce) && (c.geometry = se.id, c.program = xe.id, c.wireframe = ce, Q = !0);
    }
    oe !== null && t.update(oe, 34963), (Q || d) && (d = !1, k(A, J, xe, se), oe !== null && n.bindBuffer(34963, t.get(oe).buffer));
  }
  function m() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function v(A) {
    return i.isWebGL2 ? n.bindVertexArray(A) : s.bindVertexArrayOES(A);
  }
  function b(A) {
    return i.isWebGL2 ? n.deleteVertexArray(A) : s.deleteVertexArrayOES(A);
  }
  function x(A, J, xe) {
    const se = xe.wireframe === !0;
    let oe = a[A.id];
    oe === void 0 && (oe = {}, a[A.id] = oe);
    let Q = oe[J.id];
    Q === void 0 && (Q = {}, oe[J.id] = Q);
    let ce = Q[se];
    return ce === void 0 && (ce = y(m()), Q[se] = ce), ce;
  }
  function y(A) {
    const J = [], xe = [], se = [];
    for (let oe = 0; oe < r; oe++)
      J[oe] = 0, xe[oe] = 0, se[oe] = 0;
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: J,
      enabledAttributes: xe,
      attributeDivisors: se,
      object: A,
      attributes: {},
      index: null
    };
  }
  function S(A, J, xe, se) {
    const oe = c.attributes, Q = J.attributes;
    let ce = 0;
    const te = xe.getAttributes();
    for (const ee in te)
      if (te[ee].location >= 0) {
        const ye = oe[ee];
        let Se = Q[ee];
        if (Se === void 0 && (ee === "instanceMatrix" && A.instanceMatrix && (Se = A.instanceMatrix), ee === "instanceColor" && A.instanceColor && (Se = A.instanceColor)), ye === void 0 || ye.attribute !== Se || Se && ye.data !== Se.data)
          return !0;
        ce++;
      }
    return c.attributesNum !== ce || c.index !== se;
  }
  function C(A, J, xe, se) {
    const oe = {}, Q = J.attributes;
    let ce = 0;
    const te = xe.getAttributes();
    for (const ee in te)
      if (te[ee].location >= 0) {
        let ye = Q[ee];
        ye === void 0 && (ee === "instanceMatrix" && A.instanceMatrix && (ye = A.instanceMatrix), ee === "instanceColor" && A.instanceColor && (ye = A.instanceColor));
        const Se = {};
        Se.attribute = ye, ye && ye.data && (Se.data = ye.data), oe[ee] = Se, ce++;
      }
    c.attributes = oe, c.attributesNum = ce, c.index = se;
  }
  function M() {
    const A = c.newAttributes;
    for (let J = 0, xe = A.length; J < xe; J++)
      A[J] = 0;
  }
  function T(A) {
    P(A, 0);
  }
  function P(A, J) {
    const xe = c.newAttributes, se = c.enabledAttributes, oe = c.attributeDivisors;
    xe[A] = 1, se[A] === 0 && (n.enableVertexAttribArray(A), se[A] = 1), oe[A] !== J && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](A, J), oe[A] = J);
  }
  function D() {
    const A = c.newAttributes, J = c.enabledAttributes;
    for (let xe = 0, se = J.length; xe < se; xe++)
      J[xe] !== A[xe] && (n.disableVertexAttribArray(xe), J[xe] = 0);
  }
  function I(A, J, xe, se, oe, Q) {
    i.isWebGL2 === !0 && (xe === 5124 || xe === 5125) ? n.vertexAttribIPointer(A, J, xe, oe, Q) : n.vertexAttribPointer(A, J, xe, se, oe, Q);
  }
  function k(A, J, xe, se) {
    if (i.isWebGL2 === !1 && (A.isInstancedMesh || se.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    M();
    const oe = se.attributes, Q = xe.getAttributes(), ce = J.defaultAttributeValues;
    for (const te in Q) {
      const ee = Q[te];
      if (ee.location >= 0) {
        let Re = oe[te];
        if (Re === void 0 && (te === "instanceMatrix" && A.instanceMatrix && (Re = A.instanceMatrix), te === "instanceColor" && A.instanceColor && (Re = A.instanceColor)), Re !== void 0) {
          const ye = Re.normalized, Se = Re.itemSize, Ee = t.get(Re);
          if (Ee === void 0)
            continue;
          const gt = Ee.buffer, qe = Ee.type, Ze = Ee.bytesPerElement;
          if (Re.isInterleavedBufferAttribute) {
            const je = Re.data, st = je.stride, Ie = Re.offset;
            if (je.isInstancedInterleavedBuffer) {
              for (let Le = 0; Le < ee.locationSize; Le++)
                P(ee.location + Le, je.meshPerAttribute);
              A.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = je.meshPerAttribute * je.count);
            } else
              for (let Le = 0; Le < ee.locationSize; Le++)
                T(ee.location + Le);
            n.bindBuffer(34962, gt);
            for (let Le = 0; Le < ee.locationSize; Le++)
              I(
                ee.location + Le,
                Se / ee.locationSize,
                qe,
                ye,
                st * Ze,
                (Ie + Se / ee.locationSize * Le) * Ze
              );
          } else {
            if (Re.isInstancedBufferAttribute) {
              for (let je = 0; je < ee.locationSize; je++)
                P(ee.location + je, Re.meshPerAttribute);
              A.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = Re.meshPerAttribute * Re.count);
            } else
              for (let je = 0; je < ee.locationSize; je++)
                T(ee.location + je);
            n.bindBuffer(34962, gt);
            for (let je = 0; je < ee.locationSize; je++)
              I(
                ee.location + je,
                Se / ee.locationSize,
                qe,
                ye,
                Se * Ze,
                Se / ee.locationSize * je * Ze
              );
          }
        } else if (ce !== void 0) {
          const ye = ce[te];
          if (ye !== void 0)
            switch (ye.length) {
              case 2:
                n.vertexAttrib2fv(ee.location, ye);
                break;
              case 3:
                n.vertexAttrib3fv(ee.location, ye);
                break;
              case 4:
                n.vertexAttrib4fv(ee.location, ye);
                break;
              default:
                n.vertexAttrib1fv(ee.location, ye);
            }
        }
      }
    }
    D();
  }
  function O() {
    G();
    for (const A in a) {
      const J = a[A];
      for (const xe in J) {
        const se = J[xe];
        for (const oe in se)
          b(se[oe].object), delete se[oe];
        delete J[xe];
      }
      delete a[A];
    }
  }
  function B(A) {
    if (a[A.id] === void 0)
      return;
    const J = a[A.id];
    for (const xe in J) {
      const se = J[xe];
      for (const oe in se)
        b(se[oe].object), delete se[oe];
      delete J[xe];
    }
    delete a[A.id];
  }
  function Y(A) {
    for (const J in a) {
      const xe = a[J];
      if (xe[A.id] === void 0)
        continue;
      const se = xe[A.id];
      for (const oe in se)
        b(se[oe].object), delete se[oe];
      delete xe[A.id];
    }
  }
  function G() {
    K(), d = !0, c !== l && (c = l, v(c.object));
  }
  function K() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return {
    setup: p,
    reset: G,
    resetDefaultState: K,
    dispose: O,
    releaseStatesOfGeometry: B,
    releaseStatesOfProgram: Y,
    initAttributes: M,
    enableAttribute: T,
    disableUnusedAttributes: D
  };
}
function HG(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(c) {
    s = c;
  }
  function a(c, d) {
    n.drawArrays(s, c, d), t.update(d, s, 1);
  }
  function l(c, d, p) {
    if (p === 0)
      return;
    let m, v;
    if (r)
      m = n, v = "drawArraysInstanced";
    else if (m = e.get("ANGLE_instanced_arrays"), v = "drawArraysInstancedANGLE", m === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    m[v](s, c, d, p), t.update(d, s, p);
  }
  this.setMode = o, this.render = a, this.renderInstances = l;
}
function GG(n, e, t) {
  let i;
  function r() {
    if (i !== void 0)
      return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const I = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function s(I) {
    if (I === "highp") {
      if (n.getShaderPrecisionFormat(35633, 36338).precision > 0 && n.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      I = "mediump";
    }
    return I === "mediump" && n.getShaderPrecisionFormat(35633, 36337).precision > 0 && n.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const o = typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && n instanceof WebGL2ComputeRenderingContext;
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = s(a);
  l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
  const c = o || e.has("WEBGL_draw_buffers"), d = t.logarithmicDepthBuffer === !0, p = n.getParameter(34930), m = n.getParameter(35660), v = n.getParameter(3379), b = n.getParameter(34076), x = n.getParameter(34921), y = n.getParameter(36347), S = n.getParameter(36348), C = n.getParameter(36349), M = m > 0, T = o || e.has("OES_texture_float"), P = M && T, D = o ? n.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    drawBuffers: c,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: d,
    maxTextures: p,
    maxVertexTextures: m,
    maxTextureSize: v,
    maxCubemapSize: b,
    maxAttributes: x,
    maxVertexUniforms: y,
    maxVaryings: S,
    maxFragmentUniforms: C,
    vertexTextures: M,
    floatFragmentTextures: T,
    floatVertexTextures: P,
    maxSamples: D
  };
}
function WG(n) {
  const e = this;
  let t = null, i = 0, r = !1, s = !1;
  const o = new gu(), a = new ur(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(p, m, v) {
    const b = p.length !== 0 || m || i !== 0 || r;
    return r = m, t = d(p, v, 0), i = p.length, b;
  }, this.beginShadows = function() {
    s = !0, d(null);
  }, this.endShadows = function() {
    s = !1, c();
  }, this.setState = function(p, m, v) {
    const b = p.clippingPlanes, x = p.clipIntersection, y = p.clipShadows, S = n.get(p);
    if (!r || b === null || b.length === 0 || s && !y)
      s ? d(null) : c();
    else {
      const C = s ? 0 : i, M = C * 4;
      let T = S.clippingState || null;
      l.value = T, T = d(b, m, M, v);
      for (let P = 0; P !== M; ++P)
        T[P] = t[P];
      S.clippingState = T, this.numIntersection = x ? this.numPlanes : 0, this.numPlanes += C;
    }
  };
  function c() {
    l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function d(p, m, v, b) {
    const x = p !== null ? p.length : 0;
    let y = null;
    if (x !== 0) {
      if (y = l.value, b !== !0 || y === null) {
        const S = v + x * 4, C = m.matrixWorldInverse;
        a.getNormalMatrix(C), (y === null || y.length < S) && (y = new Float32Array(S));
        for (let M = 0, T = v; M !== x; ++M, T += 4)
          o.copy(p[M]).applyMatrix4(C, a), o.normal.toArray(y, T), y[T + 3] = o.constant;
      }
      l.value = y, l.needsUpdate = !0;
    }
    return e.numPlanes = x, e.numIntersection = 0, y;
  }
}
function jG(n) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, a) {
    return a === _b ? o.mapping = vf : a === h2 && (o.mapping = gf), o;
  }
  function i(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping;
      if (a === _b || a === h2)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new rD(l.height / 2);
            return c.fromEquirectangularTexture(n, o), e.set(o, c), o.addEventListener("dispose", r), t(c.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: s
  };
}
class uE extends _y {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = i - e, o = i + e, a = r + t, l = r - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += c * this.view.offsetX, o = s + c * this.view.width, a -= d * this.view.offsetY, l = a - d * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Ld = 4, _P = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], xu = 20, z1 = /* @__PURE__ */ new uE(), bP = /* @__PURE__ */ new xt();
let F1 = null;
const _u = (1 + Math.sqrt(5)) / 2, cd = 1 / _u, yP = [
  /* @__PURE__ */ new Z(1, 1, 1),
  /* @__PURE__ */ new Z(-1, 1, 1),
  /* @__PURE__ */ new Z(1, 1, -1),
  /* @__PURE__ */ new Z(-1, 1, -1),
  /* @__PURE__ */ new Z(0, _u, cd),
  /* @__PURE__ */ new Z(0, _u, -cd),
  /* @__PURE__ */ new Z(cd, 0, _u),
  /* @__PURE__ */ new Z(-cd, 0, _u),
  /* @__PURE__ */ new Z(_u, cd, 0),
  /* @__PURE__ */ new Z(-_u, cd, 0)
];
class g2 {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    F1 = this._renderer.getRenderTarget(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = SP(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = wP(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(F1), e.scissorTest = !1, Y0(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === vf || e.mapping === gf ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), F1 = this._renderer.getRenderTarget();
    const i = t || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
      magFilter: Zt,
      minFilter: Zt,
      generateMipmaps: !1,
      type: $r,
      format: wr,
      encoding: Ro,
      depthBuffer: !1
    }, r = xP(e, t, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = xP(e, t, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = qG(s)), this._blurMaterial = XG(s, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new wi(this._lodPlanes[0], e);
    this._renderer.compile(t, z1);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new ni(90, 1, t, i), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], d = this._renderer, p = d.autoClear, m = d.toneMapping;
    d.getClearColor(bP), d.toneMapping = dl, d.autoClear = !1;
    const v = new vy({
      name: "PMREM.Background",
      side: cr,
      depthWrite: !1,
      depthTest: !1
    }), b = new wi(new ah(), v);
    let x = !1;
    const y = e.background;
    y ? y.isColor && (v.color.copy(y), e.background = null, x = !0) : (v.color.copy(bP), x = !0);
    for (let S = 0; S < 6; S++) {
      const C = S % 3;
      C === 0 ? (a.up.set(0, l[S], 0), a.lookAt(c[S], 0, 0)) : C === 1 ? (a.up.set(0, 0, l[S]), a.lookAt(0, c[S], 0)) : (a.up.set(0, l[S], 0), a.lookAt(0, 0, c[S]));
      const M = this._cubeSize;
      Y0(r, C * M, S > 2 ? M : 0, M, M), d.setRenderTarget(r), x && d.render(b, a), d.render(e, a);
    }
    b.geometry.dispose(), b.material.dispose(), d.toneMapping = m, d.autoClear = p, e.background = y;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer, r = e.mapping === vf || e.mapping === gf;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = SP()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = wP());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, o = new wi(this._lodPlanes[0], s), a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    Y0(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, z1);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = yP[(r - 1) % yP.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      i,
      r,
      "latitudinal",
      s
    ), this._halfBlur(
      o,
      e,
      i,
      i,
      r,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer, c = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const d = 3, p = new wi(this._lodPlanes[r], c), m = c.uniforms, v = this._sizeLods[i] - 1, b = isFinite(s) ? Math.PI / (2 * v) : 2 * Math.PI / (2 * xu - 1), x = s / b, y = isFinite(s) ? 1 + Math.floor(d * x) : xu;
    y > xu && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${xu}`);
    const S = [];
    let C = 0;
    for (let I = 0; I < xu; ++I) {
      const k = I / x, O = Math.exp(-k * k / 2);
      S.push(O), I === 0 ? C += O : I < y && (C += 2 * O);
    }
    for (let I = 0; I < S.length; I++)
      S[I] = S[I] / C;
    m.envMap.value = e.texture, m.samples.value = y, m.weights.value = S, m.latitudinal.value = o === "latitudinal", a && (m.poleAxis.value = a);
    const { _lodMax: M } = this;
    m.dTheta.value = b, m.mipInt.value = M - i;
    const T = this._sizeLods[r], P = 3 * T * (r > M - Ld ? r - M + Ld : 0), D = 4 * (this._cubeSize - T);
    Y0(t, P, D, 3 * T, 2 * T), l.setRenderTarget(t), l.render(p, z1);
  }
}
function qG(n) {
  const e = [], t = [], i = [];
  let r = n;
  const s = n - Ld + 1 + _P.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let l = 1 / a;
    o > n - Ld ? l = _P[o - n + Ld - 1] : o === 0 && (l = 0), i.push(l);
    const c = 1 / (a - 2), d = -c, p = 1 + c, m = [d, d, p, d, p, p, d, d, p, p, d, p], v = 6, b = 6, x = 3, y = 2, S = 1, C = new Float32Array(x * b * v), M = new Float32Array(y * b * v), T = new Float32Array(S * b * v);
    for (let D = 0; D < v; D++) {
      const I = D % 3 * 2 / 3 - 1, k = D > 2 ? 0 : -1, O = [
        I,
        k,
        0,
        I + 2 / 3,
        k,
        0,
        I + 2 / 3,
        k + 1,
        0,
        I,
        k,
        0,
        I + 2 / 3,
        k + 1,
        0,
        I,
        k + 1,
        0
      ];
      C.set(O, x * b * D), M.set(m, y * b * D);
      const B = [D, D, D, D, D, D];
      T.set(B, S * b * D);
    }
    const P = new qn();
    P.setAttribute("position", new Vi(C, x)), P.setAttribute("uv", new Vi(M, y)), P.setAttribute("faceIndex", new Vi(T, S)), e.push(P), r > Ld && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function xP(n, e, t) {
  const i = new On(n, e, t);
  return i.texture.mapping = py, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function Y0(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function XG(n, e, t) {
  const i = new Float32Array(xu), r = new Z(0, 1, 0);
  return new Yn({
    name: "SphericalGaussianBlur",
    defines: {
      n: xu,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: hE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Si,
    depthTest: !1,
    depthWrite: !1
  });
}
function wP() {
  return new Yn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: hE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Si,
    depthTest: !1,
    depthWrite: !1
  });
}
function SP() {
  return new Yn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: hE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Si,
    depthTest: !1,
    depthWrite: !1
  });
}
function hE() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function $G(n) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping, c = l === _b || l === h2, d = l === vf || l === gf;
      if (c || d)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let p = e.get(a);
          return t === null && (t = new g2(n)), p = c ? t.fromEquirectangular(a, p) : t.fromCubemap(a, p), e.set(a, p), p.texture;
        } else {
          if (e.has(a))
            return e.get(a).texture;
          {
            const p = a.image;
            if (c && p && p.height > 0 || d && p && r(p)) {
              t === null && (t = new g2(n));
              const m = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, m), a.addEventListener("dispose", s), m.texture;
            } else
              return null;
          }
        }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const c = 6;
    for (let d = 0; d < c; d++)
      a[d] !== void 0 && l++;
    return l === c;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: i,
    dispose: o
  };
}
function ZG(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0)
      return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return e[i] = r, r;
  }
  return {
    has: function(i) {
      return t(i) !== null;
    },
    init: function(i) {
      i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(i) {
      const r = t(i);
      return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r;
    }
  };
}
function YG(n, e, t, i) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function o(p) {
    const m = p.target;
    m.index !== null && e.remove(m.index);
    for (const b in m.attributes)
      e.remove(m.attributes[b]);
    m.removeEventListener("dispose", o), delete r[m.id];
    const v = s.get(m);
    v && (e.remove(v), s.delete(m)), i.releaseStatesOfGeometry(m), m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount, t.memory.geometries--;
  }
  function a(p, m) {
    return r[m.id] === !0 || (m.addEventListener("dispose", o), r[m.id] = !0, t.memory.geometries++), m;
  }
  function l(p) {
    const m = p.attributes;
    for (const b in m)
      e.update(m[b], 34962);
    const v = p.morphAttributes;
    for (const b in v) {
      const x = v[b];
      for (let y = 0, S = x.length; y < S; y++)
        e.update(x[y], 34962);
    }
  }
  function c(p) {
    const m = [], v = p.index, b = p.attributes.position;
    let x = 0;
    if (v !== null) {
      const C = v.array;
      x = v.version;
      for (let M = 0, T = C.length; M < T; M += 3) {
        const P = C[M + 0], D = C[M + 1], I = C[M + 2];
        m.push(P, D, D, I, I, P);
      }
    } else {
      const C = b.array;
      x = b.version;
      for (let M = 0, T = C.length / 3 - 1; M < T; M += 3) {
        const P = M + 0, D = M + 1, I = M + 2;
        m.push(P, D, D, I, I, P);
      }
    }
    const y = new (YL(m) ? nD : tD)(m, 1);
    y.version = x;
    const S = s.get(p);
    S && e.remove(S), s.set(p, y);
  }
  function d(p) {
    const m = s.get(p);
    if (m) {
      const v = p.index;
      v !== null && m.version < v.version && c(p);
    } else
      c(p);
    return s.get(p);
  }
  return {
    get: a,
    update: l,
    getWireframeAttribute: d
  };
}
function KG(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(m) {
    s = m;
  }
  let a, l;
  function c(m) {
    a = m.type, l = m.bytesPerElement;
  }
  function d(m, v) {
    n.drawElements(s, v, a, m * l), t.update(v, s, 1);
  }
  function p(m, v, b) {
    if (b === 0)
      return;
    let x, y;
    if (r)
      x = n, y = "drawElementsInstanced";
    else if (x = e.get("ANGLE_instanced_arrays"), y = "drawElementsInstancedANGLE", x === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    x[y](s, v, a, m * l, b), t.update(v, s, b);
  }
  this.setMode = o, this.setIndex = c, this.render = d, this.renderInstances = p;
}
function JG(n) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(s, o, a) {
    switch (t.calls++, o) {
      case 4:
        t.triangles += a * (s / 3);
        break;
      case 1:
        t.lines += a * (s / 2);
        break;
      case 3:
        t.lines += a * (s - 1);
        break;
      case 2:
        t.lines += a * s;
        break;
      case 0:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i
  };
}
function QG(n, e) {
  return n[0] - e[0];
}
function eW(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function tW(n, e, t) {
  const i = {}, r = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), o = new gn(), a = [];
  for (let c = 0; c < 8; c++)
    a[c] = [c, 0];
  function l(c, d, p, m) {
    const v = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const b = d.morphAttributes.position || d.morphAttributes.normal || d.morphAttributes.color, x = b !== void 0 ? b.length : 0;
      let y = s.get(d);
      if (y === void 0 || y.count !== x) {
        let J = function() {
          K.dispose(), s.delete(d), d.removeEventListener("dispose", J);
        };
        y !== void 0 && y.texture.dispose();
        const M = d.morphAttributes.position !== void 0, T = d.morphAttributes.normal !== void 0, P = d.morphAttributes.color !== void 0, D = d.morphAttributes.position || [], I = d.morphAttributes.normal || [], k = d.morphAttributes.color || [];
        let O = 0;
        M === !0 && (O = 1), T === !0 && (O = 2), P === !0 && (O = 3);
        let B = d.attributes.position.count * O, Y = 1;
        B > e.maxTextureSize && (Y = Math.ceil(B / e.maxTextureSize), B = e.maxTextureSize);
        const G = new Float32Array(B * Y * 4 * x), K = new eD(G, B, Y, x);
        K.type = Qs, K.needsUpdate = !0;
        const A = O * 4;
        for (let xe = 0; xe < x; xe++) {
          const se = D[xe], oe = I[xe], Q = k[xe], ce = B * Y * 4 * xe;
          for (let te = 0; te < se.count; te++) {
            const ee = te * A;
            M === !0 && (o.fromBufferAttribute(se, te), G[ce + ee + 0] = o.x, G[ce + ee + 1] = o.y, G[ce + ee + 2] = o.z, G[ce + ee + 3] = 0), T === !0 && (o.fromBufferAttribute(oe, te), G[ce + ee + 4] = o.x, G[ce + ee + 5] = o.y, G[ce + ee + 6] = o.z, G[ce + ee + 7] = 0), P === !0 && (o.fromBufferAttribute(Q, te), G[ce + ee + 8] = o.x, G[ce + ee + 9] = o.y, G[ce + ee + 10] = o.z, G[ce + ee + 11] = Q.itemSize === 4 ? o.w : 1);
          }
        }
        y = {
          count: x,
          texture: K,
          size: new ze(B, Y)
        }, s.set(d, y), d.addEventListener("dispose", J);
      }
      let S = 0;
      for (let M = 0; M < v.length; M++)
        S += v[M];
      const C = d.morphTargetsRelative ? 1 : 1 - S;
      m.getUniforms().setValue(n, "morphTargetBaseInfluence", C), m.getUniforms().setValue(n, "morphTargetInfluences", v), m.getUniforms().setValue(n, "morphTargetsTexture", y.texture, t), m.getUniforms().setValue(n, "morphTargetsTextureSize", y.size);
    } else {
      const b = v === void 0 ? 0 : v.length;
      let x = i[d.id];
      if (x === void 0 || x.length !== b) {
        x = [];
        for (let T = 0; T < b; T++)
          x[T] = [T, 0];
        i[d.id] = x;
      }
      for (let T = 0; T < b; T++) {
        const P = x[T];
        P[0] = T, P[1] = v[T];
      }
      x.sort(eW);
      for (let T = 0; T < 8; T++)
        T < b && x[T][1] ? (a[T][0] = x[T][0], a[T][1] = x[T][1]) : (a[T][0] = Number.MAX_SAFE_INTEGER, a[T][1] = 0);
      a.sort(QG);
      const y = d.morphAttributes.position, S = d.morphAttributes.normal;
      let C = 0;
      for (let T = 0; T < 8; T++) {
        const P = a[T], D = P[0], I = P[1];
        D !== Number.MAX_SAFE_INTEGER && I ? (y && d.getAttribute("morphTarget" + T) !== y[D] && d.setAttribute("morphTarget" + T, y[D]), S && d.getAttribute("morphNormal" + T) !== S[D] && d.setAttribute("morphNormal" + T, S[D]), r[T] = I, C += I) : (y && d.hasAttribute("morphTarget" + T) === !0 && d.deleteAttribute("morphTarget" + T), S && d.hasAttribute("morphNormal" + T) === !0 && d.deleteAttribute("morphNormal" + T), r[T] = 0);
      }
      const M = d.morphTargetsRelative ? 1 : 1 - C;
      m.getUniforms().setValue(n, "morphTargetBaseInfluence", M), m.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return {
    update: l
  };
}
function nW(n, e, t, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(l) {
    const c = i.render.frame, d = l.geometry, p = e.get(l, d);
    return r.get(p) !== c && (e.update(p), r.set(p, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), p;
  }
  function o() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return {
    update: s,
    dispose: o
  };
}
const oD = /* @__PURE__ */ new Wi(), aD = /* @__PURE__ */ new eD(), lD = /* @__PURE__ */ new q9(), cD = /* @__PURE__ */ new cE(), MP = [], EP = [], CP = new Float32Array(16), TP = new Float32Array(9), PP = new Float32Array(4);
function zf(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0)
    return n;
  const r = e * t;
  let s = MP[r];
  if (s === void 0 && (s = new Float32Array(r), MP[r] = s), e !== 0) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o)
      a += t, n[o].toArray(s, a);
  }
  return s;
}
function Kr(n, e) {
  if (n.length !== e.length)
    return !1;
  for (let t = 0, i = n.length; t < i; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
function Jr(n, e) {
  for (let t = 0, i = e.length; t < i; t++)
    n[t] = e[t];
}
function yy(n, e) {
  let t = EP[e];
  t === void 0 && (t = new Int32Array(e), EP[e] = t);
  for (let i = 0; i !== e; ++i)
    t[i] = n.allocateTextureUnit();
  return t;
}
function iW(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e);
}
function rW(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Kr(t, e))
      return;
    n.uniform2fv(this.addr, e), Jr(t, e);
  }
}
function sW(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Kr(t, e))
      return;
    n.uniform3fv(this.addr, e), Jr(t, e);
  }
}
function oW(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Kr(t, e))
      return;
    n.uniform4fv(this.addr, e), Jr(t, e);
  }
}
function aW(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (Kr(t, e))
      return;
    n.uniformMatrix2fv(this.addr, !1, e), Jr(t, e);
  } else {
    if (Kr(t, i))
      return;
    PP.set(i), n.uniformMatrix2fv(this.addr, !1, PP), Jr(t, i);
  }
}
function lW(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (Kr(t, e))
      return;
    n.uniformMatrix3fv(this.addr, !1, e), Jr(t, e);
  } else {
    if (Kr(t, i))
      return;
    TP.set(i), n.uniformMatrix3fv(this.addr, !1, TP), Jr(t, i);
  }
}
function cW(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (Kr(t, e))
      return;
    n.uniformMatrix4fv(this.addr, !1, e), Jr(t, e);
  } else {
    if (Kr(t, i))
      return;
    CP.set(i), n.uniformMatrix4fv(this.addr, !1, CP), Jr(t, i);
  }
}
function uW(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e);
}
function hW(n, e) {
  const t = this.cache;
  Kr(t, e) || (n.uniform2iv(this.addr, e), Jr(t, e));
}
function dW(n, e) {
  const t = this.cache;
  Kr(t, e) || (n.uniform3iv(this.addr, e), Jr(t, e));
}
function fW(n, e) {
  const t = this.cache;
  Kr(t, e) || (n.uniform4iv(this.addr, e), Jr(t, e));
}
function pW(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e);
}
function mW(n, e) {
  const t = this.cache;
  Kr(t, e) || (n.uniform2uiv(this.addr, e), Jr(t, e));
}
function vW(n, e) {
  const t = this.cache;
  Kr(t, e) || (n.uniform3uiv(this.addr, e), Jr(t, e));
}
function gW(n, e) {
  const t = this.cache;
  Kr(t, e) || (n.uniform4uiv(this.addr, e), Jr(t, e));
}
function _W(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2D(e || oD, r);
}
function bW(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || lD, r);
}
function yW(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || cD, r);
}
function xW(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || aD, r);
}
function wW(n) {
  switch (n) {
    case 5126:
      return iW;
    case 35664:
      return rW;
    case 35665:
      return sW;
    case 35666:
      return oW;
    case 35674:
      return aW;
    case 35675:
      return lW;
    case 35676:
      return cW;
    case 5124:
    case 35670:
      return uW;
    case 35667:
    case 35671:
      return hW;
    case 35668:
    case 35672:
      return dW;
    case 35669:
    case 35673:
      return fW;
    case 5125:
      return pW;
    case 36294:
      return mW;
    case 36295:
      return vW;
    case 36296:
      return gW;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return _W;
    case 35679:
    case 36299:
    case 36307:
      return bW;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return yW;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return xW;
  }
}
function SW(n, e) {
  n.uniform1fv(this.addr, e);
}
function MW(n, e) {
  const t = zf(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function EW(n, e) {
  const t = zf(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function CW(n, e) {
  const t = zf(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function TW(n, e) {
  const t = zf(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function PW(n, e) {
  const t = zf(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function AW(n, e) {
  const t = zf(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function RW(n, e) {
  n.uniform1iv(this.addr, e);
}
function kW(n, e) {
  n.uniform2iv(this.addr, e);
}
function LW(n, e) {
  n.uniform3iv(this.addr, e);
}
function DW(n, e) {
  n.uniform4iv(this.addr, e);
}
function IW(n, e) {
  n.uniform1uiv(this.addr, e);
}
function OW(n, e) {
  n.uniform2uiv(this.addr, e);
}
function NW(n, e) {
  n.uniform3uiv(this.addr, e);
}
function zW(n, e) {
  n.uniform4uiv(this.addr, e);
}
function FW(n, e, t) {
  const i = e.length, r = yy(t, i);
  n.uniform1iv(this.addr, r);
  for (let s = 0; s !== i; ++s)
    t.setTexture2D(e[s] || oD, r[s]);
}
function BW(n, e, t) {
  const i = e.length, r = yy(t, i);
  n.uniform1iv(this.addr, r);
  for (let s = 0; s !== i; ++s)
    t.setTexture3D(e[s] || lD, r[s]);
}
function UW(n, e, t) {
  const i = e.length, r = yy(t, i);
  n.uniform1iv(this.addr, r);
  for (let s = 0; s !== i; ++s)
    t.setTextureCube(e[s] || cD, r[s]);
}
function VW(n, e, t) {
  const i = e.length, r = yy(t, i);
  n.uniform1iv(this.addr, r);
  for (let s = 0; s !== i; ++s)
    t.setTexture2DArray(e[s] || aD, r[s]);
}
function HW(n) {
  switch (n) {
    case 5126:
      return SW;
    case 35664:
      return MW;
    case 35665:
      return EW;
    case 35666:
      return CW;
    case 35674:
      return TW;
    case 35675:
      return PW;
    case 35676:
      return AW;
    case 5124:
    case 35670:
      return RW;
    case 35667:
    case 35671:
      return kW;
    case 35668:
    case 35672:
      return LW;
    case 35669:
    case 35673:
      return DW;
    case 5125:
      return IW;
    case 36294:
      return OW;
    case 36295:
      return NW;
    case 36296:
      return zW;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return FW;
    case 35679:
    case 36299:
    case 36307:
      return BW;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return UW;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return VW;
  }
}
class GW {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.setValue = wW(t.type);
  }
}
class WW {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = HW(t.type);
  }
}
class jW {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const B1 = /(\w+)(\])?(\[|\.)?/g;
function AP(n, e) {
  n.seq.push(e), n.map[e.id] = e;
}
function qW(n, e, t) {
  const i = n.name, r = i.length;
  for (B1.lastIndex = 0; ; ) {
    const s = B1.exec(i), o = B1.lastIndex;
    let a = s[1];
    const l = s[2] === "]", c = s[3];
    if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === r) {
      AP(t, c === void 0 ? new GW(a, n, e) : new WW(a, n, e));
      break;
    } else {
      let p = t.map[a];
      p === void 0 && (p = new jW(a), AP(t, p)), t = p;
    }
  }
}
class G_ {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, 35718);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r), o = e.getUniformLocation(t, s.name);
      qW(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s], l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function RP(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
let XW = 0;
function $W(n, e) {
  const t = n.split(`
`), i = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function ZW(n) {
  switch (n) {
    case Ro:
      return ["Linear", "( value )"];
    case Tt:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", n), ["Linear", "( value )"];
  }
}
function kP(n, e, t) {
  const i = n.getShaderParameter(e, 35713), r = n.getShaderInfoLog(e).trim();
  if (i && r === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return t.toUpperCase() + `

` + r + `

` + $W(n.getShaderSource(e), o);
  } else
    return r;
}
function YW(n, e) {
  const t = ZW(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function KW(n, e) {
  let t;
  switch (e) {
    case u9:
      t = "Linear";
      break;
    case h9:
      t = "Reinhard";
      break;
    case d9:
      t = "OptimizedCineon";
      break;
    case GL:
      t = "ACESFilmic";
      break;
    case f9:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function JW(n) {
  return [
    n.extensionDerivatives || !!n.envMapCubeUVHeight || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(ym).join(`
`);
}
function QW(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function ej(n, e) {
  const t = {}, i = n.getProgramParameter(e, 35721);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r), o = s.name;
    let a = 1;
    s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), t[o] = {
      type: s.type,
      location: n.getAttribLocation(e, o),
      locationSize: a
    };
  }
  return t;
}
function ym(n) {
  return n !== "";
}
function LP(n, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function DP(n, e) {
  return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const tj = /^[ \t]*#include +<([\w\d./]+)>/gm;
function _2(n) {
  return n.replace(tj, nj);
}
function nj(n, e) {
  const t = Nt[e];
  if (t === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return _2(t);
}
const ij = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function IP(n) {
  return n.replace(ij, rj);
}
function rj(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function OP(n) {
  let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
  return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function sj(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return n.shadowMapType === IL ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === OL ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === bm && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function oj(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case vf:
      case gf:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case py:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function aj(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case gf:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function lj(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case HL:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case l9:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case c9:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function cj(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function uj(n, e, t, i) {
  const r = n.getContext(), s = t.defines;
  let o = t.vertexShader, a = t.fragmentShader;
  const l = sj(t), c = oj(t), d = aj(t), p = lj(t), m = cj(t), v = t.isWebGL2 ? "" : JW(t), b = QW(s), x = r.createProgram();
  let y, S, C = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (y = [
    b
  ].filter(ym).join(`
`), y.length > 0 && (y += `
`), S = [
    v,
    b
  ].filter(ym).join(`
`), S.length > 0 && (S += `
`)) : (y = [
    OP(t),
    "#define SHADER_NAME " + t.shaderName,
    b,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + d : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(ym).join(`
`), S = [
    v,
    OP(t),
    "#define SHADER_NAME " + t.shaderName,
    b,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + d : "",
    t.envMap ? "#define " + p : "",
    m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
    m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
    m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== dl ? "#define TONE_MAPPING" : "",
    t.toneMapping !== dl ? Nt.tonemapping_pars_fragment : "",
    t.toneMapping !== dl ? KW("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Nt.encodings_pars_fragment,
    YW("linearToOutputTexel", t.outputEncoding),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(ym).join(`
`)), o = _2(o), o = LP(o, t), o = DP(o, t), a = _2(a), a = LP(a, t), a = DP(a, t), o = IP(o), a = IP(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (C = `#version 300 es
`, y = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + y, S = [
    "#define varying in",
    t.glslVersion === p2 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === p2 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + S);
  const M = C + y + o, T = C + S + a, P = RP(r, 35633, M), D = RP(r, 35632, T);
  if (r.attachShader(x, P), r.attachShader(x, D), t.index0AttributeName !== void 0 ? r.bindAttribLocation(x, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(x, 0, "position"), r.linkProgram(x), n.debug.checkShaderErrors) {
    const O = r.getProgramInfoLog(x).trim(), B = r.getShaderInfoLog(P).trim(), Y = r.getShaderInfoLog(D).trim();
    let G = !0, K = !0;
    if (r.getProgramParameter(x, 35714) === !1) {
      G = !1;
      const A = kP(r, P, "vertex"), J = kP(r, D, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(x, 35715) + `

Program Info Log: ` + O + `
` + A + `
` + J
      );
    } else
      O !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", O) : (B === "" || Y === "") && (K = !1);
    K && (this.diagnostics = {
      runnable: G,
      programLog: O,
      vertexShader: {
        log: B,
        prefix: y
      },
      fragmentShader: {
        log: Y,
        prefix: S
      }
    });
  }
  r.deleteShader(P), r.deleteShader(D);
  let I;
  this.getUniforms = function() {
    return I === void 0 && (I = new G_(r, x)), I;
  };
  let k;
  return this.getAttributes = function() {
    return k === void 0 && (k = ej(r, x)), k;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(x), this.program = void 0;
  }, this.name = t.shaderName, this.id = XW++, this.cacheKey = e, this.usedTimes = 1, this.program = x, this.vertexShader = P, this.fragmentShader = D, this;
}
let hj = 0;
class dj {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(i), o = this._getShaderCacheForMaterial(e);
    return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new fj(e), t.set(e, i)), i;
  }
}
class fj {
  constructor(e) {
    this.id = hj++, this.code = e, this.usedTimes = 0;
  }
}
function pj(n, e, t, i, r, s, o) {
  const a = new lE(), l = new dj(), c = [], d = r.isWebGL2, p = r.logarithmicDepthBuffer, m = r.vertexTextures;
  let v = r.precision;
  const b = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function x(k, O, B, Y, G) {
    const K = Y.fog, A = G.geometry, J = k.isMeshStandardMaterial ? Y.environment : null, xe = (k.isMeshStandardMaterial ? t : e).get(k.envMap || J), se = !!xe && xe.mapping === py ? xe.image.height : null, oe = b[k.type];
    k.precision !== null && (v = r.getMaxPrecision(k.precision), v !== k.precision && console.warn("THREE.WebGLProgram.getParameters:", k.precision, "not supported, using", v, "instead."));
    const Q = A.morphAttributes.position || A.morphAttributes.normal || A.morphAttributes.color, ce = Q !== void 0 ? Q.length : 0;
    let te = 0;
    A.morphAttributes.position !== void 0 && (te = 1), A.morphAttributes.normal !== void 0 && (te = 2), A.morphAttributes.color !== void 0 && (te = 3);
    let ee, Re, ye, Se;
    if (oe) {
      const st = ms[oe];
      ee = st.vertexShader, Re = st.fragmentShader;
    } else
      ee = k.vertexShader, Re = k.fragmentShader, l.update(k), ye = l.getVertexShaderID(k), Se = l.getFragmentShaderID(k);
    const Ee = n.getRenderTarget(), gt = k.alphaTest > 0, qe = k.clearcoat > 0, Ze = k.iridescence > 0;
    return {
      isWebGL2: d,
      shaderID: oe,
      shaderName: k.type,
      vertexShader: ee,
      fragmentShader: Re,
      defines: k.defines,
      customVertexShaderID: ye,
      customFragmentShaderID: Se,
      isRawShaderMaterial: k.isRawShaderMaterial === !0,
      glslVersion: k.glslVersion,
      precision: v,
      instancing: G.isInstancedMesh === !0,
      instancingColor: G.isInstancedMesh === !0 && G.instanceColor !== null,
      supportsVertexTextures: m,
      outputEncoding: Ee === null ? n.outputEncoding : Ee.isXRRenderTarget === !0 ? Ee.texture.encoding : Ro,
      map: !!k.map,
      matcap: !!k.matcap,
      envMap: !!xe,
      envMapMode: xe && xe.mapping,
      envMapCubeUVHeight: se,
      lightMap: !!k.lightMap,
      aoMap: !!k.aoMap,
      emissiveMap: !!k.emissiveMap,
      bumpMap: !!k.bumpMap,
      normalMap: !!k.normalMap,
      objectSpaceNormalMap: k.normalMapType === R9,
      tangentSpaceNormalMap: k.normalMapType === my,
      decodeVideoTexture: !!k.map && k.map.isVideoTexture === !0 && k.map.encoding === Tt,
      clearcoat: qe,
      clearcoatMap: qe && !!k.clearcoatMap,
      clearcoatRoughnessMap: qe && !!k.clearcoatRoughnessMap,
      clearcoatNormalMap: qe && !!k.clearcoatNormalMap,
      iridescence: Ze,
      iridescenceMap: Ze && !!k.iridescenceMap,
      iridescenceThicknessMap: Ze && !!k.iridescenceThicknessMap,
      displacementMap: !!k.displacementMap,
      roughnessMap: !!k.roughnessMap,
      metalnessMap: !!k.metalnessMap,
      specularMap: !!k.specularMap,
      specularIntensityMap: !!k.specularIntensityMap,
      specularColorMap: !!k.specularColorMap,
      opaque: k.transparent === !1 && k.blending === Nd,
      alphaMap: !!k.alphaMap,
      alphaTest: gt,
      gradientMap: !!k.gradientMap,
      sheen: k.sheen > 0,
      sheenColorMap: !!k.sheenColorMap,
      sheenRoughnessMap: !!k.sheenRoughnessMap,
      transmission: k.transmission > 0,
      transmissionMap: !!k.transmissionMap,
      thicknessMap: !!k.thicknessMap,
      combine: k.combine,
      vertexTangents: !!k.normalMap && !!A.attributes.tangent,
      vertexColors: k.vertexColors,
      vertexAlphas: k.vertexColors === !0 && !!A.attributes.color && A.attributes.color.itemSize === 4,
      vertexUvs: !!k.map || !!k.bumpMap || !!k.normalMap || !!k.specularMap || !!k.alphaMap || !!k.emissiveMap || !!k.roughnessMap || !!k.metalnessMap || !!k.clearcoatMap || !!k.clearcoatRoughnessMap || !!k.clearcoatNormalMap || !!k.iridescenceMap || !!k.iridescenceThicknessMap || !!k.displacementMap || !!k.transmissionMap || !!k.thicknessMap || !!k.specularIntensityMap || !!k.specularColorMap || !!k.sheenColorMap || !!k.sheenRoughnessMap,
      uvsVertexOnly: !(!!k.map || !!k.bumpMap || !!k.normalMap || !!k.specularMap || !!k.alphaMap || !!k.emissiveMap || !!k.roughnessMap || !!k.metalnessMap || !!k.clearcoatNormalMap || !!k.iridescenceMap || !!k.iridescenceThicknessMap || k.transmission > 0 || !!k.transmissionMap || !!k.thicknessMap || !!k.specularIntensityMap || !!k.specularColorMap || k.sheen > 0 || !!k.sheenColorMap || !!k.sheenRoughnessMap) && !!k.displacementMap,
      fog: !!K,
      useFog: k.fog === !0,
      fogExp2: K && K.isFogExp2,
      flatShading: !!k.flatShading,
      sizeAttenuation: k.sizeAttenuation,
      logarithmicDepthBuffer: p,
      skinning: G.isSkinnedMesh === !0,
      morphTargets: A.morphAttributes.position !== void 0,
      morphNormals: A.morphAttributes.normal !== void 0,
      morphColors: A.morphAttributes.color !== void 0,
      morphTargetsCount: ce,
      morphTextureStride: te,
      numDirLights: O.directional.length,
      numPointLights: O.point.length,
      numSpotLights: O.spot.length,
      numSpotLightMaps: O.spotLightMap.length,
      numRectAreaLights: O.rectArea.length,
      numHemiLights: O.hemi.length,
      numDirLightShadows: O.directionalShadowMap.length,
      numPointLightShadows: O.pointShadowMap.length,
      numSpotLightShadows: O.spotShadowMap.length,
      numSpotLightShadowsWithMaps: O.numSpotLightShadowsWithMaps,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: k.dithering,
      shadowMapEnabled: n.shadowMap.enabled && B.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: k.toneMapped ? n.toneMapping : dl,
      physicallyCorrectLights: n.physicallyCorrectLights,
      premultipliedAlpha: k.premultipliedAlpha,
      doubleSided: k.side === Js,
      flipSided: k.side === cr,
      useDepthPacking: !!k.depthPacking,
      depthPacking: k.depthPacking || 0,
      index0AttributeName: k.index0AttributeName,
      extensionDerivatives: k.extensions && k.extensions.derivatives,
      extensionFragDepth: k.extensions && k.extensions.fragDepth,
      extensionDrawBuffers: k.extensions && k.extensions.drawBuffers,
      extensionShaderTextureLOD: k.extensions && k.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: k.customProgramCacheKey()
    };
  }
  function y(k) {
    const O = [];
    if (k.shaderID ? O.push(k.shaderID) : (O.push(k.customVertexShaderID), O.push(k.customFragmentShaderID)), k.defines !== void 0)
      for (const B in k.defines)
        O.push(B), O.push(k.defines[B]);
    return k.isRawShaderMaterial === !1 && (S(O, k), C(O, k), O.push(n.outputEncoding)), O.push(k.customProgramCacheKey), O.join();
  }
  function S(k, O) {
    k.push(O.precision), k.push(O.outputEncoding), k.push(O.envMapMode), k.push(O.envMapCubeUVHeight), k.push(O.combine), k.push(O.vertexUvs), k.push(O.fogExp2), k.push(O.sizeAttenuation), k.push(O.morphTargetsCount), k.push(O.morphAttributeCount), k.push(O.numDirLights), k.push(O.numPointLights), k.push(O.numSpotLights), k.push(O.numSpotLightMaps), k.push(O.numHemiLights), k.push(O.numRectAreaLights), k.push(O.numDirLightShadows), k.push(O.numPointLightShadows), k.push(O.numSpotLightShadows), k.push(O.numSpotLightShadowsWithMaps), k.push(O.shadowMapType), k.push(O.toneMapping), k.push(O.numClippingPlanes), k.push(O.numClipIntersection), k.push(O.depthPacking);
  }
  function C(k, O) {
    a.disableAll(), O.isWebGL2 && a.enable(0), O.supportsVertexTextures && a.enable(1), O.instancing && a.enable(2), O.instancingColor && a.enable(3), O.map && a.enable(4), O.matcap && a.enable(5), O.envMap && a.enable(6), O.lightMap && a.enable(7), O.aoMap && a.enable(8), O.emissiveMap && a.enable(9), O.bumpMap && a.enable(10), O.normalMap && a.enable(11), O.objectSpaceNormalMap && a.enable(12), O.tangentSpaceNormalMap && a.enable(13), O.clearcoat && a.enable(14), O.clearcoatMap && a.enable(15), O.clearcoatRoughnessMap && a.enable(16), O.clearcoatNormalMap && a.enable(17), O.iridescence && a.enable(18), O.iridescenceMap && a.enable(19), O.iridescenceThicknessMap && a.enable(20), O.displacementMap && a.enable(21), O.specularMap && a.enable(22), O.roughnessMap && a.enable(23), O.metalnessMap && a.enable(24), O.gradientMap && a.enable(25), O.alphaMap && a.enable(26), O.alphaTest && a.enable(27), O.vertexColors && a.enable(28), O.vertexAlphas && a.enable(29), O.vertexUvs && a.enable(30), O.vertexTangents && a.enable(31), O.uvsVertexOnly && a.enable(32), k.push(a.mask), a.disableAll(), O.fog && a.enable(0), O.useFog && a.enable(1), O.flatShading && a.enable(2), O.logarithmicDepthBuffer && a.enable(3), O.skinning && a.enable(4), O.morphTargets && a.enable(5), O.morphNormals && a.enable(6), O.morphColors && a.enable(7), O.premultipliedAlpha && a.enable(8), O.shadowMapEnabled && a.enable(9), O.physicallyCorrectLights && a.enable(10), O.doubleSided && a.enable(11), O.flipSided && a.enable(12), O.useDepthPacking && a.enable(13), O.dithering && a.enable(14), O.specularIntensityMap && a.enable(15), O.specularColorMap && a.enable(16), O.transmission && a.enable(17), O.transmissionMap && a.enable(18), O.thicknessMap && a.enable(19), O.sheen && a.enable(20), O.sheenColorMap && a.enable(21), O.sheenRoughnessMap && a.enable(22), O.decodeVideoTexture && a.enable(23), O.opaque && a.enable(24), k.push(a.mask);
  }
  function M(k) {
    const O = b[k.type];
    let B;
    if (O) {
      const Y = ms[O];
      B = gy.clone(Y.uniforms);
    } else
      B = k.uniforms;
    return B;
  }
  function T(k, O) {
    let B;
    for (let Y = 0, G = c.length; Y < G; Y++) {
      const K = c[Y];
      if (K.cacheKey === O) {
        B = K, ++B.usedTimes;
        break;
      }
    }
    return B === void 0 && (B = new uj(n, O, k, s), c.push(B)), B;
  }
  function P(k) {
    if (--k.usedTimes === 0) {
      const O = c.indexOf(k);
      c[O] = c[c.length - 1], c.pop(), k.destroy();
    }
  }
  function D(k) {
    l.remove(k);
  }
  function I() {
    l.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: y,
    getUniforms: M,
    acquireProgram: T,
    releaseProgram: P,
    releaseShaderCache: D,
    programs: c,
    dispose: I
  };
}
function mj() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && (o = {}, n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function i(s, o, a) {
    n.get(s)[o] = a;
  }
  function r() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: i,
    dispose: r
  };
}
function vj(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id;
}
function NP(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id;
}
function zP() {
  const n = [];
  let e = 0;
  const t = [], i = [], r = [];
  function s() {
    e = 0, t.length = 0, i.length = 0, r.length = 0;
  }
  function o(p, m, v, b, x, y) {
    let S = n[e];
    return S === void 0 ? (S = {
      id: p.id,
      object: p,
      geometry: m,
      material: v,
      groupOrder: b,
      renderOrder: p.renderOrder,
      z: x,
      group: y
    }, n[e] = S) : (S.id = p.id, S.object = p, S.geometry = m, S.material = v, S.groupOrder = b, S.renderOrder = p.renderOrder, S.z = x, S.group = y), e++, S;
  }
  function a(p, m, v, b, x, y) {
    const S = o(p, m, v, b, x, y);
    v.transmission > 0 ? i.push(S) : v.transparent === !0 ? r.push(S) : t.push(S);
  }
  function l(p, m, v, b, x, y) {
    const S = o(p, m, v, b, x, y);
    v.transmission > 0 ? i.unshift(S) : v.transparent === !0 ? r.unshift(S) : t.unshift(S);
  }
  function c(p, m) {
    t.length > 1 && t.sort(p || vj), i.length > 1 && i.sort(m || NP), r.length > 1 && r.sort(m || NP);
  }
  function d() {
    for (let p = e, m = n.length; p < m; p++) {
      const v = n[p];
      if (v.id === null)
        break;
      v.id = null, v.object = null, v.geometry = null, v.material = null, v.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: d,
    sort: c
  };
}
function gj() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return s === void 0 ? (o = new zP(), n.set(i, [o])) : r >= s.length ? (o = new zP(), s.push(o)) : o = s[r], o;
  }
  function t() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function _j() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new Z(),
            color: new xt()
          };
          break;
        case "SpotLight":
          t = {
            position: new Z(),
            direction: new Z(),
            color: new xt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new Z(),
            color: new xt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new Z(),
            skyColor: new xt(),
            groundColor: new xt()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new xt(),
            position: new Z(),
            halfWidth: new Z(),
            halfHeight: new Z()
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
function bj() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ze()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ze()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ze(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
let yj = 0;
function xj(n, e) {
  return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
}
function wj(n, e) {
  const t = new _j(), i = bj(), r = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let d = 0; d < 9; d++)
    r.probe.push(new Z());
  const s = new Z(), o = new Pt(), a = new Pt();
  function l(d, p) {
    let m = 0, v = 0, b = 0;
    for (let Y = 0; Y < 9; Y++)
      r.probe[Y].set(0, 0, 0);
    let x = 0, y = 0, S = 0, C = 0, M = 0, T = 0, P = 0, D = 0, I = 0, k = 0;
    d.sort(xj);
    const O = p !== !0 ? Math.PI : 1;
    for (let Y = 0, G = d.length; Y < G; Y++) {
      const K = d[Y], A = K.color, J = K.intensity, xe = K.distance, se = K.shadow && K.shadow.map ? K.shadow.map.texture : null;
      if (K.isAmbientLight)
        m += A.r * J * O, v += A.g * J * O, b += A.b * J * O;
      else if (K.isLightProbe)
        for (let oe = 0; oe < 9; oe++)
          r.probe[oe].addScaledVector(K.sh.coefficients[oe], J);
      else if (K.isDirectionalLight) {
        const oe = t.get(K);
        if (oe.color.copy(K.color).multiplyScalar(K.intensity * O), K.castShadow) {
          const Q = K.shadow, ce = i.get(K);
          ce.shadowBias = Q.bias, ce.shadowNormalBias = Q.normalBias, ce.shadowRadius = Q.radius, ce.shadowMapSize = Q.mapSize, r.directionalShadow[x] = ce, r.directionalShadowMap[x] = se, r.directionalShadowMatrix[x] = K.shadow.matrix, T++;
        }
        r.directional[x] = oe, x++;
      } else if (K.isSpotLight) {
        const oe = t.get(K);
        oe.position.setFromMatrixPosition(K.matrixWorld), oe.color.copy(A).multiplyScalar(J * O), oe.distance = xe, oe.coneCos = Math.cos(K.angle), oe.penumbraCos = Math.cos(K.angle * (1 - K.penumbra)), oe.decay = K.decay, r.spot[S] = oe;
        const Q = K.shadow;
        if (K.map && (r.spotLightMap[I] = K.map, I++, Q.updateMatrices(K), K.castShadow && k++), r.spotLightMatrix[S] = Q.matrix, K.castShadow) {
          const ce = i.get(K);
          ce.shadowBias = Q.bias, ce.shadowNormalBias = Q.normalBias, ce.shadowRadius = Q.radius, ce.shadowMapSize = Q.mapSize, r.spotShadow[S] = ce, r.spotShadowMap[S] = se, D++;
        }
        S++;
      } else if (K.isRectAreaLight) {
        const oe = t.get(K);
        oe.color.copy(A).multiplyScalar(J), oe.halfWidth.set(K.width * 0.5, 0, 0), oe.halfHeight.set(0, K.height * 0.5, 0), r.rectArea[C] = oe, C++;
      } else if (K.isPointLight) {
        const oe = t.get(K);
        if (oe.color.copy(K.color).multiplyScalar(K.intensity * O), oe.distance = K.distance, oe.decay = K.decay, K.castShadow) {
          const Q = K.shadow, ce = i.get(K);
          ce.shadowBias = Q.bias, ce.shadowNormalBias = Q.normalBias, ce.shadowRadius = Q.radius, ce.shadowMapSize = Q.mapSize, ce.shadowCameraNear = Q.camera.near, ce.shadowCameraFar = Q.camera.far, r.pointShadow[y] = ce, r.pointShadowMap[y] = se, r.pointShadowMatrix[y] = K.shadow.matrix, P++;
        }
        r.point[y] = oe, y++;
      } else if (K.isHemisphereLight) {
        const oe = t.get(K);
        oe.skyColor.copy(K.color).multiplyScalar(J * O), oe.groundColor.copy(K.groundColor).multiplyScalar(J * O), r.hemi[M] = oe, M++;
      }
    }
    C > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ke.LTC_FLOAT_1, r.rectAreaLTC2 = Ke.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Ke.LTC_HALF_1, r.rectAreaLTC2 = Ke.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = m, r.ambient[1] = v, r.ambient[2] = b;
    const B = r.hash;
    (B.directionalLength !== x || B.pointLength !== y || B.spotLength !== S || B.rectAreaLength !== C || B.hemiLength !== M || B.numDirectionalShadows !== T || B.numPointShadows !== P || B.numSpotShadows !== D || B.numSpotMaps !== I) && (r.directional.length = x, r.spot.length = S, r.rectArea.length = C, r.point.length = y, r.hemi.length = M, r.directionalShadow.length = T, r.directionalShadowMap.length = T, r.pointShadow.length = P, r.pointShadowMap.length = P, r.spotShadow.length = D, r.spotShadowMap.length = D, r.directionalShadowMatrix.length = T, r.pointShadowMatrix.length = P, r.spotLightMatrix.length = D + I - k, r.spotLightMap.length = I, r.numSpotLightShadowsWithMaps = k, B.directionalLength = x, B.pointLength = y, B.spotLength = S, B.rectAreaLength = C, B.hemiLength = M, B.numDirectionalShadows = T, B.numPointShadows = P, B.numSpotShadows = D, B.numSpotMaps = I, r.version = yj++);
  }
  function c(d, p) {
    let m = 0, v = 0, b = 0, x = 0, y = 0;
    const S = p.matrixWorldInverse;
    for (let C = 0, M = d.length; C < M; C++) {
      const T = d[C];
      if (T.isDirectionalLight) {
        const P = r.directional[m];
        P.direction.setFromMatrixPosition(T.matrixWorld), s.setFromMatrixPosition(T.target.matrixWorld), P.direction.sub(s), P.direction.transformDirection(S), m++;
      } else if (T.isSpotLight) {
        const P = r.spot[b];
        P.position.setFromMatrixPosition(T.matrixWorld), P.position.applyMatrix4(S), P.direction.setFromMatrixPosition(T.matrixWorld), s.setFromMatrixPosition(T.target.matrixWorld), P.direction.sub(s), P.direction.transformDirection(S), b++;
      } else if (T.isRectAreaLight) {
        const P = r.rectArea[x];
        P.position.setFromMatrixPosition(T.matrixWorld), P.position.applyMatrix4(S), a.identity(), o.copy(T.matrixWorld), o.premultiply(S), a.extractRotation(o), P.halfWidth.set(T.width * 0.5, 0, 0), P.halfHeight.set(0, T.height * 0.5, 0), P.halfWidth.applyMatrix4(a), P.halfHeight.applyMatrix4(a), x++;
      } else if (T.isPointLight) {
        const P = r.point[v];
        P.position.setFromMatrixPosition(T.matrixWorld), P.position.applyMatrix4(S), v++;
      } else if (T.isHemisphereLight) {
        const P = r.hemi[y];
        P.direction.setFromMatrixPosition(T.matrixWorld), P.direction.transformDirection(S), y++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: r
  };
}
function FP(n, e) {
  const t = new wj(n, e), i = [], r = [];
  function s() {
    i.length = 0, r.length = 0;
  }
  function o(p) {
    i.push(p);
  }
  function a(p) {
    r.push(p);
  }
  function l(p) {
    t.setup(i, p);
  }
  function c(p) {
    t.setupView(i, p);
  }
  return {
    init: s,
    state: {
      lightsArray: i,
      shadowsArray: r,
      lights: t
    },
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a
  };
}
function Sj(n, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let l;
    return a === void 0 ? (l = new FP(n, e), t.set(s, [l])) : o >= a.length ? (l = new FP(n, e), a.push(l)) : l = a[o], l;
  }
  function r() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: r
  };
}
class uD extends zo {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = io, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Mj extends zo {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new Z(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const Ej = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Cj = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Tj(n, e, t) {
  let i = new by();
  const r = new ze(), s = new ze(), o = new gn(), a = new uD({ depthPacking: Xm }), l = new Mj(), c = {}, d = t.maxTextureSize, p = { 0: cr, 1: ju, 2: Js }, m = new Yn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ze() },
      radius: { value: 4 }
    },
    vertexShader: Ej,
    fragmentShader: Cj
  }), v = m.clone();
  v.defines.HORIZONTAL_PASS = 1;
  const b = new qn();
  b.setAttribute(
    "position",
    new Vi(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const x = new wi(b, m), y = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = IL, this.render = function(T, P, D) {
    if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || T.length === 0)
      return;
    const I = n.getRenderTarget(), k = n.getActiveCubeFace(), O = n.getActiveMipmapLevel(), B = n.state;
    B.setBlending(Si), B.buffers.color.setClear(1, 1, 1, 1), B.buffers.depth.setTest(!0), B.setScissorTest(!1);
    for (let Y = 0, G = T.length; Y < G; Y++) {
      const K = T[Y], A = K.shadow;
      if (A === void 0) {
        console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
        continue;
      }
      if (A.autoUpdate === !1 && A.needsUpdate === !1)
        continue;
      r.copy(A.mapSize);
      const J = A.getFrameExtents();
      if (r.multiply(J), s.copy(A.mapSize), (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / J.x), r.x = s.x * J.x, A.mapSize.x = s.x), r.y > d && (s.y = Math.floor(d / J.y), r.y = s.y * J.y, A.mapSize.y = s.y)), A.map === null) {
        const se = this.type !== bm ? { minFilter: kn, magFilter: kn } : {};
        A.map = new On(r.x, r.y, se), A.map.texture.name = K.name + ".shadowMap", A.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(A.map), n.clear();
      const xe = A.getViewportCount();
      for (let se = 0; se < xe; se++) {
        const oe = A.getViewport(se);
        o.set(
          s.x * oe.x,
          s.y * oe.y,
          s.x * oe.z,
          s.y * oe.w
        ), B.viewport(o), A.updateMatrices(K, se), i = A.getFrustum(), M(P, D, A.camera, K, this.type);
      }
      A.isPointLightShadow !== !0 && this.type === bm && S(A, D), A.needsUpdate = !1;
    }
    y.needsUpdate = !1, n.setRenderTarget(I, k, O);
  };
  function S(T, P) {
    const D = e.update(x);
    m.defines.VSM_SAMPLES !== T.blurSamples && (m.defines.VSM_SAMPLES = T.blurSamples, v.defines.VSM_SAMPLES = T.blurSamples, m.needsUpdate = !0, v.needsUpdate = !0), T.mapPass === null && (T.mapPass = new On(r.x, r.y)), m.uniforms.shadow_pass.value = T.map.texture, m.uniforms.resolution.value = T.mapSize, m.uniforms.radius.value = T.radius, n.setRenderTarget(T.mapPass), n.clear(), n.renderBufferDirect(P, null, D, m, x, null), v.uniforms.shadow_pass.value = T.mapPass.texture, v.uniforms.resolution.value = T.mapSize, v.uniforms.radius.value = T.radius, n.setRenderTarget(T.map), n.clear(), n.renderBufferDirect(P, null, D, v, x, null);
  }
  function C(T, P, D, I, k, O) {
    let B = null;
    const Y = D.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial;
    if (Y !== void 0 ? B = Y : B = D.isPointLight === !0 ? l : a, n.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0) {
      const G = B.uuid, K = P.uuid;
      let A = c[G];
      A === void 0 && (A = {}, c[G] = A);
      let J = A[K];
      J === void 0 && (J = B.clone(), A[K] = J), B = J;
    }
    return B.visible = P.visible, B.wireframe = P.wireframe, O === bm ? B.side = P.shadowSide !== null ? P.shadowSide : P.side : B.side = P.shadowSide !== null ? P.shadowSide : p[P.side], B.alphaMap = P.alphaMap, B.alphaTest = P.alphaTest, B.clipShadows = P.clipShadows, B.clippingPlanes = P.clippingPlanes, B.clipIntersection = P.clipIntersection, B.displacementMap = P.displacementMap, B.displacementScale = P.displacementScale, B.displacementBias = P.displacementBias, B.wireframeLinewidth = P.wireframeLinewidth, B.linewidth = P.linewidth, D.isPointLight === !0 && B.isMeshDistanceMaterial === !0 && (B.referencePosition.setFromMatrixPosition(D.matrixWorld), B.nearDistance = I, B.farDistance = k), B;
  }
  function M(T, P, D, I, k) {
    if (T.visible === !1)
      return;
    if (T.layers.test(P.layers) && (T.isMesh || T.isLine || T.isPoints) && (T.castShadow || T.receiveShadow && k === bm) && (!T.frustumCulled || i.intersectsObject(T))) {
      T.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse, T.matrixWorld);
      const Y = e.update(T), G = T.material;
      if (Array.isArray(G)) {
        const K = Y.groups;
        for (let A = 0, J = K.length; A < J; A++) {
          const xe = K[A], se = G[xe.materialIndex];
          if (se && se.visible) {
            const oe = C(T, se, I, D.near, D.far, k);
            n.renderBufferDirect(D, null, Y, oe, T, xe);
          }
        }
      } else if (G.visible) {
        const K = C(T, G, I, D.near, D.far, k);
        n.renderBufferDirect(D, null, Y, K, T, null);
      }
    }
    const B = T.children;
    for (let Y = 0, G = B.length; Y < G; Y++)
      M(B[Y], P, D, I, k);
  }
}
function Pj(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let pe = !1;
    const ot = new gn();
    let De = null;
    const tt = new gn(0, 0, 0, 0);
    return {
      setMask: function(Qe) {
        De !== Qe && !pe && (n.colorMask(Qe, Qe, Qe, Qe), De = Qe);
      },
      setLocked: function(Qe) {
        pe = Qe;
      },
      setClear: function(Qe, Ft, An, Hn, es) {
        es === !0 && (Qe *= Hn, Ft *= Hn, An *= Hn), ot.set(Qe, Ft, An, Hn), tt.equals(ot) === !1 && (n.clearColor(Qe, Ft, An, Hn), tt.copy(ot));
      },
      reset: function() {
        pe = !1, De = null, tt.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let pe = !1, ot = null, De = null, tt = null;
    return {
      setTest: function(Qe) {
        Qe ? gt(2929) : qe(2929);
      },
      setMask: function(Qe) {
        ot !== Qe && !pe && (n.depthMask(Qe), ot = Qe);
      },
      setFunc: function(Qe) {
        if (De !== Qe) {
          if (Qe)
            switch (Qe) {
              case FL:
                n.depthFunc(512);
                break;
              case BL:
                n.depthFunc(519);
                break;
              case u2:
                n.depthFunc(513);
                break;
              case vb:
                n.depthFunc(515);
                break;
              case gb:
                n.depthFunc(514);
                break;
              case UL:
                n.depthFunc(518);
                break;
              case VL:
                n.depthFunc(516);
                break;
              case rE:
                n.depthFunc(517);
                break;
              default:
                n.depthFunc(515);
            }
          else
            n.depthFunc(515);
          De = Qe;
        }
      },
      setLocked: function(Qe) {
        pe = Qe;
      },
      setClear: function(Qe) {
        tt !== Qe && (n.clearDepth(Qe), tt = Qe);
      },
      reset: function() {
        pe = !1, ot = null, De = null, tt = null;
      }
    };
  }
  function o() {
    let pe = !1, ot = null, De = null, tt = null, Qe = null, Ft = null, An = null, Hn = null, es = null;
    return {
      setTest: function(Sn) {
        pe || (Sn ? gt(2960) : qe(2960));
      },
      setMask: function(Sn) {
        ot !== Sn && !pe && (n.stencilMask(Sn), ot = Sn);
      },
      setFunc: function(Sn, Yi, Gn) {
        (De !== Sn || tt !== Yi || Qe !== Gn) && (n.stencilFunc(Sn, Yi, Gn), De = Sn, tt = Yi, Qe = Gn);
      },
      setOp: function(Sn, Yi, Gn) {
        (Ft !== Sn || An !== Yi || Hn !== Gn) && (n.stencilOp(Sn, Yi, Gn), Ft = Sn, An = Yi, Hn = Gn);
      },
      setLocked: function(Sn) {
        pe = Sn;
      },
      setClear: function(Sn) {
        es !== Sn && (n.clearStencil(Sn), es = Sn);
      },
      reset: function() {
        pe = !1, ot = null, De = null, tt = null, Qe = null, Ft = null, An = null, Hn = null, es = null;
      }
    };
  }
  const a = new r(), l = new s(), c = new o(), d = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap();
  let m = {}, v = {}, b = /* @__PURE__ */ new WeakMap(), x = [], y = null, S = !1, C = null, M = null, T = null, P = null, D = null, I = null, k = null, O = !1, B = null, Y = null, G = null, K = null, A = null;
  const J = n.getParameter(35661);
  let xe = !1, se = 0;
  const oe = n.getParameter(7938);
  oe.indexOf("WebGL") !== -1 ? (se = parseFloat(/^WebGL (\d)/.exec(oe)[1]), xe = se >= 1) : oe.indexOf("OpenGL ES") !== -1 && (se = parseFloat(/^OpenGL ES (\d)/.exec(oe)[1]), xe = se >= 2);
  let Q = null, ce = {};
  const te = n.getParameter(3088), ee = n.getParameter(2978), Re = new gn().fromArray(te), ye = new gn().fromArray(ee);
  function Se(pe, ot, De) {
    const tt = new Uint8Array(4), Qe = n.createTexture();
    n.bindTexture(pe, Qe), n.texParameteri(pe, 10241, 9728), n.texParameteri(pe, 10240, 9728);
    for (let Ft = 0; Ft < De; Ft++)
      n.texImage2D(ot + Ft, 0, 6408, 1, 1, 0, 6408, 5121, tt);
    return Qe;
  }
  const Ee = {};
  Ee[3553] = Se(3553, 3553, 1), Ee[34067] = Se(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), gt(2929), l.setFunc(vb), ae(!1), $(kT), gt(2884), L(Si);
  function gt(pe) {
    m[pe] !== !0 && (n.enable(pe), m[pe] = !0);
  }
  function qe(pe) {
    m[pe] !== !1 && (n.disable(pe), m[pe] = !1);
  }
  function Ze(pe, ot) {
    return v[pe] !== ot ? (n.bindFramebuffer(pe, ot), v[pe] = ot, i && (pe === 36009 && (v[36160] = ot), pe === 36160 && (v[36009] = ot)), !0) : !1;
  }
  function je(pe, ot) {
    let De = x, tt = !1;
    if (pe)
      if (De = b.get(ot), De === void 0 && (De = [], b.set(ot, De)), pe.isWebGLMultipleRenderTargets) {
        const Qe = pe.texture;
        if (De.length !== Qe.length || De[0] !== 36064) {
          for (let Ft = 0, An = Qe.length; Ft < An; Ft++)
            De[Ft] = 36064 + Ft;
          De.length = Qe.length, tt = !0;
        }
      } else
        De[0] !== 36064 && (De[0] = 36064, tt = !0);
    else
      De[0] !== 1029 && (De[0] = 1029, tt = !0);
    tt && (t.isWebGL2 ? n.drawBuffers(De) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(De));
  }
  function st(pe) {
    return y !== pe ? (n.useProgram(pe), y = pe, !0) : !1;
  }
  const Ie = {
    [Ed]: 32774,
    [KV]: 32778,
    [JV]: 32779
  };
  if (i)
    Ie[OT] = 32775, Ie[NT] = 32776;
  else {
    const pe = e.get("EXT_blend_minmax");
    pe !== null && (Ie[OT] = pe.MIN_EXT, Ie[NT] = pe.MAX_EXT);
  }
  const Le = {
    [QV]: 0,
    [e9]: 1,
    [t9]: 768,
    [NL]: 770,
    [a9]: 776,
    [s9]: 774,
    [i9]: 772,
    [n9]: 769,
    [zL]: 771,
    [o9]: 775,
    [r9]: 773
  };
  function L(pe, ot, De, tt, Qe, Ft, An, Hn) {
    if (pe === Si) {
      S === !0 && (qe(3042), S = !1);
      return;
    }
    if (S === !1 && (gt(3042), S = !0), pe !== YV) {
      if (pe !== C || Hn !== O) {
        if ((M !== Ed || D !== Ed) && (n.blendEquation(32774), M = Ed, D = Ed), Hn)
          switch (pe) {
            case Nd:
              n.blendFuncSeparate(1, 771, 1, 771);
              break;
            case LT:
              n.blendFunc(1, 1);
              break;
            case DT:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case IT:
              n.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", pe);
              break;
          }
        else
          switch (pe) {
            case Nd:
              n.blendFuncSeparate(770, 771, 1, 771);
              break;
            case LT:
              n.blendFunc(770, 1);
              break;
            case DT:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case IT:
              n.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", pe);
              break;
          }
        T = null, P = null, I = null, k = null, C = pe, O = Hn;
      }
      return;
    }
    Qe = Qe || ot, Ft = Ft || De, An = An || tt, (ot !== M || Qe !== D) && (n.blendEquationSeparate(Ie[ot], Ie[Qe]), M = ot, D = Qe), (De !== T || tt !== P || Ft !== I || An !== k) && (n.blendFuncSeparate(Le[De], Le[tt], Le[Ft], Le[An]), T = De, P = tt, I = Ft, k = An), C = pe, O = null;
  }
  function fe(pe, ot) {
    pe.side === Js ? qe(2884) : gt(2884);
    let De = pe.side === cr;
    ot && (De = !De), ae(De), pe.blending === Nd && pe.transparent === !1 ? L(Si) : L(pe.blending, pe.blendEquation, pe.blendSrc, pe.blendDst, pe.blendEquationAlpha, pe.blendSrcAlpha, pe.blendDstAlpha, pe.premultipliedAlpha), l.setFunc(pe.depthFunc), l.setTest(pe.depthTest), l.setMask(pe.depthWrite), a.setMask(pe.colorWrite);
    const tt = pe.stencilWrite;
    c.setTest(tt), tt && (c.setMask(pe.stencilWriteMask), c.setFunc(pe.stencilFunc, pe.stencilRef, pe.stencilFuncMask), c.setOp(pe.stencilFail, pe.stencilZFail, pe.stencilZPass)), re(pe.polygonOffset, pe.polygonOffsetFactor, pe.polygonOffsetUnits), pe.alphaToCoverage === !0 ? gt(32926) : qe(32926);
  }
  function ae(pe) {
    B !== pe && (pe ? n.frontFace(2304) : n.frontFace(2305), B = pe);
  }
  function $(pe) {
    pe !== $V ? (gt(2884), pe !== Y && (pe === kT ? n.cullFace(1029) : pe === ZV ? n.cullFace(1028) : n.cullFace(1032))) : qe(2884), Y = pe;
  }
  function j(pe) {
    pe !== G && (xe && n.lineWidth(pe), G = pe);
  }
  function re(pe, ot, De) {
    pe ? (gt(32823), (K !== ot || A !== De) && (n.polygonOffset(ot, De), K = ot, A = De)) : qe(32823);
  }
  function Te(pe) {
    pe ? gt(3089) : qe(3089);
  }
  function Ce(pe) {
    pe === void 0 && (pe = 33984 + J - 1), Q !== pe && (n.activeTexture(pe), Q = pe);
  }
  function F(pe, ot) {
    Q === null && Ce();
    let De = ce[Q];
    De === void 0 && (De = { type: void 0, texture: void 0 }, ce[Q] = De), (De.type !== pe || De.texture !== ot) && (n.bindTexture(pe, ot || Ee[pe]), De.type = pe, De.texture = ot);
  }
  function U() {
    const pe = ce[Q];
    pe !== void 0 && pe.type !== void 0 && (n.bindTexture(pe.type, null), pe.type = void 0, pe.texture = void 0);
  }
  function he() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function me() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function Ae() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function Ve() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function $e() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function Me() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function lt() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function Ye() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (pe) {
      console.error("THREE.WebGLState:", pe);
    }
  }
  function ht(pe) {
    Re.equals(pe) === !1 && (n.scissor(pe.x, pe.y, pe.z, pe.w), Re.copy(pe));
  }
  function Xe(pe) {
    ye.equals(pe) === !1 && (n.viewport(pe.x, pe.y, pe.z, pe.w), ye.copy(pe));
  }
  function Mt(pe, ot) {
    let De = p.get(ot);
    De === void 0 && (De = /* @__PURE__ */ new WeakMap(), p.set(ot, De));
    let tt = De.get(pe);
    tt === void 0 && (tt = n.getUniformBlockIndex(ot, pe.name), De.set(pe, tt));
  }
  function At(pe, ot) {
    const tt = p.get(ot).get(pe);
    d.get(pe) !== tt && (n.uniformBlockBinding(ot, tt, pe.__bindingPointIndex), d.set(pe, tt));
  }
  function Bt() {
    n.disable(3042), n.disable(2884), n.disable(2929), n.disable(32823), n.disable(3089), n.disable(2960), n.disable(32926), n.blendEquation(32774), n.blendFunc(1, 0), n.blendFuncSeparate(1, 0, 1, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(513), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(519, 0, 4294967295), n.stencilOp(7680, 7680, 7680), n.clearStencil(0), n.cullFace(1029), n.frontFace(2305), n.polygonOffset(0, 0), n.activeTexture(33984), n.bindFramebuffer(36160, null), i === !0 && (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), m = {}, Q = null, ce = {}, v = {}, b = /* @__PURE__ */ new WeakMap(), x = [], y = null, S = !1, C = null, M = null, T = null, P = null, D = null, I = null, k = null, O = !1, B = null, Y = null, G = null, K = null, A = null, Re.set(0, 0, n.canvas.width, n.canvas.height), ye.set(0, 0, n.canvas.width, n.canvas.height), a.reset(), l.reset(), c.reset();
  }
  return {
    buffers: {
      color: a,
      depth: l,
      stencil: c
    },
    enable: gt,
    disable: qe,
    bindFramebuffer: Ze,
    drawBuffers: je,
    useProgram: st,
    setBlending: L,
    setMaterial: fe,
    setFlipSided: ae,
    setCullFace: $,
    setLineWidth: j,
    setPolygonOffset: re,
    setScissorTest: Te,
    activeTexture: Ce,
    bindTexture: F,
    unbindTexture: U,
    compressedTexImage2D: he,
    texImage2D: lt,
    texImage3D: Ye,
    updateUBOMapping: Mt,
    uniformBlockBinding: At,
    texStorage2D: $e,
    texStorage3D: Me,
    texSubImage2D: me,
    texSubImage3D: Ae,
    compressedTexSubImage2D: Ve,
    scissor: ht,
    viewport: Xe,
    reset: Bt
  };
}
function Aj(n, e, t, i, r, s, o) {
  const a = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, d = r.maxTextureSize, p = r.maxSamples, m = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, v = /OculusBrowser/g.test(navigator.userAgent), b = /* @__PURE__ */ new WeakMap();
  let x;
  const y = /* @__PURE__ */ new WeakMap();
  let S = !1;
  try {
    S = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function C(F, U) {
    return S ? new OffscreenCanvas(F, U) : Zm("canvas");
  }
  function M(F, U, he, me) {
    let Ae = 1;
    if ((F.width > me || F.height > me) && (Ae = me / Math.max(F.width, F.height)), Ae < 1 || U === !0)
      if (typeof HTMLImageElement < "u" && F instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && F instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && F instanceof ImageBitmap) {
        const Ve = U ? wb : Math.floor, $e = Ve(Ae * F.width), Me = Ve(Ae * F.height);
        x === void 0 && (x = C($e, Me));
        const lt = he ? C($e, Me) : x;
        return lt.width = $e, lt.height = Me, lt.getContext("2d").drawImage(F, 0, 0, $e, Me), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + F.width + "x" + F.height + ") to (" + $e + "x" + Me + ")."), lt;
      } else
        return "data" in F && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + F.width + "x" + F.height + ")."), F;
    return F;
  }
  function T(F) {
    return v2(F.width) && v2(F.height);
  }
  function P(F) {
    return a ? !1 : F.wrapS !== qr || F.wrapT !== qr || F.minFilter !== kn && F.minFilter !== Zt;
  }
  function D(F, U) {
    return F.generateMipmaps && U && F.minFilter !== kn && F.minFilter !== Zt;
  }
  function I(F) {
    n.generateMipmap(F);
  }
  function k(F, U, he, me, Ae = !1) {
    if (a === !1)
      return U;
    if (F !== null) {
      if (n[F] !== void 0)
        return n[F];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + F + "'");
    }
    let Ve = U;
    return U === 6403 && (he === 5126 && (Ve = 33326), he === 5131 && (Ve = 33325), he === 5121 && (Ve = 33321)), U === 33319 && (he === 5126 && (Ve = 33328), he === 5131 && (Ve = 33327), he === 5121 && (Ve = 33323)), U === 6408 && (he === 5126 && (Ve = 34836), he === 5131 && (Ve = 34842), he === 5121 && (Ve = me === Tt && Ae === !1 ? 35907 : 32856), he === 32819 && (Ve = 32854), he === 32820 && (Ve = 32855)), (Ve === 33325 || Ve === 33326 || Ve === 33327 || Ve === 33328 || Ve === 34842 || Ve === 34836) && e.get("EXT_color_buffer_float"), Ve;
  }
  function O(F, U, he) {
    return D(F, he) === !0 || F.isFramebufferTexture && F.minFilter !== kn && F.minFilter !== Zt ? Math.log2(Math.max(U.width, U.height)) + 1 : F.mipmaps !== void 0 && F.mipmaps.length > 0 ? F.mipmaps.length : F.isCompressedTexture && Array.isArray(F.image) ? U.mipmaps.length : 1;
  }
  function B(F) {
    return F === kn || F === zT || F === FT ? 9728 : 9729;
  }
  function Y(F) {
    const U = F.target;
    U.removeEventListener("dispose", Y), K(U), U.isVideoTexture && b.delete(U);
  }
  function G(F) {
    const U = F.target;
    U.removeEventListener("dispose", G), J(U);
  }
  function K(F) {
    const U = i.get(F);
    if (U.__webglInit === void 0)
      return;
    const he = F.source, me = y.get(he);
    if (me) {
      const Ae = me[U.__cacheKey];
      Ae.usedTimes--, Ae.usedTimes === 0 && A(F), Object.keys(me).length === 0 && y.delete(he);
    }
    i.remove(F);
  }
  function A(F) {
    const U = i.get(F);
    n.deleteTexture(U.__webglTexture);
    const he = F.source, me = y.get(he);
    delete me[U.__cacheKey], o.memory.textures--;
  }
  function J(F) {
    const U = F.texture, he = i.get(F), me = i.get(U);
    if (me.__webglTexture !== void 0 && (n.deleteTexture(me.__webglTexture), o.memory.textures--), F.depthTexture && F.depthTexture.dispose(), F.isWebGLCubeRenderTarget)
      for (let Ae = 0; Ae < 6; Ae++)
        n.deleteFramebuffer(he.__webglFramebuffer[Ae]), he.__webglDepthbuffer && n.deleteRenderbuffer(he.__webglDepthbuffer[Ae]);
    else {
      if (n.deleteFramebuffer(he.__webglFramebuffer), he.__webglDepthbuffer && n.deleteRenderbuffer(he.__webglDepthbuffer), he.__webglMultisampledFramebuffer && n.deleteFramebuffer(he.__webglMultisampledFramebuffer), he.__webglColorRenderbuffer)
        for (let Ae = 0; Ae < he.__webglColorRenderbuffer.length; Ae++)
          he.__webglColorRenderbuffer[Ae] && n.deleteRenderbuffer(he.__webglColorRenderbuffer[Ae]);
      he.__webglDepthRenderbuffer && n.deleteRenderbuffer(he.__webglDepthRenderbuffer);
    }
    if (F.isWebGLMultipleRenderTargets)
      for (let Ae = 0, Ve = U.length; Ae < Ve; Ae++) {
        const $e = i.get(U[Ae]);
        $e.__webglTexture && (n.deleteTexture($e.__webglTexture), o.memory.textures--), i.remove(U[Ae]);
      }
    i.remove(U), i.remove(F);
  }
  let xe = 0;
  function se() {
    xe = 0;
  }
  function oe() {
    const F = xe;
    return F >= l && console.warn("THREE.WebGLTextures: Trying to use " + F + " texture units while this GPU supports only " + l), xe += 1, F;
  }
  function Q(F) {
    const U = [];
    return U.push(F.wrapS), U.push(F.wrapT), U.push(F.magFilter), U.push(F.minFilter), U.push(F.anisotropy), U.push(F.internalFormat), U.push(F.format), U.push(F.type), U.push(F.generateMipmaps), U.push(F.premultiplyAlpha), U.push(F.flipY), U.push(F.unpackAlignment), U.push(F.encoding), U.join();
  }
  function ce(F, U) {
    const he = i.get(F);
    if (F.isVideoTexture && Te(F), F.isRenderTargetTexture === !1 && F.version > 0 && he.__version !== F.version) {
      const me = F.image;
      if (me === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (me.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        qe(he, F, U);
        return;
      }
    }
    t.activeTexture(33984 + U), t.bindTexture(3553, he.__webglTexture);
  }
  function te(F, U) {
    const he = i.get(F);
    if (F.version > 0 && he.__version !== F.version) {
      qe(he, F, U);
      return;
    }
    t.activeTexture(33984 + U), t.bindTexture(35866, he.__webglTexture);
  }
  function ee(F, U) {
    const he = i.get(F);
    if (F.version > 0 && he.__version !== F.version) {
      qe(he, F, U);
      return;
    }
    t.activeTexture(33984 + U), t.bindTexture(32879, he.__webglTexture);
  }
  function Re(F, U) {
    const he = i.get(F);
    if (F.version > 0 && he.__version !== F.version) {
      Ze(he, F, U);
      return;
    }
    t.activeTexture(33984 + U), t.bindTexture(34067, he.__webglTexture);
  }
  const ye = {
    [qu]: 10497,
    [qr]: 33071,
    [d2]: 33648
  }, Se = {
    [kn]: 9728,
    [zT]: 9984,
    [FT]: 9986,
    [Zt]: 9729,
    [p9]: 9985,
    [Pv]: 9987
  };
  function Ee(F, U, he) {
    if (he ? (n.texParameteri(F, 10242, ye[U.wrapS]), n.texParameteri(F, 10243, ye[U.wrapT]), (F === 32879 || F === 35866) && n.texParameteri(F, 32882, ye[U.wrapR]), n.texParameteri(F, 10240, Se[U.magFilter]), n.texParameteri(F, 10241, Se[U.minFilter])) : (n.texParameteri(F, 10242, 33071), n.texParameteri(F, 10243, 33071), (F === 32879 || F === 35866) && n.texParameteri(F, 32882, 33071), (U.wrapS !== qr || U.wrapT !== qr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(F, 10240, B(U.magFilter)), n.texParameteri(F, 10241, B(U.minFilter)), U.minFilter !== kn && U.minFilter !== Zt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
      const me = e.get("EXT_texture_filter_anisotropic");
      if (U.type === Qs && e.has("OES_texture_float_linear") === !1 || a === !1 && U.type === $r && e.has("OES_texture_half_float_linear") === !1)
        return;
      (U.anisotropy > 1 || i.get(U).__currentAnisotropy) && (n.texParameterf(F, me.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(U.anisotropy, r.getMaxAnisotropy())), i.get(U).__currentAnisotropy = U.anisotropy);
    }
  }
  function gt(F, U) {
    let he = !1;
    F.__webglInit === void 0 && (F.__webglInit = !0, U.addEventListener("dispose", Y));
    const me = U.source;
    let Ae = y.get(me);
    Ae === void 0 && (Ae = {}, y.set(me, Ae));
    const Ve = Q(U);
    if (Ve !== F.__cacheKey) {
      Ae[Ve] === void 0 && (Ae[Ve] = {
        texture: n.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, he = !0), Ae[Ve].usedTimes++;
      const $e = Ae[F.__cacheKey];
      $e !== void 0 && (Ae[F.__cacheKey].usedTimes--, $e.usedTimes === 0 && A(U)), F.__cacheKey = Ve, F.__webglTexture = Ae[Ve].texture;
    }
    return he;
  }
  function qe(F, U, he) {
    let me = 3553;
    U.isDataArrayTexture && (me = 35866), U.isData3DTexture && (me = 32879);
    const Ae = gt(F, U), Ve = U.source;
    if (t.activeTexture(33984 + he), t.bindTexture(me, F.__webglTexture), Ve.version !== Ve.__currentVersion || Ae === !0) {
      n.pixelStorei(37440, U.flipY), n.pixelStorei(37441, U.premultiplyAlpha), n.pixelStorei(3317, U.unpackAlignment), n.pixelStorei(37443, 0);
      const $e = P(U) && T(U.image) === !1;
      let Me = M(U.image, $e, !1, d);
      Me = Ce(U, Me);
      const lt = T(Me) || a, Ye = s.convert(U.format, U.encoding);
      let ht = s.convert(U.type), Xe = k(U.internalFormat, Ye, ht, U.encoding, U.isVideoTexture);
      Ee(me, U, lt);
      let Mt;
      const At = U.mipmaps, Bt = a && U.isVideoTexture !== !0, pe = Ve.__currentVersion === void 0 || Ae === !0, ot = O(U, Me, lt);
      if (U.isDepthTexture)
        Xe = 6402, a ? U.type === Qs ? Xe = 36012 : U.type === cc ? Xe = 33190 : U.type === Tu ? Xe = 35056 : Xe = 33189 : U.type === Qs && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), U.format === Pu && Xe === 6402 && U.type !== jL && U.type !== cc && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), U.type = cc, ht = s.convert(U.type)), U.format === Xu && Xe === 6402 && (Xe = 34041, U.type !== Tu && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), U.type = Tu, ht = s.convert(U.type))), pe && (Bt ? t.texStorage2D(3553, 1, Xe, Me.width, Me.height) : t.texImage2D(3553, 0, Xe, Me.width, Me.height, 0, Ye, ht, null));
      else if (U.isDataTexture)
        if (At.length > 0 && lt) {
          Bt && pe && t.texStorage2D(3553, ot, Xe, At[0].width, At[0].height);
          for (let De = 0, tt = At.length; De < tt; De++)
            Mt = At[De], Bt ? t.texSubImage2D(3553, De, 0, 0, Mt.width, Mt.height, Ye, ht, Mt.data) : t.texImage2D(3553, De, Xe, Mt.width, Mt.height, 0, Ye, ht, Mt.data);
          U.generateMipmaps = !1;
        } else
          Bt ? (pe && t.texStorage2D(3553, ot, Xe, Me.width, Me.height), t.texSubImage2D(3553, 0, 0, 0, Me.width, Me.height, Ye, ht, Me.data)) : t.texImage2D(3553, 0, Xe, Me.width, Me.height, 0, Ye, ht, Me.data);
      else if (U.isCompressedTexture) {
        Bt && pe && t.texStorage2D(3553, ot, Xe, At[0].width, At[0].height);
        for (let De = 0, tt = At.length; De < tt; De++)
          Mt = At[De], U.format !== wr ? Ye !== null ? Bt ? t.compressedTexSubImage2D(3553, De, 0, 0, Mt.width, Mt.height, Ye, Mt.data) : t.compressedTexImage2D(3553, De, Xe, Mt.width, Mt.height, 0, Mt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Bt ? t.texSubImage2D(3553, De, 0, 0, Mt.width, Mt.height, Ye, ht, Mt.data) : t.texImage2D(3553, De, Xe, Mt.width, Mt.height, 0, Ye, ht, Mt.data);
      } else if (U.isDataArrayTexture)
        Bt ? (pe && t.texStorage3D(35866, ot, Xe, Me.width, Me.height, Me.depth), t.texSubImage3D(35866, 0, 0, 0, 0, Me.width, Me.height, Me.depth, Ye, ht, Me.data)) : t.texImage3D(35866, 0, Xe, Me.width, Me.height, Me.depth, 0, Ye, ht, Me.data);
      else if (U.isData3DTexture)
        Bt ? (pe && t.texStorage3D(32879, ot, Xe, Me.width, Me.height, Me.depth), t.texSubImage3D(32879, 0, 0, 0, 0, Me.width, Me.height, Me.depth, Ye, ht, Me.data)) : t.texImage3D(32879, 0, Xe, Me.width, Me.height, Me.depth, 0, Ye, ht, Me.data);
      else if (U.isFramebufferTexture) {
        if (pe)
          if (Bt)
            t.texStorage2D(3553, ot, Xe, Me.width, Me.height);
          else {
            let De = Me.width, tt = Me.height;
            for (let Qe = 0; Qe < ot; Qe++)
              t.texImage2D(3553, Qe, Xe, De, tt, 0, Ye, ht, null), De >>= 1, tt >>= 1;
          }
      } else if (At.length > 0 && lt) {
        Bt && pe && t.texStorage2D(3553, ot, Xe, At[0].width, At[0].height);
        for (let De = 0, tt = At.length; De < tt; De++)
          Mt = At[De], Bt ? t.texSubImage2D(3553, De, 0, 0, Ye, ht, Mt) : t.texImage2D(3553, De, Xe, Ye, ht, Mt);
        U.generateMipmaps = !1;
      } else
        Bt ? (pe && t.texStorage2D(3553, ot, Xe, Me.width, Me.height), t.texSubImage2D(3553, 0, 0, 0, Ye, ht, Me)) : t.texImage2D(3553, 0, Xe, Ye, ht, Me);
      D(U, lt) && I(me), Ve.__currentVersion = Ve.version, U.onUpdate && U.onUpdate(U);
    }
    F.__version = U.version;
  }
  function Ze(F, U, he) {
    if (U.image.length !== 6)
      return;
    const me = gt(F, U), Ae = U.source;
    if (t.activeTexture(33984 + he), t.bindTexture(34067, F.__webglTexture), Ae.version !== Ae.__currentVersion || me === !0) {
      n.pixelStorei(37440, U.flipY), n.pixelStorei(37441, U.premultiplyAlpha), n.pixelStorei(3317, U.unpackAlignment), n.pixelStorei(37443, 0);
      const Ve = U.isCompressedTexture || U.image[0].isCompressedTexture, $e = U.image[0] && U.image[0].isDataTexture, Me = [];
      for (let De = 0; De < 6; De++)
        !Ve && !$e ? Me[De] = M(U.image[De], !1, !0, c) : Me[De] = $e ? U.image[De].image : U.image[De], Me[De] = Ce(U, Me[De]);
      const lt = Me[0], Ye = T(lt) || a, ht = s.convert(U.format, U.encoding), Xe = s.convert(U.type), Mt = k(U.internalFormat, ht, Xe, U.encoding), At = a && U.isVideoTexture !== !0, Bt = Ae.__currentVersion === void 0 || me === !0;
      let pe = O(U, lt, Ye);
      Ee(34067, U, Ye);
      let ot;
      if (Ve) {
        At && Bt && t.texStorage2D(34067, pe, Mt, lt.width, lt.height);
        for (let De = 0; De < 6; De++) {
          ot = Me[De].mipmaps;
          for (let tt = 0; tt < ot.length; tt++) {
            const Qe = ot[tt];
            U.format !== wr ? ht !== null ? At ? t.compressedTexSubImage2D(34069 + De, tt, 0, 0, Qe.width, Qe.height, ht, Qe.data) : t.compressedTexImage2D(34069 + De, tt, Mt, Qe.width, Qe.height, 0, Qe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : At ? t.texSubImage2D(34069 + De, tt, 0, 0, Qe.width, Qe.height, ht, Xe, Qe.data) : t.texImage2D(34069 + De, tt, Mt, Qe.width, Qe.height, 0, ht, Xe, Qe.data);
          }
        }
      } else {
        ot = U.mipmaps, At && Bt && (ot.length > 0 && pe++, t.texStorage2D(34067, pe, Mt, Me[0].width, Me[0].height));
        for (let De = 0; De < 6; De++)
          if ($e) {
            At ? t.texSubImage2D(34069 + De, 0, 0, 0, Me[De].width, Me[De].height, ht, Xe, Me[De].data) : t.texImage2D(34069 + De, 0, Mt, Me[De].width, Me[De].height, 0, ht, Xe, Me[De].data);
            for (let tt = 0; tt < ot.length; tt++) {
              const Ft = ot[tt].image[De].image;
              At ? t.texSubImage2D(34069 + De, tt + 1, 0, 0, Ft.width, Ft.height, ht, Xe, Ft.data) : t.texImage2D(34069 + De, tt + 1, Mt, Ft.width, Ft.height, 0, ht, Xe, Ft.data);
            }
          } else {
            At ? t.texSubImage2D(34069 + De, 0, 0, 0, ht, Xe, Me[De]) : t.texImage2D(34069 + De, 0, Mt, ht, Xe, Me[De]);
            for (let tt = 0; tt < ot.length; tt++) {
              const Qe = ot[tt];
              At ? t.texSubImage2D(34069 + De, tt + 1, 0, 0, ht, Xe, Qe.image[De]) : t.texImage2D(34069 + De, tt + 1, Mt, ht, Xe, Qe.image[De]);
            }
          }
      }
      D(U, Ye) && I(34067), Ae.__currentVersion = Ae.version, U.onUpdate && U.onUpdate(U);
    }
    F.__version = U.version;
  }
  function je(F, U, he, me, Ae) {
    const Ve = s.convert(he.format, he.encoding), $e = s.convert(he.type), Me = k(he.internalFormat, Ve, $e, he.encoding);
    i.get(U).__hasExternalTextures || (Ae === 32879 || Ae === 35866 ? t.texImage3D(Ae, 0, Me, U.width, U.height, U.depth, 0, Ve, $e, null) : t.texImage2D(Ae, 0, Me, U.width, U.height, 0, Ve, $e, null)), t.bindFramebuffer(36160, F), re(U) ? m.framebufferTexture2DMultisampleEXT(36160, me, Ae, i.get(he).__webglTexture, 0, j(U)) : n.framebufferTexture2D(36160, me, Ae, i.get(he).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function st(F, U, he) {
    if (n.bindRenderbuffer(36161, F), U.depthBuffer && !U.stencilBuffer) {
      let me = 33189;
      if (he || re(U)) {
        const Ae = U.depthTexture;
        Ae && Ae.isDepthTexture && (Ae.type === Qs ? me = 36012 : Ae.type === cc && (me = 33190));
        const Ve = j(U);
        re(U) ? m.renderbufferStorageMultisampleEXT(36161, Ve, me, U.width, U.height) : n.renderbufferStorageMultisample(36161, Ve, me, U.width, U.height);
      } else
        n.renderbufferStorage(36161, me, U.width, U.height);
      n.framebufferRenderbuffer(36160, 36096, 36161, F);
    } else if (U.depthBuffer && U.stencilBuffer) {
      const me = j(U);
      he && re(U) === !1 ? n.renderbufferStorageMultisample(36161, me, 35056, U.width, U.height) : re(U) ? m.renderbufferStorageMultisampleEXT(36161, me, 35056, U.width, U.height) : n.renderbufferStorage(36161, 34041, U.width, U.height), n.framebufferRenderbuffer(36160, 33306, 36161, F);
    } else {
      const me = U.isWebGLMultipleRenderTargets === !0 ? U.texture : [U.texture];
      for (let Ae = 0; Ae < me.length; Ae++) {
        const Ve = me[Ae], $e = s.convert(Ve.format, Ve.encoding), Me = s.convert(Ve.type), lt = k(Ve.internalFormat, $e, Me, Ve.encoding), Ye = j(U);
        he && re(U) === !1 ? n.renderbufferStorageMultisample(36161, Ye, lt, U.width, U.height) : re(U) ? m.renderbufferStorageMultisampleEXT(36161, Ye, lt, U.width, U.height) : n.renderbufferStorage(36161, lt, U.width, U.height);
      }
    }
    n.bindRenderbuffer(36161, null);
  }
  function Ie(F, U) {
    if (U && U.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, F), !(U.depthTexture && U.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(U.depthTexture).__webglTexture || U.depthTexture.image.width !== U.width || U.depthTexture.image.height !== U.height) && (U.depthTexture.image.width = U.width, U.depthTexture.image.height = U.height, U.depthTexture.needsUpdate = !0), ce(U.depthTexture, 0);
    const me = i.get(U.depthTexture).__webglTexture, Ae = j(U);
    if (U.depthTexture.format === Pu)
      re(U) ? m.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, me, 0, Ae) : n.framebufferTexture2D(36160, 36096, 3553, me, 0);
    else if (U.depthTexture.format === Xu)
      re(U) ? m.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, me, 0, Ae) : n.framebufferTexture2D(36160, 33306, 3553, me, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Le(F) {
    const U = i.get(F), he = F.isWebGLCubeRenderTarget === !0;
    if (F.depthTexture && !U.__autoAllocateDepthBuffer) {
      if (he)
        throw new Error("target.depthTexture not supported in Cube render targets");
      Ie(U.__webglFramebuffer, F);
    } else if (he) {
      U.__webglDepthbuffer = [];
      for (let me = 0; me < 6; me++)
        t.bindFramebuffer(36160, U.__webglFramebuffer[me]), U.__webglDepthbuffer[me] = n.createRenderbuffer(), st(U.__webglDepthbuffer[me], F, !1);
    } else
      t.bindFramebuffer(36160, U.__webglFramebuffer), U.__webglDepthbuffer = n.createRenderbuffer(), st(U.__webglDepthbuffer, F, !1);
    t.bindFramebuffer(36160, null);
  }
  function L(F, U, he) {
    const me = i.get(F);
    U !== void 0 && je(me.__webglFramebuffer, F, F.texture, 36064, 3553), he !== void 0 && Le(F);
  }
  function fe(F) {
    const U = F.texture, he = i.get(F), me = i.get(U);
    F.addEventListener("dispose", G), F.isWebGLMultipleRenderTargets !== !0 && (me.__webglTexture === void 0 && (me.__webglTexture = n.createTexture()), me.__version = U.version, o.memory.textures++);
    const Ae = F.isWebGLCubeRenderTarget === !0, Ve = F.isWebGLMultipleRenderTargets === !0, $e = T(F) || a;
    if (Ae) {
      he.__webglFramebuffer = [];
      for (let Me = 0; Me < 6; Me++)
        he.__webglFramebuffer[Me] = n.createFramebuffer();
    } else {
      if (he.__webglFramebuffer = n.createFramebuffer(), Ve)
        if (r.drawBuffers) {
          const Me = F.texture;
          for (let lt = 0, Ye = Me.length; lt < Ye; lt++) {
            const ht = i.get(Me[lt]);
            ht.__webglTexture === void 0 && (ht.__webglTexture = n.createTexture(), o.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (a && F.samples > 0 && re(F) === !1) {
        const Me = Ve ? U : [U];
        he.__webglMultisampledFramebuffer = n.createFramebuffer(), he.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, he.__webglMultisampledFramebuffer);
        for (let lt = 0; lt < Me.length; lt++) {
          const Ye = Me[lt];
          he.__webglColorRenderbuffer[lt] = n.createRenderbuffer(), n.bindRenderbuffer(36161, he.__webglColorRenderbuffer[lt]);
          const ht = s.convert(Ye.format, Ye.encoding), Xe = s.convert(Ye.type), Mt = k(Ye.internalFormat, ht, Xe, Ye.encoding), At = j(F);
          n.renderbufferStorageMultisample(36161, At, Mt, F.width, F.height), n.framebufferRenderbuffer(36160, 36064 + lt, 36161, he.__webglColorRenderbuffer[lt]);
        }
        n.bindRenderbuffer(36161, null), F.depthBuffer && (he.__webglDepthRenderbuffer = n.createRenderbuffer(), st(he.__webglDepthRenderbuffer, F, !0)), t.bindFramebuffer(36160, null);
      }
    }
    if (Ae) {
      t.bindTexture(34067, me.__webglTexture), Ee(34067, U, $e);
      for (let Me = 0; Me < 6; Me++)
        je(he.__webglFramebuffer[Me], F, U, 36064, 34069 + Me);
      D(U, $e) && I(34067), t.unbindTexture();
    } else if (Ve) {
      const Me = F.texture;
      for (let lt = 0, Ye = Me.length; lt < Ye; lt++) {
        const ht = Me[lt], Xe = i.get(ht);
        t.bindTexture(3553, Xe.__webglTexture), Ee(3553, ht, $e), je(he.__webglFramebuffer, F, ht, 36064 + lt, 3553), D(ht, $e) && I(3553);
      }
      t.unbindTexture();
    } else {
      let Me = 3553;
      (F.isWebGL3DRenderTarget || F.isWebGLArrayRenderTarget) && (a ? Me = F.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Me, me.__webglTexture), Ee(Me, U, $e), je(he.__webglFramebuffer, F, U, 36064, Me), D(U, $e) && I(Me), t.unbindTexture();
    }
    F.depthBuffer && Le(F);
  }
  function ae(F) {
    const U = T(F) || a, he = F.isWebGLMultipleRenderTargets === !0 ? F.texture : [F.texture];
    for (let me = 0, Ae = he.length; me < Ae; me++) {
      const Ve = he[me];
      if (D(Ve, U)) {
        const $e = F.isWebGLCubeRenderTarget ? 34067 : 3553, Me = i.get(Ve).__webglTexture;
        t.bindTexture($e, Me), I($e), t.unbindTexture();
      }
    }
  }
  function $(F) {
    if (a && F.samples > 0 && re(F) === !1) {
      const U = F.isWebGLMultipleRenderTargets ? F.texture : [F.texture], he = F.width, me = F.height;
      let Ae = 16384;
      const Ve = [], $e = F.stencilBuffer ? 33306 : 36096, Me = i.get(F), lt = F.isWebGLMultipleRenderTargets === !0;
      if (lt)
        for (let Ye = 0; Ye < U.length; Ye++)
          t.bindFramebuffer(36160, Me.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(36160, 36064 + Ye, 36161, null), t.bindFramebuffer(36160, Me.__webglFramebuffer), n.framebufferTexture2D(36009, 36064 + Ye, 3553, null, 0);
      t.bindFramebuffer(36008, Me.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, Me.__webglFramebuffer);
      for (let Ye = 0; Ye < U.length; Ye++) {
        Ve.push(36064 + Ye), F.depthBuffer && Ve.push($e);
        const ht = Me.__ignoreDepthValues !== void 0 ? Me.__ignoreDepthValues : !1;
        if (ht === !1 && (F.depthBuffer && (Ae |= 256), F.stencilBuffer && (Ae |= 1024)), lt && n.framebufferRenderbuffer(36008, 36064, 36161, Me.__webglColorRenderbuffer[Ye]), ht === !0 && (n.invalidateFramebuffer(36008, [$e]), n.invalidateFramebuffer(36009, [$e])), lt) {
          const Xe = i.get(U[Ye]).__webglTexture;
          n.framebufferTexture2D(36009, 36064, 3553, Xe, 0);
        }
        n.blitFramebuffer(0, 0, he, me, 0, 0, he, me, Ae, 9728), v && n.invalidateFramebuffer(36008, Ve);
      }
      if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), lt)
        for (let Ye = 0; Ye < U.length; Ye++) {
          t.bindFramebuffer(36160, Me.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(36160, 36064 + Ye, 36161, Me.__webglColorRenderbuffer[Ye]);
          const ht = i.get(U[Ye]).__webglTexture;
          t.bindFramebuffer(36160, Me.__webglFramebuffer), n.framebufferTexture2D(36009, 36064 + Ye, 3553, ht, 0);
        }
      t.bindFramebuffer(36009, Me.__webglMultisampledFramebuffer);
    }
  }
  function j(F) {
    return Math.min(p, F.samples);
  }
  function re(F) {
    const U = i.get(F);
    return a && F.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && U.__useRenderToTexture !== !1;
  }
  function Te(F) {
    const U = o.render.frame;
    b.get(F) !== U && (b.set(F, U), F.update());
  }
  function Ce(F, U) {
    const he = F.encoding, me = F.format, Ae = F.type;
    return F.isCompressedTexture === !0 || F.isVideoTexture === !0 || F.format === m2 || he !== Ro && (he === Tt ? a === !1 ? e.has("EXT_sRGB") === !0 && me === wr ? (F.format = m2, F.minFilter = Zt, F.generateMipmaps = !1) : U = JL.sRGBToLinear(U) : (me !== wr || Ae !== Mi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", he)), U;
  }
  this.allocateTextureUnit = oe, this.resetTextureUnits = se, this.setTexture2D = ce, this.setTexture2DArray = te, this.setTexture3D = ee, this.setTextureCube = Re, this.rebindTextures = L, this.setupRenderTarget = fe, this.updateRenderTargetMipmap = ae, this.updateMultisampleRenderTarget = $, this.setupDepthRenderbuffer = Le, this.setupFrameBufferTexture = je, this.useMultisampledRTT = re;
}
function Rj(n, e, t) {
  const i = t.isWebGL2;
  function r(s, o = null) {
    let a;
    if (s === Mi)
      return 5121;
    if (s === _9)
      return 32819;
    if (s === b9)
      return 32820;
    if (s === m9)
      return 5120;
    if (s === v9)
      return 5122;
    if (s === jL)
      return 5123;
    if (s === g9)
      return 5124;
    if (s === cc)
      return 5125;
    if (s === Qs)
      return 5126;
    if (s === $r)
      return i ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
    if (s === y9)
      return 6406;
    if (s === wr)
      return 6408;
    if (s === sE)
      return 6409;
    if (s === w9)
      return 6410;
    if (s === Pu)
      return 6402;
    if (s === Xu)
      return 34041;
    if (s === qL)
      return 6403;
    if (s === x9)
      return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
    if (s === m2)
      return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === S9)
      return 36244;
    if (s === XL)
      return 33319;
    if (s === M9)
      return 33320;
    if (s === E9)
      return 36249;
    if (s === u1 || s === h1 || s === d1 || s === f1)
      if (o === Tt)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (s === u1)
            return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === h1)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === d1)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === f1)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (s === u1)
          return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === h1)
          return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === d1)
          return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === f1)
          return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === BT || s === UT || s === VT || s === HT)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (s === BT)
          return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === UT)
          return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === VT)
          return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === HT)
          return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === C9)
      return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === GT || s === WT)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (s === GT)
          return o === Tt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === WT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === jT || s === qT || s === XT || s === $T || s === ZT || s === YT || s === KT || s === JT || s === QT || s === eP || s === tP || s === nP || s === iP || s === rP)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (s === jT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === qT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === XT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === $T)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === ZT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === YT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === KT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === JT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === QT)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === eP)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === tP)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === nP)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === iP)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === rP)
          return o === Tt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === sP)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (s === sP)
          return o === Tt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    return s === Tu ? i ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null;
  }
  return { convert: r };
}
class kj extends ni {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class ul extends wn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const Lj = { type: "move" };
class U1 {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new ul(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new ul(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Z(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Z()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new ul(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Z(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Z()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, i) {
    let r = null, s = null, o = null;
    const a = this._targetRay, l = this._grip, c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const x of e.hand.values()) {
          const y = t.getJointPose(x, i);
          if (c.joints[x.jointName] === void 0) {
            const C = new ul();
            C.matrixAutoUpdate = !1, C.visible = !1, c.joints[x.jointName] = C, c.add(C);
          }
          const S = c.joints[x.jointName];
          y !== null && (S.matrix.fromArray(y.transform.matrix), S.matrix.decompose(S.position, S.rotation, S.scale), S.jointRadius = y.radius), S.visible = y !== null;
        }
        const d = c.joints["index-finger-tip"], p = c.joints["thumb-tip"], m = d.position.distanceTo(p.position), v = 0.02, b = 5e-3;
        c.inputState.pinching && m > v + b ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !c.inputState.pinching && m <= v - b && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
      a !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Lj)));
    }
    return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this;
  }
}
class hD extends Wi {
  constructor(e, t, i, r, s, o, a, l, c, d) {
    if (d = d !== void 0 ? d : Pu, d !== Pu && d !== Xu)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && d === Pu && (i = cc), i === void 0 && d === Xu && (i = Tu), super(null, r, s, o, a, l, d, i, c), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : kn, this.minFilter = l !== void 0 ? l : kn, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Dj extends ga {
  constructor(e, t) {
    super();
    const i = this;
    let r = null, s = 1, o = null, a = "local-floor", l = null, c = null, d = null, p = null, m = null, v = null;
    const b = t.getContextAttributes();
    let x = null, y = null;
    const S = [], C = [], M = new ni();
    M.layers.enable(1), M.viewport = new gn();
    const T = new ni();
    T.layers.enable(2), T.viewport = new gn();
    const P = [M, T], D = new kj();
    D.layers.enable(1), D.layers.enable(2);
    let I = null, k = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(Q) {
      let ce = S[Q];
      return ce === void 0 && (ce = new U1(), S[Q] = ce), ce.getTargetRaySpace();
    }, this.getControllerGrip = function(Q) {
      let ce = S[Q];
      return ce === void 0 && (ce = new U1(), S[Q] = ce), ce.getGripSpace();
    }, this.getHand = function(Q) {
      let ce = S[Q];
      return ce === void 0 && (ce = new U1(), S[Q] = ce), ce.getHandSpace();
    };
    function O(Q) {
      const ce = C.indexOf(Q.inputSource);
      if (ce === -1)
        return;
      const te = S[ce];
      te !== void 0 && te.dispatchEvent({ type: Q.type, data: Q.inputSource });
    }
    function B() {
      r.removeEventListener("select", O), r.removeEventListener("selectstart", O), r.removeEventListener("selectend", O), r.removeEventListener("squeeze", O), r.removeEventListener("squeezestart", O), r.removeEventListener("squeezeend", O), r.removeEventListener("end", B), r.removeEventListener("inputsourceschange", Y);
      for (let Q = 0; Q < S.length; Q++) {
        const ce = C[Q];
        ce !== null && (C[Q] = null, S[Q].disconnect(ce));
      }
      I = null, k = null, e.setRenderTarget(x), m = null, p = null, d = null, r = null, y = null, oe.stop(), i.isPresenting = !1, i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(Q) {
      s = Q, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(Q) {
      a = Q, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return l || o;
    }, this.setReferenceSpace = function(Q) {
      l = Q;
    }, this.getBaseLayer = function() {
      return p !== null ? p : m;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return v;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(Q) {
      if (r = Q, r !== null) {
        if (x = e.getRenderTarget(), r.addEventListener("select", O), r.addEventListener("selectstart", O), r.addEventListener("selectend", O), r.addEventListener("squeeze", O), r.addEventListener("squeezestart", O), r.addEventListener("squeezeend", O), r.addEventListener("end", B), r.addEventListener("inputsourceschange", Y), b.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const ce = {
            antialias: r.renderState.layers === void 0 ? b.antialias : !0,
            alpha: b.alpha,
            depth: b.depth,
            stencil: b.stencil,
            framebufferScaleFactor: s
          };
          m = new XRWebGLLayer(r, t, ce), r.updateRenderState({ baseLayer: m }), y = new On(
            m.framebufferWidth,
            m.framebufferHeight,
            {
              format: wr,
              type: Mi,
              encoding: e.outputEncoding,
              stencilBuffer: b.stencil
            }
          );
        } else {
          let ce = null, te = null, ee = null;
          b.depth && (ee = b.stencil ? 35056 : 33190, ce = b.stencil ? Xu : Pu, te = b.stencil ? Tu : cc);
          const Re = {
            colorFormat: 32856,
            depthFormat: ee,
            scaleFactor: s
          };
          d = new XRWebGLBinding(r, t), p = d.createProjectionLayer(Re), r.updateRenderState({ layers: [p] }), y = new On(
            p.textureWidth,
            p.textureHeight,
            {
              format: wr,
              type: Mi,
              depthTexture: new hD(p.textureWidth, p.textureHeight, te, void 0, void 0, void 0, void 0, void 0, void 0, ce),
              stencilBuffer: b.stencil,
              encoding: e.outputEncoding,
              samples: b.antialias ? 4 : 0
            }
          );
          const ye = e.properties.get(y);
          ye.__ignoreDepthValues = p.ignoreDepthValues;
        }
        y.isXRRenderTarget = !0, this.setFoveation(1), l = null, o = await r.requestReferenceSpace(a), oe.setContext(r), oe.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    };
    function Y(Q) {
      for (let ce = 0; ce < Q.removed.length; ce++) {
        const te = Q.removed[ce], ee = C.indexOf(te);
        ee >= 0 && (C[ee] = null, S[ee].dispatchEvent({ type: "disconnected", data: te }));
      }
      for (let ce = 0; ce < Q.added.length; ce++) {
        const te = Q.added[ce];
        let ee = C.indexOf(te);
        if (ee === -1) {
          for (let ye = 0; ye < S.length; ye++)
            if (ye >= C.length) {
              C.push(te), ee = ye;
              break;
            } else if (C[ye] === null) {
              C[ye] = te, ee = ye;
              break;
            }
          if (ee === -1)
            break;
        }
        const Re = S[ee];
        Re && Re.dispatchEvent({ type: "connected", data: te });
      }
    }
    const G = new Z(), K = new Z();
    function A(Q, ce, te) {
      G.setFromMatrixPosition(ce.matrixWorld), K.setFromMatrixPosition(te.matrixWorld);
      const ee = G.distanceTo(K), Re = ce.projectionMatrix.elements, ye = te.projectionMatrix.elements, Se = Re[14] / (Re[10] - 1), Ee = Re[14] / (Re[10] + 1), gt = (Re[9] + 1) / Re[5], qe = (Re[9] - 1) / Re[5], Ze = (Re[8] - 1) / Re[0], je = (ye[8] + 1) / ye[0], st = Se * Ze, Ie = Se * je, Le = ee / (-Ze + je), L = Le * -Ze;
      ce.matrixWorld.decompose(Q.position, Q.quaternion, Q.scale), Q.translateX(L), Q.translateZ(Le), Q.matrixWorld.compose(Q.position, Q.quaternion, Q.scale), Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
      const fe = Se + Le, ae = Ee + Le, $ = st - L, j = Ie + (ee - L), re = gt * Ee / ae * fe, Te = qe * Ee / ae * fe;
      Q.projectionMatrix.makePerspective($, j, re, Te, fe, ae);
    }
    function J(Q, ce) {
      ce === null ? Q.matrixWorld.copy(Q.matrix) : Q.matrixWorld.multiplyMatrices(ce.matrixWorld, Q.matrix), Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
    }
    this.updateCamera = function(Q) {
      if (r === null)
        return;
      D.near = T.near = M.near = Q.near, D.far = T.far = M.far = Q.far, (I !== D.near || k !== D.far) && (r.updateRenderState({
        depthNear: D.near,
        depthFar: D.far
      }), I = D.near, k = D.far);
      const ce = Q.parent, te = D.cameras;
      J(D, ce);
      for (let Re = 0; Re < te.length; Re++)
        J(te[Re], ce);
      D.matrixWorld.decompose(D.position, D.quaternion, D.scale), Q.matrix.copy(D.matrix), Q.matrix.decompose(Q.position, Q.quaternion, Q.scale);
      const ee = Q.children;
      for (let Re = 0, ye = ee.length; Re < ye; Re++)
        ee[Re].updateMatrixWorld(!0);
      te.length === 2 ? A(D, M, T) : D.projectionMatrix.copy(M.projectionMatrix);
    }, this.getCamera = function() {
      return D;
    }, this.getFoveation = function() {
      if (p !== null)
        return p.fixedFoveation;
      if (m !== null)
        return m.fixedFoveation;
    }, this.setFoveation = function(Q) {
      p !== null && (p.fixedFoveation = Q), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = Q);
    };
    let xe = null;
    function se(Q, ce) {
      if (c = ce.getViewerPose(l || o), v = ce, c !== null) {
        const te = c.views;
        m !== null && (e.setRenderTargetFramebuffer(y, m.framebuffer), e.setRenderTarget(y));
        let ee = !1;
        te.length !== D.cameras.length && (D.cameras.length = 0, ee = !0);
        for (let Re = 0; Re < te.length; Re++) {
          const ye = te[Re];
          let Se = null;
          if (m !== null)
            Se = m.getViewport(ye);
          else {
            const gt = d.getViewSubImage(p, ye);
            Se = gt.viewport, Re === 0 && (e.setRenderTargetTextures(
              y,
              gt.colorTexture,
              p.ignoreDepthValues ? void 0 : gt.depthStencilTexture
            ), e.setRenderTarget(y));
          }
          let Ee = P[Re];
          Ee === void 0 && (Ee = new ni(), Ee.layers.enable(Re), Ee.viewport = new gn(), P[Re] = Ee), Ee.matrix.fromArray(ye.transform.matrix), Ee.projectionMatrix.fromArray(ye.projectionMatrix), Ee.viewport.set(Se.x, Se.y, Se.width, Se.height), Re === 0 && D.matrix.copy(Ee.matrix), ee === !0 && D.cameras.push(Ee);
        }
      }
      for (let te = 0; te < S.length; te++) {
        const ee = C[te], Re = S[te];
        ee !== null && Re !== void 0 && Re.update(ee, ce, l || o);
      }
      xe && xe(Q, ce), v = null;
    }
    const oe = new sD();
    oe.setAnimationLoop(se), this.setAnimationLoop = function(Q) {
      xe = Q;
    }, this.dispose = function() {
    };
  }
}
function Ij(n, e) {
  function t(x, y) {
    x.fogColor.value.copy(y.color), y.isFog ? (x.fogNear.value = y.near, x.fogFar.value = y.far) : y.isFogExp2 && (x.fogDensity.value = y.density);
  }
  function i(x, y, S, C, M) {
    y.isMeshBasicMaterial || y.isMeshLambertMaterial ? r(x, y) : y.isMeshToonMaterial ? (r(x, y), d(x, y)) : y.isMeshPhongMaterial ? (r(x, y), c(x, y)) : y.isMeshStandardMaterial ? (r(x, y), p(x, y), y.isMeshPhysicalMaterial && m(x, y, M)) : y.isMeshMatcapMaterial ? (r(x, y), v(x, y)) : y.isMeshDepthMaterial ? r(x, y) : y.isMeshDistanceMaterial ? (r(x, y), b(x, y)) : y.isMeshNormalMaterial ? r(x, y) : y.isLineBasicMaterial ? (s(x, y), y.isLineDashedMaterial && o(x, y)) : y.isPointsMaterial ? a(x, y, S, C) : y.isSpriteMaterial ? l(x, y) : y.isShadowMaterial ? (x.color.value.copy(y.color), x.opacity.value = y.opacity) : y.isShaderMaterial && (y.uniformsNeedUpdate = !1);
  }
  function r(x, y) {
    x.opacity.value = y.opacity, y.color && x.diffuse.value.copy(y.color), y.emissive && x.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity), y.map && (x.map.value = y.map), y.alphaMap && (x.alphaMap.value = y.alphaMap), y.bumpMap && (x.bumpMap.value = y.bumpMap, x.bumpScale.value = y.bumpScale, y.side === cr && (x.bumpScale.value *= -1)), y.displacementMap && (x.displacementMap.value = y.displacementMap, x.displacementScale.value = y.displacementScale, x.displacementBias.value = y.displacementBias), y.emissiveMap && (x.emissiveMap.value = y.emissiveMap), y.normalMap && (x.normalMap.value = y.normalMap, x.normalScale.value.copy(y.normalScale), y.side === cr && x.normalScale.value.negate()), y.specularMap && (x.specularMap.value = y.specularMap), y.alphaTest > 0 && (x.alphaTest.value = y.alphaTest);
    const S = e.get(y).envMap;
    if (S && (x.envMap.value = S, x.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, x.reflectivity.value = y.reflectivity, x.ior.value = y.ior, x.refractionRatio.value = y.refractionRatio), y.lightMap) {
      x.lightMap.value = y.lightMap;
      const T = n.physicallyCorrectLights !== !0 ? Math.PI : 1;
      x.lightMapIntensity.value = y.lightMapIntensity * T;
    }
    y.aoMap && (x.aoMap.value = y.aoMap, x.aoMapIntensity.value = y.aoMapIntensity);
    let C;
    y.map ? C = y.map : y.specularMap ? C = y.specularMap : y.displacementMap ? C = y.displacementMap : y.normalMap ? C = y.normalMap : y.bumpMap ? C = y.bumpMap : y.roughnessMap ? C = y.roughnessMap : y.metalnessMap ? C = y.metalnessMap : y.alphaMap ? C = y.alphaMap : y.emissiveMap ? C = y.emissiveMap : y.clearcoatMap ? C = y.clearcoatMap : y.clearcoatNormalMap ? C = y.clearcoatNormalMap : y.clearcoatRoughnessMap ? C = y.clearcoatRoughnessMap : y.iridescenceMap ? C = y.iridescenceMap : y.iridescenceThicknessMap ? C = y.iridescenceThicknessMap : y.specularIntensityMap ? C = y.specularIntensityMap : y.specularColorMap ? C = y.specularColorMap : y.transmissionMap ? C = y.transmissionMap : y.thicknessMap ? C = y.thicknessMap : y.sheenColorMap ? C = y.sheenColorMap : y.sheenRoughnessMap && (C = y.sheenRoughnessMap), C !== void 0 && (C.isWebGLRenderTarget && (C = C.texture), C.matrixAutoUpdate === !0 && C.updateMatrix(), x.uvTransform.value.copy(C.matrix));
    let M;
    y.aoMap ? M = y.aoMap : y.lightMap && (M = y.lightMap), M !== void 0 && (M.isWebGLRenderTarget && (M = M.texture), M.matrixAutoUpdate === !0 && M.updateMatrix(), x.uv2Transform.value.copy(M.matrix));
  }
  function s(x, y) {
    x.diffuse.value.copy(y.color), x.opacity.value = y.opacity;
  }
  function o(x, y) {
    x.dashSize.value = y.dashSize, x.totalSize.value = y.dashSize + y.gapSize, x.scale.value = y.scale;
  }
  function a(x, y, S, C) {
    x.diffuse.value.copy(y.color), x.opacity.value = y.opacity, x.size.value = y.size * S, x.scale.value = C * 0.5, y.map && (x.map.value = y.map), y.alphaMap && (x.alphaMap.value = y.alphaMap), y.alphaTest > 0 && (x.alphaTest.value = y.alphaTest);
    let M;
    y.map ? M = y.map : y.alphaMap && (M = y.alphaMap), M !== void 0 && (M.matrixAutoUpdate === !0 && M.updateMatrix(), x.uvTransform.value.copy(M.matrix));
  }
  function l(x, y) {
    x.diffuse.value.copy(y.color), x.opacity.value = y.opacity, x.rotation.value = y.rotation, y.map && (x.map.value = y.map), y.alphaMap && (x.alphaMap.value = y.alphaMap), y.alphaTest > 0 && (x.alphaTest.value = y.alphaTest);
    let S;
    y.map ? S = y.map : y.alphaMap && (S = y.alphaMap), S !== void 0 && (S.matrixAutoUpdate === !0 && S.updateMatrix(), x.uvTransform.value.copy(S.matrix));
  }
  function c(x, y) {
    x.specular.value.copy(y.specular), x.shininess.value = Math.max(y.shininess, 1e-4);
  }
  function d(x, y) {
    y.gradientMap && (x.gradientMap.value = y.gradientMap);
  }
  function p(x, y) {
    x.roughness.value = y.roughness, x.metalness.value = y.metalness, y.roughnessMap && (x.roughnessMap.value = y.roughnessMap), y.metalnessMap && (x.metalnessMap.value = y.metalnessMap), e.get(y).envMap && (x.envMapIntensity.value = y.envMapIntensity);
  }
  function m(x, y, S) {
    x.ior.value = y.ior, y.sheen > 0 && (x.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen), x.sheenRoughness.value = y.sheenRoughness, y.sheenColorMap && (x.sheenColorMap.value = y.sheenColorMap), y.sheenRoughnessMap && (x.sheenRoughnessMap.value = y.sheenRoughnessMap)), y.clearcoat > 0 && (x.clearcoat.value = y.clearcoat, x.clearcoatRoughness.value = y.clearcoatRoughness, y.clearcoatMap && (x.clearcoatMap.value = y.clearcoatMap), y.clearcoatRoughnessMap && (x.clearcoatRoughnessMap.value = y.clearcoatRoughnessMap), y.clearcoatNormalMap && (x.clearcoatNormalScale.value.copy(y.clearcoatNormalScale), x.clearcoatNormalMap.value = y.clearcoatNormalMap, y.side === cr && x.clearcoatNormalScale.value.negate())), y.iridescence > 0 && (x.iridescence.value = y.iridescence, x.iridescenceIOR.value = y.iridescenceIOR, x.iridescenceThicknessMinimum.value = y.iridescenceThicknessRange[0], x.iridescenceThicknessMaximum.value = y.iridescenceThicknessRange[1], y.iridescenceMap && (x.iridescenceMap.value = y.iridescenceMap), y.iridescenceThicknessMap && (x.iridescenceThicknessMap.value = y.iridescenceThicknessMap)), y.transmission > 0 && (x.transmission.value = y.transmission, x.transmissionSamplerMap.value = S.texture, x.transmissionSamplerSize.value.set(S.width, S.height), y.transmissionMap && (x.transmissionMap.value = y.transmissionMap), x.thickness.value = y.thickness, y.thicknessMap && (x.thicknessMap.value = y.thicknessMap), x.attenuationDistance.value = y.attenuationDistance, x.attenuationColor.value.copy(y.attenuationColor)), x.specularIntensity.value = y.specularIntensity, x.specularColor.value.copy(y.specularColor), y.specularIntensityMap && (x.specularIntensityMap.value = y.specularIntensityMap), y.specularColorMap && (x.specularColorMap.value = y.specularColorMap);
  }
  function v(x, y) {
    y.matcap && (x.matcap.value = y.matcap);
  }
  function b(x, y) {
    x.referencePosition.value.copy(y.referencePosition), x.nearDistance.value = y.nearDistance, x.farDistance.value = y.farDistance;
  }
  return {
    refreshFogUniforms: t,
    refreshMaterialUniforms: i
  };
}
function Oj(n, e, t, i) {
  let r = {}, s = {}, o = [];
  const a = t.isWebGL2 ? n.getParameter(35375) : 0;
  function l(C, M) {
    const T = M.program;
    i.uniformBlockBinding(C, T);
  }
  function c(C, M) {
    let T = r[C.id];
    T === void 0 && (b(C), T = d(C), r[C.id] = T, C.addEventListener("dispose", y));
    const P = M.program;
    i.updateUBOMapping(C, P);
    const D = e.render.frame;
    s[C.id] !== D && (m(C), s[C.id] = D);
  }
  function d(C) {
    const M = p();
    C.__bindingPointIndex = M;
    const T = n.createBuffer(), P = C.__size, D = C.usage;
    return n.bindBuffer(35345, T), n.bufferData(35345, P, D), n.bindBuffer(35345, null), n.bindBufferBase(35345, M, T), T;
  }
  function p() {
    for (let C = 0; C < a; C++)
      if (o.indexOf(C) === -1)
        return o.push(C), C;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function m(C) {
    const M = r[C.id], T = C.uniforms, P = C.__cache;
    n.bindBuffer(35345, M);
    for (let D = 0, I = T.length; D < I; D++) {
      const k = T[D];
      if (v(k, D, P) === !0) {
        const O = k.value, B = k.__offset;
        typeof O == "number" ? (k.__data[0] = O, n.bufferSubData(35345, B, k.__data)) : (k.value.isMatrix3 ? (k.__data[0] = k.value.elements[0], k.__data[1] = k.value.elements[1], k.__data[2] = k.value.elements[2], k.__data[3] = k.value.elements[0], k.__data[4] = k.value.elements[3], k.__data[5] = k.value.elements[4], k.__data[6] = k.value.elements[5], k.__data[7] = k.value.elements[0], k.__data[8] = k.value.elements[6], k.__data[9] = k.value.elements[7], k.__data[10] = k.value.elements[8], k.__data[11] = k.value.elements[0]) : O.toArray(k.__data), n.bufferSubData(35345, B, k.__data));
      }
    }
    n.bindBuffer(35345, null);
  }
  function v(C, M, T) {
    const P = C.value;
    if (T[M] === void 0)
      return typeof P == "number" ? T[M] = P : T[M] = P.clone(), !0;
    if (typeof P == "number") {
      if (T[M] !== P)
        return T[M] = P, !0;
    } else {
      const D = T[M];
      if (D.equals(P) === !1)
        return D.copy(P), !0;
    }
    return !1;
  }
  function b(C) {
    const M = C.uniforms;
    let T = 0;
    const P = 16;
    let D = 0;
    for (let I = 0, k = M.length; I < k; I++) {
      const O = M[I], B = x(O);
      if (O.__data = new Float32Array(B.storage / Float32Array.BYTES_PER_ELEMENT), O.__offset = T, I > 0) {
        D = T % P;
        const Y = P - D;
        D !== 0 && Y - B.boundary < 0 && (T += P - D, O.__offset = T);
      }
      T += B.storage;
    }
    return D = T % P, D > 0 && (T += P - D), C.__size = T, C.__cache = {}, this;
  }
  function x(C) {
    const M = C.value, T = {
      boundary: 0,
      storage: 0
    };
    return typeof M == "number" ? (T.boundary = 4, T.storage = 4) : M.isVector2 ? (T.boundary = 8, T.storage = 8) : M.isVector3 || M.isColor ? (T.boundary = 16, T.storage = 12) : M.isVector4 ? (T.boundary = 16, T.storage = 16) : M.isMatrix3 ? (T.boundary = 48, T.storage = 48) : M.isMatrix4 ? (T.boundary = 64, T.storage = 64) : M.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", M), T;
  }
  function y(C) {
    const M = C.target;
    M.removeEventListener("dispose", y);
    const T = o.indexOf(M.__bindingPointIndex);
    o.splice(T, 1), n.deleteBuffer(r[M.id]), delete r[M.id], delete s[M.id];
  }
  function S() {
    for (const C in r)
      n.deleteBuffer(r[C]);
    o = [], r = {}, s = {};
  }
  return {
    bind: l,
    update: c,
    dispose: S
  };
}
function Nj() {
  const n = Zm("canvas");
  return n.style.display = "block", n;
}
function dD(n = {}) {
  this.isWebGLRenderer = !0;
  const e = n.canvas !== void 0 ? n.canvas : Nj(), t = n.context !== void 0 ? n.context : null, i = n.depth !== void 0 ? n.depth : !0, r = n.stencil !== void 0 ? n.stencil : !0, s = n.antialias !== void 0 ? n.antialias : !1, o = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0, a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1, l = n.powerPreference !== void 0 ? n.powerPreference : "default", c = n.failIfMajorPerformanceCaveat !== void 0 ? n.failIfMajorPerformanceCaveat : !1;
  let d;
  t !== null ? d = t.getContextAttributes().alpha : d = n.alpha !== void 0 ? n.alpha : !1;
  let p = null, m = null;
  const v = [], b = [];
  this.domElement = e, this.debug = {
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Ro, this.physicallyCorrectLights = !1, this.toneMapping = dl, this.toneMappingExposure = 1, Object.defineProperties(this, {
    gammaFactor: {
      get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      }
    }
  });
  const x = this;
  let y = !1, S = 0, C = 0, M = null, T = -1, P = null;
  const D = new gn(), I = new gn();
  let k = null, O = e.width, B = e.height, Y = 1, G = null, K = null;
  const A = new gn(0, 0, O, B), J = new gn(0, 0, O, B);
  let xe = !1;
  const se = new by();
  let oe = !1, Q = !1, ce = null;
  const te = new Pt(), ee = new ze(), Re = new Z(), ye = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function Se() {
    return M === null ? Y : 1;
  }
  let Ee = t;
  function gt(X, ge) {
    for (let we = 0; we < X.length; we++) {
      const de = X[we], ke = e.getContext(de, ge);
      if (ke !== null)
        return ke;
    }
    return null;
  }
  try {
    const X = {
      alpha: !0,
      depth: i,
      stencil: r,
      antialias: s,
      premultipliedAlpha: o,
      preserveDrawingBuffer: a,
      powerPreference: l,
      failIfMajorPerformanceCaveat: c
    };
    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${rh}`), e.addEventListener("webglcontextlost", Mt, !1), e.addEventListener("webglcontextrestored", At, !1), e.addEventListener("webglcontextcreationerror", Bt, !1), Ee === null) {
      const ge = ["webgl2", "webgl", "experimental-webgl"];
      if (x.isWebGL1Renderer === !0 && ge.shift(), Ee = gt(ge, X), Ee === null)
        throw gt(ge) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    Ee.getShaderPrecisionFormat === void 0 && (Ee.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (X) {
    throw console.error("THREE.WebGLRenderer: " + X.message), X;
  }
  let qe, Ze, je, st, Ie, Le, L, fe, ae, $, j, re, Te, Ce, F, U, he, me, Ae, Ve, $e, Me, lt, Ye;
  function ht() {
    qe = new ZG(Ee), Ze = new GG(Ee, qe, n), qe.init(Ze), Me = new Rj(Ee, qe, Ze), je = new Pj(Ee, qe, Ze), st = new JG(), Ie = new mj(), Le = new Aj(Ee, qe, je, Ie, Ze, Me, st), L = new jG(x), fe = new $G(x), ae = new c7(Ee, Ze), lt = new VG(Ee, qe, ae, Ze), $ = new YG(Ee, ae, st, lt), j = new nW(Ee, $, ae, st), Ae = new tW(Ee, Ze, Le), U = new WG(Ie), re = new pj(x, L, fe, qe, Ze, lt, U), Te = new Ij(x, Ie), Ce = new gj(), F = new Sj(qe, Ze), me = new UG(x, L, je, j, d, o), he = new Tj(x, j, Ze), Ye = new Oj(Ee, st, Ze, je), Ve = new HG(Ee, qe, st, Ze), $e = new KG(Ee, qe, st, Ze), st.programs = re.programs, x.capabilities = Ze, x.extensions = qe, x.properties = Ie, x.renderLists = Ce, x.shadowMap = he, x.state = je, x.info = st;
  }
  ht();
  const Xe = new Dj(x, Ee);
  this.xr = Xe, this.getContext = function() {
    return Ee;
  }, this.getContextAttributes = function() {
    return Ee.getContextAttributes();
  }, this.forceContextLoss = function() {
    const X = qe.get("WEBGL_lose_context");
    X && X.loseContext();
  }, this.forceContextRestore = function() {
    const X = qe.get("WEBGL_lose_context");
    X && X.restoreContext();
  }, this.getPixelRatio = function() {
    return Y;
  }, this.setPixelRatio = function(X) {
    X !== void 0 && (Y = X, this.setSize(O, B, !1));
  }, this.getSize = function(X) {
    return X.set(O, B);
  }, this.setSize = function(X, ge, we) {
    if (Xe.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    O = X, B = ge, e.width = Math.floor(X * Y), e.height = Math.floor(ge * Y), we !== !1 && (e.style.width = X + "px", e.style.height = ge + "px"), this.setViewport(0, 0, X, ge);
  }, this.getDrawingBufferSize = function(X) {
    return X.set(O * Y, B * Y).floor();
  }, this.setDrawingBufferSize = function(X, ge, we) {
    O = X, B = ge, Y = we, e.width = Math.floor(X * we), e.height = Math.floor(ge * we), this.setViewport(0, 0, X, ge);
  }, this.getCurrentViewport = function(X) {
    return X.copy(D);
  }, this.getViewport = function(X) {
    return X.copy(A);
  }, this.setViewport = function(X, ge, we, de) {
    X.isVector4 ? A.set(X.x, X.y, X.z, X.w) : A.set(X, ge, we, de), je.viewport(D.copy(A).multiplyScalar(Y).floor());
  }, this.getScissor = function(X) {
    return X.copy(J);
  }, this.setScissor = function(X, ge, we, de) {
    X.isVector4 ? J.set(X.x, X.y, X.z, X.w) : J.set(X, ge, we, de), je.scissor(I.copy(J).multiplyScalar(Y).floor());
  }, this.getScissorTest = function() {
    return xe;
  }, this.setScissorTest = function(X) {
    je.setScissorTest(xe = X);
  }, this.setOpaqueSort = function(X) {
    G = X;
  }, this.setTransparentSort = function(X) {
    K = X;
  }, this.getClearColor = function(X) {
    return X.copy(me.getClearColor());
  }, this.setClearColor = function() {
    me.setClearColor.apply(me, arguments);
  }, this.getClearAlpha = function() {
    return me.getClearAlpha();
  }, this.setClearAlpha = function() {
    me.setClearAlpha.apply(me, arguments);
  }, this.clear = function(X = !0, ge = !0, we = !0) {
    let de = 0;
    X && (de |= 16384), ge && (de |= 256), we && (de |= 1024), Ee.clear(de);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", Mt, !1), e.removeEventListener("webglcontextrestored", At, !1), e.removeEventListener("webglcontextcreationerror", Bt, !1), Ce.dispose(), F.dispose(), Ie.dispose(), L.dispose(), fe.dispose(), j.dispose(), lt.dispose(), Ye.dispose(), re.dispose(), Xe.dispose(), Xe.removeEventListener("sessionstart", Ft), Xe.removeEventListener("sessionend", An), ce && (ce.dispose(), ce = null), Hn.stop();
  };
  function Mt(X) {
    X.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0;
  }
  function At() {
    console.log("THREE.WebGLRenderer: Context Restored."), y = !1;
    const X = st.autoReset, ge = he.enabled, we = he.autoUpdate, de = he.needsUpdate, ke = he.type;
    ht(), st.autoReset = X, he.enabled = ge, he.autoUpdate = we, he.needsUpdate = de, he.type = ke;
  }
  function Bt(X) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", X.statusMessage);
  }
  function pe(X) {
    const ge = X.target;
    ge.removeEventListener("dispose", pe), ot(ge);
  }
  function ot(X) {
    De(X), Ie.remove(X);
  }
  function De(X) {
    const ge = Ie.get(X).programs;
    ge !== void 0 && (ge.forEach(function(we) {
      re.releaseProgram(we);
    }), X.isShaderMaterial && re.releaseShaderCache(X));
  }
  this.renderBufferDirect = function(X, ge, we, de, ke, it) {
    ge === null && (ge = ye);
    const ct = ke.isMesh && ke.matrixWorld.determinant() < 0, Et = We(X, ge, we, de, ke);
    je.setMaterial(de, ct);
    let Ct = we.index;
    const Yt = we.attributes.position;
    if (Ct === null) {
      if (Yt === void 0 || Yt.count === 0)
        return;
    } else if (Ct.count === 0)
      return;
    let Ot = 1;
    de.wireframe === !0 && (Ct = $.getWireframeAttribute(we), Ot = 2), lt.setup(ke, de, Et, we, Ct);
    let tn, zn = Ve;
    Ct !== null && (tn = ae.get(Ct), zn = $e, zn.setIndex(tn));
    const ao = Ct !== null ? Ct.count : Yt.count, Ki = we.drawRange.start * Ot, lo = we.drawRange.count * Ot, Ji = it !== null ? it.start * Ot : 0, hn = it !== null ? it.count * Ot : 1 / 0, co = Math.max(Ki, Ji), Qn = Math.min(ao, Ki + lo, Ji + hn) - 1, vi = Math.max(0, Qn - co + 1);
    if (vi !== 0) {
      if (ke.isMesh)
        de.wireframe === !0 ? (je.setLineWidth(de.wireframeLinewidth * Se()), zn.setMode(1)) : zn.setMode(4);
      else if (ke.isLine) {
        let ys = de.linewidth;
        ys === void 0 && (ys = 1), je.setLineWidth(ys * Se()), ke.isLineSegments ? zn.setMode(1) : ke.isLineLoop ? zn.setMode(2) : zn.setMode(3);
      } else
        ke.isPoints ? zn.setMode(0) : ke.isSprite && zn.setMode(4);
      if (ke.isInstancedMesh)
        zn.renderInstances(co, vi, ke.count);
      else if (we.isInstancedBufferGeometry) {
        const ys = Math.min(we.instanceCount, we._maxInstanceCount);
        zn.renderInstances(co, vi, ys);
      } else
        zn.render(co, vi);
    }
  }, this.compile = function(X, ge) {
    function we(de, ke, it) {
      de.transparent === !0 && de.side === Js ? (de.side = cr, de.needsUpdate = !0, pr(de, ke, it), de.side = ju, de.needsUpdate = !0, pr(de, ke, it), de.side = Js) : pr(de, ke, it);
    }
    m = F.get(X), m.init(), b.push(m), X.traverseVisible(function(de) {
      de.isLight && de.layers.test(ge.layers) && (m.pushLight(de), de.castShadow && m.pushShadow(de));
    }), m.setupLights(x.physicallyCorrectLights), X.traverse(function(de) {
      const ke = de.material;
      if (ke)
        if (Array.isArray(ke))
          for (let it = 0; it < ke.length; it++) {
            const ct = ke[it];
            we(ct, X, de);
          }
        else
          we(ke, X, de);
    }), b.pop(), m = null;
  };
  let tt = null;
  function Qe(X) {
    tt && tt(X);
  }
  function Ft() {
    Hn.stop();
  }
  function An() {
    Hn.start();
  }
  const Hn = new sD();
  Hn.setAnimationLoop(Qe), typeof self < "u" && Hn.setContext(self), this.setAnimationLoop = function(X) {
    tt = X, Xe.setAnimationLoop(X), X === null ? Hn.stop() : Hn.start();
  }, Xe.addEventListener("sessionstart", Ft), Xe.addEventListener("sessionend", An), this.render = function(X, ge) {
    if (ge !== void 0 && ge.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (y === !0)
      return;
    X.matrixWorldAutoUpdate === !0 && X.updateMatrixWorld(), ge.parent === null && ge.matrixWorldAutoUpdate === !0 && ge.updateMatrixWorld(), Xe.enabled === !0 && Xe.isPresenting === !0 && (Xe.cameraAutoUpdate === !0 && Xe.updateCamera(ge), ge = Xe.getCamera()), X.isScene === !0 && X.onBeforeRender(x, X, ge, M), m = F.get(X, b.length), m.init(), b.push(m), te.multiplyMatrices(ge.projectionMatrix, ge.matrixWorldInverse), se.setFromProjectionMatrix(te), Q = this.localClippingEnabled, oe = U.init(this.clippingPlanes, Q, ge), p = Ce.get(X, v.length), p.init(), v.push(p), es(X, ge, 0, x.sortObjects), p.finish(), x.sortObjects === !0 && p.sort(G, K), oe === !0 && U.beginShadows();
    const we = m.state.shadowsArray;
    if (he.render(we, X, ge), oe === !0 && U.endShadows(), this.info.autoReset === !0 && this.info.reset(), me.render(p, X), m.setupLights(x.physicallyCorrectLights), ge.isArrayCamera) {
      const de = ge.cameras;
      for (let ke = 0, it = de.length; ke < it; ke++) {
        const ct = de[ke];
        Sn(p, X, ct, ct.viewport);
      }
    } else
      Sn(p, X, ge);
    M !== null && (Le.updateMultisampleRenderTarget(M), Le.updateRenderTargetMipmap(M)), X.isScene === !0 && X.onAfterRender(x, X, ge), lt.resetDefaultState(), T = -1, P = null, b.pop(), b.length > 0 ? m = b[b.length - 1] : m = null, v.pop(), v.length > 0 ? p = v[v.length - 1] : p = null;
  };
  function es(X, ge, we, de) {
    if (X.visible === !1)
      return;
    if (X.layers.test(ge.layers)) {
      if (X.isGroup)
        we = X.renderOrder;
      else if (X.isLOD)
        X.autoUpdate === !0 && X.update(ge);
      else if (X.isLight)
        m.pushLight(X), X.castShadow && m.pushShadow(X);
      else if (X.isSprite) {
        if (!X.frustumCulled || se.intersectsSprite(X)) {
          de && Re.setFromMatrixPosition(X.matrixWorld).applyMatrix4(te);
          const ct = j.update(X), Et = X.material;
          Et.visible && p.push(X, ct, Et, we, Re.z, null);
        }
      } else if ((X.isMesh || X.isLine || X.isPoints) && (X.isSkinnedMesh && X.skeleton.frame !== st.render.frame && (X.skeleton.update(), X.skeleton.frame = st.render.frame), !X.frustumCulled || se.intersectsObject(X))) {
        de && Re.setFromMatrixPosition(X.matrixWorld).applyMatrix4(te);
        const ct = j.update(X), Et = X.material;
        if (Array.isArray(Et)) {
          const Ct = ct.groups;
          for (let Yt = 0, Ot = Ct.length; Yt < Ot; Yt++) {
            const tn = Ct[Yt], zn = Et[tn.materialIndex];
            zn && zn.visible && p.push(X, ct, zn, we, Re.z, tn);
          }
        } else
          Et.visible && p.push(X, ct, Et, we, Re.z, null);
      }
    }
    const it = X.children;
    for (let ct = 0, Et = it.length; ct < Et; ct++)
      es(it[ct], ge, we, de);
  }
  function Sn(X, ge, we, de) {
    const ke = X.opaque, it = X.transmissive, ct = X.transparent;
    m.setupLightsView(we), it.length > 0 && Yi(ke, ge, we), de && je.viewport(D.copy(de)), ke.length > 0 && Gn(ke, ge, we), it.length > 0 && Gn(it, ge, we), ct.length > 0 && Gn(ct, ge, we), je.buffers.depth.setTest(!0), je.buffers.depth.setMask(!0), je.buffers.color.setMask(!0), je.setPolygonOffset(!1);
  }
  function Yi(X, ge, we) {
    const de = Ze.isWebGL2;
    ce === null && (ce = new On(1, 1, {
      generateMipmaps: !0,
      type: qe.has("EXT_color_buffer_half_float") ? $r : Mi,
      minFilter: Pv,
      samples: de && s === !0 ? 4 : 0
    })), x.getDrawingBufferSize(ee), de ? ce.setSize(ee.x, ee.y) : ce.setSize(wb(ee.x), wb(ee.y));
    const ke = x.getRenderTarget();
    x.setRenderTarget(ce), x.clear();
    const it = x.toneMapping;
    x.toneMapping = dl, Gn(X, ge, we), x.toneMapping = it, Le.updateMultisampleRenderTarget(ce), Le.updateRenderTargetMipmap(ce), x.setRenderTarget(ke);
  }
  function Gn(X, ge, we) {
    const de = ge.isScene === !0 ? ge.overrideMaterial : null;
    for (let ke = 0, it = X.length; ke < it; ke++) {
      const ct = X[ke], Et = ct.object, Ct = ct.geometry, Yt = de === null ? ct.material : de, Ot = ct.group;
      Et.layers.test(we.layers) && Ma(Et, ge, we, Ct, Yt, Ot);
    }
  }
  function Ma(X, ge, we, de, ke, it) {
    X.onBeforeRender(x, ge, we, de, ke, it), X.modelViewMatrix.multiplyMatrices(we.matrixWorldInverse, X.matrixWorld), X.normalMatrix.getNormalMatrix(X.modelViewMatrix), ke.onBeforeRender(x, ge, we, de, X, it), ke.transparent === !0 && ke.side === Js ? (ke.side = cr, ke.needsUpdate = !0, x.renderBufferDirect(we, ge, de, ke, X, it), ke.side = ju, ke.needsUpdate = !0, x.renderBufferDirect(we, ge, de, ke, X, it), ke.side = Js) : x.renderBufferDirect(we, ge, de, ke, X, it), X.onAfterRender(x, ge, we, de, ke, it);
  }
  function pr(X, ge, we) {
    ge.isScene !== !0 && (ge = ye);
    const de = Ie.get(X), ke = m.state.lights, it = m.state.shadowsArray, ct = ke.state.version, Et = re.getParameters(X, ke.state, it, ge, we), Ct = re.getProgramCacheKey(Et);
    let Yt = de.programs;
    de.environment = X.isMeshStandardMaterial ? ge.environment : null, de.fog = ge.fog, de.envMap = (X.isMeshStandardMaterial ? fe : L).get(X.envMap || de.environment), Yt === void 0 && (X.addEventListener("dispose", pe), Yt = /* @__PURE__ */ new Map(), de.programs = Yt);
    let Ot = Yt.get(Ct);
    if (Ot !== void 0) {
      if (de.currentProgram === Ot && de.lightsStateVersion === ct)
        return le(X, Et), Ot;
    } else
      Et.uniforms = re.getUniforms(X), X.onBuild(we, Et, x), X.onBeforeCompile(Et, x), Ot = re.acquireProgram(Et, Ct), Yt.set(Ct, Ot), de.uniforms = Et.uniforms;
    const tn = de.uniforms;
    (!X.isShaderMaterial && !X.isRawShaderMaterial || X.clipping === !0) && (tn.clippingPlanes = U.uniform), le(X, Et), de.needsLights = wt(X), de.lightsStateVersion = ct, de.needsLights && (tn.ambientLightColor.value = ke.state.ambient, tn.lightProbe.value = ke.state.probe, tn.directionalLights.value = ke.state.directional, tn.directionalLightShadows.value = ke.state.directionalShadow, tn.spotLights.value = ke.state.spot, tn.spotLightShadows.value = ke.state.spotShadow, tn.rectAreaLights.value = ke.state.rectArea, tn.ltc_1.value = ke.state.rectAreaLTC1, tn.ltc_2.value = ke.state.rectAreaLTC2, tn.pointLights.value = ke.state.point, tn.pointLightShadows.value = ke.state.pointShadow, tn.hemisphereLights.value = ke.state.hemi, tn.directionalShadowMap.value = ke.state.directionalShadowMap, tn.directionalShadowMatrix.value = ke.state.directionalShadowMatrix, tn.spotShadowMap.value = ke.state.spotShadowMap, tn.spotLightMatrix.value = ke.state.spotLightMatrix, tn.spotLightMap.value = ke.state.spotLightMap, tn.pointShadowMap.value = ke.state.pointShadowMap, tn.pointShadowMatrix.value = ke.state.pointShadowMatrix);
    const zn = Ot.getUniforms(), ao = G_.seqWithValue(zn.seq, tn);
    return de.currentProgram = Ot, de.uniformsList = ao, Ot;
  }
  function le(X, ge) {
    const we = Ie.get(X);
    we.outputEncoding = ge.outputEncoding, we.instancing = ge.instancing, we.skinning = ge.skinning, we.morphTargets = ge.morphTargets, we.morphNormals = ge.morphNormals, we.morphColors = ge.morphColors, we.morphTargetsCount = ge.morphTargetsCount, we.numClippingPlanes = ge.numClippingPlanes, we.numIntersection = ge.numClipIntersection, we.vertexAlphas = ge.vertexAlphas, we.vertexTangents = ge.vertexTangents, we.toneMapping = ge.toneMapping;
  }
  function We(X, ge, we, de, ke) {
    ge.isScene !== !0 && (ge = ye), Le.resetTextureUnits();
    const it = ge.fog, ct = de.isMeshStandardMaterial ? ge.environment : null, Et = M === null ? x.outputEncoding : M.isXRRenderTarget === !0 ? M.texture.encoding : Ro, Ct = (de.isMeshStandardMaterial ? fe : L).get(de.envMap || ct), Yt = de.vertexColors === !0 && !!we.attributes.color && we.attributes.color.itemSize === 4, Ot = !!de.normalMap && !!we.attributes.tangent, tn = !!we.morphAttributes.position, zn = !!we.morphAttributes.normal, ao = !!we.morphAttributes.color, Ki = de.toneMapped ? x.toneMapping : dl, lo = we.morphAttributes.position || we.morphAttributes.normal || we.morphAttributes.color, Ji = lo !== void 0 ? lo.length : 0, hn = Ie.get(de), co = m.state.lights;
    if (oe === !0 && (Q === !0 || X !== P)) {
      const Qi = X === P && de.id === T;
      U.setState(de, X, Qi);
    }
    let Qn = !1;
    de.version === hn.__version ? (hn.needsLights && hn.lightsStateVersion !== co.state.version || hn.outputEncoding !== Et || ke.isInstancedMesh && hn.instancing === !1 || !ke.isInstancedMesh && hn.instancing === !0 || ke.isSkinnedMesh && hn.skinning === !1 || !ke.isSkinnedMesh && hn.skinning === !0 || hn.envMap !== Ct || de.fog === !0 && hn.fog !== it || hn.numClippingPlanes !== void 0 && (hn.numClippingPlanes !== U.numPlanes || hn.numIntersection !== U.numIntersection) || hn.vertexAlphas !== Yt || hn.vertexTangents !== Ot || hn.morphTargets !== tn || hn.morphNormals !== zn || hn.morphColors !== ao || hn.toneMapping !== Ki || Ze.isWebGL2 === !0 && hn.morphTargetsCount !== Ji) && (Qn = !0) : (Qn = !0, hn.__version = de.version);
    let vi = hn.currentProgram;
    Qn === !0 && (vi = pr(de, ge, ke));
    let ys = !1, Fo = !1, Ml = !1;
    const Ci = vi.getUniforms(), Hs = hn.uniforms;
    if (je.useProgram(vi.program) && (ys = !0, Fo = !0, Ml = !0), de.id !== T && (T = de.id, Fo = !0), ys || P !== X) {
      if (Ci.setValue(Ee, "projectionMatrix", X.projectionMatrix), Ze.logarithmicDepthBuffer && Ci.setValue(
        Ee,
        "logDepthBufFC",
        2 / (Math.log(X.far + 1) / Math.LN2)
      ), P !== X && (P = X, Fo = !0, Ml = !0), de.isShaderMaterial || de.isMeshPhongMaterial || de.isMeshToonMaterial || de.isMeshStandardMaterial || de.envMap) {
        const Qi = Ci.map.cameraPosition;
        Qi !== void 0 && Qi.setValue(
          Ee,
          Re.setFromMatrixPosition(X.matrixWorld)
        );
      }
      (de.isMeshPhongMaterial || de.isMeshToonMaterial || de.isMeshLambertMaterial || de.isMeshBasicMaterial || de.isMeshStandardMaterial || de.isShaderMaterial) && Ci.setValue(Ee, "isOrthographic", X.isOrthographicCamera === !0), (de.isMeshPhongMaterial || de.isMeshToonMaterial || de.isMeshLambertMaterial || de.isMeshBasicMaterial || de.isMeshStandardMaterial || de.isShaderMaterial || de.isShadowMaterial || ke.isSkinnedMesh) && Ci.setValue(Ee, "viewMatrix", X.matrixWorldInverse);
    }
    if (ke.isSkinnedMesh) {
      Ci.setOptional(Ee, ke, "bindMatrix"), Ci.setOptional(Ee, ke, "bindMatrixInverse");
      const Qi = ke.skeleton;
      Qi && (Ze.floatVertexTextures ? (Qi.boneTexture === null && Qi.computeBoneTexture(), Ci.setValue(Ee, "boneTexture", Qi.boneTexture, Le), Ci.setValue(Ee, "boneTextureSize", Qi.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
    }
    const El = we.morphAttributes;
    if ((El.position !== void 0 || El.normal !== void 0 || El.color !== void 0 && Ze.isWebGL2 === !0) && Ae.update(ke, we, de, vi), (Fo || hn.receiveShadow !== ke.receiveShadow) && (hn.receiveShadow = ke.receiveShadow, Ci.setValue(Ee, "receiveShadow", ke.receiveShadow)), de.isMeshGouraudMaterial && de.envMap !== null && (Hs.envMap.value = Ct, Hs.flipEnvMap.value = Ct.isCubeTexture && Ct.isRenderTargetTexture === !1 ? -1 : 1), Fo && (Ci.setValue(Ee, "toneMappingExposure", x.toneMappingExposure), hn.needsLights && et(Hs, Ml), it && de.fog === !0 && Te.refreshFogUniforms(Hs, it), Te.refreshMaterialUniforms(Hs, de, Y, B, ce), G_.upload(Ee, hn.uniformsList, Hs, Le)), de.isShaderMaterial && de.uniformsNeedUpdate === !0 && (G_.upload(Ee, hn.uniformsList, Hs, Le), de.uniformsNeedUpdate = !1), de.isSpriteMaterial && Ci.setValue(Ee, "center", ke.center), Ci.setValue(Ee, "modelViewMatrix", ke.modelViewMatrix), Ci.setValue(Ee, "normalMatrix", ke.normalMatrix), Ci.setValue(Ee, "modelMatrix", ke.matrixWorld), de.isShaderMaterial || de.isRawShaderMaterial) {
      const Qi = de.uniformsGroups;
      for (let Gs = 0, yh = Qi.length; Gs < yh; Gs++)
        if (Ze.isWebGL2) {
          const Ea = Qi[Gs];
          Ye.update(Ea, vi), Ye.bind(Ea, vi);
        } else
          console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
    }
    return vi;
  }
  function et(X, ge) {
    X.ambientLightColor.needsUpdate = ge, X.lightProbe.needsUpdate = ge, X.directionalLights.needsUpdate = ge, X.directionalLightShadows.needsUpdate = ge, X.pointLights.needsUpdate = ge, X.pointLightShadows.needsUpdate = ge, X.spotLights.needsUpdate = ge, X.spotLightShadows.needsUpdate = ge, X.rectAreaLights.needsUpdate = ge, X.hemisphereLights.needsUpdate = ge;
  }
  function wt(X) {
    return X.isMeshLambertMaterial || X.isMeshToonMaterial || X.isMeshPhongMaterial || X.isMeshStandardMaterial || X.isShadowMaterial || X.isShaderMaterial && X.lights === !0;
  }
  this.getActiveCubeFace = function() {
    return S;
  }, this.getActiveMipmapLevel = function() {
    return C;
  }, this.getRenderTarget = function() {
    return M;
  }, this.setRenderTargetTextures = function(X, ge, we) {
    Ie.get(X.texture).__webglTexture = ge, Ie.get(X.depthTexture).__webglTexture = we;
    const de = Ie.get(X);
    de.__hasExternalTextures = !0, de.__hasExternalTextures && (de.__autoAllocateDepthBuffer = we === void 0, de.__autoAllocateDepthBuffer || qe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), de.__useRenderToTexture = !1));
  }, this.setRenderTargetFramebuffer = function(X, ge) {
    const we = Ie.get(X);
    we.__webglFramebuffer = ge, we.__useDefaultFramebuffer = ge === void 0;
  }, this.setRenderTarget = function(X, ge = 0, we = 0) {
    M = X, S = ge, C = we;
    let de = !0;
    if (X) {
      const Ct = Ie.get(X);
      Ct.__useDefaultFramebuffer !== void 0 ? (je.bindFramebuffer(36160, null), de = !1) : Ct.__webglFramebuffer === void 0 ? Le.setupRenderTarget(X) : Ct.__hasExternalTextures && Le.rebindTextures(X, Ie.get(X.texture).__webglTexture, Ie.get(X.depthTexture).__webglTexture);
    }
    let ke = null, it = !1, ct = !1;
    if (X) {
      const Ct = X.texture;
      (Ct.isData3DTexture || Ct.isDataArrayTexture) && (ct = !0);
      const Yt = Ie.get(X).__webglFramebuffer;
      X.isWebGLCubeRenderTarget ? (ke = Yt[ge], it = !0) : Ze.isWebGL2 && X.samples > 0 && Le.useMultisampledRTT(X) === !1 ? ke = Ie.get(X).__webglMultisampledFramebuffer : ke = Yt, D.copy(X.viewport), I.copy(X.scissor), k = X.scissorTest;
    } else
      D.copy(A).multiplyScalar(Y).floor(), I.copy(J).multiplyScalar(Y).floor(), k = xe;
    if (je.bindFramebuffer(36160, ke) && Ze.drawBuffers && de && je.drawBuffers(X, ke), je.viewport(D), je.scissor(I), je.setScissorTest(k), it) {
      const Ct = Ie.get(X.texture);
      Ee.framebufferTexture2D(36160, 36064, 34069 + ge, Ct.__webglTexture, we);
    } else if (ct) {
      const Ct = Ie.get(X.texture), Yt = ge || 0;
      Ee.framebufferTextureLayer(36160, 36064, Ct.__webglTexture, we || 0, Yt);
    }
    T = -1;
  }, this.readRenderTargetPixels = function(X, ge, we, de, ke, it, ct) {
    if (!(X && X.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let Et = Ie.get(X).__webglFramebuffer;
    if (X.isWebGLCubeRenderTarget && ct !== void 0 && (Et = Et[ct]), Et) {
      je.bindFramebuffer(36160, Et);
      try {
        const Ct = X.texture, Yt = Ct.format, Ot = Ct.type;
        if (Yt !== wr && Me.convert(Yt) !== Ee.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const tn = Ot === $r && (qe.has("EXT_color_buffer_half_float") || Ze.isWebGL2 && qe.has("EXT_color_buffer_float"));
        if (Ot !== Mi && Me.convert(Ot) !== Ee.getParameter(35738) && !(Ot === Qs && (Ze.isWebGL2 || qe.has("OES_texture_float") || qe.has("WEBGL_color_buffer_float"))) && !tn) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        ge >= 0 && ge <= X.width - de && we >= 0 && we <= X.height - ke && Ee.readPixels(ge, we, de, ke, Me.convert(Yt), Me.convert(Ot), it);
      } finally {
        const Ct = M !== null ? Ie.get(M).__webglFramebuffer : null;
        je.bindFramebuffer(36160, Ct);
      }
    }
  }, this.copyFramebufferToTexture = function(X, ge, we = 0) {
    const de = Math.pow(2, -we), ke = Math.floor(ge.image.width * de), it = Math.floor(ge.image.height * de);
    Le.setTexture2D(ge, 0), Ee.copyTexSubImage2D(3553, we, 0, 0, X.x, X.y, ke, it), je.unbindTexture();
  }, this.copyTextureToTexture = function(X, ge, we, de = 0) {
    const ke = ge.image.width, it = ge.image.height, ct = Me.convert(we.format), Et = Me.convert(we.type);
    Le.setTexture2D(we, 0), Ee.pixelStorei(37440, we.flipY), Ee.pixelStorei(37441, we.premultiplyAlpha), Ee.pixelStorei(3317, we.unpackAlignment), ge.isDataTexture ? Ee.texSubImage2D(3553, de, X.x, X.y, ke, it, ct, Et, ge.image.data) : ge.isCompressedTexture ? Ee.compressedTexSubImage2D(3553, de, X.x, X.y, ge.mipmaps[0].width, ge.mipmaps[0].height, ct, ge.mipmaps[0].data) : Ee.texSubImage2D(3553, de, X.x, X.y, ct, Et, ge.image), de === 0 && we.generateMipmaps && Ee.generateMipmap(3553), je.unbindTexture();
  }, this.copyTextureToTexture3D = function(X, ge, we, de, ke = 0) {
    if (x.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const it = X.max.x - X.min.x + 1, ct = X.max.y - X.min.y + 1, Et = X.max.z - X.min.z + 1, Ct = Me.convert(de.format), Yt = Me.convert(de.type);
    let Ot;
    if (de.isData3DTexture)
      Le.setTexture3D(de, 0), Ot = 32879;
    else if (de.isDataArrayTexture)
      Le.setTexture2DArray(de, 0), Ot = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    Ee.pixelStorei(37440, de.flipY), Ee.pixelStorei(37441, de.premultiplyAlpha), Ee.pixelStorei(3317, de.unpackAlignment);
    const tn = Ee.getParameter(3314), zn = Ee.getParameter(32878), ao = Ee.getParameter(3316), Ki = Ee.getParameter(3315), lo = Ee.getParameter(32877), Ji = we.isCompressedTexture ? we.mipmaps[0] : we.image;
    Ee.pixelStorei(3314, Ji.width), Ee.pixelStorei(32878, Ji.height), Ee.pixelStorei(3316, X.min.x), Ee.pixelStorei(3315, X.min.y), Ee.pixelStorei(32877, X.min.z), we.isDataTexture || we.isData3DTexture ? Ee.texSubImage3D(Ot, ke, ge.x, ge.y, ge.z, it, ct, Et, Ct, Yt, Ji.data) : we.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Ee.compressedTexSubImage3D(Ot, ke, ge.x, ge.y, ge.z, it, ct, Et, Ct, Ji.data)) : Ee.texSubImage3D(Ot, ke, ge.x, ge.y, ge.z, it, ct, Et, Ct, Yt, Ji), Ee.pixelStorei(3314, tn), Ee.pixelStorei(32878, zn), Ee.pixelStorei(3316, ao), Ee.pixelStorei(3315, Ki), Ee.pixelStorei(32877, lo), ke === 0 && de.generateMipmaps && Ee.generateMipmap(Ot), je.unbindTexture();
  }, this.initTexture = function(X) {
    X.isCubeTexture ? Le.setTextureCube(X, 0) : X.isData3DTexture ? Le.setTexture3D(X, 0) : X.isDataArrayTexture ? Le.setTexture2DArray(X, 0) : Le.setTexture2D(X, 0), je.unbindTexture();
  }, this.resetState = function() {
    S = 0, C = 0, M = null, je.reset(), lt.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class zj extends dD {
}
zj.prototype.isWebGL1Renderer = !0;
class b2 extends wn {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
  get autoUpdate() {
    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
  }
  set autoUpdate(e) {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e;
  }
}
class fD {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = f2, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = to();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = to()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = to()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Gr = /* @__PURE__ */ new Z();
class aa {
  constructor(e, t, i, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r === !0;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      Gr.fromBufferAttribute(this, t), Gr.applyMatrix4(e), this.setXYZ(t, Gr.x, Gr.y, Gr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Gr.fromBufferAttribute(this, t), Gr.applyNormalMatrix(e), this.setXYZ(t, Gr.x, Gr.y, Gr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Gr.fromBufferAttribute(this, t), Gr.transformDirection(e), this.setXYZ(t, Gr.x, Gr.y, Gr.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = jn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = jn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = jn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = jn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = cl(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = cl(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = cl(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = cl(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = jn(t, this.array), i = jn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = jn(t, this.array), i = jn(i, this.array), r = jn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = jn(t, this.array), i = jn(i, this.array), r = jn(r, this.array), s = jn(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return new Vi(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new aa(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class pD extends zo {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new xt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let ud;
const nm = /* @__PURE__ */ new Z(), hd = /* @__PURE__ */ new Z(), dd = /* @__PURE__ */ new Z(), fd = /* @__PURE__ */ new ze(), im = /* @__PURE__ */ new ze(), mD = /* @__PURE__ */ new Pt(), K0 = /* @__PURE__ */ new Z(), rm = /* @__PURE__ */ new Z(), J0 = /* @__PURE__ */ new Z(), BP = /* @__PURE__ */ new ze(), V1 = /* @__PURE__ */ new ze(), UP = /* @__PURE__ */ new ze();
class Fj extends wn {
  constructor(e) {
    if (super(), this.isSprite = !0, this.type = "Sprite", ud === void 0) {
      ud = new qn();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), i = new fD(t, 5);
      ud.setIndex([0, 1, 2, 0, 2, 3]), ud.setAttribute("position", new aa(i, 3, 0, !1)), ud.setAttribute("uv", new aa(i, 2, 3, !1));
    }
    this.geometry = ud, this.material = e !== void 0 ? e : new pD(), this.center = new ze(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), hd.setFromMatrixScale(this.matrixWorld), mD.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), dd.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && hd.multiplyScalar(-dd.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && (s = Math.cos(i), r = Math.sin(i));
    const o = this.center;
    Q0(K0.set(-0.5, -0.5, 0), dd, o, hd, r, s), Q0(rm.set(0.5, -0.5, 0), dd, o, hd, r, s), Q0(J0.set(0.5, 0.5, 0), dd, o, hd, r, s), BP.set(0, 0), V1.set(1, 0), UP.set(1, 1);
    let a = e.ray.intersectTriangle(K0, rm, J0, !1, nm);
    if (a === null && (Q0(rm.set(-0.5, 0.5, 0), dd, o, hd, r, s), V1.set(0, 1), a = e.ray.intersectTriangle(K0, J0, rm, !1, nm), a === null))
      return;
    const l = e.ray.origin.distanceTo(nm);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: nm.clone(),
      uv: ia.getUV(nm, K0, rm, J0, BP, V1, UP, new ze()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Q0(n, e, t, i, r, s) {
  fd.subVectors(n, t).addScalar(0.5).multiply(i), r !== void 0 ? (im.x = s * fd.x - r * fd.y, im.y = r * fd.x + s * fd.y) : im.copy(fd), n.copy(e), n.x += im.x, n.y += im.y, n.applyMatrix4(mD);
}
const VP = /* @__PURE__ */ new Z(), HP = /* @__PURE__ */ new gn(), GP = /* @__PURE__ */ new gn(), Bj = /* @__PURE__ */ new Z(), WP = /* @__PURE__ */ new Pt();
class The extends wi {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Pt(), this.bindMatrixInverse = new Pt();
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new gn(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(e, t) {
    const i = this.skeleton, r = this.geometry;
    HP.fromBufferAttribute(r.attributes.skinIndex, e), GP.fromBufferAttribute(r.attributes.skinWeight, e), VP.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = GP.getComponent(s);
      if (o !== 0) {
        const a = HP.getComponent(s);
        WP.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(Bj.copy(VP).applyMatrix4(WP), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Uj extends wn {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Ff extends Wi {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, c = kn, d = kn, p, m) {
    super(null, o, a, l, c, d, r, s, p, m), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const jP = /* @__PURE__ */ new Pt(), Vj = /* @__PURE__ */ new Pt();
class vD {
  constructor(e = [], t = []) {
    this.uuid = to(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new Pt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new Pt();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : Vj;
      jP.multiplyMatrices(a, t[s]), jP.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new vD(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = ZL(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Ff(t, e, e, wr, Qs);
    return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e)
        return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Uj()), this.bones.push(o), this.boneInverses.push(new Pt().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class qP extends Vi {
  constructor(e, t, i, r = 1) {
    super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const XP = /* @__PURE__ */ new Pt(), $P = /* @__PURE__ */ new Pt(), e_ = [], sm = /* @__PURE__ */ new wi();
class Phe extends wi {
  constructor(e, t, i) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new qP(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1;
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld, r = this.count;
    if (sm.geometry = this.geometry, sm.material = this.material, sm.material !== void 0)
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, XP), $P.multiplyMatrices(i, XP), sm.matrixWorld = $P, sm.raycast(e, e_);
        for (let o = 0, a = e_.length; o < a; o++) {
          const l = e_[o];
          l.instanceId = s, l.object = this, t.push(l);
        }
        e_.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new qP(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class kc extends zo {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new xt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const ZP = /* @__PURE__ */ new Z(), YP = /* @__PURE__ */ new Z(), KP = /* @__PURE__ */ new Pt(), H1 = /* @__PURE__ */ new Nf(), t_ = /* @__PURE__ */ new sh();
class xy extends wn {
  constructor(e = new qn(), t = new kc()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        ZP.fromBufferAttribute(t, r - 1), YP.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += ZP.distanceTo(YP);
      e.setAttribute("lineDistance", new en(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), t_.copy(i.boundingSphere), t_.applyMatrix4(r), t_.radius += s, e.ray.intersectsSphere(t_) === !1)
      return;
    KP.copy(r).invert(), H1.copy(e.ray).applyMatrix4(KP);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = new Z(), d = new Z(), p = new Z(), m = new Z(), v = this.isLineSegments ? 2 : 1, b = i.index, y = i.attributes.position;
    if (b !== null) {
      const S = Math.max(0, o.start), C = Math.min(b.count, o.start + o.count);
      for (let M = S, T = C - 1; M < T; M += v) {
        const P = b.getX(M), D = b.getX(M + 1);
        if (c.fromBufferAttribute(y, P), d.fromBufferAttribute(y, D), H1.distanceSqToSegment(c, d, m, p) > l)
          continue;
        m.applyMatrix4(this.matrixWorld);
        const k = e.ray.origin.distanceTo(m);
        k < e.near || k > e.far || t.push({
          distance: k,
          point: p.clone().applyMatrix4(this.matrixWorld),
          index: M,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const S = Math.max(0, o.start), C = Math.min(y.count, o.start + o.count);
      for (let M = S, T = C - 1; M < T; M += v) {
        if (c.fromBufferAttribute(y, M), d.fromBufferAttribute(y, M + 1), H1.distanceSqToSegment(c, d, m, p) > l)
          continue;
        m.applyMatrix4(this.matrixWorld);
        const D = e.ray.origin.distanceTo(m);
        D < e.near || D > e.far || t.push({
          distance: D,
          point: p.clone().applyMatrix4(this.matrixWorld),
          index: M,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
const JP = /* @__PURE__ */ new Z(), QP = /* @__PURE__ */ new Z();
class Rv extends xy {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        JP.fromBufferAttribute(t, r), QP.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + JP.distanceTo(QP);
      e.setAttribute("lineDistance", new en(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class Ahe extends xy {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class Hj extends zo {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new xt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const eA = /* @__PURE__ */ new Pt(), y2 = /* @__PURE__ */ new Nf(), n_ = /* @__PURE__ */ new sh(), i_ = /* @__PURE__ */ new Z();
class Rhe extends wn {
  constructor(e = new qn(), t = new Hj()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), n_.copy(i.boundingSphere), n_.applyMatrix4(r), n_.radius += s, e.ray.intersectsSphere(n_) === !1)
      return;
    eA.copy(r).invert(), y2.copy(e.ray).applyMatrix4(eA);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = i.index, p = i.attributes.position;
    if (c !== null) {
      const m = Math.max(0, o.start), v = Math.min(c.count, o.start + o.count);
      for (let b = m, x = v; b < x; b++) {
        const y = c.getX(b);
        i_.fromBufferAttribute(p, y), tA(i_, y, l, r, e, t, this);
      }
    } else {
      const m = Math.max(0, o.start), v = Math.min(p.count, o.start + o.count);
      for (let b = m, x = v; b < x; b++)
        i_.fromBufferAttribute(p, b), tA(i_, b, l, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
function tA(n, e, t, i, r, s, o) {
  const a = y2.distanceSqToPoint(n);
  if (a < t) {
    const l = new Z();
    y2.closestPointToPoint(n, l), l.applyMatrix4(i);
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far)
      return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o
    });
  }
}
class gD extends Wi {
  constructor(e, t, i, r, s, o, a, l, c) {
    super(e, t, i, r, s, o, a, l, c), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : Zt, this.magFilter = s !== void 0 ? s : Zt, this.generateMipmaps = !1;
    const d = this;
    function p() {
      d.needsUpdate = !0, e.requestVideoFrameCallback(p);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(p);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class nA extends Wi {
  constructor(e, t, i) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.format = i, this.magFilter = kn, this.minFilter = kn, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class khe extends Wi {
  constructor(e, t, i, r, s, o, a, l, c, d, p, m) {
    super(null, o, a, l, c, d, r, s, p, m), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Lhe extends Wi {
  constructor(e, t, i, r, s, o, a, l, c) {
    super(e, t, i, r, s, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class _a {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i, r = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      i = this.getPoint(o / e), s += i.distanceTo(r), t.push(s), r = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? o = t : o = e * i[s - 1];
    let a = 0, l = s - 1, c;
    for (; a <= l; )
      if (r = Math.floor(a + (l - a) / 2), c = i[r] - o, c < 0)
        a = r + 1;
      else if (c > 0)
        l = r - 1;
      else {
        l = r;
        break;
      }
    if (r = l, i[r] === o)
      return r / (s - 1);
    const d = i[r], m = i[r + 1] - d, v = (o - d) / m;
    return (r + v) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4, s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r), a = this.getPoint(s), l = t || (o.isVector2 ? new ze() : new Z());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new Z(), r = [], s = [], o = [], a = new Z(), l = new Pt();
    for (let v = 0; v <= e; v++) {
      const b = v / e;
      r[v] = this.getTangentAt(b, new Z());
    }
    s[0] = new Z(), o[0] = new Z();
    let c = Number.MAX_VALUE;
    const d = Math.abs(r[0].x), p = Math.abs(r[0].y), m = Math.abs(r[0].z);
    d <= c && (c = d, i.set(1, 0, 0)), p <= c && (c = p, i.set(0, 1, 0)), m <= c && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]);
    for (let v = 1; v <= e; v++) {
      if (s[v] = s[v - 1].clone(), o[v] = o[v - 1].clone(), a.crossVectors(r[v - 1], r[v]), a.length() > Number.EPSILON) {
        a.normalize();
        const b = Math.acos(Ui(r[v - 1].dot(r[v]), -1, 1));
        s[v].applyMatrix4(l.makeRotationAxis(a, b));
      }
      o[v].crossVectors(r[v], s[v]);
    }
    if (t === !0) {
      let v = Math.acos(Ui(s[0].dot(s[e]), -1, 1));
      v /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (v = -v);
      for (let b = 1; b <= e; b++)
        s[b].applyMatrix4(l.makeRotationAxis(r[b], v * b)), o[b].crossVectors(r[b], s[b]);
    }
    return {
      tangents: r,
      normals: s,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class dE extends _a {
  constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
  }
  getPoint(e, t) {
    const i = t || new ze(), r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += r;
    for (; s > r; )
      s -= r;
    s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation), p = Math.sin(this.aRotation), m = l - this.aX, v = c - this.aY;
      l = m * d - v * p + this.aX, c = m * p + v * d + this.aY;
    }
    return i.set(l, c);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class Gj extends dE {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function fE() {
  let n = 0, e = 0, t = 0, i = 0;
  function r(s, o, a, l) {
    n = s, e = a, t = -3 * s + 3 * o - 2 * a - l, i = 2 * s - 2 * o + a + l;
  }
  return {
    initCatmullRom: function(s, o, a, l, c) {
      r(o, a, c * (a - s), c * (l - o));
    },
    initNonuniformCatmullRom: function(s, o, a, l, c, d, p) {
      let m = (o - s) / c - (a - s) / (c + d) + (a - o) / d, v = (a - o) / d - (l - o) / (d + p) + (l - a) / p;
      m *= d, v *= d, r(o, a, m, v);
    },
    calc: function(s) {
      const o = s * s, a = o * s;
      return n + e * s + t * o + i * a;
    }
  };
}
const r_ = /* @__PURE__ */ new Z(), G1 = /* @__PURE__ */ new fE(), W1 = /* @__PURE__ */ new fE(), j1 = /* @__PURE__ */ new fE();
class _D extends _a {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r;
  }
  getPoint(e, t = new Z()) {
    const i = t, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o), l = o - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
    let c, d;
    this.closed || a > 0 ? c = r[(a - 1) % s] : (r_.subVectors(r[0], r[1]).add(r[0]), c = r_);
    const p = r[a % s], m = r[(a + 1) % s];
    if (this.closed || a + 2 < s ? d = r[(a + 2) % s] : (r_.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), d = r_), this.curveType === "centripetal" || this.curveType === "chordal") {
      const v = this.curveType === "chordal" ? 0.5 : 0.25;
      let b = Math.pow(c.distanceToSquared(p), v), x = Math.pow(p.distanceToSquared(m), v), y = Math.pow(m.distanceToSquared(d), v);
      x < 1e-4 && (x = 1), b < 1e-4 && (b = x), y < 1e-4 && (y = x), G1.initNonuniformCatmullRom(c.x, p.x, m.x, d.x, b, x, y), W1.initNonuniformCatmullRom(c.y, p.y, m.y, d.y, b, x, y), j1.initNonuniformCatmullRom(c.z, p.z, m.z, d.z, b, x, y);
    } else
      this.curveType === "catmullrom" && (G1.initCatmullRom(c.x, p.x, m.x, d.x, this.tension), W1.initCatmullRom(c.y, p.y, m.y, d.y, this.tension), j1.initCatmullRom(c.z, p.z, m.z, d.z, this.tension));
    return i.set(
      G1.calc(l),
      W1.calc(l),
      j1.calc(l)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new Z().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function iA(n, e, t, i, r) {
  const s = (i - e) * 0.5, o = (r - t) * 0.5, a = n * n, l = n * a;
  return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t;
}
function Wj(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function jj(n, e) {
  return 2 * (1 - n) * n * e;
}
function qj(n, e) {
  return n * n * e;
}
function Am(n, e, t, i) {
  return Wj(n, e) + jj(n, t) + qj(n, i);
}
function Xj(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function $j(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function Zj(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function Yj(n, e) {
  return n * n * n * e;
}
function Rm(n, e, t, i, r) {
  return Xj(n, e) + $j(n, t) + Zj(n, i) + Yj(n, r);
}
class bD extends _a {
  constructor(e = new ze(), t = new ze(), i = new ze(), r = new ze()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new ze()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
    return i.set(
      Rm(e, r.x, s.x, o.x, a.x),
      Rm(e, r.y, s.y, o.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Kj extends _a {
  constructor(e = new Z(), t = new Z(), i = new Z(), r = new Z()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new Z()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
    return i.set(
      Rm(e, r.x, s.x, o.x, a.x),
      Rm(e, r.y, s.y, o.y, a.y),
      Rm(e, r.z, s.z, o.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class pE extends _a {
  constructor(e = new ze(), t = new ze()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new ze()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const i = t || new ze();
    return i.copy(this.v2).sub(this.v1).normalize(), i;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Jj extends _a {
  constructor(e = new Z(), t = new Z()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Z()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class yD extends _a {
  constructor(e = new ze(), t = new ze(), i = new ze()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new ze()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2;
    return i.set(
      Am(e, r.x, s.x, o.x),
      Am(e, r.y, s.y, o.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Qj extends _a {
  constructor(e = new Z(), t = new Z(), i = new Z()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new Z()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2;
    return i.set(
      Am(e, r.x, s.x, o.x),
      Am(e, r.y, s.y, o.y),
      Am(e, r.z, s.z, o.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class xD extends _a {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new ze()) {
    const i = t, r = this.points, s = (r.length - 1) * e, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], c = r[o], d = r[o > r.length - 2 ? r.length - 1 : o + 1], p = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(
      iA(a, l.x, c.x, d.x, p.x),
      iA(a, l.y, c.y, d.y, p.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new ze().fromArray(r));
    }
    return this;
  }
}
var wD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: Gj,
  CatmullRomCurve3: _D,
  CubicBezierCurve: bD,
  CubicBezierCurve3: Kj,
  EllipseCurve: dE,
  LineCurve: pE,
  LineCurve3: Jj,
  QuadraticBezierCurve: yD,
  QuadraticBezierCurve3: Qj,
  SplineCurve: xD
});
class eq extends _a {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new pE(t, e));
  }
  getPoint(e, t) {
    const i = e * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i, a = this.curves[s], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(c, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const d = l[c];
        i && i.equals(d) || (t.push(d), i = d);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new wD[r.type]().fromJSON(r));
    }
    return this;
  }
}
class x2 extends eq {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new ze(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new pE(this.currentPoint.clone(), new ze(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new yD(
      this.currentPoint.clone(),
      new ze(e, t),
      new ze(i, r)
    );
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new bD(
      this.currentPoint.clone(),
      new ze(e, t),
      new ze(i, r),
      new ze(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new xD(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + a,
      t + l,
      i,
      r,
      s,
      o
    ), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, a, l) {
    const c = this.currentPoint.x, d = this.currentPoint.y;
    return this.absellipse(e + c, t + d, i, r, s, o, a, l), this;
  }
  absellipse(e, t, i, r, s, o, a, l) {
    const c = new dE(e, t, i, r, s, o, a, l);
    if (this.curves.length > 0) {
      const p = c.getPoint(0);
      p.equals(this.currentPoint) || this.lineTo(p.x, p.y);
    }
    this.curves.push(c);
    const d = c.getPoint(1);
    return this.currentPoint.copy(d), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class mE extends qn {
  constructor(e = 1, t = 8, i = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: i,
      thetaLength: r
    }, t = Math.max(3, t);
    const s = [], o = [], a = [], l = [], c = new Z(), d = new ze();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let p = 0, m = 3; p <= t; p++, m += 3) {
      const v = i + p / t * r;
      c.x = e * Math.cos(v), c.y = e * Math.sin(v), o.push(c.x, c.y, c.z), a.push(0, 0, 1), d.x = (o[m] / e + 1) / 2, d.y = (o[m + 1] / e + 1) / 2, l.push(d.x, d.y);
    }
    for (let p = 1; p <= t; p++)
      s.push(p, p + 1, 0);
    this.setIndex(s), this.setAttribute("position", new en(o, 3)), this.setAttribute("normal", new en(a, 3)), this.setAttribute("uv", new en(l, 2));
  }
  static fromJSON(e) {
    return new mE(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class wy extends qn {
  constructor(e = 1, t = 1, i = 1, r = 8, s = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: i,
      radialSegments: r,
      heightSegments: s,
      openEnded: o,
      thetaStart: a,
      thetaLength: l
    };
    const c = this;
    r = Math.floor(r), s = Math.floor(s);
    const d = [], p = [], m = [], v = [];
    let b = 0;
    const x = [], y = i / 2;
    let S = 0;
    C(), o === !1 && (e > 0 && M(!0), t > 0 && M(!1)), this.setIndex(d), this.setAttribute("position", new en(p, 3)), this.setAttribute("normal", new en(m, 3)), this.setAttribute("uv", new en(v, 2));
    function C() {
      const T = new Z(), P = new Z();
      let D = 0;
      const I = (t - e) / i;
      for (let k = 0; k <= s; k++) {
        const O = [], B = k / s, Y = B * (t - e) + e;
        for (let G = 0; G <= r; G++) {
          const K = G / r, A = K * l + a, J = Math.sin(A), xe = Math.cos(A);
          P.x = Y * J, P.y = -B * i + y, P.z = Y * xe, p.push(P.x, P.y, P.z), T.set(J, I, xe).normalize(), m.push(T.x, T.y, T.z), v.push(K, 1 - B), O.push(b++);
        }
        x.push(O);
      }
      for (let k = 0; k < r; k++)
        for (let O = 0; O < s; O++) {
          const B = x[O][k], Y = x[O + 1][k], G = x[O + 1][k + 1], K = x[O][k + 1];
          d.push(B, Y, K), d.push(Y, G, K), D += 6;
        }
      c.addGroup(S, D, 0), S += D;
    }
    function M(T) {
      const P = b, D = new ze(), I = new Z();
      let k = 0;
      const O = T === !0 ? e : t, B = T === !0 ? 1 : -1;
      for (let G = 1; G <= r; G++)
        p.push(0, y * B, 0), m.push(0, B, 0), v.push(0.5, 0.5), b++;
      const Y = b;
      for (let G = 0; G <= r; G++) {
        const A = G / r * l + a, J = Math.cos(A), xe = Math.sin(A);
        I.x = O * xe, I.y = y * B, I.z = O * J, p.push(I.x, I.y, I.z), m.push(0, B, 0), D.x = J * 0.5 + 0.5, D.y = xe * 0.5 * B + 0.5, v.push(D.x, D.y), b++;
      }
      for (let G = 0; G < r; G++) {
        const K = P + G, A = Y + G;
        T === !0 ? d.push(A, A + 1, K) : d.push(A + 1, A, K), k += 3;
      }
      c.addGroup(S, k, T === !0 ? 1 : 2), S += k;
    }
  }
  static fromJSON(e) {
    return new wy(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class vE extends wy {
  constructor(e = 1, t = 1, i = 8, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: i,
      heightSegments: r,
      openEnded: s,
      thetaStart: o,
      thetaLength: a
    };
  }
  static fromJSON(e) {
    return new vE(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Sy extends qn {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: i,
      detail: r
    };
    const s = [], o = [];
    a(r), c(i), d(), this.setAttribute("position", new en(s, 3)), this.setAttribute("normal", new en(s.slice(), 3)), this.setAttribute("uv", new en(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(C) {
      const M = new Z(), T = new Z(), P = new Z();
      for (let D = 0; D < t.length; D += 3)
        v(t[D + 0], M), v(t[D + 1], T), v(t[D + 2], P), l(M, T, P, C);
    }
    function l(C, M, T, P) {
      const D = P + 1, I = [];
      for (let k = 0; k <= D; k++) {
        I[k] = [];
        const O = C.clone().lerp(T, k / D), B = M.clone().lerp(T, k / D), Y = D - k;
        for (let G = 0; G <= Y; G++)
          G === 0 && k === D ? I[k][G] = O : I[k][G] = O.clone().lerp(B, G / Y);
      }
      for (let k = 0; k < D; k++)
        for (let O = 0; O < 2 * (D - k) - 1; O++) {
          const B = Math.floor(O / 2);
          O % 2 === 0 ? (m(I[k][B + 1]), m(I[k + 1][B]), m(I[k][B])) : (m(I[k][B + 1]), m(I[k + 1][B + 1]), m(I[k + 1][B]));
        }
    }
    function c(C) {
      const M = new Z();
      for (let T = 0; T < s.length; T += 3)
        M.x = s[T + 0], M.y = s[T + 1], M.z = s[T + 2], M.normalize().multiplyScalar(C), s[T + 0] = M.x, s[T + 1] = M.y, s[T + 2] = M.z;
    }
    function d() {
      const C = new Z();
      for (let M = 0; M < s.length; M += 3) {
        C.x = s[M + 0], C.y = s[M + 1], C.z = s[M + 2];
        const T = y(C) / 2 / Math.PI + 0.5, P = S(C) / Math.PI + 0.5;
        o.push(T, 1 - P);
      }
      b(), p();
    }
    function p() {
      for (let C = 0; C < o.length; C += 6) {
        const M = o[C + 0], T = o[C + 2], P = o[C + 4], D = Math.max(M, T, P), I = Math.min(M, T, P);
        D > 0.9 && I < 0.1 && (M < 0.2 && (o[C + 0] += 1), T < 0.2 && (o[C + 2] += 1), P < 0.2 && (o[C + 4] += 1));
      }
    }
    function m(C) {
      s.push(C.x, C.y, C.z);
    }
    function v(C, M) {
      const T = C * 3;
      M.x = e[T + 0], M.y = e[T + 1], M.z = e[T + 2];
    }
    function b() {
      const C = new Z(), M = new Z(), T = new Z(), P = new Z(), D = new ze(), I = new ze(), k = new ze();
      for (let O = 0, B = 0; O < s.length; O += 9, B += 6) {
        C.set(s[O + 0], s[O + 1], s[O + 2]), M.set(s[O + 3], s[O + 4], s[O + 5]), T.set(s[O + 6], s[O + 7], s[O + 8]), D.set(o[B + 0], o[B + 1]), I.set(o[B + 2], o[B + 3]), k.set(o[B + 4], o[B + 5]), P.copy(C).add(M).add(T).divideScalar(3);
        const Y = y(P);
        x(D, B + 0, C, Y), x(I, B + 2, M, Y), x(k, B + 4, T, Y);
      }
    }
    function x(C, M, T, P) {
      P < 0 && C.x === 1 && (o[M] = C.x - 1), T.x === 0 && T.z === 0 && (o[M] = P / 2 / Math.PI + 0.5);
    }
    function y(C) {
      return Math.atan2(C.z, -C.x);
    }
    function S(C) {
      return Math.atan2(-C.y, Math.sqrt(C.x * C.x + C.z * C.z));
    }
  }
  static fromJSON(e) {
    return new Sy(e.vertices, e.indices, e.radius, e.details);
  }
}
class W_ extends x2 {
  constructor(e) {
    super(e), this.uuid = to(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new x2().fromJSON(r));
    }
    return this;
  }
}
const tq = {
  triangulate: function(n, e, t = 2) {
    const i = e && e.length, r = i ? e[0] * t : n.length;
    let s = SD(n, 0, r, t, !0);
    const o = [];
    if (!s || s.next === s.prev)
      return o;
    let a, l, c, d, p, m, v;
    if (i && (s = oq(n, e, s, t)), n.length > 80 * t) {
      a = c = n[0], l = d = n[1];
      for (let b = t; b < r; b += t)
        p = n[b], m = n[b + 1], p < a && (a = p), m < l && (l = m), p > c && (c = p), m > d && (d = m);
      v = Math.max(c - a, d - l), v = v !== 0 ? 1 / v : 0;
    }
    return Ym(s, o, t, a, l, v), o;
  }
};
function SD(n, e, t, i, r) {
  let s, o;
  if (r === gq(n, e, t, i) > 0)
    for (s = e; s < t; s += i)
      o = rA(s, n[s], n[s + 1], o);
  else
    for (s = t - i; s >= e; s -= i)
      o = rA(s, n[s], n[s + 1], o);
  return o && My(o, o.next) && (Jm(o), o = o.next), o;
}
function Sc(n, e) {
  if (!n)
    return n;
  e || (e = n);
  let t = n, i;
  do
    if (i = !1, !t.steiner && (My(t, t.next) || hi(t.prev, t, t.next) === 0)) {
      if (Jm(t), t = e = t.prev, t === t.next)
        break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function Ym(n, e, t, i, r, s, o) {
  if (!n)
    return;
  !o && s && hq(n, i, r, s);
  let a = n, l, c;
  for (; n.prev !== n.next; ) {
    if (l = n.prev, c = n.next, s ? iq(n, i, r, s) : nq(n)) {
      e.push(l.i / t), e.push(n.i / t), e.push(c.i / t), Jm(n), n = c.next, a = c.next;
      continue;
    }
    if (n = c, n === a) {
      o ? o === 1 ? (n = rq(Sc(n), e, t), Ym(n, e, t, i, r, s, 2)) : o === 2 && sq(n, e, t, i, r, s) : Ym(Sc(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function nq(n) {
  const e = n.prev, t = n, i = n.next;
  if (hi(e, t, i) >= 0)
    return !1;
  let r = n.next.next;
  for (; r !== n.prev; ) {
    if (Dd(e.x, e.y, t.x, t.y, i.x, i.y, r.x, r.y) && hi(r.prev, r, r.next) >= 0)
      return !1;
    r = r.next;
  }
  return !0;
}
function iq(n, e, t, i) {
  const r = n.prev, s = n, o = n.next;
  if (hi(r, s, o) >= 0)
    return !1;
  const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x, l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y, c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x, d = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y, p = w2(a, l, e, t, i), m = w2(c, d, e, t, i);
  let v = n.prevZ, b = n.nextZ;
  for (; v && v.z >= p && b && b.z <= m; ) {
    if (v !== n.prev && v !== n.next && Dd(r.x, r.y, s.x, s.y, o.x, o.y, v.x, v.y) && hi(v.prev, v, v.next) >= 0 || (v = v.prevZ, b !== n.prev && b !== n.next && Dd(r.x, r.y, s.x, s.y, o.x, o.y, b.x, b.y) && hi(b.prev, b, b.next) >= 0))
      return !1;
    b = b.nextZ;
  }
  for (; v && v.z >= p; ) {
    if (v !== n.prev && v !== n.next && Dd(r.x, r.y, s.x, s.y, o.x, o.y, v.x, v.y) && hi(v.prev, v, v.next) >= 0)
      return !1;
    v = v.prevZ;
  }
  for (; b && b.z <= m; ) {
    if (b !== n.prev && b !== n.next && Dd(r.x, r.y, s.x, s.y, o.x, o.y, b.x, b.y) && hi(b.prev, b, b.next) >= 0)
      return !1;
    b = b.nextZ;
  }
  return !0;
}
function rq(n, e, t) {
  let i = n;
  do {
    const r = i.prev, s = i.next.next;
    !My(r, s) && MD(r, i, i.next, s) && Km(r, s) && Km(s, r) && (e.push(r.i / t), e.push(i.i / t), e.push(s.i / t), Jm(i), Jm(i.next), i = n = s), i = i.next;
  } while (i !== n);
  return Sc(i);
}
function sq(n, e, t, i, r, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && pq(o, a)) {
        let l = ED(o, a);
        o = Sc(o, o.next), l = Sc(l, l.next), Ym(o, e, t, i, r, s), Ym(l, e, t, i, r, s);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function oq(n, e, t, i) {
  const r = [];
  let s, o, a, l, c;
  for (s = 0, o = e.length; s < o; s++)
    a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : n.length, c = SD(n, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(fq(c));
  for (r.sort(aq), s = 0; s < r.length; s++)
    lq(r[s], t), t = Sc(t, t.next);
  return t;
}
function aq(n, e) {
  return n.x - e.x;
}
function lq(n, e) {
  if (e = cq(n, e), e) {
    const t = ED(e, n);
    Sc(e, e.next), Sc(t, t.next);
  }
}
function cq(n, e) {
  let t = e;
  const i = n.x, r = n.y;
  let s = -1 / 0, o;
  do {
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const m = t.x + (r - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (m <= i && m > s) {
        if (s = m, m === i) {
          if (r === t.y)
            return t;
          if (r === t.next.y)
            return t.next;
        }
        o = t.x < t.next.x ? t : t.next;
      }
    }
    t = t.next;
  } while (t !== e);
  if (!o)
    return null;
  if (i === s)
    return o;
  const a = o, l = o.x, c = o.y;
  let d = 1 / 0, p;
  t = o;
  do
    i >= t.x && t.x >= l && i !== t.x && Dd(r < c ? i : s, r, l, c, r < c ? s : i, r, t.x, t.y) && (p = Math.abs(r - t.y) / (i - t.x), Km(t, n) && (p < d || p === d && (t.x > o.x || t.x === o.x && uq(o, t))) && (o = t, d = p)), t = t.next;
  while (t !== a);
  return o;
}
function uq(n, e) {
  return hi(n.prev, n, e.prev) < 0 && hi(e.next, n, n.next) < 0;
}
function hq(n, e, t, i) {
  let r = n;
  do
    r.z === null && (r.z = w2(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== n);
  r.prevZ.nextZ = null, r.prevZ = null, dq(r);
}
function dq(n) {
  let e, t, i, r, s, o, a, l, c = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++)
        ;
      for (l = c; a > 0 || l > 0 && i; )
        a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r;
      t = i;
    }
    s.nextZ = null, c *= 2;
  } while (o > 1);
  return n;
}
function w2(n, e, t, i, r) {
  return n = 32767 * (n - t) * r, e = 32767 * (e - i) * r, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1;
}
function fq(n) {
  let e = n, t = n;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== n);
  return t;
}
function Dd(n, e, t, i, r, s, o, a) {
  return (r - o) * (e - a) - (n - o) * (s - a) >= 0 && (n - o) * (i - a) - (t - o) * (e - a) >= 0 && (t - o) * (s - a) - (r - o) * (i - a) >= 0;
}
function pq(n, e) {
  return n.next.i !== e.i && n.prev.i !== e.i && !mq(n, e) && (Km(n, e) && Km(e, n) && vq(n, e) && (hi(n.prev, n, e.prev) || hi(n, e.prev, e)) || My(n, e) && hi(n.prev, n, n.next) > 0 && hi(e.prev, e, e.next) > 0);
}
function hi(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function My(n, e) {
  return n.x === e.x && n.y === e.y;
}
function MD(n, e, t, i) {
  const r = o_(hi(n, e, t)), s = o_(hi(n, e, i)), o = o_(hi(t, i, n)), a = o_(hi(t, i, e));
  return !!(r !== s && o !== a || r === 0 && s_(n, t, e) || s === 0 && s_(n, i, e) || o === 0 && s_(t, n, i) || a === 0 && s_(t, e, i));
}
function s_(n, e, t) {
  return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
}
function o_(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function mq(n, e) {
  let t = n;
  do {
    if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && MD(t, t.next, n, e))
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function Km(n, e) {
  return hi(n.prev, n, n.next) < 0 ? hi(n, e, n.next) >= 0 && hi(n, n.prev, e) >= 0 : hi(n, e, n.prev) < 0 || hi(n, n.next, e) < 0;
}
function vq(n, e) {
  let t = n, i = !1;
  const r = (n.x + e.x) / 2, s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== n);
  return i;
}
function ED(n, e) {
  const t = new S2(n.i, n.x, n.y), i = new S2(e.i, e.x, e.y), r = n.next, s = e.prev;
  return n.next = e, e.prev = n, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i;
}
function rA(n, e, t, i) {
  const r = new S2(n, e, t);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function Jm(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function S2(n, e, t) {
  this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function gq(n, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i)
    r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]), o = s;
  return r;
}
class zd {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return zd.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], r = [], s = [];
    sA(e), oA(i, e);
    let o = e.length;
    t.forEach(sA);
    for (let l = 0; l < t.length; l++)
      r.push(o), o += t[l].length, oA(i, t[l]);
    const a = tq.triangulate(i, r);
    for (let l = 0; l < a.length; l += 3)
      s.push(a.slice(l, l + 3));
    return s;
  }
}
function sA(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function oA(n, e) {
  for (let t = 0; t < e.length; t++)
    n.push(e[t].x), n.push(e[t].y);
}
class Sb extends qn {
  constructor(e = new W_([new ze(0.5, 0.5), new ze(-0.5, 0.5), new ze(-0.5, -0.5), new ze(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const i = this, r = [], s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      o(c);
    }
    this.setAttribute("position", new en(r, 3)), this.setAttribute("uv", new en(s, 2)), this.computeVertexNormals();
    function o(a) {
      const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, d = t.steps !== void 0 ? t.steps : 1, p = t.depth !== void 0 ? t.depth : 1;
      let m = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, v = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, b = t.bevelSize !== void 0 ? t.bevelSize : v - 0.1, x = t.bevelOffset !== void 0 ? t.bevelOffset : 0, y = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const S = t.extrudePath, C = t.UVGenerator !== void 0 ? t.UVGenerator : _q;
      let M, T = !1, P, D, I, k;
      S && (M = S.getSpacedPoints(d), T = !0, m = !1, P = S.computeFrenetFrames(d, !1), D = new Z(), I = new Z(), k = new Z()), m || (y = 0, v = 0, b = 0, x = 0);
      const O = a.extractPoints(c);
      let B = O.shape;
      const Y = O.holes;
      if (!zd.isClockWise(B)) {
        B = B.reverse();
        for (let Ie = 0, Le = Y.length; Ie < Le; Ie++) {
          const L = Y[Ie];
          zd.isClockWise(L) && (Y[Ie] = L.reverse());
        }
      }
      const K = zd.triangulateShape(B, Y), A = B;
      for (let Ie = 0, Le = Y.length; Ie < Le; Ie++) {
        const L = Y[Ie];
        B = B.concat(L);
      }
      function J(Ie, Le, L) {
        return Le || console.error("THREE.ExtrudeGeometry: vec does not exist"), Le.clone().multiplyScalar(L).add(Ie);
      }
      const xe = B.length, se = K.length;
      function oe(Ie, Le, L) {
        let fe, ae, $;
        const j = Ie.x - Le.x, re = Ie.y - Le.y, Te = L.x - Ie.x, Ce = L.y - Ie.y, F = j * j + re * re, U = j * Ce - re * Te;
        if (Math.abs(U) > Number.EPSILON) {
          const he = Math.sqrt(F), me = Math.sqrt(Te * Te + Ce * Ce), Ae = Le.x - re / he, Ve = Le.y + j / he, $e = L.x - Ce / me, Me = L.y + Te / me, lt = (($e - Ae) * Ce - (Me - Ve) * Te) / (j * Ce - re * Te);
          fe = Ae + j * lt - Ie.x, ae = Ve + re * lt - Ie.y;
          const Ye = fe * fe + ae * ae;
          if (Ye <= 2)
            return new ze(fe, ae);
          $ = Math.sqrt(Ye / 2);
        } else {
          let he = !1;
          j > Number.EPSILON ? Te > Number.EPSILON && (he = !0) : j < -Number.EPSILON ? Te < -Number.EPSILON && (he = !0) : Math.sign(re) === Math.sign(Ce) && (he = !0), he ? (fe = -re, ae = j, $ = Math.sqrt(F)) : (fe = j, ae = re, $ = Math.sqrt(F / 2));
        }
        return new ze(fe / $, ae / $);
      }
      const Q = [];
      for (let Ie = 0, Le = A.length, L = Le - 1, fe = Ie + 1; Ie < Le; Ie++, L++, fe++)
        L === Le && (L = 0), fe === Le && (fe = 0), Q[Ie] = oe(A[Ie], A[L], A[fe]);
      const ce = [];
      let te, ee = Q.concat();
      for (let Ie = 0, Le = Y.length; Ie < Le; Ie++) {
        const L = Y[Ie];
        te = [];
        for (let fe = 0, ae = L.length, $ = ae - 1, j = fe + 1; fe < ae; fe++, $++, j++)
          $ === ae && ($ = 0), j === ae && (j = 0), te[fe] = oe(L[fe], L[$], L[j]);
        ce.push(te), ee = ee.concat(te);
      }
      for (let Ie = 0; Ie < y; Ie++) {
        const Le = Ie / y, L = v * Math.cos(Le * Math.PI / 2), fe = b * Math.sin(Le * Math.PI / 2) + x;
        for (let ae = 0, $ = A.length; ae < $; ae++) {
          const j = J(A[ae], Q[ae], fe);
          gt(j.x, j.y, -L);
        }
        for (let ae = 0, $ = Y.length; ae < $; ae++) {
          const j = Y[ae];
          te = ce[ae];
          for (let re = 0, Te = j.length; re < Te; re++) {
            const Ce = J(j[re], te[re], fe);
            gt(Ce.x, Ce.y, -L);
          }
        }
      }
      const Re = b + x;
      for (let Ie = 0; Ie < xe; Ie++) {
        const Le = m ? J(B[Ie], ee[Ie], Re) : B[Ie];
        T ? (I.copy(P.normals[0]).multiplyScalar(Le.x), D.copy(P.binormals[0]).multiplyScalar(Le.y), k.copy(M[0]).add(I).add(D), gt(k.x, k.y, k.z)) : gt(Le.x, Le.y, 0);
      }
      for (let Ie = 1; Ie <= d; Ie++)
        for (let Le = 0; Le < xe; Le++) {
          const L = m ? J(B[Le], ee[Le], Re) : B[Le];
          T ? (I.copy(P.normals[Ie]).multiplyScalar(L.x), D.copy(P.binormals[Ie]).multiplyScalar(L.y), k.copy(M[Ie]).add(I).add(D), gt(k.x, k.y, k.z)) : gt(L.x, L.y, p / d * Ie);
        }
      for (let Ie = y - 1; Ie >= 0; Ie--) {
        const Le = Ie / y, L = v * Math.cos(Le * Math.PI / 2), fe = b * Math.sin(Le * Math.PI / 2) + x;
        for (let ae = 0, $ = A.length; ae < $; ae++) {
          const j = J(A[ae], Q[ae], fe);
          gt(j.x, j.y, p + L);
        }
        for (let ae = 0, $ = Y.length; ae < $; ae++) {
          const j = Y[ae];
          te = ce[ae];
          for (let re = 0, Te = j.length; re < Te; re++) {
            const Ce = J(j[re], te[re], fe);
            T ? gt(Ce.x, Ce.y + M[d - 1].y, M[d - 1].x + L) : gt(Ce.x, Ce.y, p + L);
          }
        }
      }
      ye(), Se();
      function ye() {
        const Ie = r.length / 3;
        if (m) {
          let Le = 0, L = xe * Le;
          for (let fe = 0; fe < se; fe++) {
            const ae = K[fe];
            qe(ae[2] + L, ae[1] + L, ae[0] + L);
          }
          Le = d + y * 2, L = xe * Le;
          for (let fe = 0; fe < se; fe++) {
            const ae = K[fe];
            qe(ae[0] + L, ae[1] + L, ae[2] + L);
          }
        } else {
          for (let Le = 0; Le < se; Le++) {
            const L = K[Le];
            qe(L[2], L[1], L[0]);
          }
          for (let Le = 0; Le < se; Le++) {
            const L = K[Le];
            qe(L[0] + xe * d, L[1] + xe * d, L[2] + xe * d);
          }
        }
        i.addGroup(Ie, r.length / 3 - Ie, 0);
      }
      function Se() {
        const Ie = r.length / 3;
        let Le = 0;
        Ee(A, Le), Le += A.length;
        for (let L = 0, fe = Y.length; L < fe; L++) {
          const ae = Y[L];
          Ee(ae, Le), Le += ae.length;
        }
        i.addGroup(Ie, r.length / 3 - Ie, 1);
      }
      function Ee(Ie, Le) {
        let L = Ie.length;
        for (; --L >= 0; ) {
          const fe = L;
          let ae = L - 1;
          ae < 0 && (ae = Ie.length - 1);
          for (let $ = 0, j = d + y * 2; $ < j; $++) {
            const re = xe * $, Te = xe * ($ + 1), Ce = Le + fe + re, F = Le + ae + re, U = Le + ae + Te, he = Le + fe + Te;
            Ze(Ce, F, U, he);
          }
        }
      }
      function gt(Ie, Le, L) {
        l.push(Ie), l.push(Le), l.push(L);
      }
      function qe(Ie, Le, L) {
        je(Ie), je(Le), je(L);
        const fe = r.length / 3, ae = C.generateTopUV(i, r, fe - 3, fe - 2, fe - 1);
        st(ae[0]), st(ae[1]), st(ae[2]);
      }
      function Ze(Ie, Le, L, fe) {
        je(Ie), je(Le), je(fe), je(Le), je(L), je(fe);
        const ae = r.length / 3, $ = C.generateSideWallUV(i, r, ae - 6, ae - 3, ae - 2, ae - 1);
        st($[0]), st($[1]), st($[3]), st($[1]), st($[2]), st($[3]);
      }
      function je(Ie) {
        r.push(l[Ie * 3 + 0]), r.push(l[Ie * 3 + 1]), r.push(l[Ie * 3 + 2]);
      }
      function st(Ie) {
        s.push(Ie.x), s.push(Ie.y);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return bq(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new wD[r.type]().fromJSON(r)), new Sb(i, e.options);
  }
}
const _q = {
  generateTopUV: function(n, e, t, i, r) {
    const s = e[t * 3], o = e[t * 3 + 1], a = e[i * 3], l = e[i * 3 + 1], c = e[r * 3], d = e[r * 3 + 1];
    return [
      new ze(s, o),
      new ze(a, l),
      new ze(c, d)
    ];
  },
  generateSideWallUV: function(n, e, t, i, r, s) {
    const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[i * 3], d = e[i * 3 + 1], p = e[i * 3 + 2], m = e[r * 3], v = e[r * 3 + 1], b = e[r * 3 + 2], x = e[s * 3], y = e[s * 3 + 1], S = e[s * 3 + 2];
    return Math.abs(a - d) < Math.abs(o - c) ? [
      new ze(o, 1 - l),
      new ze(c, 1 - p),
      new ze(m, 1 - b),
      new ze(x, 1 - S)
    ] : [
      new ze(a, 1 - l),
      new ze(d, 1 - p),
      new ze(v, 1 - b),
      new ze(y, 1 - S)
    ];
  }
};
function bq(n, e, t) {
  if (t.shapes = [], Array.isArray(n))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(n.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class gE extends Sy {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new gE(e.radius, e.detail);
  }
}
class _E extends qn {
  constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: i,
      phiStart: r,
      phiLength: s,
      thetaStart: o,
      thetaLength: a
    }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const l = Math.min(o + a, Math.PI);
    let c = 0;
    const d = [], p = new Z(), m = new Z(), v = [], b = [], x = [], y = [];
    for (let S = 0; S <= i; S++) {
      const C = [], M = S / i;
      let T = 0;
      S == 0 && o == 0 ? T = 0.5 / t : S == i && l == Math.PI && (T = -0.5 / t);
      for (let P = 0; P <= t; P++) {
        const D = P / t;
        p.x = -e * Math.cos(r + D * s) * Math.sin(o + M * a), p.y = e * Math.cos(o + M * a), p.z = e * Math.sin(r + D * s) * Math.sin(o + M * a), b.push(p.x, p.y, p.z), m.copy(p).normalize(), x.push(m.x, m.y, m.z), y.push(D + T, 1 - M), C.push(c++);
      }
      d.push(C);
    }
    for (let S = 0; S < i; S++)
      for (let C = 0; C < t; C++) {
        const M = d[S][C + 1], T = d[S][C], P = d[S + 1][C], D = d[S + 1][C + 1];
        (S !== 0 || o > 0) && v.push(M, T, D), (S !== i - 1 || l < Math.PI) && v.push(T, P, D);
      }
    this.setIndex(v), this.setAttribute("position", new en(b, 3)), this.setAttribute("normal", new en(x, 3)), this.setAttribute("uv", new en(y, 2));
  }
  static fromJSON(e) {
    return new _E(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class bE extends Sy {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], r = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(i, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new bE(e.radius, e.detail);
  }
}
class yE extends qn {
  constructor(e = 1, t = 0.4, i = 8, r = 6, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: i,
      tubularSegments: r,
      arc: s
    }, i = Math.floor(i), r = Math.floor(r);
    const o = [], a = [], l = [], c = [], d = new Z(), p = new Z(), m = new Z();
    for (let v = 0; v <= i; v++)
      for (let b = 0; b <= r; b++) {
        const x = b / r * s, y = v / i * Math.PI * 2;
        p.x = (e + t * Math.cos(y)) * Math.cos(x), p.y = (e + t * Math.cos(y)) * Math.sin(x), p.z = t * Math.sin(y), a.push(p.x, p.y, p.z), d.x = e * Math.cos(x), d.y = e * Math.sin(x), m.subVectors(p, d).normalize(), l.push(m.x, m.y, m.z), c.push(b / r), c.push(v / i);
      }
    for (let v = 1; v <= i; v++)
      for (let b = 1; b <= r; b++) {
        const x = (r + 1) * v + b - 1, y = (r + 1) * (v - 1) + b - 1, S = (r + 1) * (v - 1) + b, C = (r + 1) * v + b;
        o.push(x, y, C), o.push(y, S, C);
      }
    this.setIndex(o), this.setAttribute("position", new en(a, 3)), this.setAttribute("normal", new en(l, 3)), this.setAttribute("uv", new en(c, 2));
  }
  static fromJSON(e) {
    return new yE(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class yq extends qn {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), r = new Z(), s = new Z();
      if (e.index !== null) {
        const o = e.attributes.position, a = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let c = 0, d = l.length; c < d; ++c) {
          const p = l[c], m = p.start, v = p.count;
          for (let b = m, x = m + v; b < x; b += 3)
            for (let y = 0; y < 3; y++) {
              const S = a.getX(b + y), C = a.getX(b + (y + 1) % 3);
              r.fromBufferAttribute(o, S), s.fromBufferAttribute(o, C), aA(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let c = 0; c < 3; c++) {
            const d = 3 * a + c, p = 3 * a + (c + 1) % 3;
            r.fromBufferAttribute(o, d), s.fromBufferAttribute(o, p), aA(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new en(t, 3));
    }
  }
}
function aA(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
class CD extends zo {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new xt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = my, this.normalScale = new ze(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Dhe extends CD {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ze(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Ui(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new xt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new xt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new xt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class xq extends zo {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = my, this.normalScale = new ze(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
function Kl(n, e, t) {
  return TD(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t);
}
function a_(n, e, t) {
  return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n);
}
function TD(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function wq(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length, i = new Array(t);
  for (let r = 0; r !== t; ++r)
    i[r] = r;
  return i.sort(e), i;
}
function lA(n, e, t) {
  const i = n.length, r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l)
      r[o++] = n[a + l];
  }
  return r;
}
function PD(n, e, t, i) {
  let r = 1, s = n[0];
  for (; s !== void 0 && s[i] === void 0; )
    s = n[r++];
  if (s === void 0)
    return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n[r++];
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n[r++];
      while (s !== void 0);
    else
      do
        o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n[r++];
      while (s !== void 0);
}
class Ey {
  constructor(e, t, i, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex, r = t[i], s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i:
            if (!(e < r)) {
              for (let a = i + 2; ; ) {
                if (r === void 0) {
                  if (e < s)
                    break i;
                  return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
                }
                if (i === a)
                  break;
                if (s = r, r = t[++i], e < r)
                  break t;
              }
              o = t.length;
              break n;
            }
          if (!(e >= s)) {
            const a = t[1];
            e < a && (i = 2, s = a);
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i === l)
                break;
              if (r = s, s = t[--i - 1], e >= s)
                break t;
            }
            o = i, i = 0;
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = i + o >>> 1;
          e < t[a] ? o = a : i = a + 1;
        }
        if (r = t[i], s = t[i - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
      }
      this._cachedIndex = i, this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r;
    for (let o = 0; o !== r; ++o)
      t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class Sq extends Ey {
  constructor(e, t, i, r) {
    super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: Rd,
      endingEnd: Rd
    };
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2, o = e + 1, a = r[s], l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case kd:
          s = e, a = 2 * t - i;
          break;
        case xb:
          s = r.length - 2, a = t + r[s] - r[s + 1];
          break;
        default:
          s = e, a = i;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case kd:
          o = e, l = 2 * i - t;
          break;
        case xb:
          o = 1, l = i + r[1] - r[0];
          break;
        default:
          o = e - 1, l = t;
      }
    const c = (i - t) * 0.5, d = this.valueSize;
    this._weightPrev = c / (t - a), this._weightNext = c / (l - i), this._offsetPrev = s * d, this._offsetNext = o * d;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, d = this._offsetPrev, p = this._offsetNext, m = this._weightPrev, v = this._weightNext, b = (i - t) / (r - t), x = b * b, y = x * b, S = -m * y + 2 * m * x - m * b, C = (1 + m) * y + (-1.5 - 2 * m) * x + (-0.5 + m) * b + 1, M = (-1 - v) * y + (1.5 + v) * x + 0.5 * b, T = v * y - v * x;
    for (let P = 0; P !== a; ++P)
      s[P] = S * o[d + P] + C * o[c + P] + M * o[l + P] + T * o[p + P];
    return s;
  }
}
class AD extends Ey {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, d = (i - t) / (r - t), p = 1 - d;
    for (let m = 0; m !== a; ++m)
      s[m] = o[c + m] * p + o[l + m] * d;
    return s;
  }
}
class Mq extends Ey {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ba {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = a_(t, this.TimeBufferType), this.values = a_(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON)
      i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: a_(e.times, Array),
        values: a_(e.values, Array)
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new Mq(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new AD(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new Sq(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case bb:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case yb:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case p1:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return bb;
      case this.InterpolantFactoryMethodLinear:
        return yb;
      case this.InterpolantFactoryMethodSmooth:
        return p1;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i)
        t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i)
        t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times, r = i.length;
    let s = 0, o = r - 1;
    for (; s !== r && i[s] < e; )
      ++s;
    for (; o !== -1 && i[o] > t; )
      --o;
    if (++o, s !== 0 || o !== r) {
      s >= o && (o = Math.max(o, 1), s = o - 1);
      const a = this.getValueSize();
      this.times = Kl(i, s, o), this.values = Kl(this.values, s * a, o * a);
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const i = this.times, r = this.values, s = i.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
        break;
      }
      o = l;
    }
    if (r !== void 0 && TD(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = Kl(this.times), t = Kl(this.values), i = this.getValueSize(), r = this.getInterpolation() === p1, s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = e[a], d = e[a + 1];
      if (c !== d && (a !== 1 || c !== e[0]))
        if (r)
          l = !0;
        else {
          const p = a * i, m = p - i, v = p + i;
          for (let b = 0; b !== i; ++b) {
            const x = t[p + b];
            if (x !== t[m + b] || x !== t[v + b]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const p = a * i, m = o * i;
          for (let v = 0; v !== i; ++v)
            t[m + v] = t[p + v];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, c = 0; c !== i; ++c)
        t[l + c] = t[a + c];
      ++o;
    }
    return o !== e.length ? (this.times = Kl(e, 0, o), this.values = Kl(t, 0, o * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = Kl(this.times, 0), t = Kl(this.values, 0), i = this.constructor, r = new i(this.name, e, t);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
ba.prototype.TimeBufferType = Float32Array;
ba.prototype.ValueBufferType = Float32Array;
ba.prototype.DefaultInterpolation = yb;
class lh extends ba {
}
lh.prototype.ValueTypeName = "bool";
lh.prototype.ValueBufferType = Array;
lh.prototype.DefaultInterpolation = bb;
lh.prototype.InterpolantFactoryMethodLinear = void 0;
lh.prototype.InterpolantFactoryMethodSmooth = void 0;
class RD extends ba {
}
RD.prototype.ValueTypeName = "color";
class Qm extends ba {
}
Qm.prototype.ValueTypeName = "number";
class Eq extends Ey {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (i - t) / (r - t);
    let c = e * a;
    for (let d = c + a; c !== d; c += 4)
      Gi.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
}
class kv extends ba {
  InterpolantFactoryMethodLinear(e) {
    return new Eq(this.times, this.values, this.getValueSize(), e);
  }
}
kv.prototype.ValueTypeName = "quaternion";
kv.prototype.DefaultInterpolation = yb;
kv.prototype.InterpolantFactoryMethodSmooth = void 0;
class Bf extends ba {
}
Bf.prototype.ValueTypeName = "string";
Bf.prototype.ValueBufferType = Array;
Bf.prototype.DefaultInterpolation = bb;
Bf.prototype.InterpolantFactoryMethodLinear = void 0;
Bf.prototype.InterpolantFactoryMethodSmooth = void 0;
class Mb extends ba {
}
Mb.prototype.ValueTypeName = "vector";
class M2 {
  constructor(e, t = -1, i, r = oE) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = to(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o)
      t.push(Tq(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, r = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let s = 0, o = i.length; s !== o; ++s)
      t.push(ba.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length, o = [];
    for (let a = 0; a < s; a++) {
      let l = [], c = [];
      l.push(
        (a + s - 1) % s,
        a,
        (a + 1) % s
      ), c.push(0, 1, 0);
      const d = wq(l);
      l = lA(l, 1, d), c = lA(c, 1, d), !r && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(
        new Qm(
          ".morphTargetInfluences[" + t[a].name + "]",
          l,
          c
        ).scale(1 / i)
      );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < i.length; r++)
      if (i[r].name === t)
        return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], d = c.name.match(s);
      if (d && d.length > 1) {
        const p = d[1];
        let m = r[p];
        m || (r[p] = m = []), m.push(c);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(p, m, v, b, x) {
      if (v.length !== 0) {
        const y = [], S = [];
        PD(v, y, S, b), y.length !== 0 && x.push(new p(m, y, S));
      }
    }, r = [], s = e.name || "default", o = e.fps || 30, a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let p = 0; p < c.length; p++) {
      const m = c[p].keys;
      if (!(!m || m.length === 0))
        if (m[0].morphTargets) {
          const v = {};
          let b;
          for (b = 0; b < m.length; b++)
            if (m[b].morphTargets)
              for (let x = 0; x < m[b].morphTargets.length; x++)
                v[m[b].morphTargets[x]] = -1;
          for (const x in v) {
            const y = [], S = [];
            for (let C = 0; C !== m[b].morphTargets.length; ++C) {
              const M = m[b];
              y.push(M.time), S.push(M.morphTarget === x ? 1 : 0);
            }
            r.push(new Qm(".morphTargetInfluence[" + x + "]", y, S));
          }
          l = v.length * o;
        } else {
          const v = ".bones[" + t[p].name + "]";
          i(
            Mb,
            v + ".position",
            m,
            "pos",
            r
          ), i(
            kv,
            v + ".quaternion",
            m,
            "rot",
            r
          ), i(
            Mb,
            v + ".scale",
            m,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function Cq(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Qm;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Mb;
    case "color":
      return RD;
    case "quaternion":
      return kv;
    case "bool":
    case "boolean":
      return lh;
    case "string":
      return Bf;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function Tq(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = Cq(n.type);
  if (n.times === void 0) {
    const t = [], i = [];
    PD(n.keys, t, i, "value"), n.times = t, n.values = i;
  }
  return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
}
const bf = {
  enabled: !1,
  files: {},
  add: function(n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function(n) {
    if (this.enabled !== !1)
      return this.files[n];
  },
  remove: function(n) {
    delete this.files[n];
  },
  clear: function() {
    this.files = {};
  }
};
class Pq {
  constructor(e, t, i) {
    const r = this;
    let s = !1, o = 0, a = 0, l;
    const c = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(d) {
      a++, s === !1 && r.onStart !== void 0 && r.onStart(d, o, a), s = !0;
    }, this.itemEnd = function(d) {
      o++, r.onProgress !== void 0 && r.onProgress(d, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(d) {
      r.onError !== void 0 && r.onError(d);
    }, this.resolveURL = function(d) {
      return l ? l(d) : d;
    }, this.setURLModifier = function(d) {
      return l = d, this;
    }, this.addHandler = function(d, p) {
      return c.push(d, p), this;
    }, this.removeHandler = function(d) {
      const p = c.indexOf(d);
      return p !== -1 && c.splice(p, 2), this;
    }, this.getHandler = function(d) {
      for (let p = 0, m = c.length; p < m; p += 2) {
        const v = c[p], b = c[p + 1];
        if (v.global && (v.lastIndex = 0), v.test(d))
          return b;
      }
      return null;
    };
  }
}
const kD = /* @__PURE__ */ new Pq();
class ch {
  constructor(e) {
    this.manager = e !== void 0 ? e : kD, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
const Ja = {};
class Aq extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class km extends ch {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = bf.get(e);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (Ja[e] !== void 0) {
      Ja[e].push({
        onLoad: t,
        onProgress: i,
        onError: r
      });
      return;
    }
    Ja[e] = [], Ja[e].push({
      onLoad: t,
      onProgress: i,
      onError: r
    });
    const o = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
    }), a = this.mimeType, l = this.responseType;
    fetch(o).then((c) => {
      if (c.status === 200 || c.status === 0) {
        if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
          return c;
        const d = Ja[e], p = c.body.getReader(), m = c.headers.get("Content-Length"), v = m ? parseInt(m) : 0, b = v !== 0;
        let x = 0;
        const y = new ReadableStream({
          start(S) {
            C();
            function C() {
              p.read().then(({ done: M, value: T }) => {
                if (M)
                  S.close();
                else {
                  x += T.byteLength;
                  const P = new ProgressEvent("progress", { lengthComputable: b, loaded: x, total: v });
                  for (let D = 0, I = d.length; D < I; D++) {
                    const k = d[D];
                    k.onProgress && k.onProgress(P);
                  }
                  S.enqueue(T), C();
                }
              });
            }
          }
        });
        return new Response(y);
      } else
        throw new Aq(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
    }).then((c) => {
      switch (l) {
        case "arraybuffer":
          return c.arrayBuffer();
        case "blob":
          return c.blob();
        case "document":
          return c.text().then((d) => new DOMParser().parseFromString(d, a));
        case "json":
          return c.json();
        default:
          if (a === void 0)
            return c.text();
          {
            const p = /charset="?([^;"\s]*)"?/i.exec(a), m = p && p[1] ? p[1].toLowerCase() : void 0, v = new TextDecoder(m);
            return c.arrayBuffer().then((b) => v.decode(b));
          }
      }
    }).then((c) => {
      bf.add(e, c);
      const d = Ja[e];
      delete Ja[e];
      for (let p = 0, m = d.length; p < m; p++) {
        const v = d[p];
        v.onLoad && v.onLoad(c);
      }
    }).catch((c) => {
      const d = Ja[e];
      if (d === void 0)
        throw this.manager.itemError(e), c;
      delete Ja[e];
      for (let p = 0, m = d.length; p < m; p++) {
        const v = d[p];
        v.onError && v.onError(c);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class LD extends ch {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = bf.get(e);
    if (o !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(o), s.manager.itemEnd(e);
      }, 0), o;
    const a = Zm("img");
    function l() {
      d(), bf.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(p) {
      d(), r && r(p), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function d() {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1);
    }
    return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a;
  }
}
class Rq extends ch {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new cE(), o = new LD(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(c) {
      o.load(e[c], function(d) {
        s.images[c] = d, a++, a === 6 && (s.needsUpdate = !0, t && t(s));
      }, void 0, r);
    }
    for (let c = 0; c < e.length; ++c)
      l(c);
    return s;
  }
}
class kq extends ch {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new Ff(), a = new km(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
      const c = s.parse(l);
      !c || (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : qr, o.wrapT = c.wrapT !== void 0 ? c.wrapT : qr, o.magFilter = c.magFilter !== void 0 ? c.magFilter : Zt, o.minFilter = c.minFilter !== void 0 ? c.minFilter : Zt, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.encoding !== void 0 && (o.encoding = c.encoding), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = Pv), c.mipmapCount === 1 && (o.minFilter = Zt), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, t && t(o, c));
    }, i, r), o;
  }
}
class DD extends ch {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Wi(), o = new LD(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
      s.image = a, s.needsUpdate = !0, t !== void 0 && t(s);
    }, i, r), s;
  }
}
class Uf extends wn {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new xt(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class Lq extends Uf {
  constructor(e, t, i) {
    super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(wn.DefaultUp), this.updateMatrix(), this.groundColor = new xt(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const cA = /* @__PURE__ */ new Pt(), uA = /* @__PURE__ */ new Z(), hA = /* @__PURE__ */ new Z();
class xE {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ze(512, 512), this.map = null, this.mapPass = null, this.matrix = new Pt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new by(), this._frameExtents = new ze(1, 1), this._viewportCount = 1, this._viewports = [
      new gn(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    uA.setFromMatrixPosition(e.matrixWorld), t.position.copy(uA), hA.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(hA), t.updateMatrixWorld(), cA.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(cA), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(t.projectionMatrix), i.multiply(t.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class Dq extends xE {
  constructor() {
    super(new ni(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = $m * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class Iq extends Uf {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 1) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(wn.DefaultUp), this.updateMatrix(), this.target = new wn(), this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new Dq();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const dA = /* @__PURE__ */ new Pt(), om = /* @__PURE__ */ new Z(), q1 = /* @__PURE__ */ new Z();
class Oq extends xE {
  constructor() {
    super(new ni(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ze(4, 2), this._viewportCount = 6, this._viewports = [
      new gn(2, 1, 1, 1),
      new gn(0, 1, 1, 1),
      new gn(3, 1, 1, 1),
      new gn(1, 1, 1, 1),
      new gn(3, 0, 1, 1),
      new gn(1, 0, 1, 1)
    ], this._cubeDirections = [
      new Z(1, 0, 0),
      new Z(-1, 0, 0),
      new Z(0, 0, 1),
      new Z(0, 0, -1),
      new Z(0, 1, 0),
      new Z(0, -1, 0)
    ], this._cubeUps = [
      new Z(0, 1, 0),
      new Z(0, 1, 0),
      new Z(0, 1, 0),
      new Z(0, 1, 0),
      new Z(0, 0, 1),
      new Z(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const i = this.camera, r = this.matrix, s = e.distance || i.far;
    s !== i.far && (i.far = s, i.updateProjectionMatrix()), om.setFromMatrixPosition(e.matrixWorld), i.position.copy(om), q1.copy(i.position), q1.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(q1), i.updateMatrixWorld(), r.makeTranslation(-om.x, -om.y, -om.z), dA.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(dA);
  }
}
class Nq extends Uf {
  constructor(e, t, i = 0, r = 1) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new Oq();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class zq extends xE {
  constructor() {
    super(new uE(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class ID extends Uf {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(wn.DefaultUp), this.updateMatrix(), this.target = new wn(), this.shadow = new zq();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Fq extends Uf {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class Bq extends Uf {
  constructor(e, t, i = 10, r = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class Ihe {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++)
      t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class Uq extends qn {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = super.toJSON(this);
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class Ohe extends ch {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = bf.get(e);
    if (o !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(o), s.manager.itemEnd(e);
      }, 0), o;
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function(l) {
      return l.blob();
    }).then(function(l) {
      return createImageBitmap(l, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(l) {
      bf.add(e, l), t && t(l), s.manager.itemEnd(e);
    }).catch(function(l) {
      r && r(l), s.manager.itemError(e), s.manager.itemEnd(e);
    }), s.manager.itemStart(e);
  }
}
let l_;
const OD = {
  getContext: function() {
    return l_ === void 0 && (l_ = new (window.AudioContext || window.webkitAudioContext)()), l_;
  },
  setContext: function(n) {
    l_ = n;
  }
};
class Vq extends ch {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new km(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
      try {
        const l = a.slice(0);
        OD.getContext().decodeAudioData(l, function(d) {
          t(d);
        });
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(e);
      }
    }, i, r);
  }
}
class ND {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = fA(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = fA();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function fA() {
  return (typeof performance > "u" ? Date : performance).now();
}
const au = /* @__PURE__ */ new Z(), pA = /* @__PURE__ */ new Gi(), Hq = /* @__PURE__ */ new Z(), lu = /* @__PURE__ */ new Z();
class Gq extends wn {
  constructor() {
    super(), this.type = "AudioListener", this.context = OD.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new ND();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, i = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(au, pA, Hq), lu.set(0, 0, -1).applyQuaternion(pA), t.positionX) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(au.x, r), t.positionY.linearRampToValueAtTime(au.y, r), t.positionZ.linearRampToValueAtTime(au.z, r), t.forwardX.linearRampToValueAtTime(lu.x, r), t.forwardY.linearRampToValueAtTime(lu.y, r), t.forwardZ.linearRampToValueAtTime(lu.z, r), t.upX.linearRampToValueAtTime(i.x, r), t.upY.linearRampToValueAtTime(i.y, r), t.upZ.linearRampToValueAtTime(i.z, r);
    } else
      t.setPosition(au.x, au.y, au.z), t.setOrientation(lu.x, lu.y, lu.z, i.x, i.y, i.z);
  }
}
class Wq extends wn {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const cu = /* @__PURE__ */ new Z(), mA = /* @__PURE__ */ new Gi(), jq = /* @__PURE__ */ new Z(), uu = /* @__PURE__ */ new Z();
class qq extends Wq {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, i) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(cu, mA, jq), uu.set(0, 0, 1).applyQuaternion(mA);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(cu.x, i), t.positionY.linearRampToValueAtTime(cu.y, i), t.positionZ.linearRampToValueAtTime(cu.z, i), t.orientationX.linearRampToValueAtTime(uu.x, i), t.orientationY.linearRampToValueAtTime(uu.y, i), t.orientationZ.linearRampToValueAtTime(uu.z, i);
    } else
      t.setPosition(cu.x, cu.y, cu.z), t.setOrientation(uu.x, uu.y, uu.z);
  }
}
class Xq {
  constructor(e, t, i) {
    this.binding = e, this.valueSize = i;
    let r, s, o;
    switch (t) {
      case "quaternion":
        r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e, t) {
    const i = this.buffer, r = this.valueSize, s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a)
        i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const t = this.valueSize, i = this.buffer, r = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        i,
        r,
        l,
        1 - s,
        t
      );
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s)
      t[s] = t[r + s % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++)
      this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5)
      for (let o = 0; o !== s; ++o)
        e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    Gi.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    Gi.multiplyQuaternionsFlat(e, o, e, t, e, i), Gi.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const wE = "\\[\\]\\.:\\/", $q = new RegExp("[" + wE + "]", "g"), SE = "[^" + wE + "]", Zq = "[^" + wE.replace("\\.", "") + "]", Yq = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", SE), Kq = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", Zq), Jq = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", SE), Qq = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", SE), eX = new RegExp(
  "^" + Yq + Kq + Jq + Qq + "$"
), tX = ["material", "materials", "bones", "map"];
class nX {
  constructor(e, t, i) {
    const r = i || vn.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, r);
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class vn {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || vn.parseTrackName(t), this.node = vn.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new vn.Composite(e, t, i) : new vn(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace($q, "");
  }
  static parseTrackName(e) {
    const t = eX.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      propertyIndex: t[6]
    }, r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      tX.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(s) {
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          if (a.name === t || a.uuid === t)
            return a;
          const l = i(a.children);
          if (l)
            return l;
        }
        return null;
      }, r = i(e.children);
      if (r)
        return r;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, r = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = vn.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let d = 0; d < e.length; d++)
            if (e[d].name === c) {
              c = d;
              break;
            }
          break;
        case "map":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[c];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const c = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s;
    } else
      o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
vn.Composite = nX;
vn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
vn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
vn.prototype.GetterByBindingType = [
  vn.prototype._getValue_direct,
  vn.prototype._getValue_array,
  vn.prototype._getValue_arrayElement,
  vn.prototype._getValue_toArray
];
vn.prototype.SetterByBindingTypeAndVersioning = [
  [
    vn.prototype._setValue_direct,
    vn.prototype._setValue_direct_setNeedsUpdate,
    vn.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    vn.prototype._setValue_array,
    vn.prototype._setValue_array_setNeedsUpdate,
    vn.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    vn.prototype._setValue_arrayElement,
    vn.prototype._setValue_arrayElement_setNeedsUpdate,
    vn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    vn.prototype._setValue_fromArray,
    vn.prototype._setValue_fromArray_setNeedsUpdate,
    vn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class iX {
  constructor(e, t, i = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r;
    const s = t.tracks, o = s.length, a = new Array(o), l = {
      endingStart: Rd,
      endingEnd: Rd
    };
    for (let c = 0; c !== o; ++c) {
      const d = s[c].createInterpolant(null);
      a[c] = d, d.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = $L, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const r = this._clip.duration, s = e._clip.duration, o = s / r, a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer, s = r.time, o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const l = a.parameterPositions, c = a.sampleValues;
    return l[0] = s, l[1] = s + i, c[0] = e / o, c[1] = t / o, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants, c = this._propertyBindings;
      switch (this.blendMode) {
        case A9:
          for (let d = 0, p = l.length; d !== p; ++d)
            l[d].evaluate(o), c[d].accumulateAdditive(a);
          break;
        case oE:
        default:
          for (let d = 0, p = l.length; d !== p; ++d)
            l[d].evaluate(o), c[d].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, i = this.loop;
    let r = this.time + e, s = this._loopCount;
    const o = i === P9;
    if (e === 0)
      return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === T9) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (r >= t)
          r = t;
        else if (r < 0)
          r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < 0) {
        const a = Math.floor(r / t);
        r -= t * a, s += Math.abs(a);
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = s, this.time = r, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: a
          });
        }
      } else
        this.time = r;
      if (o && (s & 1) === 1)
        return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i ? (r.endingStart = kd, r.endingEnd = kd) : (e ? r.endingStart = this.zeroSlopeAtStart ? kd : Rd : r.endingStart = xb, t ? r.endingEnd = this.zeroSlopeAtEnd ? kd : Rd : r.endingEnd = xb);
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer, s = r.time;
    let o = this._weightInterpolant;
    o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
    const a = o.parameterPositions, l = o.sampleValues;
    return a[0] = s, l[0] = t, a[1] = s + e, l[1] = i, this;
  }
}
const rX = new Float32Array(1);
class zD extends ga {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root, r = e._clip.tracks, s = r.length, o = e._propertyBindings, a = e._interpolants, l = i.uuid, c = this._bindingsByRootAndName;
    let d = c[l];
    d === void 0 && (d = {}, c[l] = d);
    for (let p = 0; p !== s; ++p) {
      const m = r[p], v = m.name;
      let b = d[v];
      if (b !== void 0)
        ++b.referenceCount, o[p] = b;
      else {
        if (b = o[p], b !== void 0) {
          b._cacheIndex === null && (++b.referenceCount, this._addInactiveBinding(b, l, v));
          continue;
        }
        const x = t && t._propertyBindings[p].binding.parsedPath;
        b = new Xq(
          vn.create(i, v, x),
          m.ValueTypeName,
          m.getValueSize()
        ), ++b.referenceCount, this._addInactiveBinding(b, l, v), o[p] = b;
      }
      a[p].resultBuffer = b.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(
          e,
          s && s.knownActions[0]
        ), this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions, s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, s[t] = o;
    else {
      const a = o.knownActions;
      e._byClipCacheIndex = a.length, a.push(e);
    }
    e._cacheIndex = r.length, r.push(e), o.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, i = t[t.length - 1], r = e._cacheIndex;
    i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, c = l[l.length - 1], d = e._byClipCacheIndex;
    c._byClipCacheIndex = d, l[d] = c, l.pop(), e._byClipCacheIndex = null;
    const p = a.actionByRoot, m = (e._localRoot || this._root).uuid;
    delete p[m], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let o = r[t];
    o === void 0 && (o = {}, r[t] = o), o[i] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, i = e.binding, r = i.rootNode.uuid, s = i.path, o = this._bindingsByRootAndName, a = o[r], l = t[t.length - 1], c = e._cacheIndex;
    l._cacheIndex = c, t[c] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let i = e[t];
    return i === void 0 && (i = new AD(
      new Float32Array(2),
      new Float32Array(2),
      1,
      rX
    ), i.__cacheIndex = t, e[t] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r];
    e.__cacheIndex = r, t[r] = e, s.__cacheIndex = i, t[i] = s;
  }
  clipAction(e, t, i) {
    const r = t || this._root, s = r.uuid;
    let o = typeof e == "string" ? M2.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e, l = this._actionsByClip[a];
    let c = null;
    if (i === void 0 && (o !== null ? i = o.blendMode : i = oE), l !== void 0) {
      const p = l.actionByRoot[s];
      if (p !== void 0 && p.blendMode === i)
        return p;
      c = l.knownActions[0], o === null && (o = c._clip);
    }
    if (o === null)
      return null;
    const d = new iX(this, o, t, i);
    return this._bindAction(d, c), this._addInactiveAction(d, a, s), d;
  }
  existingAction(e, t) {
    const i = t || this._root, r = i.uuid, s = typeof e == "string" ? M2.findByName(i, e) : e, o = s ? s.uuid : e, a = this._actionsByClip[o];
    return a !== void 0 && a.actionByRoot[r] || null;
  }
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i)
      e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions, i = this._nActiveActions, r = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1;
    for (let c = 0; c !== i; ++c)
      t[c]._update(r, e, s, o);
    const a = this._bindings, l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c)
      a[c].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions, i = e.uuid, r = this._actionsByClip, s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const d = c._cacheIndex, p = t[t.length - 1];
        c._cacheIndex = null, c._byClipCacheIndex = null, p._cacheIndex = d, t[d] = p, t.pop(), this._removeInactiveBindingsForAction(c);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid, i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot, l = a[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName, s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class Ne {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new Ne(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
class E2 extends fD {
  constructor(e, t, i = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class FD {
  constructor(e, t, i = 0, r = 1 / 0) {
    this.ray = new Nf(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new lE(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return C2(e, this, i, t), i.sort(vA), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++)
      C2(e[r], this, i, t);
    return i.sort(vA), i;
  }
}
function vA(n, e) {
  return n.distance - e.distance;
}
function C2(n, e, t, i) {
  if (n.layers.test(e.layers) && n.raycast(e, t), i === !0) {
    const r = n.children;
    for (let s = 0, o = r.length; s < o; s++)
      C2(r[s], e, t, !0);
  }
}
const gA = /* @__PURE__ */ new ze();
class Nhe {
  constructor(e = new ze(1 / 0, 1 / 0), t = new ze(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = gA.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return gA.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const _A = /* @__PURE__ */ new Z(), c_ = /* @__PURE__ */ new Z();
class BD {
  constructor(e = new Z(), t = new Z()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    _A.subVectors(e, this.start), c_.subVectors(this.end, this.start);
    const i = c_.dot(c_);
    let s = c_.dot(_A) / i;
    return t && (s = Ui(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const bA = /* @__PURE__ */ new Z();
class sX extends wn {
  constructor(e, t) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
    const i = new qn(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const c = o / l * Math.PI * 2, d = a / l * Math.PI * 2;
      r.push(
        Math.cos(c),
        Math.sin(c),
        1,
        Math.cos(d),
        Math.sin(d),
        1
      );
    }
    i.setAttribute("position", new en(r, 3));
    const s = new kc({ fog: !1, toneMapped: !1 });
    this.cone = new Rv(i, s), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), bA.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(bA), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const Jl = /* @__PURE__ */ new Z(), u_ = /* @__PURE__ */ new Pt(), X1 = /* @__PURE__ */ new Pt();
class oX extends Rv {
  constructor(e) {
    const t = UD(e), i = new qn(), r = [], s = [], o = new xt(0, 0, 1), a = new xt(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const d = t[c];
      d.parent && d.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new en(r, 3)), i.setAttribute("color", new en(s, 3));
    const l = new kc({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(i, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, i = this.geometry, r = i.getAttribute("position");
    X1.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent && a.parent.isBone && (u_.multiplyMatrices(X1, a.matrixWorld), Jl.setFromMatrixPosition(u_), r.setXYZ(o, Jl.x, Jl.y, Jl.z), u_.multiplyMatrices(X1, a.parent.matrixWorld), Jl.setFromMatrixPosition(u_), r.setXYZ(o + 1, Jl.x, Jl.y, Jl.z), o += 2);
    }
    i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
}
function UD(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, UD(n.children[t]));
  return e;
}
class aX extends Rv {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    i = new xt(i), r = new xt(r);
    const s = t / 2, o = e / t, a = e / 2, l = [], c = [];
    for (let m = 0, v = 0, b = -a; m <= t; m++, b += o) {
      l.push(-a, 0, b, a, 0, b), l.push(b, 0, -a, b, 0, a);
      const x = m === s ? i : r;
      x.toArray(c, v), v += 3, x.toArray(c, v), v += 3, x.toArray(c, v), v += 3, x.toArray(c, v), v += 3;
    }
    const d = new qn();
    d.setAttribute("position", new en(l, 3)), d.setAttribute("color", new en(c, 3));
    const p = new kc({ vertexColors: !0, toneMapped: !1 });
    super(d, p), this.type = "GridHelper";
  }
}
const h_ = /* @__PURE__ */ new Z(), pi = /* @__PURE__ */ new _y();
class lX extends Rv {
  constructor(e) {
    const t = new qn(), i = new kc({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], o = {};
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
    function a(b, x) {
      l(b), l(x);
    }
    function l(b) {
      r.push(0, 0, 0), s.push(0, 0, 0), o[b] === void 0 && (o[b] = []), o[b].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new en(r, 3)), t.setAttribute("color", new en(s, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
    const c = new xt(16755200), d = new xt(16711680), p = new xt(43775), m = new xt(16777215), v = new xt(3355443);
    this.setColors(c, d, p, m, v);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, i.r, i.g, i.b), a.setXYZ(33, i.r, i.g, i.b), a.setXYZ(34, i.r, i.g, i.b), a.setXYZ(35, i.r, i.g, i.b), a.setXYZ(36, i.r, i.g, i.b), a.setXYZ(37, i.r, i.g, i.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, i = 1, r = 1;
    pi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), bi("c", t, e, pi, 0, 0, -1), bi("t", t, e, pi, 0, 0, 1), bi("n1", t, e, pi, -i, -r, -1), bi("n2", t, e, pi, i, -r, -1), bi("n3", t, e, pi, -i, r, -1), bi("n4", t, e, pi, i, r, -1), bi("f1", t, e, pi, -i, -r, 1), bi("f2", t, e, pi, i, -r, 1), bi("f3", t, e, pi, -i, r, 1), bi("f4", t, e, pi, i, r, 1), bi("u1", t, e, pi, i * 0.7, r * 1.1, -1), bi("u2", t, e, pi, -i * 0.7, r * 1.1, -1), bi("u3", t, e, pi, 0, r * 2, -1), bi("cf1", t, e, pi, -i, 0, 1), bi("cf2", t, e, pi, i, 0, 1), bi("cf3", t, e, pi, 0, -r, 1), bi("cf4", t, e, pi, 0, r, 1), bi("cn1", t, e, pi, -i, 0, -1), bi("cn2", t, e, pi, i, 0, -1), bi("cn3", t, e, pi, 0, -r, -1), bi("cn4", t, e, pi, 0, r, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function bi(n, e, t, i, r, s, o) {
  h_.set(r, s, o).unproject(i);
  const a = e[n];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, d = a.length; c < d; c++)
      l.setXYZ(a[c], h_.x, h_.y, h_.z);
  }
}
const d_ = /* @__PURE__ */ new so();
class VD extends Rv {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), s = new qn();
    s.setIndex(new Vi(i, 1)), s.setAttribute("position", new Vi(r, 3)), super(s, new kc({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && d_.setFromObject(this.object), d_.isEmpty())
      return;
    const t = d_.min, i = d_.max, r = this.geometry.attributes.position, s = r.array;
    s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
}
class zhe {
  constructor() {
    this.type = "ShapePath", this.color = new xt(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new x2(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(S) {
      const C = [];
      for (let M = 0, T = S.length; M < T; M++) {
        const P = S[M], D = new W_();
        D.curves = P.curves, C.push(D);
      }
      return C;
    }
    function i(S, C) {
      const M = C.length;
      let T = !1;
      for (let P = M - 1, D = 0; D < M; P = D++) {
        let I = C[P], k = C[D], O = k.x - I.x, B = k.y - I.y;
        if (Math.abs(B) > Number.EPSILON) {
          if (B < 0 && (I = C[D], O = -O, k = C[P], B = -B), S.y < I.y || S.y > k.y)
            continue;
          if (S.y === I.y) {
            if (S.x === I.x)
              return !0;
          } else {
            const Y = B * (S.x - I.x) - O * (S.y - I.y);
            if (Y === 0)
              return !0;
            if (Y < 0)
              continue;
            T = !T;
          }
        } else {
          if (S.y !== I.y)
            continue;
          if (k.x <= S.x && S.x <= I.x || I.x <= S.x && S.x <= k.x)
            return !0;
        }
      }
      return T;
    }
    const r = zd.isClockWise, s = this.subPaths;
    if (s.length === 0)
      return [];
    let o, a, l;
    const c = [];
    if (s.length === 1)
      return a = s[0], l = new W_(), l.curves = a.curves, c.push(l), c;
    let d = !r(s[0].getPoints());
    d = e ? !d : d;
    const p = [], m = [];
    let v = [], b = 0, x;
    m[b] = void 0, v[b] = [];
    for (let S = 0, C = s.length; S < C; S++)
      a = s[S], x = a.getPoints(), o = r(x), o = e ? !o : o, o ? (!d && m[b] && b++, m[b] = { s: new W_(), p: x }, m[b].s.curves = a.curves, d && b++, v[b] = []) : v[b].push({ h: a, p: x[0] });
    if (!m[0])
      return t(s);
    if (m.length > 1) {
      let S = !1, C = 0;
      for (let M = 0, T = m.length; M < T; M++)
        p[M] = [];
      for (let M = 0, T = m.length; M < T; M++) {
        const P = v[M];
        for (let D = 0; D < P.length; D++) {
          const I = P[D];
          let k = !0;
          for (let O = 0; O < m.length; O++)
            i(I.p, m[O].p) && (M !== O && C++, k ? (k = !1, p[O].push(I)) : S = !0);
          k && p[M].push(I);
        }
      }
      C > 0 && S === !1 && (v = p);
    }
    let y;
    for (let S = 0, C = m.length; S < C; S++) {
      l = m[S].s, c.push(l), y = v[S];
      for (let M = 0, T = y.length; M < T; M++)
        l.holes.push(y[M].h);
    }
    return c;
  }
}
const ol = /* @__PURE__ */ cX();
function cX() {
  const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), i = new Uint32Array(512), r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27 ? (i[l] = 0, i[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14, i[l | 256] = 1024 >> -c - 14 | 32768, r[l] = -c - 1, r[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10, i[l | 256] = c + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : c < 128 ? (i[l] = 31744, i[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (i[l] = 31744, i[l | 256] = 64512, r[l] = 13, r[l | 256] = 13);
  }
  const s = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13, d = 0;
    for (; (c & 8388608) === 0; )
      c <<= 1, d -= 8388608;
    c &= -8388609, d += 947912704, s[l] = c | d;
  }
  for (let l = 1024; l < 2048; ++l)
    s[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    o[l] = l << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    o[l] = 2147483648 + (l - 32 << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a
  };
}
function uX(n) {
  Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = Ui(n, -65504, 65504), ol.floatView[0] = n;
  const e = ol.uint32View[0], t = e >> 23 & 511;
  return ol.baseTable[t] + ((e & 8388607) >> ol.shiftTable[t]);
}
function hX(n) {
  const e = n >> 10;
  return ol.uint32View[0] = ol.mantissaTable[ol.offsetTable[e] + (n & 1023)] + ol.exponentTable[e], ol.floatView[0];
}
var f_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toHalfFloat: uX,
  fromHalfFloat: hX
});
class dX extends On {
  constructor(e, t, i) {
    console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, i), this.samples = 4;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: rh
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = rh);
class fX {
  constructor(e = void 0) {
    this._cb = e, this.done = void 0, this._value = void 0, this._callbacks = void 0, this._watched = void 0;
  }
  then(e) {
    var t;
    return this.done ? (e(this._value), pX) : (((t = this._callbacks) !== null && t !== void 0 ? t : this._callbacks = /* @__PURE__ */ new Set()).add(e), new Ru(() => this._callbacks.delete(e)));
  }
  watch(e) {
    var t;
    return this.done ? e._resolve(this._value) : (((t = this._watched) !== null && t !== void 0 ? t : this._watched = /* @__PURE__ */ new Set()).add(e), e.then(() => this._watched.delete(e)), e);
  }
  _resolve(e) {
    var t;
    if (this.done)
      return this;
    if (this.done = !0, this._value = e, (t = this._cb) === null || t === void 0 || t.call(this, e), this._callbacks)
      for (const i of this._callbacks)
        i(e);
    if (this._watched)
      for (const i of this._watched)
        i._resolve(e);
    return this;
  }
}
class Ru extends fX {
  constructor(e) {
    super(e);
  }
  cancel() {
    return this._resolve();
  }
}
const pX = new Ru().cancel(), HD = window;
"__LINCODE_PROMISELIKES__" in HD && console.warn("multiple versions of @lincode/promiselikes detected");
HD.__LINCODE_PROMISELIKES__ = !0;
class ME {
  constructor() {
    this.cbsMap = /* @__PURE__ */ new Map();
  }
  on(e, t) {
    var i;
    if (Array.isArray(e)) {
      const s = new Ru();
      for (const o of e)
        s.watch(this.on(o, t));
      return s;
    }
    !((i = this.states) === null || i === void 0) && i.has(e) && t(this.states.get(e));
    const r = Mr(this.cbsMap, e, () => /* @__PURE__ */ new Set());
    return r.add(t), new Ru(() => r.delete(t));
  }
  once(e, t) {
    const i = new Ru();
    return i.watch(this.on(e, (r) => {
      i.cancel(), t(r);
    })), i;
  }
  emit(e, t) {
    if (this.cbsMap.has(e))
      for (const i of this.cbsMap.get(e))
        i(t);
  }
  hasState(e) {
    var t;
    return !!(!((t = this.states) === null || t === void 0) && t.has(e));
  }
  setState(e, t) {
    var i;
    (i = this.states) !== null && i !== void 0 || (this.states = /* @__PURE__ */ new Map()), !(this.states.has(e) && this.states.get(e) === t) && (this.states.set(e, t), this.emit(e, t));
  }
  getState(e) {
    var t;
    return (t = this.states) === null || t === void 0 ? void 0 : t.get(e);
  }
  deleteState(e) {
    var t;
    (t = this.states) === null || t === void 0 || t.delete(e);
  }
  clear() {
    var e;
    this.cbsMap.clear(), (e = this.states) === null || e === void 0 || e.clear();
  }
}
class mX {
  constructor() {
    this.cbs = /* @__PURE__ */ new Set();
  }
  on(e) {
    return "state" in this && e(this.state), this.cbs.add(e), new Ru(() => this.cbs.delete(e));
  }
  once(e) {
    const t = new Ru();
    return t.watch(this.on((i) => {
      t.cancel(), e(i);
    })), t;
  }
  emit(e) {
    for (const t of this.cbs)
      t(e);
  }
  setState(e) {
    "state" in this && this.state === e || (this.state = e, this.emit(e));
  }
  getState() {
    return this.state;
  }
}
const di = () => {
  const n = new mX();
  return [(s) => n.emit(s), (s, o) => o ? n.once(s) : n.on(s), (s) => n.setState(s), () => n.getState()];
}, [$1, Pn] = di(), [ev, hr] = Be([]), yA = nh(
  ev,
  hr
), vX = ih(
  ev,
  hr
), EE = XV(
  ev,
  hr
), T2 = [!1], gX = async (n) => {
  T2[0] = !0;
  const e = hr();
  ev([]), await Promise.resolve(), n(), await Promise.resolve(), await Promise.resolve(), ev(e), T2[0] = !1;
}, [Lv, Nn] = Be(void 0), bt = new b2();
ft(() => {
  const n = Nn();
  if (!n)
    return;
  const e = new VD(n.nativeObject3d), t = requestAnimationFrame(() => bt.add(e)), i = Pn(() => e.update());
  return () => {
    cancelAnimationFrame(t), bt.remove(e), i.cancel();
  };
}, [Nn]);
ft(() => {
  const n = hr();
  if (!n.length)
    return;
  const e = [];
  for (const i of n) {
    const r = new VD(i.outerObject3d);
    bt.add(r), e.push(r);
  }
  const t = Pn(() => {
    for (const i of e)
      i.update();
  });
  return () => {
    for (const i of e)
      bt.remove(i);
    t.cancel();
  };
}, [hr]);
const GD = 100, Ut = 1 / GD, Ai = GD, WD = Number.EPSILON, zs = 100 * Ut, fl = zs * 0.5, Eb = /* @__PURE__ */ new WeakMap(), Cb = /* @__PURE__ */ new WeakMap(), xA = () => ({}), wA = (n, e) => {
  Object.assign(
    Mr(Eb, n, xA),
    Eb.get(e)
  ), Object.assign(
    Mr(Cb, n, xA),
    Cb.get(e)
  );
}, yt = (n, e, t, i) => {
  const r = {};
  t && Eb.set(r, t), i && Cb.set(r, i);
  for (const s of n)
    Object.assign(r, s), wA(r, s);
  return Object.assign(r, e), wA(r, e), r;
};
class Tn {
  constructor(e) {
    this.value = e;
  }
}
class dt {
  constructor(e, t, i) {
    this.min = e, this.max = t, this.step = i;
  }
}
const Vf = {
  color: String,
  opacity: Number,
  texture: [String, Object],
  videoTexture: [String, Object],
  alphaMap: String,
  textureRepeat: [Object, Number],
  textureFlipY: Boolean,
  textureRotation: Number
}, Dv = yt(
  [],
  {
    color: new Tn("#ffffff"),
    opacity: new Tn(1),
    texture: void 0,
    videoTexture: void 0,
    alphaMap: void 0,
    textureRepeat: new Tn({ x: 1, y: 1 }),
    textureFlipY: new Tn(!1),
    textureRotation: new Tn(0)
  },
  {
    opacity: new dt(0, 1),
    textureRotation: new dt(0, 360)
  }
), Li = (n, e) => n[e];
class Is {
  constructor(e, t) {
    this.x = e, this.y = t;
  }
}
class yf {
  constructor(e, t, i) {
    this.x = e, this.y = t, this.z = i;
  }
}
const pl = 180 / Math.PI, Pi = Math.PI / 180, Z1 = (n, e, t, i, r, s) => {
  const o = t - e, a = r - i, l = i + (n - e) / o * a;
  if (!s)
    return l;
  let c, d;
  return i < r ? (c = i, d = r) : (c = r, d = i), l < c ? c : l > d ? d : l;
}, Y1 = (n, e, t, i) => Math.sqrt((n - t) ** 2 + (e - i) ** 2), jD = (n, e, t, i, r, s) => Math.sqrt((n - i) ** 2 + (e - r) ** 2 + (t - s) ** 2), _X = (n, e, t, i) => {
  const r = Y1(n.x, n.y, e.x, e.y), s = Y1(n.x, n.y, t.x, t.y), o = Y1(e.x, e.y, t.x, t.y), a = Math.acos((r * r + s * s - o * o) / (2 * r * s)) * pl;
  return i ? 360 - a : a;
}, bX = (n, e, t) => {
  const i = t * Pi, r = n.x - e.x, s = n.y - e.y, o = r * Math.cos(i) - s * Math.sin(i), a = r * Math.sin(i) + s * Math.cos(i);
  return new Is(o + e.x, a + e.y);
}, yX = (n, e, t, i) => n >= t && e <= i ? 1 : n <= t && e <= i ? 2 : n <= t && e >= i ? 3 : 4, xX = (n, e, t, i) => {
  const r = t *= Pi;
  return new Is(n + i * Math.cos(r), e + i * Math.sin(r));
};
class CE {
  constructor(e = void 0) {
    this._cb = e, this.done = void 0, this._value = void 0, this._callbacks = void 0, this._watched = void 0;
  }
  then(e) {
    var t;
    return this.done ? (e(this._value), SX) : (((t = this._callbacks) !== null && t !== void 0 ? t : this._callbacks = /* @__PURE__ */ new Set()).add(e), new Xn(() => this._callbacks.delete(e)));
  }
  watch(e) {
    var t;
    return this.done ? e._resolve(this._value) : (((t = this._watched) !== null && t !== void 0 ? t : this._watched = /* @__PURE__ */ new Set()).add(e), e.then(() => this._watched.delete(e)), e);
  }
  _resolve(e) {
    var t;
    if (this.done)
      return this;
    if (this.done = !0, this._value = e, (t = this._cb) === null || t === void 0 || t.call(this, e), this._callbacks)
      for (const i of this._callbacks)
        i(e);
    if (this._watched)
      for (const i of this._watched)
        i._resolve(e);
    return this;
  }
}
class qD extends CE {
  constructor(e) {
    super(e);
  }
  resolve(e) {
    return this._resolve(e);
  }
}
class Xn extends CE {
  constructor(e) {
    super(e);
  }
  cancel() {
    return this._resolve();
  }
}
class wX extends CE {
  constructor(e) {
    super(e);
  }
  _resolve() {
    return this.dispose(), this;
  }
  dispose() {
    return super._resolve();
  }
}
const SX = new Xn().cancel();
let XD = (n = 21) => crypto.getRandomValues(new Uint8Array(n)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += "-" : e += "_", e), "");
const [MX, Tb] = Be("#000000"), [EX, $D] = Be(!1), [CX, Ln] = Be(void 0);
ft(() => {
  const n = new dD({
    powerPreference: "high-performance",
    alpha: !0,
    logarithmicDepthBuffer: !0,
    antialias: !0,
    precision: "highp"
  });
  return n.physicallyCorrectLights = !0, n.setPixelRatio(window.devicePixelRatio * 2), n.setSize(window.innerWidth, window.innerHeight), n.shadowMap.enabled = !0, n.shadowMap.type = OL, n.toneMapping = GL, n.toneMappingExposure = 1, n.outputEncoding = Tt, n.sortObjects = !1, CX(n), () => {
    n.dispose();
  };
}, [Tb, $D]);
const TX = 375, PX = 667, SA = 100, pc = 60, tv = 1 / pc, ZD = 10, YD = 175, p_ = 5.7, uh = 0.1, Mc = 1e3, Cy = -55e-4, KD = "https://unpkg.com/lingo3d-dummy@1.0.4/assets/", P2 = KD + "ybot.fbx", TE = "https://unpkg.com/lingo3d-textures@1.0.4/assets/", JD = TE + "waternormals.jpg", AX = "https://unpkg.com/lingo3d-facade@1.0.0/assets/", RX = "https://unpkg.com/lingo3d-forest@1.0.0/assets/", QD = "https://unpkg.com/lingo3d-editor@1.0.5/assets/", kX = "https://unpkg.com/lingo3d-wasm@1.0.1/assets/", e5 = "2.0.3", ki = 12, Os = ki * 2, t5 = Number.MAX_SAFE_INTEGER / ki, xf = 28, Pb = 200, n5 = 25, [LX, A2] = Be(pc), [i5, Ty] = Be(0), R2 = () => i5(Ty() + 1), Fd = () => setTimeout(() => i5(Ty() - 1)), [DX, MA] = Be(!1), IX = Ty(
  No((n) => {
    n || (IX.cancel(), DX(!0));
  }, 100)
), [OX, k2] = Be(!1), [NX, zX] = di(), [K1, Ec] = di(), FX = Ec(() => {
  FX.cancel();
});
let r5 = !1;
const J1 = (n) => r5 = !1, [EA, CA] = Be(!1);
ft(() => {
  CA();
  const n = () => J1(), e = () => J1(), t = () => {
    J1(), EA(!1), setTimeout(() => EA(!1), 1e3);
  };
  window.addEventListener("blur", n), window.addEventListener("focus", e), document.addEventListener("visibilitychange", e), window.addEventListener("resize", t);
  const i = setInterval(e, 1e3);
  return e(), () => {
    window.removeEventListener("blur", n), window.removeEventListener("focus", e), document.removeEventListener("visibilitychange", e), window.removeEventListener("resize", t), clearInterval(i);
  };
}, [CA]);
const Py = (n, e, t) => {
  let i = 0;
  const r = setInterval(() => {
    t(), e !== -1 && ++i >= e && clearInterval(r);
  }, n);
  return new Xn(() => clearInterval(r));
}, L2 = /* @__PURE__ */ new Set(), BX = new ND();
let hu = 0;
const ta = [1], Iv = [0];
let TA = 0;
ft(() => {
  const n = Ln();
  if (!n || k2() && !MA())
    return;
  const e = 1 / A2() * 0.9;
  n.setAnimationLoop(() => {
    if (!r5 && (hu += BX.getDelta(), hu > 0.2 && (hu = 0), !(hu < e))) {
      ta[0] = hu * pc, Iv[0] = hu, hu = 0;
      for (const t of L2)
        t();
      ++TA === 2 && (TA = 0, NX());
    }
  });
}, [A2, Ln, MA, k2]);
const ku = (n) => (L2.add(n), new Xn(() => L2.delete(n))), [UX, Ay] = di(), [VX, PE] = di(), j_ = No(VX), Ov = (n) => n.userData.manager, Ds = (n, e) => {
  var t, i;
  return (i = (t = n.userData).manager) != null ? i : t.manager = e;
}, Zr = /* @__PURE__ */ new Set(), ko = /* @__PURE__ */ new WeakSet(), AE = /* @__PURE__ */ new WeakSet(), no = /* @__PURE__ */ new Map();
class Ii extends wX {
  constructor(t = new wn()) {
    super();
    V(this, "nativeObject3d");
    V(this, "parent");
    V(this, "children");
    V(this, "_uuid");
    V(this, "_proxy");
    V(this, "handles");
    V(this, "_onLoop");
    this.outerObject3d = t, Ds(t, this), this.nativeObject3d = t, Zr.add(this), j_();
  }
  _append(t) {
    var i, r, s;
    Zr.delete(t), j_(), (r = (i = t.parent) == null ? void 0 : i.children) == null || r.delete(t), t.parent = this, ((s = this.children) != null ? s : this.children = /* @__PURE__ */ new Set()).add(t);
  }
  append(t) {
    this._append(t), this.outerObject3d.add(t.outerObject3d);
  }
  attach(t) {
    this._append(t), this.outerObject3d.attach(t.outerObject3d);
  }
  dispose() {
    var t, i, r;
    if (this.done)
      return this;
    if (super.dispose(), this._uuid !== void 0 && no.delete(this._uuid), this.handles)
      for (const s of this.handles.values())
        s.cancel();
    if (Zr.delete(this), (i = (t = this.parent) == null ? void 0 : t.children) == null || i.delete(this), this.parent = void 0, j_(), UX(this), (r = this.outerObject3d.parent) == null || r.remove(this.outerObject3d), this.children)
      for (const s of this.children)
        s.dispose();
    return this;
  }
  traverse(t) {
    var i;
    for (const r of (i = this.children) != null ? i : [])
      t(r), r.traverse(t);
  }
  traverseSome(t) {
    var i;
    for (const r of (i = this.children) != null ? i : []) {
      if (t(r))
        return !0;
      r.traverseSome(t);
    }
    return !1;
  }
  get uuid() {
    if (this._uuid !== void 0)
      return this._uuid;
    const t = this._uuid = XD();
    return no.set(t, this), t;
  }
  set uuid(t) {
    this._uuid === void 0 && (this._uuid = t, no.set(t, this));
  }
  get proxy() {
    return this._proxy;
  }
  set proxy(t) {
    this._proxy && Bs(this._proxy, "__target", void 0), this._proxy = t, t && Bs(t, "__target", this);
  }
  timer(t, i, r) {
    return this.watch(Py(t, i, r));
  }
  beforeRender(t) {
    return this.watch(Pn(t));
  }
  queueMicrotask(t) {
    queueMicrotask(() => !this.done && t());
  }
  cancellable(t) {
    return this.watch(new Xn(t));
  }
  createEffect(t, i) {
    return this.watch(ft(t, i));
  }
  cancelHandle(t, i) {
    var o, a;
    const r = (o = this.handles) != null ? o : this.handles = /* @__PURE__ */ new Map();
    if ((a = r.get(t)) == null || a.cancel(), !i)
      return;
    const s = i();
    return r.set(t, s), s;
  }
  get onLoop() {
    return this._onLoop;
  }
  set onLoop(t) {
    this._onLoop = t, this.cancelHandle("onLoop", t && (() => Pn(t)));
  }
}
const s5 = /* @__PURE__ */ new Set(), ya = (n) => {
  for (const e of n)
    s5.add(e);
}, _s = {
  onLoop: Function,
  proxy: Object,
  uuid: String
};
ya(["proxy", "uuid"]);
const bs = yt([], {
  onLoop: void 0,
  proxy: void 0,
  uuid: ""
}), o5 = {
  ..._s,
  ...Vf
}, a5 = yt(
  [bs, Dv],
  {}
), HX = () => {
  const n = /* @__PURE__ */ new Map(), e = No(() => {
    for (const t of n.values())
      t();
    n.clear();
  });
  return (t, i) => {
    n.set(t, i), e();
  };
}, PA = [0], AA = /* @__PURE__ */ new Map(), RE = /* @__PURE__ */ new Set(), GX = (n) => {
  RE.add(n);
}, WX = (n) => {
  RE.delete(n);
}, Ry = (n) => (e) => {
  AA.set(n, e.loaded), PA[0] = [...AA.values()].reduce(
    (t, i) => t + i,
    0
  ), RE.forEach((t) => {
    try {
      t(PA[0]);
    } finally {
    }
  });
};
class l5 extends kq {
  constructor(e) {
    super(e), this.type = $r;
  }
  parse(e) {
    const a = function(M, T) {
      switch (M) {
        case 1:
          console.error("THREE.RGBELoader Read Error: " + (T || ""));
          break;
        case 2:
          console.error("THREE.RGBELoader Write Error: " + (T || ""));
          break;
        case 3:
          console.error("THREE.RGBELoader Bad File Format: " + (T || ""));
          break;
        default:
        case 4:
          console.error("THREE.RGBELoader: Error: " + (T || ""));
      }
      return -1;
    }, p = `
`, m = function(M, T, P) {
      T = T || 1024;
      let I = M.pos, k = -1, O = 0, B = "", Y = String.fromCharCode.apply(null, new Uint16Array(M.subarray(I, I + 128)));
      for (; 0 > (k = Y.indexOf(p)) && O < T && I < M.byteLength; )
        B += Y, O += Y.length, I += 128, Y += String.fromCharCode.apply(null, new Uint16Array(M.subarray(I, I + 128)));
      return -1 < k ? (P !== !1 && (M.pos += O + k + 1), B + Y.slice(0, k)) : !1;
    }, v = function(M) {
      const T = /^#\?(\S+)/, P = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, D = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, I = /^\s*FORMAT=(\S+)\s*$/, k = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, O = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let B, Y;
      if (M.pos >= M.byteLength || !(B = m(M)))
        return a(1, "no header found");
      if (!(Y = B.match(T)))
        return a(3, "bad initial token");
      for (O.valid |= 1, O.programtype = Y[1], O.string += B + `
`; B = m(M), B !== !1; ) {
        if (O.string += B + `
`, B.charAt(0) === "#") {
          O.comments += B + `
`;
          continue;
        }
        if ((Y = B.match(P)) && (O.gamma = parseFloat(Y[1])), (Y = B.match(D)) && (O.exposure = parseFloat(Y[1])), (Y = B.match(I)) && (O.valid |= 2, O.format = Y[1]), (Y = B.match(k)) && (O.valid |= 4, O.height = parseInt(Y[1], 10), O.width = parseInt(Y[2], 10)), O.valid & 2 && O.valid & 4)
          break;
      }
      return O.valid & 2 ? O.valid & 4 ? O : a(3, "missing image size specifier") : a(3, "missing format specifier");
    }, b = function(M, T, P) {
      const D = T;
      if (D < 8 || D > 32767 || M[0] !== 2 || M[1] !== 2 || M[2] & 128)
        return new Uint8Array(M);
      if (D !== (M[2] << 8 | M[3]))
        return a(3, "wrong scanline width");
      const I = new Uint8Array(4 * T * P);
      if (!I.length)
        return a(4, "unable to allocate buffer space");
      let k = 0, O = 0;
      const B = 4 * D, Y = new Uint8Array(4), G = new Uint8Array(B);
      let K = P;
      for (; K > 0 && O < M.byteLength; ) {
        if (O + 4 > M.byteLength)
          return a(1);
        if (Y[0] = M[O++], Y[1] = M[O++], Y[2] = M[O++], Y[3] = M[O++], Y[0] != 2 || Y[1] != 2 || (Y[2] << 8 | Y[3]) != D)
          return a(3, "bad rgbe scanline format");
        let A = 0, J;
        for (; A < B && O < M.byteLength; ) {
          J = M[O++];
          const se = J > 128;
          if (se && (J -= 128), J === 0 || A + J > B)
            return a(3, "bad scanline data");
          if (se) {
            const oe = M[O++];
            for (let Q = 0; Q < J; Q++)
              G[A++] = oe;
          } else
            G.set(M.subarray(O, O + J), A), A += J, O += J;
        }
        const xe = D;
        for (let se = 0; se < xe; se++) {
          let oe = 0;
          I[k] = G[se + oe], oe += D, I[k + 1] = G[se + oe], oe += D, I[k + 2] = G[se + oe], oe += D, I[k + 3] = G[se + oe], k += 4;
        }
        K--;
      }
      return I;
    }, x = function(M, T, P, D) {
      const I = M[T + 3], k = Math.pow(2, I - 128) / 255;
      P[D + 0] = M[T + 0] * k, P[D + 1] = M[T + 1] * k, P[D + 2] = M[T + 2] * k, P[D + 3] = 1;
    }, y = function(M, T, P, D) {
      const I = M[T + 3], k = Math.pow(2, I - 128) / 255;
      P[D + 0] = f_.toHalfFloat(Math.min(M[T + 0] * k, 65504)), P[D + 1] = f_.toHalfFloat(Math.min(M[T + 1] * k, 65504)), P[D + 2] = f_.toHalfFloat(Math.min(M[T + 2] * k, 65504)), P[D + 3] = f_.toHalfFloat(1);
    }, S = new Uint8Array(e);
    S.pos = 0;
    const C = v(S);
    if (C !== -1) {
      const M = C.width, T = C.height, P = b(S.subarray(S.pos), M, T);
      if (P !== -1) {
        let D, I, k;
        switch (this.type) {
          case Qs:
            k = P.length / 4;
            const O = new Float32Array(k * 4);
            for (let Y = 0; Y < k; Y++)
              x(P, Y * 4, O, Y * 4);
            D = O, I = Qs;
            break;
          case $r:
            k = P.length / 4;
            const B = new Uint16Array(k * 4);
            for (let Y = 0; Y < k; Y++)
              y(P, Y * 4, B, Y * 4);
            D = B, I = $r;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: M,
          height: T,
          data: D,
          header: C.string,
          gamma: C.gamma,
          exposure: C.exposure,
          type: I
        };
      }
    }
    return null;
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, i, r) {
    function s(o, a) {
      switch (o.type) {
        case Qs:
        case $r:
          o.encoding = Ro, o.minFilter = Zt, o.magFilter = Zt, o.generateMipmaps = !1, o.flipY = !0;
          break;
      }
      t && t(o, a);
    }
    return super.load(e, s, i, r);
  }
}
const [c5, kE] = Be(0), ky = () => c5(kE() + 1), Ly = () => setTimeout(() => c5(kE() - 1)), jX = /* @__PURE__ */ new Map(), qX = new DD(), XX = new l5(), RA = new ME(), Wr = (n, e) => {
  e && RA.once(n, () => queueMicrotask(e));
  const t = Mr(jX, n, () => {
    const i = n.startsWith("https://unpkg.com/");
    return i && ky(), (n.toLowerCase().endsWith(".hdr") ? XX : qX).load(
      n,
      (o) => {
        o.wrapS = o.wrapT = qr, o.encoding = Tt, o.flipY = !0, o.magFilter = kn, o.needsUpdate = !0, o.anisotropy = 20, o.minFilter = kn, o.generateMipmaps = !1, RA.setState(n), i && Ly();
      },
      Ry(n)
    );
  });
  return t.constructor === Ff ? t : t.clone();
}, pd = ["map", "alphaMap"], $X = HX();
class Bd extends Ii {
  constructor(t) {
    super();
    V(this, "videoTextureState");
    V(this, "textureState");
    V(this, "_alphaMap");
    V(this, "_textureRepeat");
    V(this, "_textureFlipY");
    V(this, "_textureRotation");
    this.nativeMaterial = t, AE.add(this), ko.add(this);
  }
  dispose() {
    return this.done ? this : (super.dispose(), this.nativeMaterial.dispose(), this);
  }
  get color() {
    return "#" + this.nativeMaterial.color.getHexString();
  }
  set color(t) {
    this.nativeMaterial.color.set(t);
  }
  get opacity() {
    return this.nativeMaterial.opacity;
  }
  set opacity(t) {
    this.nativeMaterial.opacity = t, this.nativeMaterial.transparent = t <= 1, this.nativeMaterial.needsUpdate = !0;
  }
  applyTexture(t) {
    $X(this, () => {
      const i = this._textureRepeat, r = this._textureFlipY, s = this._textureRotation;
      for (const o of t) {
        const a = this.nativeMaterial[o];
        if (!a)
          return;
        i !== void 0 && (a.repeat = i), s !== void 0 && (a.rotation = s * Pi), r !== void 0 && r !== a.flipY && (a.flipY = r, a.needsUpdate = !0), a.encoding = Tt;
      }
    }), this.nativeMaterial.needsUpdate = !0;
  }
  initTexture() {
    if (this.textureState)
      return;
    const t = this.videoTextureState = new Je(void 0), i = this.textureState = new Je(void 0);
    this.createEffect(() => {
      const r = i.get(), s = t.get();
      if (s) {
        let l;
        typeof s == "string" ? (l = document.createElement("video"), l.crossOrigin = "anonymous", l.src = s, l.loop = !0, l.autoplay = !0, l.muted = !0, l.playsInline = !0, l.play()) : l = s;
        const c = new gD(
          l,
          void 0,
          qu,
          qu
        ), { nativeMaterial: d } = this, { map: p } = d;
        return d.map = c, this.applyTexture(pd), () => {
          l.pause(), c.dispose(), d.map = p;
        };
      }
      if (!r)
        return;
      const { nativeMaterial: o } = this, { map: a } = o;
      return o.map = Wr(r), o.map.anisotropy = 200, o.llightMapIntens, this.applyTexture(pd), () => {
        o.map = a;
      };
    }, [t.get, i.get]);
  }
  get videoTexture() {
    var t;
    return (t = this.videoTextureState) == null ? void 0 : t.get();
  }
  set videoTexture(t) {
    this.initTexture(), this.videoTextureState.set(t);
  }
  get texture() {
    var t;
    return (t = this.textureState) == null ? void 0 : t.get();
  }
  set texture(t) {
    this.initTexture(), this.textureState.set(t);
  }
  get alphaMap() {
    return this._alphaMap;
  }
  set alphaMap(t) {
    this._alphaMap = t, this.nativeMaterial.alphaMap = t ? Wr(t) : null, this.applyTexture(pd);
  }
  get textureRepeat() {
    var t, i;
    return (i = (t = this.nativeMaterial.map) == null ? void 0 : t.repeat) != null ? i : this._textureRepeat;
  }
  set textureRepeat(t) {
    typeof t == "number" && (t = new ze(t, t)), this._textureRepeat = t, this.applyTexture(pd);
  }
  get textureFlipY() {
    var t, i;
    return (i = (t = this.nativeMaterial.map) == null ? void 0 : t.flipY) != null ? i : this._textureFlipY;
  }
  set textureFlipY(t) {
    this._textureFlipY = t, this.applyTexture(pd);
  }
  get textureRotation() {
    return this.nativeMaterial.map ? this.nativeMaterial.map.rotation * pl : this._textureRotation;
  }
  set textureRotation(t) {
    this._textureRotation = t, this.applyTexture(pd);
  }
}
V(Bd, "componentName", "basicMaterial"), V(Bd, "defaults", a5), V(Bd, "schema", o5);
const Nv = {
  wireframe: Boolean,
  envMap: String,
  envMapIntensity: Number,
  aoMap: String,
  aoMapIntensity: Number,
  bumpMap: String,
  bumpScale: Number,
  displacementMap: String,
  displacementScale: Number,
  displacementBias: Number,
  emissive: Boolean,
  emissiveIntensity: Number,
  lightMap: String,
  lightMapIntensity: Number,
  metalnessMap: String,
  metalness: Number,
  roughnessMap: String,
  roughness: Number,
  normalMap: String,
  normalScale: Number
}, Dy = yt(
  [],
  {
    wireframe: new Tn(!1),
    envMap: void 0,
    envMapIntensity: new Tn(1),
    aoMap: void 0,
    aoMapIntensity: new Tn(1),
    bumpMap: void 0,
    bumpScale: new Tn(1),
    displacementMap: void 0,
    displacementScale: new Tn(1),
    displacementBias: new Tn(0),
    emissive: new Tn(!1),
    emissiveIntensity: new Tn(1),
    lightMap: void 0,
    lightMapIntensity: new Tn(1),
    metalnessMap: void 0,
    metalness: new Tn(0),
    roughnessMap: void 0,
    roughness: new Tn(1),
    normalMap: void 0,
    normalScale: new Tn(1)
  },
  {
    envMapIntensity: new dt(0, 4),
    aoMapIntensity: new dt(0, 4),
    bumpScale: new dt(0, 4),
    displacementScale: new dt(0, 4),
    displacementBias: new dt(0, 4),
    emissiveIntensity: new dt(0, 4),
    lightMapIntensity: new dt(0, 4),
    metalness: new dt(-2, 2),
    roughness: new dt(0, 4),
    normalScale: new dt(0, 4)
  }
), ZX = {
  ...o5,
  ...Nv
}, YX = yt(
  [a5, Dy],
  {}
), Ql = [
  "map",
  "alphaMap",
  "envMap",
  "aoMap",
  "bumpMap",
  "displacementMap",
  "lightMap",
  "metalnessMap",
  "roughnessMap",
  "normalMap"
];
class q_ extends Bd {
  constructor() {
    super(...arguments);
    V(this, "_envMap");
    V(this, "_aoMap");
    V(this, "_bumpMap");
    V(this, "_displacementMap");
    V(this, "_lightMap");
    V(this, "_metalnessMap");
    V(this, "_roughnessMap");
    V(this, "_normalMap");
  }
  get wireframe() {
    return this.nativeMaterial.wireframe;
  }
  set wireframe(t) {
    this.nativeMaterial.wireframe = t;
  }
  get envMap() {
    return this._envMap;
  }
  set envMap(t) {
    this._envMap = t, this.nativeMaterial.envMap = t ? Wr(t) : null, this.applyTexture(Ql);
  }
  get envMapIntensity() {
    return this.nativeMaterial.envMapIntensity;
  }
  set envMapIntensity(t) {
    this.nativeMaterial.envMapIntensity = t;
  }
  get aoMap() {
    return this._aoMap;
  }
  set aoMap(t) {
    this._aoMap = t, this.nativeMaterial.aoMap = t ? Wr(t) : null, this.applyTexture(Ql);
  }
  get aoMapIntensity() {
    return this.nativeMaterial.aoMapIntensity;
  }
  set aoMapIntensity(t) {
    this.nativeMaterial.aoMapIntensity = t;
  }
  get bumpMap() {
    return this._bumpMap;
  }
  set bumpMap(t) {
    this._bumpMap = t, this.nativeMaterial.bumpMap = t ? Wr(t) : null, this.applyTexture(Ql);
  }
  get bumpScale() {
    return this.nativeMaterial.bumpScale;
  }
  set bumpScale(t) {
    this.nativeMaterial.bumpScale = t;
  }
  get displacementMap() {
    return this._displacementMap;
  }
  set displacementMap(t) {
    this._displacementMap = t, this.nativeMaterial.displacementMap = t ? Wr(t) : null, this.applyTexture(Ql);
  }
  get displacementScale() {
    return this.nativeMaterial.displacementScale;
  }
  set displacementScale(t) {
    this.nativeMaterial.displacementScale = t;
  }
  get displacementBias() {
    return this.nativeMaterial.displacementBias;
  }
  set displacementBias(t) {
    this.nativeMaterial.displacementBias = t;
  }
  get emissiveIntensity() {
    return this.nativeMaterial.emissiveIntensity;
  }
  set emissiveIntensity(t) {
    this.nativeMaterial.emissiveIntensity = t;
  }
  get emissive() {
    return this.nativeMaterial.emissive.getHexString() !== "000000";
  }
  set emissive(t) {
    this.nativeMaterial.emissive = t ? this.nativeMaterial.color : new xt(0);
  }
  get lightMap() {
    return this._lightMap;
  }
  set lightMap(t) {
    this._lightMap = t, this.nativeMaterial.lightMap = t ? Wr(t) : null, this.applyTexture(Ql);
  }
  get lightMapIntensity() {
    return this.nativeMaterial.lightMapIntensity;
  }
  set lightMapIntensity(t) {
    this.nativeMaterial.lightMapIntensity = t;
  }
  get metalnessMap() {
    return this._metalnessMap;
  }
  set metalnessMap(t) {
    this._metalnessMap = t, this.nativeMaterial.metalnessMap = t ? Wr(t) : null, this.applyTexture(Ql);
  }
  get metalness() {
    return this.nativeMaterial.metalness;
  }
  set metalness(t) {
    this.nativeMaterial.metalness = t;
  }
  get roughnessMap() {
    return this._roughnessMap;
  }
  set roughnessMap(t) {
    this._roughnessMap = t, this.nativeMaterial.roughnessMap = t ? Wr(t) : null, this.applyTexture(Ql);
  }
  get roughness() {
    return this.nativeMaterial.roughness;
  }
  set roughness(t) {
    this.nativeMaterial.roughness = t;
  }
  get normalMap() {
    return this._normalMap;
  }
  set normalMap(t) {
    this._normalMap = t, this.nativeMaterial.normalMap = t ? Wr(t) : null, this.applyTexture(Ql);
  }
  get normalScale() {
    return this.nativeMaterial.normalScale.x;
  }
  set normalScale(t) {
    this.nativeMaterial.normalScale.set(t, t);
  }
}
V(q_, "componentName", "standardMaterial"), V(q_, "defaults", YX), V(q_, "schema", ZX);
const u5 = /* @__PURE__ */ new WeakMap(), zv = (n, e, t, i = [], r, s = Li(
  n,
  "material"
)) => Mr(u5, n, () => {
  if (t) {
    const l = /* @__PURE__ */ new WeakMap();
    return n.traverse(
      (c) => zv(
        c,
        e,
        !1,
        i,
        l
      )
    ), i;
  }
  if (!s)
    return i;
  if (Array.isArray(s) && (s = s[0]), r != null && r.has(s))
    return Bs(n, "material", r.get(s)), i;
  const o = s.clone();
  s === Li(n, "material") && Bs(n, "material", o), r == null || r.set(s, o);
  const a = new q_(o);
  return s.dispose(), e.append(a), i.push(a), i;
}), KX = (n, e) => Mr(u5, n, () => {
  const t = Li(n, "material");
  if (!t)
    return [];
  const i = new Bd(
    Bs(n, "material", t.clone())
  );
  return t.dispose(), e.append(i), [i];
});
class yl {
}
Object.assign(yl.prototype, {
  getMaterial() {
    return KX(this.nativeObject3d, this)[0];
  }
});
for (const n of Object.keys(Vf))
  Object.defineProperty(yl.prototype, n, {
    get() {
      var e;
      return (e = this.getMaterial()) == null ? void 0 : e[n];
    },
    set(e) {
      const t = this.getMaterial();
      !t || (t[n] = e);
    }
  });
class LE extends yl {
}
Object.assign(yl.prototype, {
  getMaterial() {
    return zv(this.nativeObject3d, this)[0];
  }
});
for (const n of Object.keys(Nv))
  Object.defineProperty(yl.prototype, n, {
    get() {
      var e;
      return (e = this.getMaterial()) == null ? void 0 : e[n];
    },
    set(e) {
      const t = this.getMaterial();
      !t || (t[n] = e);
    }
  });
const il = () => {
}, JX = {
  ..._s,
  onClick: Function,
  onMouseDown: Function,
  onMouseUp: Function,
  onMouseOver: Function,
  onMouseOut: Function,
  onMouseMove: Function,
  onLookToEnd: Function,
  lookAt: [Function, Array],
  lookTo: [Function, Array],
  name: String,
  id: String
}, QX = yt(
  [bs],
  {
    onClick: void 0,
    onMouseDown: void 0,
    onMouseUp: void 0,
    onMouseOver: void 0,
    onMouseOut: void 0,
    onMouseMove: void 0,
    onLookToEnd: void 0,
    lookAt: il,
    lookTo: il,
    name: "",
    id: void 0
  }
), e$ = {
  ...JX,
  animations: Object,
  animation: [String, Number, Array, Boolean, Object],
  animationPaused: Boolean,
  animationRepeat: Number,
  onAnimationFinish: Function
};
ya(["animationRepeat"]);
const t$ = yt([QX], {
  animations: {},
  animation: void 0,
  animationPaused: new Tn(!1),
  animationRepeat: new Tn(1 / 0),
  onAnimationFinish: void 0
}), Fv = {
  ..._s,
  x: Number,
  y: Number,
  z: Number,
  onMove: Function
}, Bv = yt(
  [bs],
  { x: 0, y: 0, z: 0, onMove: void 0 }
);
ya(["rotation"]);
const h5 = {
  ...e$,
  ...Fv,
  onIntersect: Function,
  onIntersectOut: Function,
  onMoveToEnd: Function,
  stopMove: Function,
  stopKeyboardMove: Function,
  moveTo: [Function, Array],
  lerpTo: [Function, Array],
  placeAt: [Function, Array],
  translateX: [Function, Array],
  translateY: [Function, Array],
  translateZ: [Function, Array],
  intersectIds: Array,
  scaleX: Number,
  scaleY: Number,
  scaleZ: Number,
  scale: Number,
  rotationX: Number,
  rotationY: Number,
  rotationZ: Number,
  rotation: Number
};
ya(["intersectIds"]);
const d5 = yt(
  [t$, Bv],
  {
    onIntersect: void 0,
    onIntersectOut: void 0,
    onMoveToEnd: void 0,
    moveTo: il,
    lerpTo: il,
    placeAt: il,
    translateX: il,
    translateY: il,
    translateZ: il,
    intersectIds: void 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    scale: 1,
    rotationX: 0,
    rotationY: 0,
    rotationZ: 0,
    rotation: 0
  },
  {
    rotation: new dt(0, 360),
    rotationX: new dt(0, 360),
    rotationY: new dt(0, 360),
    rotationZ: new dt(0, 360),
    scale: new dt(0, 200),
    scaleX: new dt(0, 200),
    scaleY: new dt(0, 200),
    scaleZ: new dt(0, 200)
  }
), n$ = {
  ...h5,
  velocity: Object,
  gravity: Boolean,
  physics: [String, Boolean]
};
ya(["velocity"]);
const i$ = yt([d5], {
  velocity: { x: 0, y: 0, z: 0 },
  gravity: !0,
  physics: !1
}), Iy = {
  ...n$,
  innerRotationX: Number,
  innerRotationY: Number,
  innerRotationZ: Number,
  innerRotation: Number,
  innerX: Number,
  innerY: Number,
  innerZ: Number,
  firstInnerY: Number,
  firstInnerX: Number,
  firstInnerZ: Number,
  width: Number,
  height: Number,
  depth: Number,
  innerVisible: Boolean
};
ya(["innerRotation"]);
const Oy = yt(
  [i$],
  {
    innerRotationX: 0,
    innerRotationY: 0,
    innerRotationZ: 0,
    innerRotation: 0,
    innerX: 0,
    innerY: 0,
    innerZ: 0,
    firstInnerY: 0,
    firstInnerX: 0,
    firstInnerZ: 0,
    width: 100,
    height: 100,
    depth: 100,
    playAllAnimation: !1,
    innerVisible: !0
  },
  {
    innerRotation: new dt(0, 360),
    innerRotationX: new dt(0, 360),
    innerRotationY: new dt(0, 360),
    innerRotationZ: new dt(0, 360),
    innerX: new dt(-1e3, 1e3),
    innerY: new dt(-1e3, 1e3),
    innerZ: new dt(-1e3, 1e3),
    width: new dt(0, 1e3),
    height: new dt(0, 1e3),
    depth: new dt(0, 1e3)
  }
), f5 = {
  bloom: Boolean,
  outline: Boolean,
  visible: Boolean,
  frustumCulled: Boolean,
  castShadow: Boolean,
  receiveShadow: Boolean
}, p5 = yt([], {
  bloom: !1,
  outline: !1,
  visible: !0,
  frustumCulled: !0,
  castShadow: !0,
  receiveShadow: !0
}), Lc = {
  ...Iy,
  ...f5
}, Dc = yt(
  [Oy, p5],
  {}
), DE = {
  ...Lc,
  ...Vf,
  ...Nv
}, IE = yt(
  [
    Dc,
    Dv,
    Dy
  ],
  {}
), Jn = new Z(), Fhe = new Z(), Bhe = new Z(), bu = new Gi(), r$ = new Gi(), Uhe = new Z(0, 0, 0), kA = new Z(
  zs,
  zs,
  zs
), s$ = new Z(
  fl,
  fl,
  fl
), Ud = new so(), m5 = new Nf(), ui = new oh(0, 0, 0, "YXZ"), Vhe = new BD(), v5 = new by(), o$ = new Pt(), xm = Math.PI * 0.5, g5 = new vy({ wireframe: !0 }), _5 = new CD();
/**
 * postprocessing v6.28.7 build Wed Aug 31 2022
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2022 Raoul van Rüschen
 * @license Zlib
 */
var Hf = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", a$ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`, m_ = class extends Yn {
  constructor(n = !1, e = !1) {
    super({
      name: "BokehMaterial",
      defines: {
        PASS: n ? "2" : "1"
      },
      uniforms: {
        inputBuffer: new Ne(null),
        cocBuffer: new Ne(null),
        texelSize: new Ne(new ze()),
        kernel64: new Ne(null),
        kernel16: new Ne(null),
        scale: new Ne(1)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: a$,
      vertexShader: Hf
    }), this.toneMapped = !1, e && (this.defines.FOREGROUND = "1"), this.generateKernel();
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setInputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  set cocBuffer(n) {
    this.uniforms.cocBuffer.value = n;
  }
  setCoCBuffer(n) {
    this.uniforms.cocBuffer.value = n;
  }
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(n) {
    this.uniforms.scale.value = n;
  }
  getScale(n) {
    return this.scale;
  }
  setScale(n) {
    this.scale = n;
  }
  generateKernel() {
    const n = 2.39996323, e = new Float64Array(128), t = new Float64Array(32);
    let i = 0, r = 0;
    for (let s = 0, o = Math.sqrt(80); s < 80; ++s) {
      const a = s * n, l = Math.sqrt(s) / o, c = l * Math.cos(a), d = l * Math.sin(a);
      s % 5 === 0 ? (t[r++] = c, t[r++] = d) : (e[i++] = c, e[i++] = d);
    }
    this.uniforms.kernel64.value = e, this.uniforms.kernel16.value = t;
  }
  setTexelSize(n, e) {
    this.uniforms.texelSize.value.set(n, e);
  }
  setSize(n, e) {
    this.uniforms.texelSize.value.set(1 / n, 1 / e);
  }
};
function LA(n, e) {
  let t = "texel";
  if (n !== null) {
    const i = Number.parseInt(rh);
    if (!(e && i >= 133 && i !== 135 && n.format === wr && n.type === Mi && n.encoding === Tt))
      switch (n.encoding) {
        case Tt:
          t = "sRGBToLinear(texel)";
          break;
        case Ro:
          t = "texel";
          break;
        default:
          throw new Error(`Unsupported encoding: ${n.encoding}`);
      }
  }
  return t;
}
function Id(n, e, t) {
  return n * (e - t) - e;
}
function Su(n, e, t) {
  return Math.min(Math.max((n + e) / (e - t), 0), 1);
}
var l$ = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`, c$ = class extends Yn {
  constructor(n) {
    super({
      name: "CircleOfConfusionMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Ne(null),
        focusDistance: new Ne(0),
        focusRange: new Ne(0),
        cameraNear: new Ne(0.3),
        cameraFar: new Ne(1e3)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: l$,
      vertexShader: Hf
    }), this.toneMapped = !1, this.uniforms.focalLength = this.uniforms.focusRange, this.adoptCameraSettings(n);
  }
  get near() {
    return this.uniforms.cameraNear.value;
  }
  get far() {
    return this.uniforms.cameraFar.value;
  }
  set depthBuffer(n) {
    this.uniforms.depthBuffer.value = n;
  }
  set depthPacking(n) {
    this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(n, e = io) {
    this.depthBuffer = n, this.depthPacking = e;
  }
  get focusDistance() {
    return this.uniforms.focusDistance.value;
  }
  set focusDistance(n) {
    this.uniforms.focusDistance.value = n;
  }
  get worldFocusDistance() {
    return -Id(this.focusDistance, this.near, this.far);
  }
  set worldFocusDistance(n) {
    this.focusDistance = Su(-n, this.near, this.far);
  }
  getFocusDistance(n) {
    this.uniforms.focusDistance.value = n;
  }
  setFocusDistance(n) {
    this.uniforms.focusDistance.value = n;
  }
  get focalLength() {
    return this.focusRange;
  }
  set focalLength(n) {
    this.focusRange = n;
  }
  get focusRange() {
    return this.uniforms.focusRange.value;
  }
  set focusRange(n) {
    this.uniforms.focusRange.value = n;
  }
  get worldFocusRange() {
    return -Id(this.focusRange, this.near, this.far);
  }
  set worldFocusRange(n) {
    this.focusRange = Su(-n, this.near, this.far);
  }
  getFocalLength(n) {
    return this.focusRange;
  }
  setFocalLength(n) {
    this.focusRange = n;
  }
  adoptCameraSettings(n) {
    n && (this.uniforms.cameraNear.value = n.near, this.uniforms.cameraFar.value = n.far, n instanceof ni ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
}, $t = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
}, b5 = {
  RED: 0,
  GREEN: 1,
  BLUE: 2,
  ALPHA: 3
}, Lm = {
  DEFAULT: 0,
  KEEP_MAX_DEPTH: 1,
  DISCARD_MAX_DEPTH: 2
}, ua = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
}, yn = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
}, Uv = {
  VERY_SMALL: 0,
  SMALL: 1,
  MEDIUM: 2,
  LARGE: 3,
  VERY_LARGE: 4,
  HUGE: 5
}, y5 = {
  DISCARD: 0,
  MULTIPLY: 1,
  MULTIPLY_RGB_SET_ALPHA: 2
}, v_ = {
  DEFAULT: 0,
  ESKIL: 1
}, u$ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`, h$ = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", d$ = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
], f$ = class extends Yn {
  constructor(n = new gn()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new Ne(null),
        texelSize: new Ne(new gn()),
        scale: new Ne(1),
        kernel: new Ne(0)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: u$,
      vertexShader: h$
    }), this.toneMapped = !1, this.setTexelSize(n.x, n.y), this.kernelSize = Uv.MEDIUM;
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setInputBuffer(n) {
    this.inputBuffer = n;
  }
  get kernelSequence() {
    return d$[this.kernelSize];
  }
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(n) {
    this.uniforms.scale.value = n;
  }
  getScale() {
    return this.uniforms.scale.value;
  }
  setScale(n) {
    this.uniforms.scale.value = n;
  }
  getKernel() {
    return null;
  }
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(n) {
    this.uniforms.kernel.value = n;
  }
  setKernel(n) {
    this.kernel = n;
  }
  setTexelSize(n, e) {
    this.uniforms.texelSize.value.set(n, e, n * 0.5, e * 0.5);
  }
  setSize(n, e) {
    const t = 1 / n, i = 1 / e;
    this.uniforms.texelSize.value.set(t, i, t * 0.5, i * 0.5);
  }
}, p$ = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
#include <dithering_fragment>
}`, x5 = class extends Yn {
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new Ne(null),
        opacity: new Ne(1)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: p$,
      vertexShader: Hf
    }), this.toneMapped = !1;
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setInputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  getOpacity(n) {
    return this.uniforms.opacity.value;
  }
  setOpacity(n) {
    this.uniforms.opacity.value = n;
  }
}, m$ = `#include <packing>
#include <clipping_planes_pars_fragment>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float cameraNear;uniform float cameraFar;varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <clipping_planes_fragment>
vec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);
#if DEPTH_PACKING == 3201
float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));
#else
float fragCoordZ=texture2D(depthBuffer,projTexCoord).r;
#endif
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#else
float viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#endif
float depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`, v$ = `#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
vViewZ=mvPosition.z;vProjTexCoord=gl_Position;
#include <clipping_planes_vertex>
}`, g$ = class extends Yn {
  constructor(n = null, e) {
    super({
      name: "DepthComparisonMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Ne(null),
        cameraNear: new Ne(0.3),
        cameraFar: new Ne(1e3)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: m$,
      vertexShader: v$
    }), this.toneMapped = !1, this.depthBuffer = n, this.depthPacking = Xm, this.adoptCameraSettings(e);
  }
  set depthBuffer(n) {
    this.uniforms.depthBuffer.value = n;
  }
  set depthPacking(n) {
    this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(n, e = Xm) {
    this.depthBuffer = n, this.depthPacking = e;
  }
  adoptCameraSettings(n) {
    n && (this.uniforms.cameraNear.value = n.near, this.uniforms.cameraFar.value = n.far, n instanceof ni ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
}, _$ = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;
#else
uniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;
#endif
uniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}varying vec2 vUv;void main(){vec2 depth;
#if DEPTH_PACKING_0 == 3201
depth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));
#else
depth.x=texture2D(depthBuffer0,vUv).r;
#endif
#if DEPTH_PACKING_1 == 3201
depth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));
#else
depth.y=texture2D(depthBuffer1,vUv).r;
#endif
bool isMaxDepth=(depth.x==1.0);
#ifdef PERSPECTIVE_CAMERA
depth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);
#endif
#if DEPTH_TEST_STRATEGY == 0
bool keep=depthTest(depth.x,depth.y);
#elif DEPTH_TEST_STRATEGY == 1
bool keep=isMaxDepth||depthTest(depth.x,depth.y);
#else
bool keep=!isMaxDepth&&depthTest(depth.x,depth.y);
#endif
if(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`, b$ = class extends Yn {
  constructor() {
    super({
      name: "DepthMaskMaterial",
      defines: {
        DEPTH_EPSILON: "0.0001",
        DEPTH_PACKING_0: "0",
        DEPTH_PACKING_1: "0",
        DEPTH_TEST_STRATEGY: Lm.KEEP_MAX_DEPTH
      },
      uniforms: {
        inputBuffer: new Ne(null),
        depthBuffer0: new Ne(null),
        depthBuffer1: new Ne(null),
        cameraNearFar: new Ne(new ze(1, 1))
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: _$,
      vertexShader: Hf
    }), this.toneMapped = !1, this.depthMode = u2;
  }
  set depthBuffer0(n) {
    this.uniforms.depthBuffer0.value = n;
  }
  set depthPacking0(n) {
    this.defines.DEPTH_PACKING_0 = n.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer0(n, e = io) {
    this.depthBuffer0 = n, this.depthPacking0 = e;
  }
  set depthBuffer1(n) {
    this.uniforms.depthBuffer1.value = n;
  }
  set depthPacking1(n) {
    this.defines.DEPTH_PACKING_1 = n.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer1(n, e = io) {
    this.depthBuffer1 = n, this.depthPacking1 = e;
  }
  get maxDepthStrategy() {
    return Number(this.defines.DEPTH_TEST_STRATEGY);
  }
  set maxDepthStrategy(n) {
    this.defines.DEPTH_TEST_STRATEGY = n.toFixed(0), this.needsUpdate = !0;
  }
  get keepFar() {
    return this.maxDepthStrategy;
  }
  set keepFar(n) {
    this.maxDepthStrategy = n ? Lm.KEEP_MAX_DEPTH : Lm.DISCARD_MAX_DEPTH;
  }
  getMaxDepthStrategy() {
    return this.maxDepthStrategy;
  }
  setMaxDepthStrategy(n) {
    this.maxDepthStrategy = n;
  }
  get epsilon() {
    return Number(this.defines.DEPTH_EPSILON);
  }
  set epsilon(n) {
    this.defines.DEPTH_EPSILON = n.toFixed(16), this.needsUpdate = !0;
  }
  getEpsilon() {
    return this.epsilon;
  }
  setEpsilon(n) {
    this.epsilon = n;
  }
  get depthMode() {
    return Number(this.defines.DEPTH_MODE);
  }
  set depthMode(n) {
    let e;
    switch (n) {
      case FL:
        e = "false";
        break;
      case BL:
        e = "true";
        break;
      case gb:
        e = "abs(d1 - d0) <= DEPTH_EPSILON";
        break;
      case rE:
        e = "abs(d1 - d0) > DEPTH_EPSILON";
        break;
      case u2:
        e = "d0 > d1";
        break;
      case vb:
        e = "d0 >= d1";
        break;
      case UL:
        e = "d0 <= d1";
        break;
      case VL:
      default:
        e = "d0 < d1";
        break;
    }
    this.defines.DEPTH_MODE = n.toFixed(0), this.defines["depthTest(d0, d1)"] = e, this.needsUpdate = !0;
  }
  getDepthMode() {
    return this.depthMode;
  }
  setDepthMode(n) {
    this.depthMode = n;
  }
  adoptCameraSettings(n) {
    n && (this.uniforms.cameraNearFar.value.set(n.near, n.far), n instanceof ni ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
}, y$ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <encodings_fragment>
}`, x$ = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}", w$ = class extends Yn {
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new Ne(null),
        texelSize: new Ne(new ze())
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: y$,
      vertexShader: x$
    }), this.toneMapped = !1;
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setSize(n, e) {
    this.uniforms.texelSize.value.set(1 / n, 1 / e);
  }
}, S$ = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`, M$ = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}", E$ = class extends Yn {
  constructor(n, e, t, i, r = !1) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: rh.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Ne(null),
        depthBuffer: new Ne(null),
        resolution: new Ne(new ze()),
        texelSize: new Ne(new ze()),
        cameraNear: new Ne(0.3),
        cameraFar: new Ne(1e3),
        aspect: new Ne(1),
        time: new Ne(0)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      dithering: r
    }), this.toneMapped = !1, n && this.setShaderParts(n), e && this.setDefines(e), t && this.setUniforms(t), this.adoptCameraSettings(i);
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setInputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(n) {
    this.uniforms.depthBuffer.value = n;
  }
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(n) {
    this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(n, e = io) {
    this.depthBuffer = n, this.depthPacking = e;
  }
  setShaderData(n) {
    this.setShaderParts(n.shaderParts), this.setDefines(n.defines), this.setUniforms(n.uniforms), this.setExtensions(n.extensions);
  }
  setShaderParts(n) {
    var e, t, i, r, s;
    return this.fragmentShader = S$.replace(yn.FRAGMENT_HEAD, (e = n.get(yn.FRAGMENT_HEAD)) != null ? e : "").replace(yn.FRAGMENT_MAIN_UV, (t = n.get(yn.FRAGMENT_MAIN_UV)) != null ? t : "").replace(yn.FRAGMENT_MAIN_IMAGE, (i = n.get(yn.FRAGMENT_MAIN_IMAGE)) != null ? i : ""), this.vertexShader = M$.replace(yn.VERTEX_HEAD, (r = n.get(yn.VERTEX_HEAD)) != null ? r : "").replace(yn.VERTEX_MAIN_SUPPORT, (s = n.get(yn.VERTEX_MAIN_SUPPORT)) != null ? s : ""), this.needsUpdate = !0, this;
  }
  setDefines(n) {
    for (const e of n.entries())
      this.defines[e[0]] = e[1];
    return this.needsUpdate = !0, this;
  }
  setUniforms(n) {
    for (const e of n.entries())
      this.uniforms[e[0]] = e[1];
    return this;
  }
  setExtensions(n) {
    this.extensions = {};
    for (const e of n)
      this.extensions[e] = !0;
    return this;
  }
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(n) {
    this.encodeOutput !== n && (n ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0);
  }
  isOutputEncodingEnabled(n) {
    return this.encodeOutput;
  }
  setOutputEncodingEnabled(n) {
    this.encodeOutput = n;
  }
  get time() {
    return this.uniforms.time.value;
  }
  set time(n) {
    this.uniforms.time.value = n;
  }
  setDeltaTime(n) {
    this.uniforms.time.value += n;
  }
  adoptCameraSettings(n) {
    n && (this.uniforms.cameraNear.value = n.near, this.uniforms.cameraFar.value = n.far, n instanceof ni ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
  setSize(n, e) {
    const t = this.uniforms;
    t.resolution.value.set(n, e), t.texelSize.value.set(1 / n, 1 / e), t.aspect.value = n / e;
  }
  static get Section() {
    return yn;
  }
}, C$ = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`, T$ = class extends Yn {
  constructor(n = !1, e = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: rh.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new Ne(null),
        threshold: new Ne(0),
        smoothing: new Ne(1),
        range: new Ne(null)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: C$,
      vertexShader: Hf
    }), this.toneMapped = !1, this.colorOutput = n, this.luminanceRange = e;
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setInputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(n) {
    this.smoothing > 0 || n > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = n;
  }
  getThreshold() {
    return this.threshold;
  }
  setThreshold(n) {
    this.threshold = n;
  }
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(n) {
    this.threshold > 0 || n > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = n;
  }
  getSmoothingFactor() {
    return this.smoothing;
  }
  setSmoothingFactor(n) {
    this.smoothing = n;
  }
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(n) {
  }
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(n) {
    n ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0;
  }
  isColorOutputEnabled(n) {
    return this.colorOutput;
  }
  setColorOutputEnabled(n) {
    this.colorOutput = n;
  }
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(n) {
    this.luminanceRange = null;
  }
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(n) {
    n !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = n, this.needsUpdate = !0;
  }
  getLuminanceRange() {
    return this.luminanceRange;
  }
  setLuminanceRange(n) {
    this.luminanceRange = n;
  }
}, P$ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`, A$ = class extends Yn {
  constructor(n = null) {
    super({
      name: "MaskMaterial",
      uniforms: {
        maskTexture: new Ne(n),
        inputBuffer: new Ne(null),
        strength: new Ne(1)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: P$,
      vertexShader: Hf
    }), this.toneMapped = !1, this.setColorChannel(b5.RED), this.setMaskFunction(y5.DISCARD);
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setInputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  set maskTexture(n) {
    this.uniforms.maskTexture.value = n, delete this.defines.MASK_PRECISION_HIGH, n.type !== Mi && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0;
  }
  setMaskTexture(n) {
    this.maskTexture = n;
  }
  set colorChannel(n) {
    this.defines.COLOR_CHANNEL = n.toFixed(0), this.needsUpdate = !0;
  }
  setColorChannel(n) {
    this.colorChannel = n;
  }
  set maskFunction(n) {
    this.defines.MASK_FUNCTION = n.toFixed(0), this.needsUpdate = !0;
  }
  setMaskFunction(n) {
    this.maskFunction = n;
  }
  get inverted() {
    return this.defines.INVERTED !== void 0;
  }
  set inverted(n) {
    this.inverted && !n ? delete this.defines.INVERTED : n && (this.defines.INVERTED = "1"), this.needsUpdate = !0;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(n) {
    this.inverted = n;
  }
  get strength() {
    return this.uniforms.strength.value;
  }
  set strength(n) {
    this.uniforms.strength.value = n;
  }
  getStrength() {
    return this.strength;
  }
  setStrength(n) {
    this.strength = n;
  }
}, R$ = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}", k$ = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}", L$ = class extends Yn {
  constructor(n = new ze()) {
    super({
      name: "OutlineMaterial",
      uniforms: {
        inputBuffer: new Ne(null),
        texelSize: new Ne(new ze())
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: R$,
      vertexShader: k$
    }), this.toneMapped = !1, this.setTexelSize(n.x, n.y), this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setInputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  setTexelSize(n, e) {
    this.uniforms.texelSize.value.set(n, e);
  }
  setSize(n, e) {
    this.uniforms.texelSize.value.set(1 / n, 1 / e);
  }
}, D$ = `#include <common>
#include <packing>
#ifdef NORMAL_DEPTH
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
#else
uniform lowp sampler2D normalBuffer;
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
uniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float minRadiusScale;uniform float intensity;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){
#ifdef DISTANCE_SCALING
float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;
#else
float radius=RADIUS;
#endif
float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float invSamples=1.0/SAMPLES_FLOAT;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*invSamples;float angle=alpha*rings+baseAngle;vec2 coord=alpha*radius*vec2(cos(angle),sin(angle))*texelSize+uv;if(coord.s<0.0||coord.s>1.0||coord.t<0.0||coord.t>1.0){continue;}
#ifdef NORMAL_DEPTH
float sampleDepth=texture2D(normalDepthBuffer,coord).a;
#else
float sampleDepth=readDepth(coord);
#endif
float viewZ=getViewZ(sampleDepth);
#ifdef PERSPECTIVE_CAMERA
float linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);
#else
float linearSampleDepth=sampleDepth;
#endif
float proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coord,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){
#ifdef NORMAL_DEPTH
vec4 normalDepth=texture2D(normalDepthBuffer,vUv);
#else
vec4 normalDepth=vec4(texture2D(normalBuffer,vUv).rgb,readDepth(vUv));
#endif
float ao=1.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);
#ifdef PERSPECTIVE_CAMERA
float linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);
#else
float linearDepth=depth;
#endif
if(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao-=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,1.0,d);ao=clamp(pow(ao,abs(intensity)),0.0,1.0);}gl_FragColor.r=ao;}`, I$ = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}", O$ = class extends Yn {
  constructor(n) {
    super({
      name: "SSAOMaterial",
      defines: {
        SAMPLES_INT: "0",
        SAMPLES_FLOAT: "0.0",
        SPIRAL_TURNS: "0.0",
        RADIUS: "1.0",
        RADIUS_SQ: "1.0",
        DISTANCE_SCALING: "1",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Ne(null),
        normalBuffer: new Ne(null),
        normalDepthBuffer: new Ne(null),
        noiseTexture: new Ne(null),
        inverseProjectionMatrix: new Ne(new Pt()),
        projectionMatrix: new Ne(new Pt()),
        texelSize: new Ne(new ze()),
        cameraNearFar: new Ne(new ze()),
        distanceCutoff: new Ne(new ze()),
        proximityCutoff: new Ne(new ze()),
        noiseScale: new Ne(new ze()),
        minRadiusScale: new Ne(0.33),
        intensity: new Ne(1),
        fade: new Ne(0.01),
        bias: new Ne(0)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: D$,
      vertexShader: I$
    }), this.toneMapped = !1, this.adoptCameraSettings(n), this.resolution = new ze(), this.r = 1;
  }
  get near() {
    return this.uniforms.cameraNearFar.value.x;
  }
  get far() {
    return this.uniforms.cameraNearFar.value.y;
  }
  set normalDepthBuffer(n) {
    this.uniforms.normalDepthBuffer.value = n, n !== null ? this.defines.NORMAL_DEPTH = "1" : delete this.defines.NORMAL_DEPTH, this.needsUpdate = !0;
  }
  setNormalDepthBuffer(n) {
    this.normalDepthBuffer = n;
  }
  set normalBuffer(n) {
    this.uniforms.normalBuffer.value = n;
  }
  setNormalBuffer(n) {
    this.uniforms.normalBuffer.value = n;
  }
  set depthBuffer(n) {
    this.uniforms.depthBuffer.value = n;
  }
  set depthPacking(n) {
    this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(n, e = io) {
    this.depthBuffer = n, this.depthPacking = e;
  }
  set noiseTexture(n) {
    this.uniforms.noiseTexture.value = n;
  }
  setNoiseTexture(n) {
    this.uniforms.noiseTexture.value = n;
  }
  get samples() {
    return Number(this.defines.SAMPLES_INT);
  }
  set samples(n) {
    this.defines.SAMPLES_INT = n.toFixed(0), this.defines.SAMPLES_FLOAT = n.toFixed(1), this.needsUpdate = !0;
  }
  getSamples() {
    return this.samples;
  }
  setSamples(n) {
    this.samples = n;
  }
  get rings() {
    return Number(this.defines.SPIRAL_TURNS);
  }
  set rings(n) {
    this.defines.SPIRAL_TURNS = n.toFixed(1), this.needsUpdate = !0;
  }
  getRings() {
    return this.rings;
  }
  setRings(n) {
    this.rings = n;
  }
  get intensity() {
    return this.uniforms.intensity.value;
  }
  set intensity(n) {
    this.uniforms.intensity.value = n;
  }
  getIntensity() {
    return this.uniforms.intensity.value;
  }
  setIntensity(n) {
    this.uniforms.intensity.value = n;
  }
  get fade() {
    return this.uniforms.fade.value;
  }
  set fade(n) {
    this.uniforms.fade.value = n;
  }
  getFade() {
    return this.uniforms.fade.value;
  }
  setFade(n) {
    this.uniforms.fade.value = n;
  }
  get bias() {
    return this.uniforms.bias.value;
  }
  set bias(n) {
    this.uniforms.bias.value = n;
  }
  getBias() {
    return this.uniforms.bias.value;
  }
  setBias(n) {
    this.uniforms.bias.value = n;
  }
  get minRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  set minRadiusScale(n) {
    this.uniforms.minRadiusScale.value = n;
  }
  getMinRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  setMinRadiusScale(n) {
    this.uniforms.minRadiusScale.value = n;
  }
  updateRadius() {
    const n = this.r * this.resolution.height;
    this.defines.RADIUS = n.toFixed(11), this.defines.RADIUS_SQ = (n * n).toFixed(11), this.needsUpdate = !0;
  }
  get radius() {
    return this.r;
  }
  set radius(n) {
    this.r = Math.min(Math.max(n, 1e-6), 1), this.updateRadius();
  }
  getRadius() {
    return this.radius;
  }
  setRadius(n) {
    this.radius = n;
  }
  get distanceScaling() {
    return this.defines.DISTANCE_SCALING !== void 0;
  }
  set distanceScaling(n) {
    this.isDistanceScalingEnabled() !== n && (n ? this.defines.DISTANCE_SCALING = "1" : delete this.defines.DISTANCE_SCALING, this.needsUpdate = !0);
  }
  isDistanceScalingEnabled() {
    return this.distanceScaling;
  }
  setDistanceScalingEnabled(n) {
    this.distanceScaling = n;
  }
  get distanceThreshold() {
    return this.uniforms.distanceCutoff.value.x;
  }
  set distanceThreshold(n) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(n, 0), 1),
      Math.min(Math.max(n + this.distanceFalloff, 0), 1)
    );
  }
  get worldDistanceThreshold() {
    return -Id(this.distanceThreshold, this.near, this.far);
  }
  set worldDistanceThreshold(n) {
    this.distanceThreshold = Su(-n, this.near, this.far);
  }
  get distanceFalloff() {
    return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;
  }
  set distanceFalloff(n) {
    this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + n, 0), 1);
  }
  get worldDistanceFalloff() {
    return -Id(this.distanceFalloff, this.near, this.far);
  }
  set worldDistanceFalloff(n) {
    this.distanceFalloff = Su(-n, this.near, this.far);
  }
  setDistanceCutoff(n, e) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(n, 0), 1),
      Math.min(Math.max(n + e, 0), 1)
    );
  }
  get proximityThreshold() {
    return this.uniforms.proximityCutoff.value.x;
  }
  set proximityThreshold(n) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(n, 0), 1),
      Math.min(Math.max(n + this.proximityFalloff, 0), 1)
    );
  }
  get worldProximityThreshold() {
    return -Id(this.proximityThreshold, this.near, this.far);
  }
  set worldProximityThreshold(n) {
    this.proximityThreshold = Su(-n, this.near, this.far);
  }
  get proximityFalloff() {
    return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;
  }
  set proximityFalloff(n) {
    this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + n, 0), 1);
  }
  get worldProximityFalloff() {
    return -Id(this.proximityFalloff, this.near, this.far);
  }
  set worldProximityFalloff(n) {
    this.proximityFalloff = Su(-n, this.near, this.far);
  }
  setProximityCutoff(n, e) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(n, 0), 1),
      Math.min(Math.max(n + e, 0), 1)
    );
  }
  setTexelSize(n, e) {
    this.uniforms.texelSize.value.set(n, e);
  }
  adoptCameraSettings(n) {
    n && (this.uniforms.cameraNearFar.value.set(n.near, n.far), this.uniforms.projectionMatrix.value.copy(n.projectionMatrix), this.uniforms.inverseProjectionMatrix.value.copy(n.projectionMatrix).invert(), n instanceof ni ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
  setSize(n, e) {
    const t = this.uniforms, i = t.noiseTexture.value;
    i !== null && t.noiseScale.value.set(
      n / i.image.width,
      e / i.image.height
    ), t.texelSize.value.set(1 / n, 1 / e), this.resolution.set(n, e), this.updateRadius();
  }
}, N$ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <encodings_fragment>
}`, z$ = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}", F$ = class extends Yn {
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new Ne(null),
        supportBuffer: new Ne(null),
        texelSize: new Ne(new ze()),
        radius: new Ne(0.85)
      },
      blending: Si,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: N$,
      vertexShader: z$
    }), this.toneMapped = !1;
  }
  set inputBuffer(n) {
    this.uniforms.inputBuffer.value = n;
  }
  set supportBuffer(n) {
    this.uniforms.supportBuffer.value = n;
  }
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(n) {
    this.uniforms.radius.value = n;
  }
  setSize(n, e) {
    this.uniforms.texelSize.value.set(1 / n, 1 / e);
  }
}, B$ = new _y(), ec = null;
function U$() {
  if (ec === null) {
    const n = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), e = new Float32Array([0, 0, 2, 0, 0, 2]);
    ec = new qn(), ec.setAttribute !== void 0 ? (ec.setAttribute("position", new Vi(n, 3)), ec.setAttribute("uv", new Vi(e, 2))) : (ec.addAttribute("position", new Vi(n, 3)), ec.addAttribute("uv", new Vi(e, 2)));
  }
  return ec;
}
var Cr = class {
  constructor(n = "Pass", e = new b2(), t = B$) {
    this.name = n, this.renderer = null, this.scene = e, this.camera = t, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0;
  }
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(n) {
    if (this.rtt === n) {
      const e = this.fullscreenMaterial;
      e !== null && (e.needsUpdate = !0), this.rtt = !n;
    }
  }
  setRenderer(n) {
    this.renderer = n;
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(n) {
    this.enabled = n;
  }
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(n) {
    let e = this.screen;
    e !== null ? e.material = n : (e = new wi(U$(), n), e.frustumCulled = !1, this.scene === null && (this.scene = new b2()), this.scene.add(e), this.screen = e);
  }
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  setFullscreenMaterial(n) {
    this.fullscreenMaterial = n;
  }
  getDepthTexture() {
    return null;
  }
  setDepthTexture(n, e = io) {
  }
  render(n, e, t, i, r) {
    throw new Error("Render method not implemented!");
  }
  setSize(n, e) {
  }
  initialize(n, e, t) {
  }
  dispose() {
    for (const n of Object.keys(this)) {
      const e = this[n];
      (e instanceof On || e instanceof zo || e instanceof Wi || e instanceof Cr) && this[n].dispose();
    }
  }
}, V$ = class extends Cr {
  constructor(n, e = !0) {
    super("CopyPass"), this.fullscreenMaterial = new x5(), this.needsSwap = !1, this.renderTarget = n, n === void 0 && (this.renderTarget = new On(1, 1, {
      minFilter: Zt,
      magFilter: Zt,
      stencilBuffer: !1,
      depthBuffer: !1
    }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e;
  }
  get resize() {
    return this.autoResize;
  }
  set resize(n) {
    this.autoResize = n;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  setAutoResizeEnabled(n) {
    this.autoResize = n;
  }
  render(n, e, t, i, r) {
    this.fullscreenMaterial.inputBuffer = e.texture, n.setRenderTarget(this.renderToScreen ? null : this.renderTarget), n.render(this.scene, this.camera);
  }
  setSize(n, e) {
    this.autoResize && this.renderTarget.setSize(n, e);
  }
  initialize(n, e, t) {
    t !== void 0 && (this.renderTarget.texture.type = t, t !== Mi ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : n.outputEncoding === Tt && (this.renderTarget.texture.encoding = Tt));
  }
}, H$ = class extends Cr {
  constructor() {
    super("ClearMaskPass", null, null), this.needsSwap = !1;
  }
  render(n, e, t, i, r) {
    const s = n.state.buffers.stencil;
    s.setLocked(!1), s.setTest(!1);
  }
}, Q1 = new xt(), Ny = class extends Cr {
  constructor(n = !0, e = !0, t = !1) {
    super("ClearPass", null, null), this.needsSwap = !1, this.color = n, this.depth = e, this.stencil = t, this.overrideClearColor = null, this.overrideClearAlpha = -1;
  }
  setClearFlags(n, e, t) {
    this.color = n, this.depth = e, this.stencil = t;
  }
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  setOverrideClearColor(n) {
    this.overrideClearColor = n;
  }
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  setOverrideClearAlpha(n) {
    this.overrideClearAlpha = n;
  }
  render(n, e, t, i, r) {
    const s = this.overrideClearColor, o = this.overrideClearAlpha, a = n.getClearAlpha(), l = s !== null, c = o >= 0;
    l ? (Q1.copy(n.getClearColor(Q1)), n.setClearColor(s, c ? o : a)) : c && n.setClearAlpha(o), n.setRenderTarget(this.renderToScreen ? null : e), n.clear(this.color, this.depth, this.stencil), l ? n.setClearColor(Q1, a) : c && n.setClearAlpha(a);
  }
}, tc = -1, ii = class extends ga {
  constructor(n, e = tc, t = tc, i = 1) {
    super(), this.resizable = n, this.baseSize = new ze(1, 1), this.preferredSize = new ze(e, t), this.target = this.preferredSize, this.s = i, this.effectiveSize = new ze(), this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize();
  }
  updateEffectiveSize() {
    const n = this.baseSize, e = this.preferredSize, t = this.effectiveSize, i = this.scale;
    e.width !== tc ? t.width = e.width : e.height !== tc ? t.width = Math.round(e.height * (n.width / Math.max(n.height, 1))) : t.width = Math.round(n.width * i), e.height !== tc ? t.height = e.height : e.width !== tc ? t.height = Math.round(e.width / Math.max(n.width / Math.max(n.height, 1), 1)) : t.height = Math.round(n.height * i);
  }
  get width() {
    return this.effectiveSize.width;
  }
  set width(n) {
    this.preferredWidth = n;
  }
  get height() {
    return this.effectiveSize.height;
  }
  set height(n) {
    this.preferredHeight = n;
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  get scale() {
    return this.s;
  }
  set scale(n) {
    this.s !== n && (this.s = n, this.preferredSize.setScalar(tc), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getScale() {
    return this.scale;
  }
  setScale(n) {
    this.scale = n;
  }
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(n) {
    this.baseSize.width !== n && (this.baseSize.width = n, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getBaseWidth() {
    return this.baseWidth;
  }
  setBaseWidth(n) {
    this.baseWidth = n;
  }
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(n) {
    this.baseSize.height !== n && (this.baseSize.height = n, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getBaseHeight() {
    return this.baseHeight;
  }
  setBaseHeight(n) {
    this.baseHeight = n;
  }
  setBaseSize(n, e) {
    (this.baseSize.width !== n || this.baseSize.height !== e) && (this.baseSize.set(n, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(n) {
    this.preferredSize.width !== n && (this.preferredSize.width = n, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getPreferredWidth() {
    return this.preferredWidth;
  }
  setPreferredWidth(n) {
    this.preferredWidth = n;
  }
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(n) {
    this.preferredSize.height !== n && (this.preferredSize.height = n, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getPreferredHeight() {
    return this.preferredHeight;
  }
  setPreferredHeight(n) {
    this.preferredHeight = n;
  }
  setPreferredSize(n, e) {
    (this.preferredSize.width !== n || this.preferredSize.height !== e) && (this.preferredSize.set(n, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  copy(n) {
    this.s = n.scale, this.baseSize.set(n.getBaseWidth(), n.getBaseHeight()), this.preferredSize.set(n.getPreferredWidth(), n.getPreferredHeight()), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  static get AUTO_SIZE() {
    return tc;
  }
}, eS = !1, DA = class {
  constructor(n = null) {
    this.originalMaterials = /* @__PURE__ */ new Map(), this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(n), this.meshCount = 0, this.replaceMaterial = (e) => {
      if (e.isMesh) {
        let t;
        if (e.material.flatShading)
          switch (e.material.side) {
            case Js:
              t = this.materialsFlatShadedDoubleSide;
              break;
            case cr:
              t = this.materialsFlatShadedBackSide;
              break;
            default:
              t = this.materialsFlatShaded;
              break;
          }
        else
          switch (e.material.side) {
            case Js:
              t = this.materialsDoubleSide;
              break;
            case cr:
              t = this.materialsBackSide;
              break;
            default:
              t = this.materials;
              break;
          }
        this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount;
      }
    };
  }
  setMaterial(n) {
    if (this.disposeMaterials(), this.material = n, n !== null) {
      const e = this.materials = [
        n.clone(),
        n.clone(),
        n.clone()
      ];
      for (const t of e)
        t.uniforms = Object.assign({}, n.uniforms), t.side = ju;
      e[2].skinning = !0, this.materialsBackSide = e.map((t) => {
        const i = t.clone();
        return i.uniforms = Object.assign({}, n.uniforms), i.side = cr, i;
      }), this.materialsDoubleSide = e.map((t) => {
        const i = t.clone();
        return i.uniforms = Object.assign({}, n.uniforms), i.side = Js, i;
      }), this.materialsFlatShaded = e.map((t) => {
        const i = t.clone();
        return i.uniforms = Object.assign({}, n.uniforms), i.flatShading = !0, i;
      }), this.materialsFlatShadedBackSide = e.map((t) => {
        const i = t.clone();
        return i.uniforms = Object.assign({}, n.uniforms), i.flatShading = !0, i.side = cr, i;
      }), this.materialsFlatShadedDoubleSide = e.map((t) => {
        const i = t.clone();
        return i.uniforms = Object.assign({}, n.uniforms), i.flatShading = !0, i.side = Js, i;
      });
    }
  }
  render(n, e, t) {
    const i = n.shadowMap.enabled;
    if (n.shadowMap.enabled = !1, eS) {
      const r = this.originalMaterials;
      this.meshCount = 0, e.traverse(this.replaceMaterial), n.render(e, t);
      for (const s of r)
        s[0].material = s[1];
      this.meshCount !== r.size && r.clear();
    } else {
      const r = e.overrideMaterial;
      e.overrideMaterial = this.material, n.render(e, t), e.overrideMaterial = r;
    }
    n.shadowMap.enabled = i;
  }
  disposeMaterials() {
    if (this.material !== null) {
      const n = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const e of n)
        e.dispose();
    }
  }
  dispose() {
    this.originalMaterials.clear(), this.disposeMaterials();
  }
  static get workaroundEnabled() {
    return eS;
  }
  static set workaroundEnabled(n) {
    eS = n;
  }
}, Vv = class extends Cr {
  constructor(n, e, t = null) {
    super("RenderPass", n, e), this.needsSwap = !1, this.clearPass = new Ny(), this.overrideMaterialManager = t === null ? null : new DA(t), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(n) {
    super.renderToScreen = n, this.clearPass.renderToScreen = n;
  }
  get overrideMaterial() {
    const n = this.overrideMaterialManager;
    return n !== null ? n.material : null;
  }
  set overrideMaterial(n) {
    const e = this.overrideMaterialManager;
    n !== null ? e !== null ? e.setMaterial(n) : this.overrideMaterialManager = new DA(n) : e !== null && (e.dispose(), this.overrideMaterialManager = null);
  }
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  setOverrideMaterial(n) {
    this.overrideMaterial = n;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(n) {
    this.clearPass.enabled = n;
  }
  getSelection() {
    return this.selection;
  }
  setSelection(n) {
    this.selection = n;
  }
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  setBackgroundDisabled(n) {
    this.ignoreBackground = n;
  }
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  setShadowMapDisabled(n) {
    this.skipShadowMapUpdate = n;
  }
  getClearPass() {
    return this.clearPass;
  }
  render(n, e, t, i, r) {
    const s = this.scene, o = this.camera, a = this.selection, l = o.layers.mask, c = s.background, d = n.shadowMap.autoUpdate, p = this.renderToScreen ? null : e;
    a !== null && o.layers.set(a.getLayer()), this.skipShadowMapUpdate && (n.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (s.background = null), this.clearPass.enabled && this.clearPass.render(n, e), n.setRenderTarget(p), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(n, s, o) : n.render(s, o), o.layers.mask = l, s.background = c, n.shadowMap.autoUpdate = d;
  }
}, OE = class extends Cr {
  constructor(n, e, {
    renderTarget: t,
    resolutionScale: i = 1,
    width: r = ii.AUTO_SIZE,
    height: s = ii.AUTO_SIZE,
    resolutionX: o = r,
    resolutionY: a = s
  } = {}) {
    super("DepthPass"), this.needsSwap = !1, this.renderPass = new Vv(n, e, new uD({
      depthPacking: Xm
    }));
    const l = this.renderPass;
    l.skipShadowMapUpdate = !0, l.ignoreBackground = !0;
    const c = l.getClearPass();
    c.overrideClearColor = new xt(16777215), c.overrideClearAlpha = 1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new On(1, 1, {
      minFilter: kn,
      magFilter: kn
    }), this.renderTarget.texture.name = "DepthPass.Target");
    const d = this.resolution = new ii(this, o, a, i);
    d.addEventListener("change", (p) => this.setSize(d.baseWidth, d.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(n) {
    this.resolution.scale = n;
  }
  render(n, e, t, i, r) {
    const s = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(n, s);
  }
  setSize(n, e) {
    const t = this.resolution;
    t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height);
  }
};
function IA(n, e, t) {
  for (const i of e) {
    const r = "$1" + n + i.charAt(0).toUpperCase() + i.slice(1), s = new RegExp("([^\\.])(\\b" + i + "\\b)", "g");
    for (const o of t.entries())
      o[1] !== null && t.set(o[0], o[1].replace(s, r));
  }
}
function G$(n, e, t) {
  var i, r, s, o, a;
  let l = e.getFragmentShader(), c = e.getVertexShader();
  const d = l !== void 0 && /mainImage/.test(l), p = l !== void 0 && /mainUv/.test(l);
  if (t.attributes |= e.getAttributes(), l === void 0)
    throw new Error(`Missing fragment shader (${e.name})`);
  if (p && (t.attributes & ua.CONVOLUTION) !== 0)
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);
  if (!d && !p)
    throw new Error(`Could not find mainImage or mainUv function (${e.name})`);
  {
    const m = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g, v = t.shaderParts;
    let b = (i = v.get(yn.FRAGMENT_HEAD)) != null ? i : "", x = (r = v.get(yn.FRAGMENT_MAIN_UV)) != null ? r : "", y = (s = v.get(yn.FRAGMENT_MAIN_IMAGE)) != null ? s : "", S = (o = v.get(yn.VERTEX_HEAD)) != null ? o : "", C = (a = v.get(yn.VERTEX_MAIN_SUPPORT)) != null ? a : "";
    const M = /* @__PURE__ */ new Set(), T = /* @__PURE__ */ new Set();
    if (p && (x += `	${n}MainUv(UV);
`, t.uvTransformation = !0), c !== null && /mainSupport/.test(c)) {
      const I = /mainSupport *\([\w\s]*?uv\s*?\)/.test(c);
      C += `	${n}MainSupport(`, C += I ? `vUv);
` : `);
`;
      for (const k of c.matchAll(/(?:varying\s+\w+\s+(\w*))/g))
        t.varyings.add(k[1]), M.add(k[1]), T.add(k[1]);
      for (const k of c.matchAll(m))
        T.add(k[1]);
    }
    for (const I of l.matchAll(m))
      T.add(I[1]);
    for (const I of e.defines.keys())
      T.add(I.replace(/\([\w\s,]*\)/g, ""));
    for (const I of e.uniforms.keys())
      T.add(I);
    T.delete("while"), T.delete("for"), T.delete("if"), e.uniforms.forEach((I, k) => t.uniforms.set(n + k.charAt(0).toUpperCase() + k.slice(1), I)), e.defines.forEach((I, k) => t.defines.set(n + k.charAt(0).toUpperCase() + k.slice(1), I));
    const P = /* @__PURE__ */ new Map([["fragment", l], ["vertex", c]]);
    IA(n, T, t.defines), IA(n, T, P), l = P.get("fragment"), c = P.get("vertex");
    const D = e.blendMode;
    if (t.blendModes.set(D.blendFunction, D), d) {
      e.inputColorSpace !== null && e.inputColorSpace !== t.colorSpace && (y += e.inputColorSpace === Tt ? `color0 = LinearTosRGB(color0);
	` : `color0 = sRGBToLinear(color0);
	`), e.outputColorSpace !== null ? t.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace);
      const I = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      y += `${n}MainImage(color0, UV, `, (t.attributes & ua.DEPTH) !== 0 && I.test(l) && (y += "depth, ", t.readDepth = !0), y += `color1);
	`;
      const k = n + "BlendOpacity";
      t.uniforms.set(k, D.opacity), y += `color0 = blend${D.blendFunction}(color0, color1, ${k});

	`, b += `uniform float ${k};

`;
    }
    if (b += l + `
`, c !== null && (S += c + `
`), v.set(yn.FRAGMENT_HEAD, b), v.set(yn.FRAGMENT_MAIN_UV, x), v.set(yn.FRAGMENT_MAIN_IMAGE, y), v.set(yn.VERTEX_HEAD, S), v.set(yn.VERTEX_MAIN_SUPPORT, C), e.extensions !== null)
      for (const I of e.extensions)
        t.extensions.add(I);
  }
}
var W$ = class extends Cr {
  constructor(n, ...e) {
    super("EffectPass"), this.fullscreenMaterial = new E$(null, null, null, n), this.listener = (t) => this.handleEvent(t), this.effects = [], this.setEffects(e), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY;
  }
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(n) {
    this.fullscreenMaterial.encodeOutput = n;
  }
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(n) {
    const e = this.fullscreenMaterial;
    e.dithering = n, e.needsUpdate = !0;
  }
  setEffects(n) {
    for (const e of this.effects)
      e.removeEventListener("change", this.listener);
    this.effects = n.sort((e, t) => t.attributes - e.attributes);
    for (const e of this.effects)
      e.addEventListener("change", this.listener);
  }
  updateMaterial() {
    const n = new J$();
    let e = 0;
    for (const o of this.effects)
      if (o.blendMode.blendFunction === $t.DST)
        n.attributes |= o.getAttributes() & ua.DEPTH;
      else {
        if ((n.attributes & o.getAttributes() & ua.CONVOLUTION) !== 0)
          throw new Error(`Convolution effects cannot be merged (${o.name})`);
        G$("e" + e++, o, n);
      }
    let t = n.shaderParts.get(yn.FRAGMENT_HEAD), i = n.shaderParts.get(yn.FRAGMENT_MAIN_IMAGE), r = n.shaderParts.get(yn.FRAGMENT_MAIN_UV);
    const s = /\bblend\b/g;
    for (const o of n.blendModes.values())
      t += o.getShaderCode().replace(s, `blend${o.blendFunction}`) + `
`;
    (n.attributes & ua.DEPTH) !== 0 ? (n.readDepth && (i = `float depth = readDepth(UV);

	` + i), this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1, n.colorSpace === Tt && (i += `color0 = sRGBToLinear(color0);
	`), n.uvTransformation ? (r = `vec2 transformedUv = vUv;
` + r, n.defines.set("UV", "transformedUv")) : n.defines.set("UV", "vUv"), n.shaderParts.set(yn.FRAGMENT_HEAD, t), n.shaderParts.set(yn.FRAGMENT_MAIN_IMAGE, i), n.shaderParts.set(yn.FRAGMENT_MAIN_UV, r), n.shaderParts.forEach((o, a, l) => l.set(a, o == null ? void 0 : o.trim().replace(/^#/, `
#`))), this.skipRendering = e === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(n);
  }
  recompile() {
    this.updateMaterial();
  }
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  setDepthTexture(n, e = io) {
    this.fullscreenMaterial.depthBuffer = n, this.fullscreenMaterial.depthPacking = e;
    for (const t of this.effects)
      t.setDepthTexture(n, e);
  }
  render(n, e, t, i, r) {
    for (const s of this.effects)
      s.update(n, e, i);
    if (!this.skipRendering || this.renderToScreen) {
      const s = this.fullscreenMaterial;
      s.inputBuffer = e.texture, s.time += i, n.setRenderTarget(this.renderToScreen ? null : t), n.render(this.scene, this.camera);
    }
  }
  setSize(n, e) {
    this.fullscreenMaterial.setSize(n, e);
    for (const t of this.effects)
      t.setSize(n, e);
  }
  initialize(n, e, t) {
    this.renderer = n;
    for (const i of this.effects)
      i.initialize(n, e, t);
    this.updateMaterial(), t !== void 0 && t !== Mi && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
  dispose() {
    super.dispose();
    for (const n of this.effects)
      n.removeEventListener("change", this.listener), n.dispose();
  }
  handleEvent(n) {
    switch (n.type) {
      case "change":
        this.recompile();
        break;
    }
  }
}, NE = class extends Cr {
  constructor({
    kernelSize: n = Uv.MEDIUM,
    resolutionScale: e = 0.5,
    width: t = ii.AUTO_SIZE,
    height: i = ii.AUTO_SIZE,
    resolutionX: r = t,
    resolutionY: s = i
  } = {}) {
    super("KawaseBlurPass"), this.renderTargetA = new On(1, 1, { depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
    const o = this.resolution = new ii(this, r, s, e);
    o.addEventListener("change", (a) => this.setSize(o.baseWidth, o.baseHeight)), this.blurMaterial = new f$(), this.copyMaterial = new x5();
  }
  getResolution() {
    return this.resolution;
  }
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(n) {
    this.copyMaterial.dithering = n;
  }
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(n) {
    this.blurMaterial.kernelSize = n;
  }
  get width() {
    return this.resolution.width;
  }
  set width(n) {
    this.resolution.preferredWidth = n;
  }
  get height() {
    return this.resolution.height;
  }
  set height(n) {
    this.resolution.preferredHeight = n;
  }
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(n) {
    this.blurMaterial.scale = n;
  }
  getScale() {
    return this.blurMaterial.scale;
  }
  setScale(n) {
    this.blurMaterial.scale = n;
  }
  getKernelSize() {
    return this.kernelSize;
  }
  setKernelSize(n) {
    this.kernelSize = n;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(n) {
    this.resolution.scale = n;
  }
  render(n, e, t, i, r) {
    const s = this.scene, o = this.camera, a = this.renderTargetA, l = this.renderTargetB, c = this.blurMaterial, d = c.kernelSequence;
    let p = e;
    this.fullscreenMaterial = c;
    for (let m = 0, v = d.length; m < v; ++m) {
      const b = (m & 1) === 0 ? a : l;
      c.kernel = d[m], c.inputBuffer = p.texture, n.setRenderTarget(b), n.render(s, o), p = b;
    }
    this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = p.texture, n.setRenderTarget(this.renderToScreen ? null : t), n.render(s, o);
  }
  setSize(n, e) {
    const t = this.resolution;
    t.setBaseSize(n, e);
    const i = t.width, r = t.height;
    this.renderTargetA.setSize(i, r), this.renderTargetB.setSize(i, r), this.blurMaterial.setSize(n, e);
  }
  initialize(n, e, t) {
    t !== void 0 && (this.renderTargetA.texture.type = t, this.renderTargetB.texture.type = t, t !== Mi ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : n.outputEncoding === Tt && (this.renderTargetA.texture.encoding = Tt, this.renderTargetB.texture.encoding = Tt));
  }
  static get AUTO_SIZE() {
    return ii.AUTO_SIZE;
  }
}, j$ = class extends Cr {
  constructor({
    renderTarget: n,
    luminanceRange: e,
    colorOutput: t,
    resolutionScale: i = 1,
    width: r = ii.AUTO_SIZE,
    height: s = ii.AUTO_SIZE,
    resolutionX: o = r,
    resolutionY: a = s
  } = {}) {
    super("LuminancePass"), this.fullscreenMaterial = new T$(t, e), this.needsSwap = !1, this.renderTarget = n, this.renderTarget === void 0 && (this.renderTarget = new On(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "LuminancePass.Target");
    const l = this.resolution = new ii(this, o, a, i);
    l.addEventListener("change", (c) => this.setSize(l.baseWidth, l.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  render(n, e, t, i, r) {
    const s = this.fullscreenMaterial;
    s.inputBuffer = e.texture, n.setRenderTarget(this.renderToScreen ? null : this.renderTarget), n.render(this.scene, this.camera);
  }
  setSize(n, e) {
    const t = this.resolution;
    t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height);
  }
  initialize(n, e, t) {
    t !== void 0 && t !== Mi && (this.renderTarget.texture.type = t, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
}, q$ = class extends Cr {
  constructor(n, e) {
    super("MaskPass", n, e), this.needsSwap = !1, this.clearPass = new Ny(!1, !1, !0), this.inverse = !1;
  }
  get inverted() {
    return this.inverse;
  }
  set inverted(n) {
    this.inverse = n;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(n) {
    this.clearPass.enabled = n;
  }
  getClearPass() {
    return this.clearPass;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(n) {
    this.inverted = n;
  }
  render(n, e, t, i, r) {
    const s = n.getContext(), o = n.state.buffers, a = this.scene, l = this.camera, c = this.clearPass, d = this.inverted ? 0 : 1, p = 1 - d;
    o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.stencil.setFunc(s.ALWAYS, d, 4294967295), o.stencil.setClear(p), o.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? c.render(n, null) : (c.render(n, e), c.render(n, t))), this.renderToScreen ? (n.setRenderTarget(null), n.render(a, l)) : (n.setRenderTarget(e), n.render(a, l), n.setRenderTarget(t), n.render(a, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(s.EQUAL, 1, 4294967295), o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.stencil.setLocked(!0);
  }
}, X$ = class extends Cr {
  constructor() {
    super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new On(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new w$(), this.upsamplingMaterial = new F$(), this.resolution = new ze();
  }
  get texture() {
    return this.renderTarget.texture;
  }
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(n) {
    if (this.levels !== n) {
      const e = this.renderTarget;
      this.dispose();
      for (let t = 0; t < n; ++t) {
        const i = e.clone();
        i.texture.name = "Downsampling.Mipmap" + t, this.downsamplingMipmaps.push(i);
      }
      this.upsamplingMipmaps.push(e);
      for (let t = 1, i = n - 1; t < i; ++t) {
        const r = e.clone();
        r.texture.name = "Upsampling.Mipmap" + t, this.upsamplingMipmaps.push(r);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(n) {
    this.upsamplingMaterial.radius = n;
  }
  render(n, e, t, i, r) {
    const { scene: s, camera: o } = this, { downsamplingMaterial: a, upsamplingMaterial: l } = this, { downsamplingMipmaps: c, upsamplingMipmaps: d } = this;
    let p = e;
    this.fullscreenMaterial = a;
    for (let m = 0, v = c.length; m < v; ++m) {
      const b = c[m];
      a.setSize(p.width, p.height), a.inputBuffer = p.texture, n.setRenderTarget(b), n.render(s, o), p = b;
    }
    this.fullscreenMaterial = l;
    for (let m = d.length - 1; m >= 0; --m) {
      const v = d[m];
      l.setSize(p.width, p.height), l.inputBuffer = p.texture, l.supportBuffer = c[m].texture, n.setRenderTarget(v), n.render(s, o), p = v;
    }
  }
  setSize(n, e) {
    const t = this.resolution;
    t.set(n, e);
    let i = t.width, r = t.height;
    for (let s = 0, o = this.downsamplingMipmaps.length; s < o; ++s)
      i = Math.round(i * 0.5), r = Math.round(r * 0.5), this.downsamplingMipmaps[s].setSize(i, r), s < this.upsamplingMipmaps.length && this.upsamplingMipmaps[s].setSize(i, r);
  }
  initialize(n, e, t) {
    if (t !== void 0) {
      const i = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const r of i)
        r.texture.type = t;
      if (t !== Mi)
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      else if (n.outputEncoding === Tt)
        for (const r of i)
          r.texture.encoding = Tt;
    }
  }
  dispose() {
    super.dispose();
    for (const n of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
      n.dispose();
  }
}, $$ = class extends Cr {
  constructor(n, e, {
    renderTarget: t,
    resolutionScale: i = 1,
    width: r = ii.AUTO_SIZE,
    height: s = ii.AUTO_SIZE,
    resolutionX: o = r,
    resolutionY: a = s
  } = {}) {
    super("NormalPass"), this.needsSwap = !1, this.renderPass = new Vv(n, e, new xq());
    const l = this.renderPass;
    l.setBackgroundDisabled(!0), l.setShadowMapDisabled(!0);
    const c = l.getClearPass();
    c.setOverrideClearColor(new xt(7829503)), c.setOverrideClearAlpha(1), this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new On(1, 1, {
      minFilter: kn,
      magFilter: kn
    }), this.renderTarget.texture.name = "NormalPass.Target");
    const d = this.resolution = new ii(this, o, a, i);
    d.addEventListener("change", (p) => this.setSize(d.baseWidth, d.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(n) {
    this.resolution.scale = n;
  }
  render(n, e, t, i, r) {
    const s = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(n, s, s);
  }
  setSize(n, e) {
    const t = this.resolution;
    t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height);
  }
}, rl = class extends Cr {
  constructor(n, e = "inputBuffer") {
    super("ShaderPass"), this.fullscreenMaterial = n, this.input = e;
  }
  setInput(n) {
  }
  render(n, e, t, i, r) {
    const s = this.fullscreenMaterial.uniforms;
    e !== null && s !== void 0 && s[this.input] !== void 0 && (s[this.input].value = e.texture), n.setRenderTarget(this.renderToScreen ? null : t), n.render(this.scene, this.camera);
  }
  initialize(n, e, t) {
    t !== void 0 && t !== Mi && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
}, tS = 1 / 1e3, Z$ = 1e3, Y$ = class {
  constructor() {
    this.previousTime = 0, this.currentTime = 0, this.delta = 0, this.fixedDelta = 1e3 / 60, this.elapsed = 0, this.timescale = 1, this.fixedDeltaEnabled = !1, this.autoReset = !1;
  }
  setFixedDeltaEnabled(n) {
    return this.fixedDeltaEnabled = n, this;
  }
  isAutoResetEnabled(n) {
    return this.autoReset;
  }
  setAutoResetEnabled(n) {
    return typeof document < "u" && document.hidden !== void 0 && (n ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this.autoReset = n), this;
  }
  getDelta() {
    return this.delta * tS;
  }
  getFixedDelta() {
    return this.fixedDelta * tS;
  }
  setFixedDelta(n) {
    return this.fixedDelta = n * Z$, this;
  }
  getElapsed() {
    return this.elapsed * tS;
  }
  getTimescale() {
    return this.timescale;
  }
  setTimescale(n) {
    return this.timescale = n, this;
  }
  update(n) {
    return this.fixedDeltaEnabled ? this.delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = n !== void 0 ? n : performance.now(), this.delta = this.currentTime - this.previousTime), this.delta *= this.timescale, this.elapsed += this.delta, this;
  }
  reset() {
    return this.delta = 0, this.elapsed = 0, this.currentTime = performance.now(), this;
  }
  handleEvent(n) {
    document.hidden || (this.currentTime = performance.now());
  }
  dispose() {
    this.setAutoResetEnabled(!1);
  }
}, K$ = class {
  constructor(n = null, {
    depthBuffer: e = !0,
    stencilBuffer: t = !1,
    multisampling: i = 0,
    frameBufferType: r
  } = {}) {
    this.renderer = null, this.inputBuffer = this.createBuffer(e, t, r, i), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new V$(), this.depthTexture = null, this.passes = [], this.timer = new Y$(), this.autoRenderToScreen = !0, this.setRenderer(n);
  }
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  set multisampling(n) {
    const e = this.inputBuffer, t = this.multisampling;
    t > 0 && n > 0 ? (this.inputBuffer.samples = n, this.outputBuffer.samples = n, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : t !== n && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(
      e.depthBuffer,
      e.stencilBuffer,
      e.texture.type,
      n
    ), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone());
  }
  getTimer() {
    return this.timer;
  }
  getRenderer() {
    return this.renderer;
  }
  setRenderer(n) {
    if (this.renderer = n, n !== null) {
      const e = n.getSize(new ze()), t = n.getContext().getContextAttributes().alpha, i = this.inputBuffer.texture.type;
      i === Mi && n.outputEncoding === Tt && (this.inputBuffer.texture.encoding = Tt, this.outputBuffer.texture.encoding = Tt, this.inputBuffer.dispose(), this.outputBuffer.dispose()), n.autoClear = !1, this.setSize(e.width, e.height);
      for (const r of this.passes)
        r.initialize(n, t, i);
    }
  }
  replaceRenderer(n, e = !0) {
    const t = this.renderer, i = t.domElement.parentNode;
    return this.setRenderer(n), e && i !== null && (i.removeChild(t.domElement), i.appendChild(n.domElement)), t;
  }
  createDepthTexture() {
    const n = this.depthTexture = new hD();
    return this.inputBuffer.depthTexture = n, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (n.format = Xu, n.type = Tu) : n.type = cc, n;
  }
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
      for (const n of this.passes)
        n.setDepthTexture(null);
    }
  }
  createBuffer(n, e, t, i) {
    const r = this.renderer, s = r === null ? new ze() : r.getDrawingBufferSize(new ze()), o = {
      minFilter: Zt,
      magFilter: Zt,
      stencilBuffer: e,
      depthBuffer: n,
      type: t
    };
    let a;
    return i > 0 ? (a = Number(rh.replace(/\D+/g, "")) < 138 ? new dX(s.width, s.height, o) : new On(s.width, s.height, o), a.ignoreDepthForMultisampleCopy = !1, a.samples = i) : a = new On(s.width, s.height, o), t === Mi && r !== null && r.outputEncoding === Tt && (a.texture.encoding = Tt), a.texture.name = "EffectComposer.Buffer", a.texture.generateMipmaps = !1, a;
  }
  addPass(n, e) {
    const t = this.passes, i = this.renderer, r = i.getDrawingBufferSize(new ze()), s = i.getContext().getContextAttributes().alpha, o = this.inputBuffer.texture.type;
    if (n.setRenderer(i), n.setSize(r.width, r.height), n.initialize(i, s, o), this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1), n.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? t.splice(e, 0, n) : t.push(n), this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0), n.needsDepthTexture || this.depthTexture !== null)
      if (this.depthTexture === null) {
        const a = this.createDepthTexture();
        for (n of t)
          n.setDepthTexture(a);
      } else
        n.setDepthTexture(this.depthTexture);
  }
  removePass(n) {
    const e = this.passes, t = e.indexOf(n);
    if (t !== -1 && e.splice(t, 1).length > 0) {
      if (this.depthTexture !== null) {
        const s = (a, l) => a || l.needsDepthTexture;
        e.reduce(s, !1) || (n.getDepthTexture() === this.depthTexture && n.setDepthTexture(null), this.deleteDepthTexture());
      }
      this.autoRenderToScreen && t === e.length && (n.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0));
    }
  }
  removeAllPasses() {
    const n = this.passes;
    this.deleteDepthTexture(), n.length > 0 && (this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !1), this.passes = []);
  }
  render(n) {
    const e = this.renderer, t = this.copyPass;
    let i = this.inputBuffer, r = this.outputBuffer, s = !1, o, a, l;
    n === void 0 && (n = this.timer.update().getDelta());
    for (const c of this.passes)
      c.enabled && (c.render(e, i, r, n, s), c.needsSwap && (s && (t.renderToScreen = c.renderToScreen, o = e.getContext(), a = e.state.buffers.stencil, a.setFunc(o.NOTEQUAL, 1, 4294967295), t.render(e, i, r, n, s), a.setFunc(o.EQUAL, 1, 4294967295)), l = i, i = r, r = l), c instanceof q$ ? s = !0 : c instanceof H$ && (s = !1));
  }
  setSize(n, e, t) {
    const i = this.renderer;
    if (n === void 0 || e === void 0) {
      const s = i.getSize(new ze());
      n = s.width, e = s.height;
    }
    i.setSize(n, e, t);
    const r = i.getDrawingBufferSize(new ze());
    this.inputBuffer.setSize(r.width, r.height), this.outputBuffer.setSize(r.width, r.height);
    for (const s of this.passes)
      s.setSize(r.width, r.height);
  }
  reset() {
    const n = this.timer.isAutoResetEnabled();
    this.dispose(), this.autoRenderToScreen = !0, this.timer.setAutoResetEnabled(n);
  }
  dispose() {
    for (const n of this.passes)
      n.dispose();
    this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose();
  }
}, J$ = class {
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [yn.FRAGMENT_HEAD, null],
      [yn.FRAGMENT_MAIN_UV, null],
      [yn.FRAGMENT_MAIN_IMAGE, null],
      [yn.VERTEX_HEAD, null],
      [yn.VERTEX_MAIN_SUPPORT, null]
    ]), this.defines = /* @__PURE__ */ new Map(), this.uniforms = /* @__PURE__ */ new Map(), this.blendModes = /* @__PURE__ */ new Map(), this.extensions = /* @__PURE__ */ new Set(), this.attributes = ua.NONE, this.varyings = /* @__PURE__ */ new Set(), this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = Ro;
  }
}, zE = class extends Set {
  constructor(n, e = 10) {
    super(), this.l = e, this.exclusive = !1, n !== void 0 && this.set(n);
  }
  get layer() {
    return this.l;
  }
  set layer(n) {
    const e = this.l;
    for (const t of this)
      t.layers.disable(e), t.layers.enable(n);
    this.l = n;
  }
  getLayer() {
    return this.layer;
  }
  setLayer(n) {
    this.layer = n;
  }
  isExclusive() {
    return this.exclusive;
  }
  setExclusive(n) {
    this.exclusive = n;
  }
  clear() {
    const n = this.layer;
    for (const e of this)
      e.layers.disable(n);
    return super.clear();
  }
  set(n) {
    this.clear();
    for (const e of n)
      this.add(e);
    return this;
  }
  indexOf(n) {
    return this.has(n) ? 0 : -1;
  }
  add(n) {
    return this.exclusive ? n.layers.set(this.layer) : n.layers.enable(this.layer), super.add(n);
  }
  delete(n) {
    return this.has(n) && n.layers.disable(this.layer), super.delete(n);
  }
  toggle(n) {
    let e;
    return this.has(n) ? (this.delete(n), e = !1) : (this.add(n), e = !0), e;
  }
  setVisible(n) {
    for (const e of this)
      n ? e.layers.enable(0) : e.layers.disable(0);
    return this;
  }
}, Q$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}", eZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}", tZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}", nZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", iZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}", rZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}", sZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}", oZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}", aZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}", lZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}", cZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}", uZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}", hZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}", dZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}", fZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}", pZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}", mZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}", vZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}", gZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}", _Z = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", bZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}", yZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}", xZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}", wZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}", SZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}", MZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}", EZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", CZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}", TZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}", PZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}", AZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}", RZ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}", kZ = /* @__PURE__ */ new Map([
  [$t.ADD, Q$],
  [$t.ALPHA, eZ],
  [$t.AVERAGE, tZ],
  [$t.COLOR, nZ],
  [$t.COLOR_BURN, iZ],
  [$t.COLOR_DODGE, rZ],
  [$t.DARKEN, sZ],
  [$t.DIFFERENCE, oZ],
  [$t.DIVIDE, aZ],
  [$t.DST, null],
  [$t.EXCLUSION, lZ],
  [$t.HARD_LIGHT, cZ],
  [$t.HARD_MIX, uZ],
  [$t.HUE, hZ],
  [$t.INVERT, dZ],
  [$t.INVERT_RGB, fZ],
  [$t.LIGHTEN, pZ],
  [$t.LINEAR_BURN, mZ],
  [$t.LINEAR_DODGE, vZ],
  [$t.LINEAR_LIGHT, gZ],
  [$t.LUMINOSITY, _Z],
  [$t.MULTIPLY, bZ],
  [$t.NEGATION, yZ],
  [$t.NORMAL, xZ],
  [$t.OVERLAY, wZ],
  [$t.PIN_LIGHT, SZ],
  [$t.REFLECT, MZ],
  [$t.SATURATION, EZ],
  [$t.SCREEN, CZ],
  [$t.SOFT_LIGHT, TZ],
  [$t.SRC, PZ],
  [$t.SUBTRACT, AZ],
  [$t.VIVID_LIGHT, RZ]
]), LZ = class extends ga {
  constructor(n, e = 1) {
    super(), this._blendFunction = n, this.opacity = new Ne(e);
  }
  getOpacity() {
    return this.opacity.value;
  }
  setOpacity(n) {
    this.opacity.value = n;
  }
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(n) {
    this._blendFunction = n, this.dispatchEvent({ type: "change" });
  }
  getBlendFunction() {
    return this.blendFunction;
  }
  setBlendFunction(n) {
    this.blendFunction = n;
  }
  getShaderCode() {
    return kZ.get(this.blendFunction);
  }
}, Gf = class extends ga {
  constructor(n, e, {
    attributes: t = ua.NONE,
    blendFunction: i = $t.NORMAL,
    defines: r = /* @__PURE__ */ new Map(),
    uniforms: s = /* @__PURE__ */ new Map(),
    extensions: o = null,
    vertexShader: a = null
  } = {}) {
    super(), this.name = n, this.renderer = null, this.attributes = t, this.fragmentShader = e, this.vertexShader = a, this.defines = r, this.uniforms = s, this.extensions = o, this.blendMode = new LZ(i), this.blendMode.addEventListener("change", (l) => this.setChanged()), this._inputColorSpace = Ro, this._outputColorSpace = null;
  }
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  set inputColorSpace(n) {
    this._inputColorSpace = n, this.setChanged();
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(n) {
    this._outputColorSpace = n, this.setChanged();
  }
  getName() {
    return this.name;
  }
  setRenderer(n) {
    this.renderer = n;
  }
  getDefines() {
    return this.defines;
  }
  getUniforms() {
    return this.uniforms;
  }
  getExtensions() {
    return this.extensions;
  }
  getBlendMode() {
    return this.blendMode;
  }
  getAttributes() {
    return this.attributes;
  }
  setAttributes(n) {
    this.attributes = n, this.setChanged();
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  setFragmentShader(n) {
    this.fragmentShader = n, this.setChanged();
  }
  getVertexShader() {
    return this.vertexShader;
  }
  setVertexShader(n) {
    this.vertexShader = n, this.setChanged();
  }
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  setDepthTexture(n, e = io) {
  }
  update(n, e, t) {
  }
  setSize(n, e) {
  }
  initialize(n, e, t) {
  }
  dispose() {
    for (const n of Object.keys(this)) {
      const e = this[n];
      (e instanceof On || e instanceof zo || e instanceof Wi || e instanceof Cr) && this[n].dispose();
    }
  }
}, DZ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}`, w5 = class extends Gf {
  constructor({
    blendFunction: n = $t.SCREEN,
    luminanceThreshold: e = 0.9,
    luminanceSmoothing: t = 0.025,
    mipmapBlur: i = !1,
    intensity: r = 1,
    radius: s = 0.85,
    levels: o = 8,
    kernelSize: a = Uv.LARGE,
    resolutionScale: l = 0.5,
    width: c = ii.AUTO_SIZE,
    height: d = ii.AUTO_SIZE,
    resolutionX: p = c,
    resolutionY: m = d
  } = {}) {
    super("BloomEffect", DZ, {
      blendFunction: n,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Ne(null)],
        ["intensity", new Ne(r)]
      ])
    }), this.renderTarget = new On(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new NE({ kernelSize: a }), this.luminancePass = new j$({ colorOutput: !0 }), this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothing = t, this.mipmapBlurPass = new X$(), this.mipmapBlurPass.enabled = i, this.mipmapBlurPass.radius = s, this.mipmapBlurPass.levels = o, this.uniforms.get("map").value = i ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const v = this.resolution = new ii(this, p, m, l);
    v.addEventListener("change", (b) => this.setSize(v.baseWidth, v.baseHeight));
  }
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  getTexture() {
    return this.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getLuminancePass() {
    return this.luminancePass;
  }
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  get width() {
    return this.resolution.width;
  }
  set width(n) {
    this.resolution.preferredWidth = n;
  }
  get height() {
    return this.resolution.height;
  }
  set height(n) {
    this.resolution.preferredHeight = n;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(n) {
    this.blurPass.dithering = n;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(n) {
    this.blurPass.kernelSize = n;
  }
  get distinction() {
    return console.warn(this.name, "distinction was removed"), 1;
  }
  set distinction(n) {
    console.warn(this.name, "distinction was removed");
  }
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(n) {
    this.uniforms.get("intensity").value = n;
  }
  getIntensity() {
    return this.intensity;
  }
  setIntensity(n) {
    this.intensity = n;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(n) {
    this.resolution.scale = n;
  }
  update(n, e, t) {
    const i = this.renderTarget, r = this.luminancePass;
    r.enabled ? (r.render(n, e), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(n, r.renderTarget) : this.blurPass.render(n, r.renderTarget, i)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(n, e) : this.blurPass.render(n, e, i);
  }
  setSize(n, e) {
    const t = this.resolution;
    t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height), this.blurPass.resolution.copy(t), this.luminancePass.setSize(n, e), this.mipmapBlurPass.setSize(n, e);
  }
  initialize(n, e, t) {
    this.blurPass.initialize(n, e, t), this.luminancePass.initialize(n, e, t), this.mipmapBlurPass.initialize(n, e, t), t !== void 0 && (this.renderTarget.texture.type = t, n.outputEncoding === Tt && (this.renderTarget.texture.encoding = Tt));
  }
}, IZ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float cocNear=texture2D(nearCoCBuffer,uv).r;cocNear=min(cocNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,cocNear);outputColor=result;}`, OZ = class extends Gf {
  constructor(n, {
    blendFunction: e,
    worldFocusDistance: t,
    worldFocusRange: i,
    focusDistance: r = 0,
    focalLength: s = 0.1,
    focusRange: o = s,
    bokehScale: a = 1,
    resolutionScale: l = 1,
    width: c = ii.AUTO_SIZE,
    height: d = ii.AUTO_SIZE,
    resolutionX: p = c,
    resolutionY: m = d
  } = {}) {
    super("DepthOfFieldEffect", IZ, {
      blendFunction: e,
      attributes: ua.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["nearColorBuffer", new Ne(null)],
        ["farColorBuffer", new Ne(null)],
        ["nearCoCBuffer", new Ne(null)],
        ["scale", new Ne(1)]
      ])
    }), this.camera = n, this.renderTarget = new On(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.name = "DoF.CoC", this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new rl(new c$(n));
    const v = this.cocMaterial;
    v.focusDistance = r, v.focusRange = o, t !== void 0 && (v.worldFocusDistance = t), i !== void 0 && (v.worldFocusRange = i), this.blurPass = new NE({ resolutionScale: l, resolutionX: p, resolutionY: m, kernelSize: Uv.MEDIUM }), this.maskPass = new rl(new A$(this.renderTargetCoC.texture));
    const b = this.maskPass.fullscreenMaterial;
    b.maskFunction = y5.MULTIPLY, b.colorChannel = b5.GREEN, this.bokehNearBasePass = new rl(new m_(!1, !0)), this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehNearFillPass = new rl(new m_(!0, !0)), this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehFarBasePass = new rl(new m_(!1, !1)), this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.bokehFarFillPass = new rl(new m_(!0, !1)), this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.target = null;
    const x = this.resolution = new ii(this, p, m, l);
    x.addEventListener("change", (y) => this.setSize(x.baseWidth, x.baseHeight)), this.bokehScale = a;
  }
  get cocTexture() {
    return this.renderTargetCoC.texture;
  }
  get cocMaterial() {
    return this.cocPass.fullscreenMaterial;
  }
  get circleOfConfusionMaterial() {
    return this.cocMaterial;
  }
  getCircleOfConfusionMaterial() {
    return this.circleOfConfusionMaterial;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getResolution() {
    return this.resolution;
  }
  get bokehScale() {
    return this.uniforms.get("scale").value;
  }
  set bokehScale(n) {
    this.bokehNearBasePass.fullscreenMaterial.scale = n, this.bokehNearFillPass.fullscreenMaterial.scale = n, this.bokehFarBasePass.fullscreenMaterial.scale = n, this.bokehFarFillPass.fullscreenMaterial.scale = n, this.maskPass.fullscreenMaterial.strength = n, this.uniforms.get("scale").value = n;
  }
  getBokehScale() {
    return this.bokehScale;
  }
  setBokehScale(n) {
    this.bokehScale = n;
  }
  getTarget() {
    return this.target;
  }
  setTarget(n) {
    this.target = n;
  }
  calculateFocusDistance(n) {
    const e = this.camera, t = e.position.distanceTo(n);
    return Su(-t, e.near, e.far);
  }
  setDepthTexture(n, e = io) {
    this.circleOfConfusionMaterial.depthBuffer = n, this.circleOfConfusionMaterial.depthPacking = e;
  }
  update(n, e, t) {
    const i = this.renderTarget, r = this.renderTargetCoC, s = this.renderTargetCoCBlurred, o = this.renderTargetMasked;
    if (this.target !== null) {
      const a = this.calculateFocusDistance(this.target);
      this.circleOfConfusionMaterial.focusDistance = a;
    }
    this.cocPass.render(n, null, r), this.blurPass.render(n, r, s), this.maskPass.render(n, e, o), this.bokehFarBasePass.render(n, o, i), this.bokehFarFillPass.render(n, i, this.renderTargetFar), this.bokehNearBasePass.render(n, e, i), this.bokehNearFillPass.render(n, i, this.renderTargetNear);
  }
  setSize(n, e) {
    const t = this.resolution;
    t.setBaseSize(n, e);
    const i = t.width, r = t.height;
    this.cocPass.setSize(n, e), this.blurPass.setSize(n, e), this.maskPass.setSize(n, e), this.renderTargetCoC.setSize(n, e), this.renderTargetMasked.setSize(n, e), this.renderTarget.setSize(i, r), this.renderTargetNear.setSize(i, r), this.renderTargetFar.setSize(i, r), this.renderTargetCoCBlurred.setSize(i, r), this.bokehNearBasePass.fullscreenMaterial.setSize(n, e), this.bokehNearFillPass.fullscreenMaterial.setSize(n, e), this.bokehFarBasePass.fullscreenMaterial.setSize(n, e), this.bokehFarFillPass.fullscreenMaterial.setSize(n, e);
  }
  initialize(n, e, t) {
    this.cocPass.initialize(n, e, t), this.maskPass.initialize(n, e, t), this.bokehNearBasePass.initialize(n, e, t), this.bokehNearFillPass.initialize(n, e, t), this.bokehFarBasePass.initialize(n, e, t), this.bokehFarFillPass.initialize(n, e, t), this.blurPass.initialize(n, e, Mi), t !== void 0 && (this.renderTarget.texture.type = t, this.renderTargetNear.texture.type = t, this.renderTargetFar.texture.type = t, this.renderTargetMasked.texture.type = t, n.outputEncoding === Tt && (this.renderTarget.texture.encoding = Tt, this.renderTargetNear.texture.encoding = Tt, this.renderTargetFar.texture.encoding = Tt, this.renderTargetMasked.texture.encoding = Tt));
  }
};
function NZ(n, e, t) {
  const i = /* @__PURE__ */ new Map([
    [sE, 1],
    [qL, 1],
    [XL, 2],
    [wr, 4]
  ]);
  let r;
  if (i.has(e) || console.error("Invalid noise texture format"), t === Mi) {
    r = new Uint8Array(n * i.get(e));
    for (let s = 0, o = r.length; s < o; ++s)
      r[s] = Math.random() * 255 + 0.5;
  } else {
    r = new Float32Array(n * i.get(e));
    for (let s = 0, o = r.length; s < o; ++s)
      r[s] = Math.random();
  }
  return r;
}
var zZ = class extends Ff {
  constructor(n, e, t = sE, i = Mi) {
    super(NZ(n * e, t, i), n, e, t, i), this.needsUpdate = !0;
  }
};
new Z();
new Pt();
new xt();
var FZ = `uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;
#ifdef USE_PATTERN
uniform lowp sampler2D patternTexture;varying vec2 vUvPattern;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;
#ifndef X_RAY
edge.y=0.0;
#endif
edge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;
#ifdef USE_PATTERN
vec4 patternColor=texelToLinear(texture2D(patternTexture,vUvPattern));
#ifdef X_RAY
float hiddenFactor=0.5;
#else
float hiddenFactor=0.0;
#endif
visibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;
#endif
float alpha=max(max(edge.x,edge.y),visibilityFactor);
#ifdef ALPHA
outputColor=vec4(color,alpha);
#else
outputColor=vec4(color,max(alpha,inputColor.a));
#endif
}`, BZ = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}", UZ = class extends Gf {
  constructor(n, e, {
    blendFunction: t = $t.SCREEN,
    patternTexture: i = null,
    patternScale: r = 1,
    edgeStrength: s = 1,
    pulseSpeed: o = 0,
    visibleEdgeColor: a = 16777215,
    hiddenEdgeColor: l = 2230538,
    kernelSize: c = Uv.VERY_SMALL,
    blur: d = !1,
    xRay: p = !0,
    multisampling: m = 0,
    resolutionScale: v = 0.5,
    width: b = ii.AUTO_SIZE,
    height: x = ii.AUTO_SIZE,
    resolutionX: y = b,
    resolutionY: S = x
  } = {}) {
    super("OutlineEffect", FZ, {
      uniforms: /* @__PURE__ */ new Map([
        ["maskTexture", new Ne(null)],
        ["edgeTexture", new Ne(null)],
        ["edgeStrength", new Ne(s)],
        ["visibleEdgeColor", new Ne(new xt(a))],
        ["hiddenEdgeColor", new Ne(new xt(l))],
        ["pulse", new Ne(1)],
        ["patternScale", new Ne(r)],
        ["patternTexture", new Ne(null)]
      ])
    }), this.blendMode.addEventListener("change", (P) => {
      this.blendMode.getBlendFunction() === $t.ALPHA ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA"), this.setChanged();
    }), this.blendMode.setBlendFunction(t), this.patternTexture = i, this.xRay = p, this.scene = n, this.camera = e, this.renderTargetMask = new On(1, 1), this.renderTargetMask.samples = m, this.renderTargetMask.texture.name = "Outline.Mask", this.uniforms.get("maskTexture").value = this.renderTargetMask.texture, this.renderTargetOutline = new On(1, 1, { depthBuffer: !1 }), this.renderTargetOutline.texture.name = "Outline.Edges", this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture, this.clearPass = new Ny(), this.clearPass.overrideClearColor = new xt(0), this.clearPass.overrideClearAlpha = 1, this.depthPass = new OE(n, e), this.maskPass = new Vv(n, e, new g$(this.depthPass.texture, e));
    const C = this.maskPass.clearPass;
    C.overrideClearColor = new xt(16777215), C.overrideClearAlpha = 1, this.blurPass = new NE({ resolutionScale: v, resolutionX: y, resolutionY: S, kernelSize: c }), this.blurPass.enabled = d;
    const M = this.blurPass.resolution;
    M.addEventListener("change", (P) => this.setSize(M.baseWidth, M.baseHeight)), this.outlinePass = new rl(new L$());
    const T = this.outlinePass.fullscreenMaterial;
    T.inputBuffer = this.renderTargetMask.texture, this.time = 0, this.selection = new zE(), this.selection.layer = 10, this.pulseSpeed = o;
  }
  get resolution() {
    return this.blurPass.resolution;
  }
  getResolution() {
    return this.blurPass.getResolution();
  }
  get multisampling() {
    return this.renderTargetMask.samples;
  }
  set multisampling(n) {
    this.renderTargetMask.samples = n, this.renderTargetMask.dispose();
  }
  get patternScale() {
    return this.uniforms.get("patternScale").value;
  }
  set patternScale(n) {
    this.uniforms.get("patternScale").value = n;
  }
  get edgeStrength() {
    return this.uniforms.get("edgeStrength").value;
  }
  set edgeStrength(n) {
    this.uniforms.get("edgeStrength").value = n;
  }
  get visibleEdgeColor() {
    return this.uniforms.get("visibleEdgeColor").value;
  }
  set visibleEdgeColor(n) {
    this.uniforms.get("visibleEdgeColor").value = n;
  }
  get hiddenEdgeColor() {
    return this.uniforms.get("hiddenEdgeColor").value;
  }
  set hiddenEdgeColor(n) {
    this.uniforms.get("hiddenEdgeColor").value = n;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getSelection() {
    return this.selection;
  }
  getPulseSpeed() {
    return this.pulseSpeed;
  }
  setPulseSpeed(n) {
    this.pulseSpeed = n;
  }
  get width() {
    return this.resolution.width;
  }
  set width(n) {
    this.resolution.preferredWidth = n;
  }
  get height() {
    return this.resolution.height;
  }
  set height(n) {
    this.resolution.preferredHeight = n;
  }
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(n) {
    this.selection.layer = n;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(n) {
    this.blurPass.dithering = n;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(n) {
    this.blurPass.kernelSize = n;
  }
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(n) {
    this.blurPass.enabled = n;
  }
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(n) {
    this.xRay !== n && (n ? this.defines.set("X_RAY", "1") : this.defines.delete("X_RAY"), this.setChanged());
  }
  isXRayEnabled() {
    return this.xRay;
  }
  setXRayEnabled(n) {
    this.xRay = n;
  }
  get patternTexture() {
    return this.uniforms.get("patternTexture").value;
  }
  set patternTexture(n) {
    if (n !== null ? (n.wrapS = n.wrapT = qu, this.defines.set("USE_PATTERN", "1"), this.setVertexShader(BZ)) : (this.defines.delete("USE_PATTERN"), this.setVertexShader(null)), this.renderer !== null) {
      const e = LA(n, this.renderer.capabilities.isWebGL2);
      this.defines.set("texelToLinear(texel)", e);
    }
    this.uniforms.get("patternTexture").value = n, this.setChanged();
  }
  setPatternTexture(n) {
    this.patternTexture = n;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(n) {
    this.resolution.scale = n;
  }
  setSelection(n) {
    return this.selection.set(n), this;
  }
  clearSelection() {
    return this.selection.clear(), this;
  }
  selectObject(n) {
    return this.selection.add(n), this;
  }
  deselectObject(n) {
    return this.selection.delete(n), this;
  }
  update(n, e, t) {
    const i = this.scene, r = this.camera, s = this.selection, a = this.uniforms.get("pulse"), l = i.background, c = r.layers.mask;
    s.size > 0 ? (i.background = null, a.value = 1, this.pulseSpeed > 0 && (a.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625), this.time += t, s.setVisible(!1), this.depthPass.render(n), s.setVisible(!0), r.layers.set(s.layer), this.maskPass.render(n, this.renderTargetMask), r.layers.mask = c, i.background = l, this.outlinePass.render(n, null, this.renderTargetOutline), this.blurPass.enabled && this.blurPass.render(n, this.renderTargetOutline, this.renderTargetOutline)) : this.time > 0 && (this.clearPass.render(n, this.renderTargetOutline), this.time = 0);
  }
  setSize(n, e) {
    this.blurPass.setSize(n, e), this.renderTargetMask.setSize(n, e);
    const t = this.resolution;
    t.setBaseSize(n, e);
    const i = t.width, r = t.height;
    this.depthPass.setSize(i, r), this.renderTargetOutline.setSize(i, r), this.outlinePass.fullscreenMaterial.setSize(i, r);
  }
  initialize(n, e, t) {
    const i = this.patternTexture, r = LA(i, n.capabilities.isWebGL2);
    this.defines.set("texelToLinear(texel)", r), this.blurPass.initialize(n, e, Mi), t !== void 0 && (this.depthPass.initialize(n, e, t), this.maskPass.initialize(n, e, t), this.outlinePass.initialize(n, e, t));
  }
};
new Z();
new Z();
var VZ = class extends w5 {
  constructor(n, e, t) {
    super(t), this.setAttributes(this.getAttributes() | ua.DEPTH), this.camera = e, this.depthPass = new OE(n, e), this.clearPass = new Ny(!0, !1, !1), this.clearPass.overrideClearColor = new xt(0), this.depthMaskPass = new rl(new b$());
    const i = this.depthMaskMaterial;
    i.adoptCameraSettings(e), i.depthBuffer1 = this.depthPass.texture, i.depthPacking1 = Xm, i.depthMode = gb, this.renderTargetMasked = new On(1, 1, { depthBuffer: !1 }), this.renderTargetMasked.texture.name = "Bloom.Masked", this.selection = new zE(), this.selection.layer = 11, this._inverted = !1, this._ignoreBackground = !1;
  }
  getSelection() {
    return this.selection;
  }
  get depthMaskMaterial() {
    return this.depthMaskPass.fullscreenMaterial;
  }
  get inverted() {
    return this._inverted;
  }
  set inverted(n) {
    this._inverted = n, this.depthMaskMaterial.depthMode = n ? rE : gb;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(n) {
    this.inverted = n;
  }
  get ignoreBackground() {
    return this._ignoreBackground;
  }
  set ignoreBackground(n) {
    this._ignoreBackground = n, this.depthMaskMaterial.maxDepthStrategy = n ? Lm.DISCARD_MAX_DEPTH : Lm.KEEP_MAX_DEPTH;
  }
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  setBackgroundDisabled(n) {
    this.ignoreBackground = n;
  }
  setDepthTexture(n, e = io) {
    this.depthMaskMaterial.depthBuffer0 = n, this.depthMaskMaterial.depthPacking0 = e;
  }
  update(n, e, t) {
    const i = this.camera, r = this.selection, s = this.inverted;
    let o = e;
    if (this.ignoreBackground || !s || r.size > 0) {
      const a = i.layers.mask;
      i.layers.set(r.layer), this.depthPass.render(n), i.layers.mask = a, o = this.renderTargetMasked, this.clearPass.render(n, o), this.depthMaskPass.render(n, e, o);
    }
    super.update(n, o, t);
  }
  setSize(n, e) {
    super.setSize(n, e), this.renderTargetMasked.setSize(n, e), this.depthPass.setSize(n, e);
  }
  initialize(n, e, t) {
    super.initialize(n, e, t), this.clearPass.initialize(n, e, t), this.depthPass.initialize(n, e, t), this.depthMaskPass.initialize(n, e, t), t !== void 0 && (this.renderTargetMasked.texture.type = t, n.outputEncoding === Tt && (this.renderTargetMasked.texture.encoding = Tt));
  }
}, HZ = `uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef DEPTH_AWARE_UPSAMPLING
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D normalDepthBuffer;
#else
uniform mediump sampler2D normalDepthBuffer;
#endif
#endif
#ifdef COLORIZE
uniform vec3 color;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;
#if defined(DEPTH_AWARE_UPSAMPLING) && __VERSION__ == 300
vec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);
#else
float ao=aoLinear;
#endif
float l=luminance(inputColor.rgb);ao=mix(ao,1.0,l*luminanceInfluence);
#ifdef COLORIZE
outputColor=vec4(1.0-(1.0-ao)*(1.0-color),inputColor.a);
#else
outputColor=vec4(vec3(ao),inputColor.a);
#endif
}`, OA = 64, GZ = class extends Gf {
  constructor(n, e, {
    blendFunction: t = $t.MULTIPLY,
    distanceScaling: i = !0,
    depthAwareUpsampling: r = !0,
    normalDepthBuffer: s = null,
    samples: o = 9,
    rings: a = 7,
    worldDistanceThreshold: l,
    worldDistanceFalloff: c,
    worldProximityThreshold: d,
    worldProximityFalloff: p,
    distanceThreshold: m = 0.97,
    distanceFalloff: v = 0.03,
    rangeThreshold: b = 5e-4,
    rangeFalloff: x = 1e-3,
    minRadiusScale: y = 0.1,
    luminanceInfluence: S = 0.7,
    radius: C = 0.1825,
    intensity: M = 1,
    bias: T = 0.025,
    fade: P = 0.01,
    color: D = null,
    resolutionScale: I = 1,
    width: k = ii.AUTO_SIZE,
    height: O = ii.AUTO_SIZE,
    resolutionX: B = k,
    resolutionY: Y = O
  } = {}) {
    super("SSAOEffect", HZ, {
      blendFunction: t,
      attributes: ua.DEPTH,
      defines: /* @__PURE__ */ new Map([
        ["THRESHOLD", "0.997"]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["aoBuffer", new Ne(null)],
        ["normalDepthBuffer", new Ne(s)],
        ["luminanceInfluence", new Ne(S)],
        ["color", new Ne(null)],
        ["scale", new Ne(0)]
      ])
    }), this.renderTargetAO = new On(1, 1, { depthBuffer: !1 }), this.renderTargetAO.texture.name = "AO.Target", this.uniforms.get("aoBuffer").value = this.renderTargetAO.texture;
    const G = this.resolution = new ii(this, B, Y, I);
    G.addEventListener("change", (J) => this.setSize(G.baseWidth, G.baseHeight)), this.camera = n, this.ssaoPass = new rl(new O$(n));
    const K = new zZ(OA, OA, wr);
    K.wrapS = K.wrapT = qu;
    const A = this.ssaoMaterial;
    A.noiseTexture = K, A.minRadiusScale = y, A.intensity = M, A.fade = P, A.bias = T, s !== null ? (A.normalDepthBuffer = s, this.depthAwareUpsampling = r) : A.normalBuffer = e, A.distanceThreshold = m, A.distanceFalloff = v, A.proximityThreshold = b, A.proximityFalloff = x, l !== void 0 && (A.worldDistanceThreshold = l), c !== void 0 && (A.worldDistanceFalloff = c), d !== void 0 && (A.worldProximityThreshold = d), p !== void 0 && (A.worldProximityFalloff = p), A.distanceScaling = i, A.samples = o, A.radius = C, A.rings = a, this.color = D;
  }
  getResolution() {
    return this.resolution;
  }
  get ssaoMaterial() {
    return this.ssaoPass.fullscreenMaterial;
  }
  getSSAOMaterial() {
    return this.ssaoMaterial;
  }
  get samples() {
    return this.ssaoMaterial.samples;
  }
  set samples(n) {
    this.ssaoMaterial.samples = n;
  }
  get rings() {
    return this.ssaoMaterial.rings;
  }
  set rings(n) {
    this.ssaoMaterial.rings = n;
  }
  get radius() {
    return this.ssaoMaterial.radius;
  }
  set radius(n) {
    this.ssaoMaterial.radius = n;
  }
  get depthAwareUpsampling() {
    return this.defines.has("DEPTH_AWARE_UPSAMPLING");
  }
  set depthAwareUpsampling(n) {
    this.depthAwareUpsampling !== n && (n && this.uniforms.get("normalDepthBuffer").value !== null ? this.defines.set("DEPTH_AWARE_UPSAMPLING", "1") : this.defines.delete("DEPTH_AWARE_UPSAMPLING"), this.setChanged());
  }
  isDepthAwareUpsamplingEnabled() {
    return this.depthAwareUpsampling;
  }
  setDepthAwareUpsamplingEnabled(n) {
    this.depthAwareUpsampling = n;
  }
  get distanceScaling() {
    return this.ssaoMaterial.distanceScaling;
  }
  set distanceScaling(n) {
    this.ssaoMaterial.distanceScaling = n;
  }
  get color() {
    return this.uniforms.get("color").value;
  }
  set color(n) {
    const e = this.uniforms, t = this.defines;
    n !== null ? t.has("COLORIZE") ? e.get("color").value.set(n) : (t.set("COLORIZE", "1"), e.get("color").value = new xt(n), this.setChanged()) : t.has("COLORIZE") && (t.delete("COLORIZE"), e.get("color").value = null, this.setChanged());
  }
  get luminanceInfluence() {
    return this.uniforms.get("luminanceInfluence").value;
  }
  set luminanceInfluence(n) {
    this.uniforms.get("luminanceInfluence").value = n;
  }
  getColor() {
    return this.color;
  }
  setColor(n) {
    this.color = n;
  }
  setDistanceCutoff(n, e) {
    this.ssaoMaterial.distanceThreshold = n, this.ssaoMaterial.distanceFalloff = e;
  }
  setProximityCutoff(n, e) {
    this.ssaoMaterial.proximityThreshold = n, this.ssaoMaterial.proximityFalloff = e;
  }
  setDepthTexture(n, e = io) {
    this.ssaoMaterial.depthBuffer = n, this.ssaoMaterial.depthPacking = e;
  }
  update(n, e, t) {
    this.ssaoPass.render(n, null, this.renderTargetAO);
  }
  setSize(n, e) {
    const t = this.resolution;
    t.setBaseSize(n, e);
    const i = t.width, r = t.height, s = this.ssaoMaterial;
    s.adoptCameraSettings(this.camera), s.setSize(i, r), this.renderTargetAO.setSize(i, r);
  }
}, WZ = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`, jZ = class extends Gf {
  constructor({
    blendFunction: n,
    technique: e = v_.DEFAULT,
    eskil: t = !1,
    offset: i = 0.5,
    darkness: r = 0.5
  } = {}) {
    super("VignetteEffect", WZ, {
      blendFunction: n,
      defines: /* @__PURE__ */ new Map([
        ["VIGNETTE_TECHNIQUE", e.toFixed(0)]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new Ne(i)],
        ["darkness", new Ne(r)]
      ])
    });
  }
  get technique() {
    return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
  }
  set technique(n) {
    this.technique !== n && (this.defines.set("VIGNETTE_TECHNIQUE", n.toFixed(0)), this.setChanged());
  }
  get eskil() {
    return this.technique === v_.ESKIL;
  }
  set eskil(n) {
    this.technique = n ? v_.ESKIL : v_.DEFAULT;
  }
  getTechnique() {
    return this.technique;
  }
  setTechnique(n) {
    this.technique = n;
  }
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(n) {
    this.uniforms.get("offset").value = n;
  }
  getOffset() {
    return this.offset;
  }
  setOffset(n) {
    this.offset = n;
  }
  get darkness() {
    return this.uniforms.get("darkness").value;
  }
  set darkness(n) {
    this.uniforms.get("darkness").value = n;
  }
  getDarkness() {
    return this.darkness;
  }
  setDarkness(n) {
    this.darkness = n;
  }
};
const xo = new ni(75, 1, uh, Mc), un = new ni(75, 1, uh, Mc), [qZ, Lo] = Be([TX, PX]), XZ = ([n, e]) => qZ([Math.max(n, 1), Math.max(e, 1)]), FE = (n) => {
  const e = /* @__PURE__ */ new Map();
  let t = !1;
  const i = () => {
    t || (t = !0, Ec(() => {
      t = !1, e.clear();
    }, !0));
  };
  return (r) => {
    if (e.has(r))
      return e.get(r);
    const s = n(r);
    return e.set(r, s), i(), s;
  };
}, Wf = (n) => {
  const e = FE(n);
  return (t) => e(t).clone();
}, Dn = Wf(
  (n) => n.parent === bt ? n.position.clone() : n.getWorldPosition(new Z())
), gl = Wf(
  (n) => n.parent === bt ? n.quaternion.clone() : n.getWorldQuaternion(new Gi())
), $u = (n) => Math.min(n * ta[0], 1), [Hhe, wf] = Be(!1), [D2, Zu] = Be(!1), [S5, Dm] = Be(
  [un]
), $Z = nh(S5, Dm), NA = ih(S5, Dm), [Vd, X_] = Be(void 0), [ZZ, zy] = di(), dr = No(
  (n, e, t) => ZZ({ target: n, rightClick: e, noDeselect: t })
);
ft(() => {
  const n = Nn();
  if (!n)
    return;
  const e = Ay((t) => t === n && Lv(void 0));
  return () => {
    e.cancel();
  };
}, [Nn]);
const Sf = (n, e) => n[e], [Fy, Zn] = Be(void 0);
ft(() => {
  const n = Zn();
  if (!n)
    return;
  const e = Ay(
    (t) => t === n && Fy(void 0)
  );
  return () => {
    e.cancel();
  };
}, [Zn]);
var By, St, M5, Im, zA, E5, Ab = {}, C5 = [], YZ = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function uc(n, e) {
  for (var t in e)
    n[t] = e[t];
  return n;
}
function T5(n) {
  var e = n.parentNode;
  e && e.removeChild(n);
}
function Yu(n, e, t) {
  var i, r, s, o = {};
  for (s in e)
    s == "key" ? i = e[s] : s == "ref" ? r = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? By.call(arguments, 2) : t), typeof n == "function" && n.defaultProps != null)
    for (s in n.defaultProps)
      o[s] === void 0 && (o[s] = n.defaultProps[s]);
  return $_(n, o, i, r, null);
}
function $_(n, e, t, i, r) {
  var s = { type: n, props: e, key: t, ref: i, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: r == null ? ++M5 : r };
  return r == null && St.vnode != null && St.vnode(s), s;
}
function Mf(n) {
  return n.children;
}
function ha(n, e) {
  this.props = n, this.context = e;
}
function nv(n, e) {
  if (e == null)
    return n.__ ? nv(n.__, n.__.__k.indexOf(n) + 1) : null;
  for (var t; e < n.__k.length; e++)
    if ((t = n.__k[e]) != null && t.__e != null)
      return t.__e;
  return typeof n.type == "function" ? nv(n) : null;
}
function P5(n) {
  var e, t;
  if ((n = n.__) != null && n.__c != null) {
    for (n.__e = n.__c.base = null, e = 0; e < n.__k.length; e++)
      if ((t = n.__k[e]) != null && t.__e != null) {
        n.__e = n.__c.base = t.__e;
        break;
      }
    return P5(n);
  }
}
function I2(n) {
  (!n.__d && (n.__d = !0) && Im.push(n) && !Rb.__r++ || zA !== St.debounceRendering) && ((zA = St.debounceRendering) || setTimeout)(Rb);
}
function Rb() {
  for (var n; Rb.__r = Im.length; )
    n = Im.sort(function(e, t) {
      return e.__v.__b - t.__v.__b;
    }), Im = [], n.some(function(e) {
      var t, i, r, s, o, a;
      e.__d && (o = (s = (t = e).__v).__e, (a = t.__P) && (i = [], (r = uc({}, s)).__v = s.__v + 1, BE(a, s, r, t.__n, a.ownerSVGElement !== void 0, s.__h != null ? [o] : null, i, o == null ? nv(s) : o, s.__h), L5(i, s), s.__e != o && P5(s)));
    });
}
function A5(n, e, t, i, r, s, o, a, l, c) {
  var d, p, m, v, b, x, y, S = i && i.__k || C5, C = S.length;
  for (t.__k = [], d = 0; d < e.length; d++)
    if ((v = t.__k[d] = (v = e[d]) == null || typeof v == "boolean" ? null : typeof v == "string" || typeof v == "number" || typeof v == "bigint" ? $_(null, v, null, null, v) : Array.isArray(v) ? $_(Mf, { children: v }, null, null, null) : v.__b > 0 ? $_(v.type, v.props, v.key, v.ref ? v.ref : null, v.__v) : v) != null) {
      if (v.__ = t, v.__b = t.__b + 1, (m = S[d]) === null || m && v.key == m.key && v.type === m.type)
        S[d] = void 0;
      else
        for (p = 0; p < C; p++) {
          if ((m = S[p]) && v.key == m.key && v.type === m.type) {
            S[p] = void 0;
            break;
          }
          m = null;
        }
      BE(n, v, m = m || Ab, r, s, o, a, l, c), b = v.__e, (p = v.ref) && m.ref != p && (y || (y = []), m.ref && y.push(m.ref, null, v), y.push(p, v.__c || b, v)), b != null ? (x == null && (x = b), typeof v.type == "function" && v.__k === m.__k ? v.__d = l = R5(v, l, n) : l = k5(n, v, m, S, b, l), typeof t.type == "function" && (t.__d = l)) : l && m.__e == l && l.parentNode != n && (l = nv(m));
    }
  for (t.__e = x, d = C; d--; )
    S[d] != null && I5(S[d], S[d]);
  if (y)
    for (d = 0; d < y.length; d++)
      D5(y[d], y[++d], y[++d]);
}
function R5(n, e, t) {
  for (var i, r = n.__k, s = 0; r && s < r.length; s++)
    (i = r[s]) && (i.__ = n, e = typeof i.type == "function" ? R5(i, e, t) : k5(t, i, i, r, i.__e, e));
  return e;
}
function kb(n, e) {
  return e = e || [], n == null || typeof n == "boolean" || (Array.isArray(n) ? n.some(function(t) {
    kb(t, e);
  }) : e.push(n)), e;
}
function k5(n, e, t, i, r, s) {
  var o, a, l;
  if (e.__d !== void 0)
    o = e.__d, e.__d = void 0;
  else if (t == null || r != s || r.parentNode == null)
    e:
      if (s == null || s.parentNode !== n)
        n.appendChild(r), o = null;
      else {
        for (a = s, l = 0; (a = a.nextSibling) && l < i.length; l += 1)
          if (a == r)
            break e;
        n.insertBefore(r, s), o = s;
      }
  return o !== void 0 ? o : r.nextSibling;
}
function KZ(n, e, t, i, r) {
  var s;
  for (s in t)
    s === "children" || s === "key" || s in e || Lb(n, s, null, t[s], i);
  for (s in e)
    r && typeof e[s] != "function" || s === "children" || s === "key" || s === "value" || s === "checked" || t[s] === e[s] || Lb(n, s, e[s], t[s], i);
}
function FA(n, e, t) {
  e[0] === "-" ? n.setProperty(e, t) : n[e] = t == null ? "" : typeof t != "number" || YZ.test(e) ? t : t + "px";
}
function Lb(n, e, t, i, r) {
  var s;
  e:
    if (e === "style")
      if (typeof t == "string")
        n.style.cssText = t;
      else {
        if (typeof i == "string" && (n.style.cssText = i = ""), i)
          for (e in i)
            t && e in t || FA(n.style, e, "");
        if (t)
          for (e in t)
            i && t[e] === i[e] || FA(n.style, e, t[e]);
      }
    else if (e[0] === "o" && e[1] === "n")
      s = e !== (e = e.replace(/Capture$/, "")), e = e.toLowerCase() in n ? e.toLowerCase().slice(2) : e.slice(2), n.l || (n.l = {}), n.l[e + s] = t, t ? i || n.addEventListener(e, s ? UA : BA, s) : n.removeEventListener(e, s ? UA : BA, s);
    else if (e !== "dangerouslySetInnerHTML") {
      if (r)
        e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (e !== "href" && e !== "list" && e !== "form" && e !== "tabIndex" && e !== "download" && e in n)
        try {
          n[e] = t == null ? "" : t;
          break e;
        } catch {
        }
      typeof t == "function" || (t == null || t === !1 && e.indexOf("-") == -1 ? n.removeAttribute(e) : n.setAttribute(e, t));
    }
}
function BA(n) {
  this.l[n.type + !1](St.event ? St.event(n) : n);
}
function UA(n) {
  this.l[n.type + !0](St.event ? St.event(n) : n);
}
function BE(n, e, t, i, r, s, o, a, l) {
  var c, d, p, m, v, b, x, y, S, C, M, T, P, D, I, k = e.type;
  if (e.constructor !== void 0)
    return null;
  t.__h != null && (l = t.__h, a = e.__e = t.__e, e.__h = null, s = [a]), (c = St.__b) && c(e);
  try {
    e:
      if (typeof k == "function") {
        if (y = e.props, S = (c = k.contextType) && i[c.__c], C = c ? S ? S.props.value : c.__ : i, t.__c ? x = (d = e.__c = t.__c).__ = d.__E : ("prototype" in k && k.prototype.render ? e.__c = d = new k(y, C) : (e.__c = d = new ha(y, C), d.constructor = k, d.render = QZ), S && S.sub(d), d.props = y, d.state || (d.state = {}), d.context = C, d.__n = i, p = d.__d = !0, d.__h = [], d._sb = []), d.__s == null && (d.__s = d.state), k.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = uc({}, d.__s)), uc(d.__s, k.getDerivedStateFromProps(y, d.__s))), m = d.props, v = d.state, p)
          k.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), d.componentDidMount != null && d.__h.push(d.componentDidMount);
        else {
          if (k.getDerivedStateFromProps == null && y !== m && d.componentWillReceiveProps != null && d.componentWillReceiveProps(y, C), !d.__e && d.shouldComponentUpdate != null && d.shouldComponentUpdate(y, d.__s, C) === !1 || e.__v === t.__v) {
            for (d.props = y, d.state = d.__s, e.__v !== t.__v && (d.__d = !1), d.__v = e, e.__e = t.__e, e.__k = t.__k, e.__k.forEach(function(O) {
              O && (O.__ = e);
            }), M = 0; M < d._sb.length; M++)
              d.__h.push(d._sb[M]);
            d._sb = [], d.__h.length && o.push(d);
            break e;
          }
          d.componentWillUpdate != null && d.componentWillUpdate(y, d.__s, C), d.componentDidUpdate != null && d.__h.push(function() {
            d.componentDidUpdate(m, v, b);
          });
        }
        if (d.context = C, d.props = y, d.__v = e, d.__P = n, T = St.__r, P = 0, "prototype" in k && k.prototype.render) {
          for (d.state = d.__s, d.__d = !1, T && T(e), c = d.render(d.props, d.state, d.context), D = 0; D < d._sb.length; D++)
            d.__h.push(d._sb[D]);
          d._sb = [];
        } else
          do
            d.__d = !1, T && T(e), c = d.render(d.props, d.state, d.context), d.state = d.__s;
          while (d.__d && ++P < 25);
        d.state = d.__s, d.getChildContext != null && (i = uc(uc({}, i), d.getChildContext())), p || d.getSnapshotBeforeUpdate == null || (b = d.getSnapshotBeforeUpdate(m, v)), I = c != null && c.type === Mf && c.key == null ? c.props.children : c, A5(n, Array.isArray(I) ? I : [I], e, t, i, r, s, o, a, l), d.base = e.__e, e.__h = null, d.__h.length && o.push(d), x && (d.__E = d.__ = null), d.__e = !1;
      } else
        s == null && e.__v === t.__v ? (e.__k = t.__k, e.__e = t.__e) : e.__e = JZ(t.__e, e, t, i, r, s, o, l);
    (c = St.diffed) && c(e);
  } catch (O) {
    e.__v = null, (l || s != null) && (e.__e = a, e.__h = !!l, s[s.indexOf(a)] = null), St.__e(O, e, t);
  }
}
function L5(n, e) {
  St.__c && St.__c(e, n), n.some(function(t) {
    try {
      n = t.__h, t.__h = [], n.some(function(i) {
        i.call(t);
      });
    } catch (i) {
      St.__e(i, t.__v);
    }
  });
}
function JZ(n, e, t, i, r, s, o, a) {
  var l, c, d, p = t.props, m = e.props, v = e.type, b = 0;
  if (v === "svg" && (r = !0), s != null) {
    for (; b < s.length; b++)
      if ((l = s[b]) && "setAttribute" in l == !!v && (v ? l.localName === v : l.nodeType === 3)) {
        n = l, s[b] = null;
        break;
      }
  }
  if (n == null) {
    if (v === null)
      return document.createTextNode(m);
    n = r ? document.createElementNS("http://www.w3.org/2000/svg", v) : document.createElement(v, m.is && m), s = null, a = !1;
  }
  if (v === null)
    p === m || a && n.data === m || (n.data = m);
  else {
    if (s = s && By.call(n.childNodes), c = (p = t.props || Ab).dangerouslySetInnerHTML, d = m.dangerouslySetInnerHTML, !a) {
      if (s != null)
        for (p = {}, b = 0; b < n.attributes.length; b++)
          p[n.attributes[b].name] = n.attributes[b].value;
      (d || c) && (d && (c && d.__html == c.__html || d.__html === n.innerHTML) || (n.innerHTML = d && d.__html || ""));
    }
    if (KZ(n, m, p, r, a), d)
      e.__k = [];
    else if (b = e.props.children, A5(n, Array.isArray(b) ? b : [b], e, t, i, r && v !== "foreignObject", s, o, s ? s[0] : t.__k && nv(t, 0), a), s != null)
      for (b = s.length; b--; )
        s[b] != null && T5(s[b]);
    a || ("value" in m && (b = m.value) !== void 0 && (b !== n.value || v === "progress" && !b || v === "option" && b !== p.value) && Lb(n, "value", b, p.value, !1), "checked" in m && (b = m.checked) !== void 0 && b !== n.checked && Lb(n, "checked", b, p.checked, !1));
  }
  return n;
}
function D5(n, e, t) {
  try {
    typeof n == "function" ? n(e) : n.current = e;
  } catch (i) {
    St.__e(i, t);
  }
}
function I5(n, e, t) {
  var i, r;
  if (St.unmount && St.unmount(n), (i = n.ref) && (i.current && i.current !== n.__e || D5(i, null, e)), (i = n.__c) != null) {
    if (i.componentWillUnmount)
      try {
        i.componentWillUnmount();
      } catch (s) {
        St.__e(s, e);
      }
    i.base = i.__P = null, n.__c = void 0;
  }
  if (i = n.__k)
    for (r = 0; r < i.length; r++)
      i[r] && I5(i[r], e, t || typeof n.type != "function");
  t || n.__e == null || T5(n.__e), n.__ = n.__e = n.__d = void 0;
}
function QZ(n, e, t) {
  return this.constructor(n, t);
}
function Db(n, e, t) {
  var i, r, s;
  St.__ && St.__(n, e), r = (i = typeof t == "function") ? null : t && t.__k || e.__k, s = [], BE(e, n = (!i && t || e).__k = Yu(Mf, null, [n]), r || Ab, Ab, e.ownerSVGElement !== void 0, !i && t ? [t] : r ? null : e.firstChild ? By.call(e.childNodes) : null, s, !i && t ? t : r ? r.__e : e.firstChild, i), L5(s, n);
}
function O5(n, e) {
  var t = { __c: e = "__cC" + E5++, __: n, Consumer: function(i, r) {
    return i.children(r);
  }, Provider: function(i) {
    var r, s;
    return this.getChildContext || (r = [], (s = {})[e] = this, this.getChildContext = function() {
      return s;
    }, this.shouldComponentUpdate = function(o) {
      this.props.value !== o.value && r.some(I2);
    }, this.sub = function(o) {
      r.push(o);
      var a = o.componentWillUnmount;
      o.componentWillUnmount = function() {
        r.splice(r.indexOf(o), 1), a && a.call(o);
      };
    }), i.children;
  } };
  return t.Provider.__ = t.Consumer.contextType = t;
}
By = C5.slice, St = { __e: function(n, e, t, i) {
  for (var r, s, o; e = e.__; )
    if ((r = e.__c) && !r.__)
      try {
        if ((s = r.constructor) && s.getDerivedStateFromError != null && (r.setState(s.getDerivedStateFromError(n)), o = r.__d), r.componentDidCatch != null && (r.componentDidCatch(n, i || {}), o = r.__d), o)
          return r.__E = r;
      } catch (a) {
        n = a;
      }
  throw n;
} }, M5 = 0, ha.prototype.setState = function(n, e) {
  var t;
  t = this.__s != null && this.__s !== this.state ? this.__s : this.__s = uc({}, this.state), typeof n == "function" && (n = n(uc({}, t), this.props)), n && uc(t, n), n != null && this.__v && (e && this._sb.push(e), I2(this));
}, ha.prototype.forceUpdate = function(n) {
  this.__v && (this.__e = !0, n && this.__h.push(n), I2(this));
}, ha.prototype.render = Mf, Im = [], Rb.__r = 0, E5 = 0;
var jf, mi, nS, VA, iv = 0, N5 = [], Z_ = [], HA = St.__b, GA = St.__r, WA = St.diffed, jA = St.__c, qA = St.unmount;
function Hv(n, e) {
  St.__h && St.__h(mi, n, iv || e), iv = 0;
  var t = mi.__H || (mi.__H = { __: [], __h: [] });
  return n >= t.__.length && t.__.push({ __V: Z_ }), t.__[n];
}
function ji(n) {
  return iv = 1, eY(z5, n);
}
function eY(n, e, t) {
  var i = Hv(jf++, 2);
  if (i.t = n, !i.__c && (i.__ = [t ? t(e) : z5(void 0, e), function(s) {
    var o = i.__N ? i.__N[0] : i.__[0], a = i.t(o, s);
    o !== a && (i.__N = [a, i.__[1]], i.__c.setState({}));
  }], i.__c = mi, !mi.u)) {
    mi.u = !0;
    var r = mi.shouldComponentUpdate;
    mi.shouldComponentUpdate = function(s, o, a) {
      if (!i.__c.__H)
        return !0;
      var l = i.__c.__H.__.filter(function(d) {
        return d.__c;
      });
      if (l.every(function(d) {
        return !d.__N;
      }))
        return !r || r.call(this, s, o, a);
      var c = !1;
      return l.forEach(function(d) {
        if (d.__N) {
          var p = d.__[0];
          d.__ = d.__N, d.__N = void 0, p !== d.__[0] && (c = !0);
        }
      }), !(!c && i.__c.props === s) && (!r || r.call(this, s, o, a));
    };
  }
  return i.__N || i.__;
}
function qi(n, e) {
  var t = Hv(jf++, 3);
  !St.__s && VE(t.__H, e) && (t.__ = n, t.i = e, mi.__H.__h.push(t));
}
function Sr(n, e) {
  var t = Hv(jf++, 4);
  !St.__s && VE(t.__H, e) && (t.__ = n, t.i = e, mi.__h.push(t));
}
function xa(n) {
  return iv = 5, Di(function() {
    return { current: n };
  }, []);
}
function Di(n, e) {
  var t = Hv(jf++, 7);
  return VE(t.__H, e) ? (t.__V = n(), t.i = e, t.__h = n, t.__V) : t.__;
}
function XA(n, e) {
  return iv = 8, Di(function() {
    return n;
  }, e);
}
function UE(n) {
  var e = mi.context[n.__c], t = Hv(jf++, 9);
  return t.c = n, e ? (t.__ == null && (t.__ = !0, e.sub(mi)), e.props.value) : n.__;
}
function tY() {
  for (var n; n = N5.shift(); )
    if (n.__P && n.__H)
      try {
        n.__H.__h.forEach(Y_), n.__H.__h.forEach(O2), n.__H.__h = [];
      } catch (e) {
        n.__H.__h = [], St.__e(e, n.__v);
      }
}
St.__b = function(n) {
  mi = null, HA && HA(n);
}, St.__r = function(n) {
  GA && GA(n), jf = 0;
  var e = (mi = n.__c).__H;
  e && (nS === mi ? (e.__h = [], mi.__h = [], e.__.forEach(function(t) {
    t.__N && (t.__ = t.__N), t.__V = Z_, t.__N = t.i = void 0;
  })) : (e.__h.forEach(Y_), e.__h.forEach(O2), e.__h = [])), nS = mi;
}, St.diffed = function(n) {
  WA && WA(n);
  var e = n.__c;
  e && e.__H && (e.__H.__h.length && (N5.push(e) !== 1 && VA === St.requestAnimationFrame || ((VA = St.requestAnimationFrame) || nY)(tY)), e.__H.__.forEach(function(t) {
    t.i && (t.__H = t.i), t.__V !== Z_ && (t.__ = t.__V), t.i = void 0, t.__V = Z_;
  })), nS = mi = null;
}, St.__c = function(n, e) {
  e.some(function(t) {
    try {
      t.__h.forEach(Y_), t.__h = t.__h.filter(function(i) {
        return !i.__ || O2(i);
      });
    } catch (i) {
      e.some(function(r) {
        r.__h && (r.__h = []);
      }), e = [], St.__e(i, t.__v);
    }
  }), jA && jA(n, e);
}, St.unmount = function(n) {
  qA && qA(n);
  var e, t = n.__c;
  t && t.__H && (t.__H.__.forEach(function(i) {
    try {
      Y_(i);
    } catch (r) {
      e = r;
    }
  }), t.__H = void 0, e && St.__e(e, t.__v));
};
var $A = typeof requestAnimationFrame == "function";
function nY(n) {
  var e, t = function() {
    clearTimeout(i), $A && cancelAnimationFrame(e), setTimeout(n);
  }, i = setTimeout(t, 100);
  $A && (e = requestAnimationFrame(t));
}
function Y_(n) {
  var e = mi, t = n.__c;
  typeof t == "function" && (n.__c = void 0, t()), mi = e;
}
function O2(n) {
  var e = mi;
  n.__c = n.__(), mi = e;
}
function VE(n, e) {
  return !n || n.length !== e.length || e.some(function(t, i) {
    return t !== n[i];
  });
}
function z5(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function Uy() {
  throw new Error("Cycle detected");
}
function HE() {
  if (Hd > 1)
    Hd--;
  else {
    for (var n, e = !1; Om !== void 0; ) {
      var t = Om;
      for (Om = void 0, N2++; t !== void 0; ) {
        var i = t.o;
        if (t.o = void 0, t.f &= -3, !(8 & t.f) && B5(t))
          try {
            t.c();
          } catch (r) {
            e || (n = r, e = !0);
          }
        t = i;
      }
    }
    if (N2 = 0, Hd--, e)
      throw n;
  }
}
var yi = void 0, Om = void 0, Hd = 0, N2 = 0, Ib = 0;
function F5(n) {
  if (yi !== void 0) {
    var e = n.n;
    if (e === void 0 || e.t !== yi)
      return e = { i: 0, S: n, p: yi.s, n: void 0, t: yi, e: void 0, x: void 0, r: e }, yi.s !== void 0 && (yi.s.n = e), yi.s = e, n.n = e, 32 & yi.f && n.S(e), e;
    if (e.i === -1)
      return e.i = 0, e.n !== void 0 && (e.n.p = e.p, e.p !== void 0 && (e.p.n = e.n), e.p = yi.s, e.n = void 0, yi.s.n = e, yi.s = e), e;
  }
}
function Qr(n) {
  this.v = n, this.i = 0, this.n = void 0, this.t = void 0;
}
Qr.prototype.h = function() {
  return !0;
};
Qr.prototype.S = function(n) {
  this.t !== n && n.e === void 0 && (n.x = this.t, this.t !== void 0 && (this.t.e = n), this.t = n);
};
Qr.prototype.U = function(n) {
  if (this.t !== void 0) {
    var e = n.e, t = n.x;
    e !== void 0 && (e.x = t, n.e = void 0), t !== void 0 && (t.e = e, n.x = void 0), n === this.t && (this.t = t);
  }
};
Qr.prototype.subscribe = function(n) {
  var e = this;
  return WE(function() {
    var t = e.value, i = 32 & this.f;
    this.f &= -33;
    try {
      n(t);
    } finally {
      this.f |= i;
    }
  });
};
Qr.prototype.valueOf = function() {
  return this.value;
};
Qr.prototype.toString = function() {
  return this.value + "";
};
Qr.prototype.peek = function() {
  return this.v;
};
Object.defineProperty(Qr.prototype, "value", { get: function() {
  var n = F5(this);
  return n !== void 0 && (n.i = this.i), this.v;
}, set: function(n) {
  if (n !== this.v) {
    N2 > 100 && Uy(), this.v = n, this.i++, Ib++, Hd++;
    try {
      for (var e = this.t; e !== void 0; e = e.x)
        e.t.N();
    } finally {
      HE();
    }
  }
} });
function hh(n) {
  return new Qr(n);
}
function B5(n) {
  for (var e = n.s; e !== void 0; e = e.n)
    if (e.S.i !== e.i || !e.S.h() || e.S.i !== e.i)
      return !0;
  return !1;
}
function U5(n) {
  for (var e = n.s; e !== void 0; e = e.n) {
    var t = e.S.n;
    if (t !== void 0 && (e.r = t), e.S.n = e, e.i = -1, e.n === void 0) {
      n.s = e;
      break;
    }
  }
}
function V5(n) {
  for (var e = n.s, t = void 0; e !== void 0; ) {
    var i = e.p;
    e.i === -1 ? (e.S.U(e), i !== void 0 && (i.n = e.n), e.n !== void 0 && (e.n.p = i)) : t = e, e.S.n = e.r, e.r !== void 0 && (e.r = void 0), e = i;
  }
  n.s = t;
}
function dh(n) {
  Qr.call(this, void 0), this.x = n, this.s = void 0, this.g = Ib - 1, this.f = 4;
}
(dh.prototype = new Qr()).h = function() {
  if (this.f &= -3, 1 & this.f)
    return !1;
  if ((36 & this.f) == 32 || (this.f &= -5, this.g === Ib))
    return !0;
  if (this.g = Ib, this.f |= 1, this.i > 0 && !B5(this))
    return this.f &= -2, !0;
  var n = yi;
  try {
    U5(this), yi = this;
    var e = this.x();
    (16 & this.f || this.v !== e || this.i === 0) && (this.v = e, this.f &= -17, this.i++);
  } catch (t) {
    this.v = t, this.f |= 16, this.i++;
  }
  return yi = n, V5(this), this.f &= -2, !0;
};
dh.prototype.S = function(n) {
  if (this.t === void 0) {
    this.f |= 36;
    for (var e = this.s; e !== void 0; e = e.n)
      e.S.S(e);
  }
  Qr.prototype.S.call(this, n);
};
dh.prototype.U = function(n) {
  if (this.t !== void 0 && (Qr.prototype.U.call(this, n), this.t === void 0)) {
    this.f &= -33;
    for (var e = this.s; e !== void 0; e = e.n)
      e.S.U(e);
  }
};
dh.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var n = this.t; n !== void 0; n = n.x)
      n.t.N();
  }
};
dh.prototype.peek = function() {
  if (this.h() || Uy(), 16 & this.f)
    throw this.v;
  return this.v;
};
Object.defineProperty(dh.prototype, "value", { get: function() {
  1 & this.f && Uy();
  var n = F5(this);
  if (this.h(), n !== void 0 && (n.i = this.i), 16 & this.f)
    throw this.v;
  return this.v;
} });
function iY(n) {
  return new dh(n);
}
function H5(n) {
  var e = n.u;
  if (n.u = void 0, typeof e == "function") {
    Hd++;
    var t = yi;
    yi = void 0;
    try {
      e();
    } catch (i) {
      throw n.f &= -2, n.f |= 8, GE(n), i;
    } finally {
      yi = t, HE();
    }
  }
}
function GE(n) {
  for (var e = n.s; e !== void 0; e = e.n)
    e.S.U(e);
  n.x = void 0, n.s = void 0, H5(n);
}
function rY(n) {
  if (yi !== this)
    throw new Error("Out-of-order effect");
  V5(this), yi = n, this.f &= -2, 8 & this.f && GE(this), HE();
}
function Gv(n) {
  this.x = n, this.u = void 0, this.s = void 0, this.o = void 0, this.f = 32;
}
Gv.prototype.c = function() {
  var n = this.S();
  try {
    !(8 & this.f) && this.x !== void 0 && (this.u = this.x());
  } finally {
    n();
  }
};
Gv.prototype.S = function() {
  1 & this.f && Uy(), this.f |= 1, this.f &= -9, H5(this), U5(this), Hd++;
  var n = yi;
  return yi = this, rY.bind(this, n);
};
Gv.prototype.N = function() {
  2 & this.f || (this.f |= 2, this.o = Om, Om = this);
};
Gv.prototype.d = function() {
  this.f |= 8, 1 & this.f || GE(this);
};
function WE(n) {
  var e = new Gv(n);
  try {
    e.c();
  } catch (t) {
    throw e.d(), t;
  }
  return e.d.bind(e);
}
var iS;
function qf(n, e) {
  St[n] = e.bind(null, St[n] || function() {
  });
}
function Ob(n) {
  iS && iS(), iS = n && n.S();
}
function G5(n) {
  var e = this, t = n.data, i = Vy(t);
  i.value = t;
  var r = Di(function() {
    for (var s = e.__v; s = s.__; )
      if (s.__c) {
        s.__c.__$f |= 4;
        break;
      }
    return e.__$u.c = function() {
      e.base.data = r.peek();
    }, iY(function() {
      var o = i.value.value;
      return o === 0 ? 0 : o === !0 ? "" : o || "";
    });
  }, []);
  return r.value;
}
G5.displayName = "_st";
Object.defineProperties(Qr.prototype, { constructor: { configurable: !0 }, type: { configurable: !0, value: G5 }, props: { configurable: !0, get: function() {
  return { data: this };
} }, __b: { configurable: !0, value: 1 } });
qf("__b", function(n, e) {
  if (typeof e.type == "string") {
    var t, i = e.props;
    for (var r in i)
      if (r !== "children") {
        var s = i[r];
        s instanceof Qr && (t || (e.__np = t = {}), t[r] = s, i[r] = s.peek());
      }
  }
  n(e);
});
qf("__r", function(n, e) {
  Ob();
  var t, i = e.__c;
  i && (i.__$f &= -2, (t = i.__$u) === void 0 && (i.__$u = t = function(r) {
    var s;
    return WE(function() {
      s = this;
    }), s.c = function() {
      i.__$f |= 1, i.setState({});
    }, s;
  }())), Ob(t), n(e);
});
qf("__e", function(n, e, t, i) {
  Ob(), n(e, t, i);
});
qf("diffed", function(n, e) {
  Ob();
  var t;
  if (typeof e.type == "string" && (t = e.__e)) {
    var i = e.__np, r = e.props;
    if (i) {
      var s = t.U;
      if (s)
        for (var o in s) {
          var a = s[o];
          a !== void 0 && !(o in i) && (a.d(), s[o] = void 0);
        }
      else
        t.U = s = {};
      for (var l in i) {
        var c = s[l], d = i[l];
        c === void 0 ? (c = sY(t, l, d, r), s[l] = c) : c.o(d, r);
      }
    }
  }
  n(e);
});
function sY(n, e, t, i) {
  var r = e in n && n.ownerSVGElement === void 0, s = hh(t);
  return { o: function(o, a) {
    s.value = o, i = a;
  }, d: WE(function() {
    var o = s.value.value;
    i[e] !== o && (i[e] = o, r ? n[e] = o : o ? n.setAttribute(e, o) : n.removeAttribute(e));
  }) };
}
qf("unmount", function(n, e) {
  if (typeof e.type == "string") {
    var t = e.__e;
    if (t) {
      var i = t.U;
      if (i) {
        t.U = void 0;
        for (var r in i) {
          var s = i[r];
          s && s.d();
        }
      }
    }
  } else {
    var o = e.__c;
    if (o) {
      var a = o.__$u;
      a && (o.__$u = void 0, a.d());
    }
  }
  n(e);
});
qf("__h", function(n, e, t, i) {
  i < 3 && (e.__$f |= 2), n(e, t, i);
});
ha.prototype.shouldComponentUpdate = function(n, e) {
  var t = this.__$u;
  if (!(t && t.s !== void 0 || 4 & this.__$f) || 3 & this.__$f)
    return !0;
  for (var i in e)
    return !0;
  for (var r in n)
    if (r !== "__source" && n[r] !== this.props[r])
      return !0;
  for (var s in this.props)
    if (!(s in n))
      return !0;
  return !1;
};
function Vy(n) {
  return Di(function() {
    return hh(n);
  }, []);
}
function oY(n, e) {
  for (var t in e)
    n[t] = e[t];
  return n;
}
function z2(n, e) {
  for (var t in n)
    if (t !== "__source" && !(t in e))
      return !0;
  for (var i in e)
    if (i !== "__source" && n[i] !== e[i])
      return !0;
  return !1;
}
function rS(n, e) {
  return n === e && (n !== 0 || 1 / n == 1 / e) || n != n && e != e;
}
function ZA(n) {
  this.props = n;
}
function fh(n, e) {
  function t(r) {
    var s = this.props.ref, o = s == r.ref;
    return !o && s && (s.call ? s(null) : s.current = null), e ? !e(this.props, r) || !o : z2(this.props, r);
  }
  function i(r) {
    return this.shouldComponentUpdate = t, Yu(n, r);
  }
  return i.displayName = "Memo(" + (n.displayName || n.name) + ")", i.prototype.isReactComponent = !0, i.__f = !0, i;
}
(ZA.prototype = new ha()).isPureReactComponent = !0, ZA.prototype.shouldComponentUpdate = function(n, e) {
  return z2(this.props, n) || z2(this.state, e);
};
var YA = St.__b;
St.__b = function(n) {
  n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), YA && YA(n);
};
var aY = St.__e;
St.__e = function(n, e, t, i) {
  if (n.then) {
    for (var r, s = e; s = s.__; )
      if ((r = s.__c) && r.__c)
        return e.__e == null && (e.__e = t.__e, e.__k = t.__k), r.__c(n, e);
  }
  aY(n, e, t, i);
};
var KA = St.unmount;
function W5(n, e, t) {
  return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function(i) {
    typeof i.__c == "function" && i.__c();
  }), n.__c.__H = null), (n = oY({}, n)).__c != null && (n.__c.__P === t && (n.__c.__P = e), n.__c = null), n.__k = n.__k && n.__k.map(function(i) {
    return W5(i, e, t);
  })), n;
}
function j5(n, e, t) {
  return n && (n.__v = null, n.__k = n.__k && n.__k.map(function(i) {
    return j5(i, e, t);
  }), n.__c && n.__c.__P === e && (n.__e && t.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = t)), n;
}
function sS() {
  this.__u = 0, this.t = null, this.__b = null;
}
function q5(n) {
  var e = n.__.__c;
  return e && e.__a && e.__a(n);
}
function g_() {
  this.u = null, this.o = null;
}
St.unmount = function(n) {
  var e = n.__c;
  e && e.__R && e.__R(), e && n.__h === !0 && (n.type = null), KA && KA(n);
}, (sS.prototype = new ha()).__c = function(n, e) {
  var t = e.__c, i = this;
  i.t == null && (i.t = []), i.t.push(t);
  var r = q5(i.__v), s = !1, o = function() {
    s || (s = !0, t.__R = null, r ? r(a) : a());
  };
  t.__R = o;
  var a = function() {
    if (!--i.__u) {
      if (i.state.__a) {
        var c = i.state.__a;
        i.__v.__k[0] = j5(c, c.__c.__P, c.__c.__O);
      }
      var d;
      for (i.setState({ __a: i.__b = null }); d = i.t.pop(); )
        d.forceUpdate();
    }
  }, l = e.__h === !0;
  i.__u++ || l || i.setState({ __a: i.__b = i.__v.__k[0] }), n.then(o, o);
}, sS.prototype.componentWillUnmount = function() {
  this.t = [];
}, sS.prototype.render = function(n, e) {
  if (this.__b) {
    if (this.__v.__k) {
      var t = document.createElement("div"), i = this.__v.__k[0].__c;
      this.__v.__k[0] = W5(this.__b, t, i.__O = i.__P);
    }
    this.__b = null;
  }
  var r = e.__a && Yu(Mf, null, n.fallback);
  return r && (r.__h = null), [Yu(Mf, null, e.__a ? null : n.children), r];
};
var JA = function(n, e, t) {
  if (++t[1] === t[0] && n.o.delete(e), n.props.revealOrder && (n.props.revealOrder[0] !== "t" || !n.o.size))
    for (t = n.u; t; ) {
      for (; t.length > 3; )
        t.pop()();
      if (t[1] < t[0])
        break;
      n.u = t = t[2];
    }
};
function lY(n) {
  return this.getChildContext = function() {
    return n.context;
  }, n.children;
}
function cY(n) {
  var e = this, t = n.i;
  e.componentWillUnmount = function() {
    Db(null, e.l), e.l = null, e.i = null;
  }, e.i && e.i !== t && e.componentWillUnmount(), n.__v ? (e.l || (e.i = t, e.l = { nodeType: 1, parentNode: t, childNodes: [], appendChild: function(i) {
    this.childNodes.push(i), e.i.appendChild(i);
  }, insertBefore: function(i, r) {
    this.childNodes.push(i), e.i.appendChild(i);
  }, removeChild: function(i) {
    this.childNodes.splice(this.childNodes.indexOf(i) >>> 1, 1), e.i.removeChild(i);
  } }), Db(Yu(lY, { context: e.context }, n.__v), e.l)) : e.l && e.componentWillUnmount();
}
function jE(n, e) {
  var t = Yu(cY, { __v: n, i: e });
  return t.containerInfo = e, t;
}
(g_.prototype = new ha()).__a = function(n) {
  var e = this, t = q5(e.__v), i = e.o.get(n);
  return i[0]++, function(r) {
    var s = function() {
      e.props.revealOrder ? (i.push(r), JA(e, n, i)) : r();
    };
    t ? t(s) : s();
  };
}, g_.prototype.render = function(n) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var e = kb(n.children);
  n.revealOrder && n.revealOrder[0] === "b" && e.reverse();
  for (var t = e.length; t--; )
    this.o.set(e[t], this.u = [1, 0, this.u]);
  return n.children;
}, g_.prototype.componentDidUpdate = g_.prototype.componentDidMount = function() {
  var n = this;
  this.o.forEach(function(e, t) {
    JA(n, t, e);
  });
};
var uY = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, hY = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, dY = typeof document < "u", fY = function(n) {
  return (typeof Symbol < "u" && typeof Symbol() == "symbol" ? /fil|che|rad/i : /fil|che|ra/i).test(n);
};
ha.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(n) {
  Object.defineProperty(ha.prototype, n, { configurable: !0, get: function() {
    return this["UNSAFE_" + n];
  }, set: function(e) {
    Object.defineProperty(this, n, { configurable: !0, writable: !0, value: e });
  } });
});
var QA = St.event;
function pY() {
}
function mY() {
  return this.cancelBubble;
}
function vY() {
  return this.defaultPrevented;
}
St.event = function(n) {
  return QA && (n = QA(n)), n.persist = pY, n.isPropagationStopped = mY, n.isDefaultPrevented = vY, n.nativeEvent = n;
};
var eR = { configurable: !0, get: function() {
  return this.class;
} }, tR = St.vnode;
St.vnode = function(n) {
  var e = n.type, t = n.props, i = t;
  if (typeof e == "string") {
    var r = e.indexOf("-") === -1;
    for (var s in i = {}, t) {
      var o = t[s];
      dY && s === "children" && e === "noscript" || s === "value" && "defaultValue" in t && o == null || (s === "defaultValue" && "value" in t && t.value == null ? s = "value" : s === "download" && o === !0 ? o = "" : /ondoubleclick/i.test(s) ? s = "ondblclick" : /^onchange(textarea|input)/i.test(s + e) && !fY(t.type) ? s = "oninput" : /^onfocus$/i.test(s) ? s = "onfocusin" : /^onblur$/i.test(s) ? s = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(s) ? s = s.toLowerCase() : r && hY.test(s) ? s = s.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : o === null && (o = void 0), /^oninput$/i.test(s) && (s = s.toLowerCase(), i[s] && (s = "oninputCapture")), i[s] = o);
    }
    e == "select" && i.multiple && Array.isArray(i.value) && (i.value = kb(t.children).forEach(function(a) {
      a.props.selected = i.value.indexOf(a.props.value) != -1;
    })), e == "select" && i.defaultValue != null && (i.value = kb(t.children).forEach(function(a) {
      a.props.selected = i.multiple ? i.defaultValue.indexOf(a.props.value) != -1 : i.defaultValue == a.props.value;
    })), n.props = i, t.class != t.className && (eR.enumerable = "className" in t, t.className != null && (i.class = t.className), Object.defineProperty(i, "className", eR));
  }
  n.$$typeof = uY, tR && tR(n);
};
var nR = St.__r;
St.__r = function(n) {
  nR && nR(n), n.__c;
};
function gY(n, e) {
  var t = e(), i = ji({ h: { __: t, v: e } }), r = i[0].h, s = i[1];
  return Sr(function() {
    r.__ = t, r.v = e, rS(r.__, e()) || s({ h: r });
  }, [n, t, e]), qi(function() {
    return rS(r.__, r.v()) || s({ h: r }), n(function() {
      rS(r.__, r.v()) || s({ h: r });
    });
  }, [n]), t;
}
const [Gd, Ef] = Be(
  void 0
);
ft(() => {
  const n = Nn(), e = Ef();
  !e && n ? Gd(n.uuid) : e && !n ? Gd(void 0) : e && n && e.split(" ")[0] !== n.uuid && Gd(n.uuid);
}, [Ef, Nn]);
var Hy = { exports: {} }, md = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var oS, iR;
function X5() {
  if (iR)
    return oS;
  iR = 1;
  var n = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;
  function i(s) {
    if (s == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(s);
  }
  function r() {
    try {
      if (!Object.assign)
        return !1;
      var s = new String("abc");
      if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
        return !1;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(o).map(function(d) {
        return o[d];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(d) {
        c[d] = d;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return oS = r() ? Object.assign : function(s, o) {
    for (var a, l = i(s), c, d = 1; d < arguments.length; d++) {
      a = Object(arguments[d]);
      for (var p in a)
        e.call(a, p) && (l[p] = a[p]);
      if (n) {
        c = n(a);
        for (var m = 0; m < c.length; m++)
          t.call(a, c[m]) && (l[c[m]] = a[c[m]]);
      }
    }
    return l;
  }, oS;
}
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rR;
function _Y() {
  if (rR)
    return md;
  rR = 1, X5();
  var n = Gt, e = 60103;
  if (md.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var t = Symbol.for;
    e = t("react.element"), md.Fragment = t("react.fragment");
  }
  var i = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, r = Object.prototype.hasOwnProperty, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, l, c) {
    var d, p = {}, m = null, v = null;
    c !== void 0 && (m = "" + c), l.key !== void 0 && (m = "" + l.key), l.ref !== void 0 && (v = l.ref);
    for (d in l)
      r.call(l, d) && !s.hasOwnProperty(d) && (p[d] = l[d]);
    if (a && a.defaultProps)
      for (d in l = a.defaultProps, l)
        p[d] === void 0 && (p[d] = l[d]);
    return { $$typeof: e, type: a, key: m, ref: v, props: p, _owner: i.current };
  }
  return md.jsx = o, md.jsxs = o, md;
}
var aS = {};
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sR;
function bY() {
  return sR || (sR = 1, function(n) {
    process.env.NODE_ENV !== "production" && function() {
      var e = Gt, t = X5(), i = 60103, r = 60106;
      n.Fragment = 60107;
      var s = 60108, o = 60114, a = 60109, l = 60110, c = 60112, d = 60113, p = 60120, m = 60115, v = 60116, b = 60121, x = 60122, y = 60117, S = 60129, C = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var M = Symbol.for;
        i = M("react.element"), r = M("react.portal"), n.Fragment = M("react.fragment"), s = M("react.strict_mode"), o = M("react.profiler"), a = M("react.provider"), l = M("react.context"), c = M("react.forward_ref"), d = M("react.suspense"), p = M("react.suspense_list"), m = M("react.memo"), v = M("react.lazy"), b = M("react.block"), x = M("react.server.block"), y = M("react.fundamental"), M("react.scope"), M("react.opaque.id"), S = M("react.debug_trace_mode"), M("react.offscreen"), C = M("react.legacy_hidden");
      }
      var T = typeof Symbol == "function" && Symbol.iterator, P = "@@iterator";
      function D(le) {
        if (le === null || typeof le != "object")
          return null;
        var We = T && le[T] || le[P];
        return typeof We == "function" ? We : null;
      }
      var I = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function k(le) {
        {
          for (var We = arguments.length, et = new Array(We > 1 ? We - 1 : 0), wt = 1; wt < We; wt++)
            et[wt - 1] = arguments[wt];
          O("error", le, et);
        }
      }
      function O(le, We, et) {
        {
          var wt = I.ReactDebugCurrentFrame, X = wt.getStackAddendum();
          X !== "" && (We += "%s", et = et.concat([X]));
          var ge = et.map(function(we) {
            return "" + we;
          });
          ge.unshift("Warning: " + We), Function.prototype.apply.call(console[le], console, ge);
        }
      }
      var B = !1;
      function Y(le) {
        return !!(typeof le == "string" || typeof le == "function" || le === n.Fragment || le === o || le === S || le === s || le === d || le === p || le === C || B || typeof le == "object" && le !== null && (le.$$typeof === v || le.$$typeof === m || le.$$typeof === a || le.$$typeof === l || le.$$typeof === c || le.$$typeof === y || le.$$typeof === b || le[0] === x));
      }
      function G(le, We, et) {
        var wt = We.displayName || We.name || "";
        return le.displayName || (wt !== "" ? et + "(" + wt + ")" : et);
      }
      function K(le) {
        return le.displayName || "Context";
      }
      function A(le) {
        if (le == null)
          return null;
        if (typeof le.tag == "number" && k("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof le == "function")
          return le.displayName || le.name || null;
        if (typeof le == "string")
          return le;
        switch (le) {
          case n.Fragment:
            return "Fragment";
          case r:
            return "Portal";
          case o:
            return "Profiler";
          case s:
            return "StrictMode";
          case d:
            return "Suspense";
          case p:
            return "SuspenseList";
        }
        if (typeof le == "object")
          switch (le.$$typeof) {
            case l:
              var We = le;
              return K(We) + ".Consumer";
            case a:
              var et = le;
              return K(et._context) + ".Provider";
            case c:
              return G(le, le.render, "ForwardRef");
            case m:
              return A(le.type);
            case b:
              return A(le._render);
            case v: {
              var wt = le, X = wt._payload, ge = wt._init;
              try {
                return A(ge(X));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var J = 0, xe, se, oe, Q, ce, te, ee;
      function Re() {
      }
      Re.__reactDisabledLog = !0;
      function ye() {
        {
          if (J === 0) {
            xe = console.log, se = console.info, oe = console.warn, Q = console.error, ce = console.group, te = console.groupCollapsed, ee = console.groupEnd;
            var le = {
              configurable: !0,
              enumerable: !0,
              value: Re,
              writable: !0
            };
            Object.defineProperties(console, {
              info: le,
              log: le,
              warn: le,
              error: le,
              group: le,
              groupCollapsed: le,
              groupEnd: le
            });
          }
          J++;
        }
      }
      function Se() {
        {
          if (J--, J === 0) {
            var le = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: t({}, le, {
                value: xe
              }),
              info: t({}, le, {
                value: se
              }),
              warn: t({}, le, {
                value: oe
              }),
              error: t({}, le, {
                value: Q
              }),
              group: t({}, le, {
                value: ce
              }),
              groupCollapsed: t({}, le, {
                value: te
              }),
              groupEnd: t({}, le, {
                value: ee
              })
            });
          }
          J < 0 && k("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Ee = I.ReactCurrentDispatcher, gt;
      function qe(le, We, et) {
        {
          if (gt === void 0)
            try {
              throw Error();
            } catch (X) {
              var wt = X.stack.trim().match(/\n( *(at )?)/);
              gt = wt && wt[1] || "";
            }
          return `
` + gt + le;
        }
      }
      var Ze = !1, je;
      {
        var st = typeof WeakMap == "function" ? WeakMap : Map;
        je = new st();
      }
      function Ie(le, We) {
        if (!le || Ze)
          return "";
        {
          var et = je.get(le);
          if (et !== void 0)
            return et;
        }
        var wt;
        Ze = !0;
        var X = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var ge;
        ge = Ee.current, Ee.current = null, ye();
        try {
          if (We) {
            var we = function() {
              throw Error();
            };
            if (Object.defineProperty(we.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(we, []);
              } catch (Ot) {
                wt = Ot;
              }
              Reflect.construct(le, [], we);
            } else {
              try {
                we.call();
              } catch (Ot) {
                wt = Ot;
              }
              le.call(we.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Ot) {
              wt = Ot;
            }
            le();
          }
        } catch (Ot) {
          if (Ot && wt && typeof Ot.stack == "string") {
            for (var de = Ot.stack.split(`
`), ke = wt.stack.split(`
`), it = de.length - 1, ct = ke.length - 1; it >= 1 && ct >= 0 && de[it] !== ke[ct]; )
              ct--;
            for (; it >= 1 && ct >= 0; it--, ct--)
              if (de[it] !== ke[ct]) {
                if (it !== 1 || ct !== 1)
                  do
                    if (it--, ct--, ct < 0 || de[it] !== ke[ct]) {
                      var Et = `
` + de[it].replace(" at new ", " at ");
                      return typeof le == "function" && je.set(le, Et), Et;
                    }
                  while (it >= 1 && ct >= 0);
                break;
              }
          }
        } finally {
          Ze = !1, Ee.current = ge, Se(), Error.prepareStackTrace = X;
        }
        var Ct = le ? le.displayName || le.name : "", Yt = Ct ? qe(Ct) : "";
        return typeof le == "function" && je.set(le, Yt), Yt;
      }
      function Le(le, We, et) {
        return Ie(le, !1);
      }
      function L(le) {
        var We = le.prototype;
        return !!(We && We.isReactComponent);
      }
      function fe(le, We, et) {
        if (le == null)
          return "";
        if (typeof le == "function")
          return Ie(le, L(le));
        if (typeof le == "string")
          return qe(le);
        switch (le) {
          case d:
            return qe("Suspense");
          case p:
            return qe("SuspenseList");
        }
        if (typeof le == "object")
          switch (le.$$typeof) {
            case c:
              return Le(le.render);
            case m:
              return fe(le.type, We, et);
            case b:
              return Le(le._render);
            case v: {
              var wt = le, X = wt._payload, ge = wt._init;
              try {
                return fe(ge(X), We, et);
              } catch {
              }
            }
          }
        return "";
      }
      var ae = {}, $ = I.ReactDebugCurrentFrame;
      function j(le) {
        if (le) {
          var We = le._owner, et = fe(le.type, le._source, We ? We.type : null);
          $.setExtraStackFrame(et);
        } else
          $.setExtraStackFrame(null);
      }
      function re(le, We, et, wt, X) {
        {
          var ge = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var we in le)
            if (ge(le, we)) {
              var de = void 0;
              try {
                if (typeof le[we] != "function") {
                  var ke = Error((wt || "React class") + ": " + et + " type `" + we + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof le[we] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw ke.name = "Invariant Violation", ke;
                }
                de = le[we](We, we, wt, et, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (it) {
                de = it;
              }
              de && !(de instanceof Error) && (j(X), k("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", wt || "React class", et, we, typeof de), j(null)), de instanceof Error && !(de.message in ae) && (ae[de.message] = !0, j(X), k("Failed %s type: %s", et, de.message), j(null));
            }
        }
      }
      var Te = I.ReactCurrentOwner, Ce = Object.prototype.hasOwnProperty, F = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, U, he, me;
      me = {};
      function Ae(le) {
        if (Ce.call(le, "ref")) {
          var We = Object.getOwnPropertyDescriptor(le, "ref").get;
          if (We && We.isReactWarning)
            return !1;
        }
        return le.ref !== void 0;
      }
      function Ve(le) {
        if (Ce.call(le, "key")) {
          var We = Object.getOwnPropertyDescriptor(le, "key").get;
          if (We && We.isReactWarning)
            return !1;
        }
        return le.key !== void 0;
      }
      function $e(le, We) {
        if (typeof le.ref == "string" && Te.current && We && Te.current.stateNode !== We) {
          var et = A(Te.current.type);
          me[et] || (k('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', A(Te.current.type), le.ref), me[et] = !0);
        }
      }
      function Me(le, We) {
        {
          var et = function() {
            U || (U = !0, k("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", We));
          };
          et.isReactWarning = !0, Object.defineProperty(le, "key", {
            get: et,
            configurable: !0
          });
        }
      }
      function lt(le, We) {
        {
          var et = function() {
            he || (he = !0, k("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", We));
          };
          et.isReactWarning = !0, Object.defineProperty(le, "ref", {
            get: et,
            configurable: !0
          });
        }
      }
      var Ye = function(le, We, et, wt, X, ge, we) {
        var de = {
          $$typeof: i,
          type: le,
          key: We,
          ref: et,
          props: we,
          _owner: ge
        };
        return de._store = {}, Object.defineProperty(de._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(de, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: wt
        }), Object.defineProperty(de, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: X
        }), Object.freeze && (Object.freeze(de.props), Object.freeze(de)), de;
      };
      function ht(le, We, et, wt, X) {
        {
          var ge, we = {}, de = null, ke = null;
          et !== void 0 && (de = "" + et), Ve(We) && (de = "" + We.key), Ae(We) && (ke = We.ref, $e(We, X));
          for (ge in We)
            Ce.call(We, ge) && !F.hasOwnProperty(ge) && (we[ge] = We[ge]);
          if (le && le.defaultProps) {
            var it = le.defaultProps;
            for (ge in it)
              we[ge] === void 0 && (we[ge] = it[ge]);
          }
          if (de || ke) {
            var ct = typeof le == "function" ? le.displayName || le.name || "Unknown" : le;
            de && Me(we, ct), ke && lt(we, ct);
          }
          return Ye(le, de, ke, X, wt, Te.current, we);
        }
      }
      var Xe = I.ReactCurrentOwner, Mt = I.ReactDebugCurrentFrame;
      function At(le) {
        if (le) {
          var We = le._owner, et = fe(le.type, le._source, We ? We.type : null);
          Mt.setExtraStackFrame(et);
        } else
          Mt.setExtraStackFrame(null);
      }
      var Bt;
      Bt = !1;
      function pe(le) {
        return typeof le == "object" && le !== null && le.$$typeof === i;
      }
      function ot() {
        {
          if (Xe.current) {
            var le = A(Xe.current.type);
            if (le)
              return `

Check the render method of \`` + le + "`.";
          }
          return "";
        }
      }
      function De(le) {
        {
          if (le !== void 0) {
            var We = le.fileName.replace(/^.*[\\\/]/, ""), et = le.lineNumber;
            return `

Check your code at ` + We + ":" + et + ".";
          }
          return "";
        }
      }
      var tt = {};
      function Qe(le) {
        {
          var We = ot();
          if (!We) {
            var et = typeof le == "string" ? le : le.displayName || le.name;
            et && (We = `

Check the top-level render call using <` + et + ">.");
          }
          return We;
        }
      }
      function Ft(le, We) {
        {
          if (!le._store || le._store.validated || le.key != null)
            return;
          le._store.validated = !0;
          var et = Qe(We);
          if (tt[et])
            return;
          tt[et] = !0;
          var wt = "";
          le && le._owner && le._owner !== Xe.current && (wt = " It was passed a child from " + A(le._owner.type) + "."), At(le), k('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', et, wt), At(null);
        }
      }
      function An(le, We) {
        {
          if (typeof le != "object")
            return;
          if (Array.isArray(le))
            for (var et = 0; et < le.length; et++) {
              var wt = le[et];
              pe(wt) && Ft(wt, We);
            }
          else if (pe(le))
            le._store && (le._store.validated = !0);
          else if (le) {
            var X = D(le);
            if (typeof X == "function" && X !== le.entries)
              for (var ge = X.call(le), we; !(we = ge.next()).done; )
                pe(we.value) && Ft(we.value, We);
          }
        }
      }
      function Hn(le) {
        {
          var We = le.type;
          if (We == null || typeof We == "string")
            return;
          var et;
          if (typeof We == "function")
            et = We.propTypes;
          else if (typeof We == "object" && (We.$$typeof === c || We.$$typeof === m))
            et = We.propTypes;
          else
            return;
          if (et) {
            var wt = A(We);
            re(et, le.props, "prop", wt, le);
          } else if (We.PropTypes !== void 0 && !Bt) {
            Bt = !0;
            var X = A(We);
            k("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", X || "Unknown");
          }
          typeof We.getDefaultProps == "function" && !We.getDefaultProps.isReactClassApproved && k("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function es(le) {
        {
          for (var We = Object.keys(le.props), et = 0; et < We.length; et++) {
            var wt = We[et];
            if (wt !== "children" && wt !== "key") {
              At(le), k("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", wt), At(null);
              break;
            }
          }
          le.ref !== null && (At(le), k("Invalid attribute `ref` supplied to `React.Fragment`."), At(null));
        }
      }
      function Sn(le, We, et, wt, X, ge) {
        {
          var we = Y(le);
          if (!we) {
            var de = "";
            (le === void 0 || typeof le == "object" && le !== null && Object.keys(le).length === 0) && (de += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var ke = De(X);
            ke ? de += ke : de += ot();
            var it;
            le === null ? it = "null" : Array.isArray(le) ? it = "array" : le !== void 0 && le.$$typeof === i ? (it = "<" + (A(le.type) || "Unknown") + " />", de = " Did you accidentally export a JSX literal instead of a component?") : it = typeof le, k("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", it, de);
          }
          var ct = ht(le, We, et, X, ge);
          if (ct == null)
            return ct;
          if (we) {
            var Et = We.children;
            if (Et !== void 0)
              if (wt)
                if (Array.isArray(Et)) {
                  for (var Ct = 0; Ct < Et.length; Ct++)
                    An(Et[Ct], le);
                  Object.freeze && Object.freeze(Et);
                } else
                  k("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                An(Et, le);
          }
          return le === n.Fragment ? es(ct) : Hn(ct), ct;
        }
      }
      function Yi(le, We, et) {
        return Sn(le, We, et, !0);
      }
      function Gn(le, We, et) {
        return Sn(le, We, et, !1);
      }
      var Ma = Gn, pr = Yi;
      n.jsx = Ma, n.jsxs = pr;
    }();
  }(aS)), aS;
}
(function(n) {
  process.env.NODE_ENV === "production" ? n.exports = _Y() : n.exports = bY();
})(Hy);
const Ic = Hy.exports.Fragment, H = Hy.exports.jsx, vt = Hy.exports.jsxs, Wd = (n) => {
  if (n) {
    setTimeout(() => F2.value = n);
    return;
  }
  F2.value = void 0;
}, F2 = hh(void 0);
Ef(() => Wd());
const yY = () => {
  const n = F2.value;
  return n ? /* @__PURE__ */ H("div", {
    style: {
      position: "absolute",
      pointerEvents: "none",
      width: ki,
      height: Os,
      background: "rgba(255, 255, 255, 0.1)",
      left: n.x,
      top: n.y
    }
  }) : null;
}, xY = fh(yY, () => !0), [wY, SY] = di(), [$5, Do] = Be(-1), Xf = (n) => {
  const e = Zn();
  !e || ($5(
    e.frame = typeof n == "function" ? n(e) : n
  ), Wd(), e.paused = !0, wY());
}, MY = () => Xf(Do() + 1), EY = () => Xf(Math.max(Do() - 1, 0)), CY = () => Xf(0), TY = () => Xf((n) => n.clipTotalFrames);
Zn((n) => Xf(n ? 0 : -1));
const [oR, pa] = Be(!0);
ft(() => {
  const n = Zn();
  if (!n)
    return;
  const e = Sf(n, "pausedState").get(
    oR
  );
  return () => {
    e.cancel(), oR(!0);
  };
}, [Zn]);
ft(() => {
  const n = Zn();
  if (!n || pa())
    return;
  dr(void 0);
  const e = Pn(() => {
    let { frame: t, totalFrames: i } = n;
    t >= i && (t = n.frame = i, n.paused = !0), $5(t);
  });
  return () => {
    e.cancel();
  };
}, [Zn, pa]);
const [aR, rv] = Be(un);
ft(() => {
  var n, e, t, i;
  if (!pa()) {
    aR(
      (e = (n = Dm().at(-1)) != null ? n : X_()) != null ? e : un
    );
    return;
  }
  aR(
    (i = (t = X_()) != null ? t : Dm().at(-1)) != null ? i : un
  );
}, [Dm, X_, pa]);
const [__, nt] = Be(un), B2 = (n) => {
  const [e, t] = Lo(), i = e / t;
  return n instanceof ni && !wf() ? (n.aspect = i, n.updateProjectionMatrix()) : n instanceof uE && ([n.left, n.right, n.top, n.bottom] = [
    i * p_ * -0.5,
    i * p_ * 0.5,
    p_ * 0.5,
    p_ * -0.5
  ], n.updateProjectionMatrix()), [e, t, i];
}, lR = (n, e, t) => n + (e - n) * t;
let cR;
ft(() => {
  if (Zu()) {
    __(un);
    return;
  }
  const n = nt() === xo ? xo : cR, e = cR = rv(), t = e.userData.transition;
  if (!n || !t || n === e || n === un || e === un) {
    __(e);
    return;
  }
  __(xo);
  const i = Dn(n), r = gl(n);
  xo.zoom = n.zoom, xo.fov = n.fov, B2(xo);
  let s = 0;
  const o = typeof t == "number" ? t : 1 / 0, a = Pn(() => {
    const l = Dn(e), c = gl(e);
    xo.position.lerpVectors(
      i,
      l,
      s
    ), xo.quaternion.slerpQuaternions(
      r,
      c,
      s
    ), xo.zoom = lR(n.zoom, e.zoom, s), xo.fov = lR(n.fov, e.fov, s), xo.updateProjectionMatrix(), s = Math.min((1 - s) * $u(0.1), o) + s, !(s < 0.9999) && (__(e), B2(e), a.cancel());
  });
  return () => {
    a.cancel();
  };
}, [Zu, rv]);
const [PY, uR] = Be(!1), [AY, Z5] = Be("#ffffff"), [RY, Y5] = Be("#000000"), [kY, K5] = Be(
  void 0
), [LY, J5] = Be(0), [DY, Q5] = Be(4), [hR, dR] = Be(
  void 0
);
let sv = /* @__PURE__ */ new Set();
const eI = (n) => {
  sv.add(n), sv.size === 1 && PY(!0);
}, tI = (n) => sv.delete(n);
ft(() => {
  if (!uR())
    return;
  const n = new UZ(bt, nt());
  hR(n);
  for (const o of sv)
    n.selection.add(o);
  sv = n.selection;
  const e = Z5((o) => n.visibleEdgeColor.set(o)), t = Y5(
    (o) => n.hiddenEdgeColor.set(o)
  ), i = K5(
    (o) => Bs(n, "patternTexture", o ? Wr(o) : null)
  ), r = J5((o) => n.pulseSpeed = o), s = Q5((o) => n.edgeStrength = o);
  return () => {
    hR(void 0), n.dispose(), e.cancel(), t.cancel(), i.cancel(), r.cancel(), s.cancel();
  };
}, [uR, nt]);
const [IY, qE] = Be(0.5), [OY, XE] = Be(0.8), [NY, $E] = Be(0), [zY, fR] = Be(!1);
let ov = /* @__PURE__ */ new Set();
const ZE = (n) => {
  ov.add(n), ov.size === 1 && zY(!0);
}, YE = (n) => ov.delete(n), [pR, mR] = Be(void 0);
ft(() => {
  if (!fR())
    return;
  const n = new VZ(bt, nt(), {
    blendFunction: $t.ADD,
    mipmapBlur: !0,
    luminanceSmoothing: 0.3
  });
  pR(n);
  for (const r of ov)
    n.selection.add(r);
  ov = n.selection;
  const e = qE((r) => n.intensity = r), t = $E(
    (r) => n.luminanceMaterial.threshold = r
  ), i = XE(
    (r) => Li(n, "mipmapBlurPass").radius = Math.min(
      r,
      0.9
    )
  );
  return () => {
    pR(void 0), n.dispose(), e.cancel(), t.cancel(), i.cancel();
  };
}, [fR, nt]);
class nI extends Ii {
  constructor() {
    super(...arguments);
    V(this, "_bloom");
    V(this, "_outline");
    V(this, "_visible");
    V(this, "_castShadow");
    V(this, "_firstInnerY");
    V(this, "_firstInnerZ");
    V(this, "_firstInnerX");
    V(this, "_receiveShadow");
  }
  get bloom() {
    return !!this._bloom;
  }
  set bloom(t) {
    this._bloom = t, t ? ZE(this.nativeObject3d) : YE(this.nativeObject3d);
  }
  get outline() {
    return !!this._outline;
  }
  set outline(t) {
    this._outline = t, t ? eI(this.nativeObject3d) : tI(this.nativeObject3d);
  }
  get visible() {
    return this._visible !== !1;
  }
  set visible(t) {
    this._visible = t, this.outerObject3d.visible = t;
  }
  get frustumCulled() {
    return this.outerObject3d.frustumCulled;
  }
  set frustumCulled(t) {
    this.outerObject3d.traverse((i) => i.frustumCulled = !0);
  }
  get castShadow() {
    var t;
    return (t = this._castShadow) != null ? t : !0;
  }
  get firstInnerY() {
    return this._firstInnerY;
  }
  set firstInnerY(t) {
    this._firstInnerY = t;
  }
  get firstInnerZ() {
    return this._firstInnerZ;
  }
  set firstInnerZ(t) {
    this._firstInnerZ = t;
  }
  get firstInnerX() {
    return this._firstInnerX;
  }
  set firstInnerX(t) {
    this._firstInnerX = t;
  }
  set castShadow(t) {
    this._castShadow = t, this.outerObject3d.traverse((i) => i.castShadow = t);
  }
  get receiveShadow() {
    var t;
    return (t = this._receiveShadow) != null ? t : !0;
  }
  set receiveShadow(t) {
    this._receiveShadow = t, this.outerObject3d.traverse((i) => i.receiveShadow = t);
  }
}
const FY = {
  ...h5,
  ...Vf,
  ...Nv,
  ...f5
}, BY = yt(
  [
    d5,
    Dv,
    Dy,
    p5
  ],
  {}
), Po = (n) => new yf(n.x * Ai, n.y * Ai, n.z * Ai), Gy = (n) => new Z(n.x * Ut, n.y * Ut, n.z * Ut), Wv = Wf((n) => "isBone" in n || (n.updateWorldMatrix(!0, !1), Ud.setFromObject(n), Ud.isEmpty()) ? Dn(n) : Ud.getCenter(new Z())), Nb = FE((n) => {
  const { userData: e } = n, t = Dn(n), i = e.positionOld ? !t.equals(e.positionOld) : !1;
  return e.positionOld = t, i;
}), UY = FE((n) => {
  const { userData: e } = n, t = gl(n), i = e.quaternionOld ? !t.equals(e.quaternionOld) : !1;
  return e.quaternionOld = t, i;
}), VY = iE(
  () => Pn(() => {
    for (const [n, e] of U2)
      if (Nb(n))
        for (const t of e)
          t();
  })
), U2 = /* @__PURE__ */ new Map(), HY = (n, e) => {
  VY();
  const t = Mr(U2, n, GY);
  return t.add(e), new Xn(() => {
    t.delete(e), !t.size && U2.delete(n);
  });
}, GY = () => /* @__PURE__ */ new Set();
class Wy extends Ii {
  constructor(t = new wn()) {
    super(t);
    V(this, "_onMove");
    bt.add(t);
  }
  get x() {
    return this.outerObject3d.position.x * Ai;
  }
  set x(t) {
    this.outerObject3d.position.x = t * Ut;
  }
  get y() {
    return this.outerObject3d.position.y * Ai;
  }
  set y(t) {
    this.outerObject3d.position.y = t * Ut;
  }
  get z() {
    return this.outerObject3d.position.z * Ai;
  }
  set z(t) {
    this.outerObject3d.position.z = t * Ut;
  }
  getWorldPosition() {
    return Po(Dn(this.nativeObject3d));
  }
  get onMove() {
    return this._onMove;
  }
  set onMove(t) {
    this._onMove = t, this.cancelHandle(
      "onMove",
      t && (() => HY(this.outerObject3d, t))
    );
  }
}
const Cc = (n) => n instanceof Ii && "x" in n, dn = {
  c: null,
  u: [new Z(), new Z(), new Z()],
  e: []
}, Cn = {
  c: null,
  u: [new Z(), new Z(), new Z()],
  e: []
}, li = [[], [], []], Ht = [[], [], []], Kn = [], du = new Z(), fu = new Z(), pu = new Z(), Bi = new Z(), vR = new Z(), gR = new Z(), wo = new ur(), _R = new so(), b_ = new Pt(), bR = new Pt(), yR = new Nf();
class KE {
  constructor(e = new Z(), t = new Z(), i = new ur()) {
    this.center = e, this.halfSize = t, this.rotation = i;
  }
  set(e, t, i) {
    return this.center = e, this.halfSize = t, this.rotation = i, this;
  }
  copy(e) {
    return this.center.copy(e.center), this.halfSize.copy(e.halfSize), this.rotation.copy(e.rotation), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  getSize(e) {
    return e.copy(this.halfSize).multiplyScalar(2);
  }
  clampPoint(e, t) {
    const i = this.halfSize;
    Bi.subVectors(e, this.center), this.rotation.extractBasis(du, fu, pu), t.copy(this.center);
    const r = Pm.clamp(Bi.dot(du), -i.x, i.x);
    t.add(du.multiplyScalar(r));
    const s = Pm.clamp(Bi.dot(fu), -i.y, i.y);
    t.add(fu.multiplyScalar(s));
    const o = Pm.clamp(Bi.dot(pu), -i.z, i.z);
    return t.add(pu.multiplyScalar(o)), t;
  }
  containsPoint(e) {
    return Bi.subVectors(e, this.center), this.rotation.extractBasis(du, fu, pu), Math.abs(Bi.dot(du)) <= this.halfSize.x && Math.abs(Bi.dot(fu)) <= this.halfSize.y && Math.abs(Bi.dot(pu)) <= this.halfSize.z;
  }
  intersectsBox3(e) {
    return this.intersectsOBB(WY.fromBox3(e));
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, gR), gR.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsOBB(e, t = Number.EPSILON) {
    dn.c = this.center, dn.e[0] = this.halfSize.x, dn.e[1] = this.halfSize.y, dn.e[2] = this.halfSize.z, this.rotation.extractBasis(dn.u[0], dn.u[1], dn.u[2]), Cn.c = e.center, Cn.e[0] = e.halfSize.x, Cn.e[1] = e.halfSize.y, Cn.e[2] = e.halfSize.z, e.rotation.extractBasis(Cn.u[0], Cn.u[1], Cn.u[2]);
    for (let s = 0; s < 3; s++)
      for (let o = 0; o < 3; o++)
        li[s][o] = dn.u[s].dot(Cn.u[o]);
    Bi.subVectors(Cn.c, dn.c), Kn[0] = Bi.dot(dn.u[0]), Kn[1] = Bi.dot(dn.u[1]), Kn[2] = Bi.dot(dn.u[2]);
    for (let s = 0; s < 3; s++)
      for (let o = 0; o < 3; o++)
        Ht[s][o] = Math.abs(li[s][o]) + t;
    let i, r;
    for (let s = 0; s < 3; s++)
      if (i = dn.e[s], r = Cn.e[0] * Ht[s][0] + Cn.e[1] * Ht[s][1] + Cn.e[2] * Ht[s][2], Math.abs(Kn[s]) > i + r)
        return !1;
    for (let s = 0; s < 3; s++)
      if (i = dn.e[0] * Ht[0][s] + dn.e[1] * Ht[1][s] + dn.e[2] * Ht[2][s], r = Cn.e[s], Math.abs(Kn[0] * li[0][s] + Kn[1] * li[1][s] + Kn[2] * li[2][s]) > i + r)
        return !1;
    return i = dn.e[1] * Ht[2][0] + dn.e[2] * Ht[1][0], r = Cn.e[1] * Ht[0][2] + Cn.e[2] * Ht[0][1], !(Math.abs(Kn[2] * li[1][0] - Kn[1] * li[2][0]) > i + r || (i = dn.e[1] * Ht[2][1] + dn.e[2] * Ht[1][1], r = Cn.e[0] * Ht[0][2] + Cn.e[2] * Ht[0][0], Math.abs(Kn[2] * li[1][1] - Kn[1] * li[2][1]) > i + r) || (i = dn.e[1] * Ht[2][2] + dn.e[2] * Ht[1][2], r = Cn.e[0] * Ht[0][1] + Cn.e[1] * Ht[0][0], Math.abs(Kn[2] * li[1][2] - Kn[1] * li[2][2]) > i + r) || (i = dn.e[0] * Ht[2][0] + dn.e[2] * Ht[0][0], r = Cn.e[1] * Ht[1][2] + Cn.e[2] * Ht[1][1], Math.abs(Kn[0] * li[2][0] - Kn[2] * li[0][0]) > i + r) || (i = dn.e[0] * Ht[2][1] + dn.e[2] * Ht[0][1], r = Cn.e[0] * Ht[1][2] + Cn.e[2] * Ht[1][0], Math.abs(Kn[0] * li[2][1] - Kn[2] * li[0][1]) > i + r) || (i = dn.e[0] * Ht[2][2] + dn.e[2] * Ht[0][2], r = Cn.e[0] * Ht[1][1] + Cn.e[1] * Ht[1][0], Math.abs(Kn[0] * li[2][2] - Kn[2] * li[0][2]) > i + r) || (i = dn.e[0] * Ht[1][0] + dn.e[1] * Ht[0][0], r = Cn.e[1] * Ht[2][2] + Cn.e[2] * Ht[2][1], Math.abs(Kn[1] * li[0][0] - Kn[0] * li[1][0]) > i + r) || (i = dn.e[0] * Ht[1][1] + dn.e[1] * Ht[0][1], r = Cn.e[0] * Ht[2][2] + Cn.e[2] * Ht[2][0], Math.abs(Kn[1] * li[0][1] - Kn[0] * li[1][1]) > i + r) || (i = dn.e[0] * Ht[1][2] + dn.e[1] * Ht[0][2], r = Cn.e[0] * Ht[2][1] + Cn.e[1] * Ht[2][0], Math.abs(Kn[1] * li[0][2] - Kn[0] * li[1][2]) > i + r));
  }
  intersectsPlane(e) {
    this.rotation.extractBasis(du, fu, pu);
    const t = this.halfSize.x * Math.abs(e.normal.dot(du)) + this.halfSize.y * Math.abs(e.normal.dot(fu)) + this.halfSize.z * Math.abs(e.normal.dot(pu)), i = e.normal.dot(this.center) - e.constant;
    return Math.abs(i) <= t;
  }
  intersectRay(e, t) {
    return this.getSize(vR), _R.setFromCenterAndSize(Bi.set(0, 0, 0), vR), b_.setFromMatrix3(this.rotation), b_.setPosition(this.center), bR.copy(b_).invert(), yR.copy(e).applyMatrix4(bR), yR.intersectBox(_R, t) ? t.applyMatrix4(b_) : null;
  }
  intersectsRay(e) {
    return this.intersectRay(e, Bi) !== null;
  }
  fromBox3(e) {
    return e.getCenter(this.center), e.getSize(this.halfSize).multiplyScalar(0.5), this.rotation.identity(), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.halfSize.equals(this.halfSize) && e.rotation.equals(this.rotation);
  }
  applyMatrix4(e) {
    const t = e.elements;
    let i = Bi.set(t[0], t[1], t[2]).length();
    const r = Bi.set(t[4], t[5], t[6]).length(), s = Bi.set(t[8], t[9], t[10]).length();
    e.determinant() < 0 && (i = -i), wo.setFromMatrix4(e);
    const a = 1 / i, l = 1 / r, c = 1 / s;
    return wo.elements[0] *= a, wo.elements[1] *= a, wo.elements[2] *= a, wo.elements[3] *= l, wo.elements[4] *= l, wo.elements[5] *= l, wo.elements[6] *= c, wo.elements[7] *= c, wo.elements[8] *= c, this.rotation.multiply(wo), this.halfSize.x *= i, this.halfSize.y *= r, this.halfSize.z *= s, Bi.setFromMatrixPosition(e), this.center.add(Bi), this;
  }
}
const WY = new KE(), [jY, V2] = Be(1), [qY, H2] = Be(!1), zb = {
  createButton(n, e) {
    e && console.error(
      'THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.'
    );
    const t = document.createElement("button");
    function i() {
      let l = null;
      async function c(p) {
        p.addEventListener("end", d), await n.xr.setSession(p), t.textContent = "EXIT VR", l = p;
      }
      function d() {
        l.removeEventListener("end", d), t.textContent = "ENTER VR", l = null;
      }
      t.style.display = "", t.style.cursor = "pointer", t.style.left = "calc(50% - 50px)", t.style.width = "100px", t.textContent = "ENTER VR", t.onmouseenter = function() {
        t.style.opacity = "1.0";
      }, t.onmouseleave = function() {
        t.style.opacity = "0.5";
      }, t.onclick = function() {
        if (l === null) {
          const p = {
            optionalFeatures: [
              "local-floor",
              "bounded-floor",
              "hand-tracking",
              "layers"
            ]
          };
          navigator.xr.requestSession("immersive-vr", p).then(c);
        } else
          l.end();
      };
    }
    function r() {
      t.style.display = "", t.style.cursor = "auto", t.style.left = "calc(50% - 75px)", t.style.width = "150px", t.onmouseenter = null, t.onmouseleave = null, t.onclick = null;
    }
    function s() {
      r(), t.textContent = "VR NOT SUPPORTED";
    }
    function o(l) {
      r(), console.warn(
        "Exception when trying to call xr.isSessionSupported",
        l
      ), t.textContent = "VR NOT ALLOWED";
    }
    function a(l) {
      l.style.position = "absolute", l.style.bottom = "20px", l.style.padding = "12px 6px", l.style.border = "1px solid #fff", l.style.borderRadius = "4px", l.style.background = "rgba(0,0,0,0.1)", l.style.color = "#fff", l.style.font = "normal 13px sans-serif", l.style.textAlign = "center", l.style.opacity = "0.5", l.style.outline = "none", l.style.zIndex = "999";
    }
    if ("xr" in navigator)
      return t.id = "VRButton", t.style.display = "none", a(t), navigator.xr.isSessionSupported("immersive-vr").then(function(l) {
        l ? i() : s(), l && zb.xrSessionIsGranted && t.click();
      }).catch(o), t;
    {
      const l = document.createElement("a");
      return window.isSecureContext === !1 ? (l.href = document.location.href.replace(
        /^http:/,
        "https:"
      ), l.innerHTML = "WEBXR NEEDS HTTPS") : (l.href = "https://immersiveweb.dev/", l.innerHTML = "WEBXR NOT AVAILABLE"), l.style.left = "calc(50% - 90px)", l.style.width = "180px", l.style.textDecoration = "none", a(l), l;
    }
  },
  xrSessionIsGranted: !1,
  registerSessionGrantedListener() {
    if ("xr" in navigator) {
      if (/WebXRViewer\//i.test(navigator.userAgent))
        return;
      navigator.xr.addEventListener("sessiongranted", () => {
        zb.xrSessionIsGranted = !0;
      });
    }
  }
};
zb.registerSessionGrantedListener();
const [XY, G2] = Be(!1), [$Y, W2] = Be(1), oo = (n) => {
  const e = document.createElement("div");
  return e.innerHTML = n, e.children[0];
}, [ZY, j2] = Be(!0), YY = oo(`
    <style>
        .shareverse-container {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 100%;
            height: 100%;
        }
        .shareverse-uicontainer {
            pointer-events: none;
        }
        .shareverse-uicontainer > * {
            pointer-events: auto;
        }
    </style>
`);
document.head.appendChild(YY);
const pn = oo('<div class="shareverse-container"></div>'), wa = oo(
  '<div class="shareverse-container shareverse-uicontainer"></div>'
);
pn.appendChild(wa);
Zu((n) => {
  pn.style.height = n ? "50%" : "100%", wa.style.top = n ? "100%" : "0px";
});
ft(() => {
  wa.style.display = j2() || !pa() ? "block" : "none";
}, [j2, pa]);
const iI = [pn.getBoundingClientRect()], lS = (n) => {
  fy(() => {
    const e = () => {
      iI[0] = pn.getBoundingClientRect(), XZ(n === document.body ? [window.innerWidth, window.innerHeight] : [n.clientWidth, n.clientHeight]);
    };
    e();
    const t = new ResizeObserver(No(e, 100));
    return t.observe(pn), () => {
      t.disconnect();
    };
  }, [n]);
};
ft(() => {
  const n = G2();
  if (!!n) {
    if (typeof n == "string") {
      const e = document.querySelector(n);
      return e ? (e.prepend(pn), lS(e), () => {
        pn.remove();
      }) : void 0;
    }
    return n === !0 ? (document.body.prepend(pn), lS(document.body), () => {
      pn.remove();
    }) : (n.prepend(pn), lS(n), () => {
      pn.remove();
    });
  }
}, [G2]);
ft(() => {
  const n = Ln();
  if (!n)
    return;
  const e = n.domElement;
  return pn.prepend(e), Object.assign(e.style, {
    position: "absolute",
    left: "0px",
    top: "0px"
  }), () => {
    e.remove();
  };
}, [Ln]);
ft(() => {
  const n = Ln();
  if (!n)
    return;
  const [e, t] = Lo();
  n.setSize(e, t), n.setPixelRatio(Math.min(W2(), devicePixelRatio));
}, [Ln, Lo, W2]);
ft(() => {
  const n = Ln();
  !n || (n.physicallyCorrectLights = H2());
}, [Ln, H2]);
ft(() => {
  !Ln() || V2();
}, [V2, Ln]);
ft(() => {
  if (!wf())
    return;
  const n = Ln();
  if (!n)
    return;
  n.xr.enabled = !0;
  const e = zb.createButton(n);
  return wa.appendChild(e), e.ontouchstart = () => {
    var t;
    return (t = e.onclick) == null ? void 0 : t.call(e, new MouseEvent("click"));
  }, () => {
    n.xr.enabled = !1, e.remove();
  };
}, [wf, Ln]);
const xR = Wf((n) => {
  const e = Wv(n);
  return e.project(nt()), new ze(
    (e.x * 0.5 + 0.5) * pn.clientWidth,
    (e.y * -0.5 + 0.5) * pn.clientHeight
  );
}), KY = (n, e) => n.clone().multiply(e.clone().invert()), rI = Wf(
  (n) => n.getWorldDirection(new Z())
), sI = /* @__PURE__ */ new Set(), oI = /* @__PURE__ */ new Set(), aI = /* @__PURE__ */ new Set(), lI = /* @__PURE__ */ new Set(), cI = /* @__PURE__ */ new Set(), uI = /* @__PURE__ */ new Set();
class q2 {
  constructor(e, t, i, r, s, o, a) {
    this.clientX = e, this.clientY = t, this.xNorm = i, this.yNorm = r, this.point = s, this.distance = o, this.target = a;
  }
}
const JY = {
  ..._s,
  onClick: Function,
  onRightClick: Function,
  onMouseMove: Function,
  onMouseDown: Function,
  onMouseUp: Function,
  onMousePress: Function
}, QY = yt([bs], {
  onClick: void 0,
  onRightClick: void 0,
  onMouseMove: void 0,
  onMouseDown: void 0,
  onMouseUp: void 0,
  onMousePress: void 0
}), [Ghe, eK] = Be(void 0), JE = (n, e) => {
  const t = iI[0];
  return n -= t.x, e -= t.y, [
    n / t.width * 2 - 1,
    -(e / t.height) * 2 + 1,
    n,
    e
  ];
}, tK = (n) => {
  const [t, i, r, s] = JE(
    n.clientX,
    n.clientY
  );
  if (eK())
    return new q2(
      r,
      s,
      0,
      0,
      new yf(0, 0, 0),
      500,
      void 0
    );
  const o = nt();
  Jn.set(t, i, 0.5), Jn.unproject(o);
  const a = Dn(o);
  Jn.sub(a).normalize();
  const l = a.add(Jn.multiplyScalar(500 * Ut));
  return new q2(
    r,
    s,
    t,
    i,
    Po(l),
    500,
    void 0
  );
}, [wR, Fs] = Be(!1), [Co, X2] = Be("play");
ft(() => {
  Co(
    nt() === un && Fs() ? "translate" : "play"
  );
}, [nt, Fs]);
const [y_, ro] = Be(
  X2()
);
ft(() => {
  const n = Nn(), e = X2();
  if (!n || e !== "rotate" && e !== "scale" && e !== "translate") {
    y_(e);
    return;
  }
  if (!Cc(n)) {
    y_("select");
    return;
  }
  if (!(n instanceof $f)) {
    y_("translate");
    return;
  }
  y_(e);
}, [X2, Nn]);
const [nK, ma] = Be(
  ro() === "play"
);
ro((n) => nK(n === "play"));
const xr = new ME();
let $2 = 0, Z2 = 0, Y2 = 0, K2 = !1;
pn.addEventListener("contextmenu", (n) => {
  n.preventDefault(), K2 = !0;
});
pn.addEventListener("touchstart", (n) => {
  n.preventDefault();
});
xr.on("down", (n) => {
  $2 = Date.now(), Z2 = n.clientX, Y2 = n.clientY;
});
xr.on("up", (n) => {
  const e = Date.now(), t = e - $2, i = Math.abs(n.clientX - Z2), r = Math.abs(n.clientY - Y2);
  $2 = e, Z2 = n.clientX, Y2 = n.clientY, t < 300 && i < 5 && r < 5 && xr.emit(K2 ? "rightClick" : "click", n), K2 = !1;
});
const QE = PL(tK, 0, "leading");
pn.addEventListener("pointermove", (n) => {
  xr.emit("move", QE(n));
});
let J2 = !1;
pn.addEventListener("pointerdown", (n) => {
  J2 = !0;
  const e = QE(n);
  xr.emit("down", e), xr.emit("move", e);
});
const eC = (n) => {
  J2 && xr.emit("up", QE(n)), J2 = !1;
};
pn.addEventListener("pointerup", eC);
pn.addEventListener("pointercancel", eC);
pn.addEventListener("pointerleave", eC);
class Lu extends Ii {
  constructor() {
    super();
    V(this, "onClick");
    V(this, "onRightClick");
    V(this, "onMouseMove");
    V(this, "onMouseDown");
    V(this, "onMouseUp");
    V(this, "onMousePress");
    let t = { clientX: 0, clientY: 0 };
    const [i, r] = Be(!1);
    this.createEffect(() => {
      const s = this.onMousePress;
      if (!r() || !s)
        return;
      const o = Pn(() => s(t));
      return () => {
        o.cancel();
      };
    }, [r]), this.createEffect(() => {
      if (!ma() || Fs() && nt() === un)
        return;
      const s = xr.on("move", (d) => {
        var p;
        (p = this.onMouseMove) == null || p.call(this, d), t = d;
      }), o = xr.on("click", (d) => {
        var p;
        (p = this.onClick) == null || p.call(this, d), t = d;
      }), a = xr.on("rightClick", (d) => {
        var p;
        (p = this.onRightClick) == null || p.call(this, d), t = d;
      }), l = xr.on("down", (d) => {
        var p;
        (p = this.onMouseDown) == null || p.call(this, d), t = d, i(!0);
      }), c = xr.on("up", (d) => {
        var p;
        (p = this.onMouseUp) == null || p.call(this, d), t = d, i(!1);
      });
      return () => {
        s.cancel(), o.cancel(), a.cancel(), l.cancel(), c.cancel();
      };
    }, [ma, Fs, nt]);
  }
}
V(Lu, "componentName", "mouse"), V(Lu, "defaults", QY), V(Lu, "schema", JY);
const hI = new Lu();
Zr.delete(hI);
const Q2 = new FD();
Q2.firstHitOnly = !0;
const iK = (n) => !n.object.userData.unselectable, dI = (n, e, t) => (Q2.setFromCamera({ x: n, y: e }, nt()), Q2.intersectObjects([...t]).filter(iK)[0]), yu = (n, e, t) => xr.on(n, (i) => {
  if (!e.size)
    return;
  const r = dI(i.xNorm, i.yNorm, e);
  if (!r)
    return;
  const s = Po(r.point), o = r.distance * Ai, a = Ov(r.object);
  t(
    a,
    new q2(
      i.clientX,
      i.clientY,
      i.xNorm,
      i.yNorm,
      s,
      o,
      a
    )
  );
});
ft(() => {
  if (!ma())
    return;
  EE(), Lv(void 0);
  const n = yu("click", sI, (c, d) => {
    var p;
    return (p = c.onClick) == null ? void 0 : p.call(c, d);
  }), e = yu(
    "down",
    oI,
    (c, d) => {
      var p;
      return (p = c.onMouseDown) == null ? void 0 : p.call(c, d);
    }
  ), t = yu("up", aI, (c, d) => {
    var p;
    return (p = c.onMouseUp) == null ? void 0 : p.call(c, d);
  });
  let i = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
  const s = yu("move", lI, (c, d) => {
    i.add(c), c.outerObject3d.userData.eMove = d;
  }), o = yu("move", cI, (c, d) => {
    i.add(c), c.outerObject3d.userData.eMove = d;
  }), a = yu("move", uI, (c, d) => {
    i.add(c), c.outerObject3d.userData.eMove = d;
  }), l = xr.on("move", () => {
    var c, d, p;
    for (const m of i)
      r.has(m) || (c = m.onMouseOver) == null || c.call(m, m.outerObject3d.userData.eMove), (d = m.onMouseMove) == null || d.call(m, m.outerObject3d.userData.eMove);
    for (const m of r)
      i.has(m) || (p = m.onMouseOut) == null || p.call(m, m.outerObject3d.userData.eMove);
    r = i, i = /* @__PURE__ */ new Set();
  });
  return () => {
    n.cancel(), e.cancel(), t.cancel(), s.cancel(), o.cancel(), a.cancel(), l.cancel();
  };
}, [ma]);
const [cS, eM] = Be(!1), [Whe, Io] = Be(!1), [jy, Tc] = Be([
  /* @__PURE__ */ new Set()
]), rK = (n) => {
  const [e] = Tc();
  e.add(n), jy([e]);
}, sK = (n) => {
  const [e] = Tc();
  e.delete(n), jy([e]);
}, oK = () => {
  const [n] = Tc();
  n.clear(), jy([n]);
};
ft(() => {
  const [n] = Tc();
  if (!n.size)
    return;
  const e = Ay((t) => {
    !n.has(t) || (n.delete(t), jy([n]));
  });
  return () => {
    e.cancel();
  };
}, [Tc]);
const fI = (n, e, t) => n[e].call(n, t), mc = /* @__PURE__ */ new Set(), pI = /* @__PURE__ */ new WeakSet(), av = /* @__PURE__ */ new Set(), Du = /* @__PURE__ */ new Set(), ph = (n, e) => {
  e.outerObject3d.add(n.outerObject3d), av.add(n.nativeObject3d);
  const t = zy(({ target: i }) => i === n && dr(e));
  return new Xn(() => {
    n.dispose(), av.delete(n.nativeObject3d), t.cancel();
  });
}, mI = (n, e) => {
  for (const t of n)
    e.has(t) || ("addToRaycastSet" in t && !pI.has(t) && fI(t, "addToRaycastSet", mc), t.children && mI(t.children, e));
}, tM = No(
  (n = Zr) => {
    if (mc.clear(), Du.size) {
      for (const t of Du)
        mc.add(t);
      return;
    }
    const [e] = Tc();
    mI(n, e);
    for (const t of av)
      mc.add(t);
  }
);
Tc(() => {
  tM(), dr(void 0);
});
ft(() => {
  const n = eM(), e = qm(!0);
  if (fy(() => {
    !n && (e.current = !0);
  }, [n]), ma() || Io())
    return;
  tM();
  const t = PE(() => tM()), i = xr.on(
    "click",
    () => dr(void 0)
  );
  let r = !1;
  const s = xr.on("rightClick", () => {
    r = !0, queueMicrotask(() => {
      !r || (r = !1, dr(void 0, !0));
    });
  }), o = yu(
    ["click", "rightClick"],
    mc,
    (l) => {
      dr(l, r), r = !1;
    }
  ), a = zy(({ target: l, rightClick: c, noDeselect: d }) => {
    if (n) {
      if (!Cc(l) || c)
        return;
      if (e.current) {
        const p = Nn();
        Cc(p) && !ko.has(p) && yA(p);
      }
      e.current = !1, hr().includes(l) ? vX(l) : ko.has(l) || yA(l);
      return;
    }
    EE(), Lv(
      c || d ? l : l === Nn() ? void 0 : l
    );
  });
  return () => {
    t.cancel(), i.cancel(), s.cancel(), o.cancel(), a.cancel();
  };
}, [ma, Io, eM]);
const [aK, SR] = Be(
  ro() === "curve"
);
ro((n) => aK(n === "curve"));
ft(() => {
  if (!SR())
    return;
  EE(), Lv(void 0);
  const n = new Xn();
  Promise.resolve().then(() => Sne).then(({ default: t }) => {
    if (n.done)
      return;
    const i = new t();
    i.helper = !0, Du.add(i.outerObject3d), n.then(() => {
      i.helper = !1, Du.delete(i.outerObject3d), i.points.length < 2 && i.dispose();
    }), n.watch(
      xr.on("click", (r) => {
        const s = Nn();
        setTimeout(() => {
          n.done || Nn() || s || i.addPoint(r.point);
        });
      })
    );
  });
  const e = zy(({ target: t }) => {
    !t || Du.has(t.outerObject3d) || hr().length || Co("translate");
  });
  return () => {
    n.cancel(), e.cancel();
  };
}, [SR]);
const [lK, cK] = di(), [vI, gI] = di(), uS = new KE(), am = new KE(), uK = PL(() => {
  const n = nt();
  v5.setFromProjectionMatrix(o$.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse));
}, 200, "leading"), jd = /* @__PURE__ */ new Map(), hK = () => /* @__PURE__ */ new Set(), nM = (n) => Mr(jd, n, hK), _I = (n) => {
  const e = [];
  if (Array.isArray(n))
    for (const t of n)
      e.push(nM(t));
  else
    typeof n == "string" ? e.push(nM(n)) : e.push(/* @__PURE__ */ new Set([n]));
  return e;
};
class bI extends Ii {
  constructor() {
    super(...arguments);
    V(this, "_id");
    V(this, "_onClick");
    V(this, "_onMouseDown");
    V(this, "_onMouseUp");
    V(this, "_onMouseOver");
    V(this, "_onMouseOut");
    V(this, "_onMouseMove");
    V(this, "onLookToEnd");
  }
  dispose() {
    return this.done ? this : (super.dispose(), this._id !== void 0 && jd.get(this._id).delete(this), this);
  }
  get id() {
    return this._id;
  }
  set id(t) {
    this._id !== void 0 && jd.get(this._id).delete(this), this._id = t, t !== void 0 && (nM(t).add(this), lK(t));
  }
  addToRaycastSet(t) {
    return t.add(this.nativeObject3d), new Xn(() => t.delete(this.nativeObject3d));
  }
  get onClick() {
    return this._onClick;
  }
  set onClick(t) {
    this._onClick = t, this.cancelHandle("onClick", t && (() => this.addToRaycastSet(sI)));
  }
  get onMouseDown() {
    return this._onMouseDown;
  }
  set onMouseDown(t) {
    this._onMouseDown = t, this.cancelHandle("onMouseDown", t && (() => this.addToRaycastSet(oI)));
  }
  get onMouseUp() {
    return this._onMouseUp;
  }
  set onMouseUp(t) {
    this._onMouseUp = t, this.cancelHandle("onMouseUp", t && (() => this.addToRaycastSet(aI)));
  }
  get onMouseOver() {
    return this._onMouseOver;
  }
  set onMouseOver(t) {
    this._onMouseOver = t, this.cancelHandle("onMouseOver", t && (() => this.addToRaycastSet(lI)));
  }
  get onMouseOut() {
    return this._onMouseOut;
  }
  set onMouseOut(t) {
    this._onMouseOut = t, this.cancelHandle("onMouseOut", t && (() => this.addToRaycastSet(cI)));
  }
  get onMouseMove() {
    return this._onMouseMove;
  }
  set onMouseMove(t) {
    this._onMouseMove = t, this.cancelHandle("onMouseMove", t && (() => this.addToRaycastSet(uI)));
  }
  get name() {
    return this.outerObject3d.name;
  }
  set name(t) {
    this.outerObject3d.name = vn.sanitizeNodeName(t), vI(this);
  }
  getRay() {
    return m5.set(Dn(this.nativeObject3d), rI(this.nativeObject3d));
  }
  pointAt(t) {
    return Po(this.getRay().at(t * Ut, Jn));
  }
  rayIntersectsAt(t, i) {
    if (this.done || t.done || this === t)
      return;
    am.set(Dn(t.nativeObject3d), s$, new ur().setFromMatrix4(t.nativeObject3d.matrixWorld));
    const r = am.intersectRay(this.getRay(), Jn);
    if (!!r) {
      if (i) {
        const {
          x: s,
          y: o,
          z: a
        } = Dn(this.nativeObject3d);
        if (jD(r.x, r.y, r.z, s, o, a) * Ai > i)
          return;
      }
      return Po(r);
    }
  }
  rayIntersects(t) {
    return !!this.rayIntersectsAt(t);
  }
  intersects(t) {
    return this.done || t.done || this === t ? !1 : (uS.set(Dn(this.nativeObject3d), kA.clone(), new ur()), uS.applyMatrix4(this.nativeObject3d.matrixWorld), am.set(Dn(t.nativeObject3d), kA.clone(), new ur()), am.applyMatrix4(t.nativeObject3d.matrixWorld), uS.intersectsOBB(am, 0));
  }
  get clientX() {
    return xR(this.nativeObject3d).x;
  }
  get clientY() {
    return xR(this.nativeObject3d).y;
  }
  get frustumVisible() {
    return uK(), v5.containsPoint(Wv(this.nativeObject3d));
  }
  lookAt(t, i, r) {
    if (typeof t == "number") {
      this.lookAt(new yf(t, i === void 0 ? this.outerObject3d.position.y * Ai : i, r));
      return;
    }
    "outerObject3d" in t ? this.outerObject3d.lookAt(Dn(t.nativeObject3d)) : this.outerObject3d.lookAt(Gy(t));
  }
  lookTo(t, i, r, s, o) {
    if (typeof t == "number") {
      this.lookTo(new yf(t, i === void 0 ? this.outerObject3d.position.y * Ai : i, r), s, void 0, o);
      return;
    }
    const {
      quaternion: a
    } = this.outerObject3d, l = a.clone();
    this.lookAt(t);
    const c = a.clone();
    a.copy(l), this.cancelHandle("lookTo", () => Pn(() => {
      var v;
      a.slerp(c, $u(i));
      const {
        x: d,
        y: p,
        z: m
      } = KY(a, c);
      Math.abs(d) + Math.abs(p) + Math.abs(m) < 1e-3 && (this.cancelHandle("lookTo", void 0), (v = this.onLookToEnd) == null || v.call(this), console.log(c, "quaternionNew1"), a.copy(c));
    }));
  }
  getWorldPosition() {
    return Po(Dn(this.nativeObject3d));
  }
}
const [dK, ml] = Be(!1), yI = {
  ..._s,
  paused: Boolean,
  data: Object,
  name: String
}, xI = yt(
  [bs],
  { paused: !0, data: void 0, name: "" }
), fK = {
  ..._s,
  name: String,
  src: String
}, pK = yt(
  [bs],
  { name: "", src: void 0 }
);
class vc extends Ii {
  constructor() {
    super();
    V(this, "audio", new Audio());
    V(this, "srcState", new Je(void 0));
    V(this, "durationState", new Je(0));
    this.audio.ondurationchange = () => this.durationState.set(this.audio.duration);
  }
  get name() {
    return this.outerObject3d.name;
  }
  set name(t) {
    this.outerObject3d.name = t, vI(this);
  }
  get src() {
    return this.srcState.get();
  }
  set src(t) {
    this.srcState.set(t), this.audio.src = t != null ? t : "", this.durationState.set(0);
  }
  get duration() {
    return this.durationState.get();
  }
}
V(vc, "componentName", "timelineAudio"), V(vc, "defaults", pK), V(vc, "schema", fK);
const mK = /* @__PURE__ */ new WeakMap(), MR = /* @__PURE__ */ new WeakMap(), ER = /* @__PURE__ */ new WeakMap(), vK = (n) => typeof n[0] == "boolean", gK = (n) => typeof n[0] == "number", _K = (n, e, t) => {
  const i = Object.keys(t);
  if (!i.length)
    return;
  const r = Object.values(t), s = n + "." + e, o = i.map((a) => Number(a) * tv);
  if (vK(r))
    return new lh(s, o, r);
  if (gK(r))
    return new Qm(s, o, r);
}, p3 = class extends Ii {
  constructor(t, i, r, s, o, a, l) {
    super();
    V(this, "actionState", new Je(void 0));
    V(this, "clipState", new Je(void 0));
    V(this, "dataState", new Je([void 0]));
    V(this, "gotoFrameState", new Je(void 0));
    V(this, "awaitState", new Je(0));
    V(this, "pausedState", new Je(!0));
    V(this, "mixer");
    V(this, "clip");
    V(this, "clipTotalFrames", 0);
    V(this, "audioTotalFrames", 0);
    this.name = t, !l && AE.add(this);
    const c = this.mixer = NV(mK, r != null ? r : this, zD, [r]);
    this.clip = i, this.createEffect(() => {
      if (this.pausedState.get())
        return;
      const p = a == null ? void 0 : a.get();
      if (p) {
        const [v] = p, b = () => v();
        return c.addEventListener("finished", b), () => {
          c.removeEventListener("finished", b);
        };
      }
      const m = o.get();
      if (!!m)
        return c.addEventListener("finished", m), () => {
          c.removeEventListener("finished", m);
        };
    }, [o.get, this.pausedState.get, a == null ? void 0 : a.get]), this.createEffect(() => {
      const [p] = this.dataState.get();
      if (!p) {
        this.clipState.set(i), this.audioTotalFrames = 0;
        return;
      }
      const m = [], v = new M2(
        void 0,
        void 0,
        Object.entries(p).map(([y, S]) => {
          const C = no.get(y);
          return C ? C instanceof vc ? (m.push(Sf(C, "durationState").get), []) : Object.entries(S).map(([M, T]) => _K(y, M, T)).filter(BV) : [];
        }).flat()
      );
      this.clipState.set(v);
      const b = new Xn(), x = No(() => {
        if (b.done)
          return;
        const y = Math.max(...m.map((S) => S()));
        this.audioTotalFrames = Math.ceil(y * pc);
      });
      for (const y of m)
        b.watch(y(x));
      return () => {
        b.cancel();
      };
    }, [this.dataState.get]);
    let d;
    this.createEffect(() => {
      const p = this.clipState.get();
      if (!p) {
        this.clipTotalFrames = 0;
        return;
      }
      this.clipTotalFrames = Math.ceil(p.duration * pc);
      const m = c.clipAction(p);
      return this.actionState.set(m), d !== void 0 && (this.frame = d, d = void 0), () => {
        d = this.frame, m.stop(), m.enabled = !1, c.uncacheClip(p);
      };
    }, [this.clipState.get]), this.createEffect(() => {
      const p = this.actionState.get();
      p && (p.repetitions = a != null && a.get() ? 0 : s.get());
    }, [this.actionState.get, s.get, a == null ? void 0 : a.get]), this.createEffect(() => {
      const p = this.actionState.get();
      if (!p)
        return;
      const m = this.gotoFrameState.get();
      if (p.paused = (this.pausedState.get() || !!this.awaitState.get()) && m === void 0, p.paused)
        return;
      const v = ER.get(c);
      ER.set(c, this), v && v !== this && v.pausedState.set(!0);
      const b = MR.get(c);
      if (MR.set(c, p), (b == null ? void 0 : b.enabled) && p !== b && b.stop(), p.clampWhenFinished = !0, p.enabled = !0, p.play(), m !== void 0) {
        c.setTime(m * tv), this.gotoFrameState.set(void 0);
        return;
      }
      const x = Pn(() => c.update(Iv[0]));
      return () => {
        x.cancel();
      };
    }, [this.actionState.get, this.pausedState.get, this.awaitState.get, this.gotoFrameState.get]);
  }
  get await() {
    return this.awaitState.get();
  }
  set await(t) {
    this.awaitState.set(t);
  }
  get paused() {
    return this.pausedState.get();
  }
  set paused(t) {
    this.pausedState.set(t);
  }
  get totalFrames() {
    return Math.max(this.clipTotalFrames, this.audioTotalFrames);
  }
  retarget(t, i, r, s) {
    const o = this.clipState.get().clone(), a = t.name + ".";
    o.tracks = o.tracks.filter((c) => c.name.startsWith(a));
    const l = new p3(this.name, o, t, i, r, s);
    return t.append(l), l;
  }
  get data() {
    return this.dataState.get()[0];
  }
  set data(t) {
    this.dataState.set([t]);
  }
  mergeData(t) {
    const [i] = this.dataState.get();
    if (!i) {
      this.dataState.set([t]);
      return;
    }
    lr.exports.merge(i, t), this.dataState.set([i]);
  }
  get frame() {
    return Math.ceil(this.mixer.time * pc);
  }
  set frame(t) {
    this.gotoFrameState.set(t);
  }
};
let ra = p3;
V(ra, "componentName", "animation"), V(ra, "defaults", xI), V(ra, "schema", yI);
const bK = (n) => {
  var a;
  const e = Object.entries(n);
  let t = 0;
  for (const [, { length: l }] of e)
    l > t && (t = l);
  const r = 1e3 * 1e-3 / t, s = {}, o = (a = s[""]) != null ? a : s[""] = {};
  for (const [l, c] of e)
    o[l] = Object.fromEntries(c.map((d, p) => [Math.ceil(p * r * pc), d]));
  return s;
};
class yK extends bI {
  constructor() {
    super(...arguments);
    V(this, "states");
    V(this, "_animation");
  }
  lazyStates() {
    if (this.states)
      return this.states;
    const { managerState: t, pausedState: i } = this.states = {
      managerRecordState: new Je({}),
      managerState: new Je(void 0),
      pausedState: new Je(!1),
      repeatState: new Je(1 / 0),
      onFinishState: new Je(void 0),
      finishEventState: new Je(void 0)
    };
    return this.createEffect(() => {
      const r = t.get();
      r && (r.paused = i.get());
    }, [t.get, i.get]), this.states;
  }
  get animations() {
    return this.lazyStates().managerRecordState.get();
  }
  set animations(t) {
    this.lazyStates().managerRecordState.set(t);
  }
  get animationPaused() {
    return this.lazyStates().pausedState.get();
  }
  set animationPaused(t) {
    this.lazyStates().pausedState.set(t);
  }
  get animationRepeat() {
    return this.lazyStates().repeatState.get();
  }
  set animationRepeat(t) {
    this.lazyStates().repeatState.set(t);
  }
  get onAnimationFinish() {
    return this.lazyStates().onFinishState.get();
  }
  set onAnimationFinish(t) {
    this.lazyStates().onFinishState.set(t);
  }
  playAnimation(t) {
    const { managerState: i, pausedState: r } = this.lazyStates();
    r.set(!1), i.set(typeof t == "string" ? this.animations[t] : Object.values(this.animations)[t != null ? t : 0]);
  }
  stopAnimation() {
    this.lazyStates().pausedState.set(!0);
  }
  createAnimation(t) {
    let i = this.animations[t];
    if (i && typeof i != "string")
      return i;
    const { onFinishState: r, repeatState: s, finishEventState: o } = this.lazyStates();
    return i = this.watch(new ra(t, void 0, this, s, r, o)), this.append(i), this.animations[t] = i, i;
  }
  get serializeAnimation() {
    return typeof this._animation != "object" ? this._animation : void 0;
  }
  setAnimation(t) {
    if (this._animation = t, typeof t == "string" || typeof t == "number") {
      this.playAnimation(t);
      return;
    }
    if (typeof t == "boolean") {
      t ? this.playAnimation(void 0) : this.stopAnimation();
      return;
    }
    if (!t) {
      this.stopAnimation();
      return;
    }
    const i = "animation", r = this.createAnimation(i);
    r.data = bK(t), this.playAnimation(i);
  }
  get animation() {
    return this._animation;
  }
  set animation(t) {
    this.cancelHandle(
      "playAnimation",
      Array.isArray(t) ? () => {
        const { finishEventState: i, managerRecordState: r } = this.lazyStates(), s = di();
        i.set(s);
        let o = 0;
        const a = () => {
          var d;
          if (o === t.length) {
            if (this.animationRepeat < 2) {
              (d = this.onAnimationFinish) == null || d.call(this);
              return;
            }
            o = 0;
          }
          this.setAnimation(t[o++]);
        };
        a();
        const [, l] = s, c = l(a);
        return new Xn(() => {
          i.set(void 0), c.cancel();
        });
      } : void this.setAnimation(t)
    );
  }
}
const tC = Wf(
  (n) => n.nativeObject3d.scale.clone().multiply(n.outerObject3d.scale)
), CR = /* @__PURE__ */ new WeakMap(), TR = (n, e) => {
  const t = CR.get(n);
  if (t)
    return t;
  const i = jD(
    n.x,
    n.y,
    n.z,
    e.x * Ai,
    e.y * Ai,
    e.z * Ai
  );
  return CR.set(n, i), i;
};
class $f extends yK {
  constructor() {
    super(...arguments);
    V(this, "onIntersectState");
    V(this, "onIntersectOutState");
    V(this, "intersectIdsState");
    V(this, "onMoveToEnd");
  }
  getRayIntersectionsAt(t, i) {
    var o;
    const r = [];
    for (const a of (o = jd.get(t)) != null ? o : []) {
      if (a === this)
        continue;
      const l = this.rayIntersectsAt(a, i);
      l && r.push([a, l]);
    }
    const s = Dn(this.nativeObject3d);
    return r.sort((a, l) => TR(a[1], s) - TR(l[1], s));
  }
  getRayIntersections(t, i) {
    return this.getRayIntersectionsAt(t, i).map(
      (r) => r[0]
    );
  }
  listenToRayIntersection(t, i, r) {
    return this.beforeRender(() => {
      for (const [s, o] of this.getRayIntersectionsAt(
        t,
        r
      ))
        i(s, o);
    });
  }
  getIntersections(t) {
    var r;
    const i = /* @__PURE__ */ new Set();
    for (const s of (r = jd.get(t)) != null ? r : [])
      s !== this && this.intersects(s) && i.add(s);
    return i;
  }
  listenToIntersection(t, i, r) {
    let s = /* @__PURE__ */ new Set();
    return this.beforeRender(() => {
      const o = this.getIntersections(t);
      if (i)
        for (const a of o)
          !s.has(a) && i(a);
      if (r)
        for (const a of s)
          !o.has(a) && r(a);
      s = o;
    });
  }
  initIntersect() {
    this.onIntersectState || (this.onIntersectState = new Je(
      void 0
    ), this.onIntersectOutState = new Je(
      void 0
    ), this.intersectIdsState = new Je(
      void 0
    ), this.createEffect(() => {
      const { onIntersect: t, onIntersectOut: i, intersectIds: r } = this;
      if (!r || !t && !i)
        return;
      const s = [];
      for (const o of r)
        s.push(
          this.listenToIntersection(o, t, i)
        );
      return () => {
        for (const o of s)
          o.cancel();
      };
    }, [
      this.onIntersectState.get,
      this.onIntersectOutState.get,
      this.intersectIdsState.get
    ]));
  }
  get onIntersect() {
    var t;
    return (t = this.onIntersectState) == null ? void 0 : t.get();
  }
  set onIntersect(t) {
    var i;
    this.initIntersect(), (i = this.onIntersectState) == null || i.set(t);
  }
  get onIntersectOut() {
    var t;
    return (t = this.onIntersectOutState) == null ? void 0 : t.get();
  }
  set onIntersectOut(t) {
    var i;
    this.initIntersect(), (i = this.onIntersectOutState) == null || i.set(t);
  }
  get intersectIds() {
    var t;
    return (t = this.intersectIdsState) == null ? void 0 : t.get();
  }
  set intersectIds(t) {
    var i;
    this.initIntersect(), (i = this.intersectIdsState) == null || i.set(t);
  }
  get scaleX() {
    return this.outerObject3d.scale.x;
  }
  set scaleX(t) {
    this.outerObject3d.scale.x = t;
  }
  get scaleY() {
    return this.outerObject3d.scale.y;
  }
  set scaleY(t) {
    this.outerObject3d.scale.y = t;
  }
  get scaleZ() {
    return this.outerObject3d.scale.z;
  }
  set scaleZ(t) {
    this.outerObject3d.scale.z = t;
  }
  get scale() {
    return this.scaleX;
  }
  set scale(t) {
    this.scaleX = t, this.scaleY = t, this.scaleZ = t;
  }
  get rotationX() {
    return this.outerObject3d.rotation.x * pl;
  }
  set rotationX(t) {
    this.outerObject3d.rotation.x = t * Pi;
  }
  get rotationY() {
    return this.outerObject3d.rotation.y * pl;
  }
  set rotationY(t) {
    this.outerObject3d.rotation.y = t * Pi;
  }
  get rotationZ() {
    return this.outerObject3d.rotation.z * pl;
  }
  set rotationZ(t) {
    this.outerObject3d.rotation.z = t * Pi;
  }
  get rotation() {
    return this.rotationZ;
  }
  set rotation(t) {
    this.rotationZ = t;
  }
  translateX(t) {
    this.outerObject3d.translateX(t * Ut * ta[0]);
  }
  translateY(t) {
    this.outerObject3d.translateY(t * Ut * ta[0]);
  }
  translateZ(t) {
    this.outerObject3d.translateZ(t * Ut * ta[0]);
  }
  placeAt(t) {
    var i;
    if (typeof t == "string") {
      const [r] = (i = jd.get(t)) != null ? i : [void 0];
      if (!r)
        return;
      t = r;
    }
    if ("outerObject3d" in t) {
      "isSpawnPoint" in t && (t.object3d.position.y = tC(this).y * 0.5), this.outerObject3d.position.copy(Wv(t.nativeObject3d)), this.outerObject3d.quaternion.copy(
        gl(t.outerObject3d)
      );
      return;
    }
    this.outerObject3d.position.copy(Gy(t));
  }
  moveForward(t) {
    ml() ? this.translateZ(-t) : (Jn.setFromMatrixColumn(this.outerObject3d.matrix, 0), Jn.crossVectors(this.outerObject3d.up, Jn), this.outerObject3d.position.addScaledVector(
      Jn,
      t * Ut * ta[0]
    ));
  }
  stopKeyboardMove() {
    ml() ? this.translateX(0.1) : (Jn.setFromMatrixColumn(this.outerObject3d.matrix, 0), this.outerObject3d.position.set(0, 0, 0));
  }
  moveRight(t) {
    ml() ? this.translateX(t) : (Jn.setFromMatrixColumn(this.outerObject3d.matrix, 0), this.outerObject3d.position.addScaledVector(
      Jn,
      t * Ut * ta[0]
    ));
  }
  lerpTo(t, i, r, s, o) {
    const a = new Z(this.x, this.y, this.z), l = new Z(t, i, r);
    this.cancelHandle(
      "lerpTo",
      () => Pn(() => {
        var m;
        const { x: c, y: d, z: p } = a.lerp(l, $u(s));
        Math.abs(this.x - c) < 0.1 && Math.abs(this.y - d) < 0.1 && Math.abs(this.z - p) < 0.1 && (this.cancelHandle("lerpTo", void 0), (m = this.onMoveToEnd) == null || m.call(this)), this.x = c, this.y = d, this.z = p, o == null || o();
      })
    );
  }
  stopMove() {
    var t;
    this.cancelHandle("lerpTo", void 0), (t = this.onMoveToEnd) == null || t.call(this);
  }
  moveTo(t, i, r, s, o) {
    t === this.x && (t += 0.01), r === this.z && (r += 0.01);
    const {
      x: a,
      y: l,
      z: c
    } = new Z(
      t - this.x,
      i === void 0 ? 0 : i - this.y,
      r - this.z
    ).normalize(), d = s * a, p = s * l, m = s * c, v = yX(t, r, this.x, this.z);
    this.cancelHandle(
      "lerpTo",
      () => Pn(() => {
        var y;
        this.x += d * ta[0], i !== void 0 && (this.y += p * ta[0]), this.z += m * ta[0];
        const b = _X(
          new Is(this.x, this.z),
          new Is(t, r),
          new Is(this.x, r)
        ), x = bX(
          new Is(t, r),
          new Is(this.x, this.z),
          v === 1 || v === 4 ? b : -b
        );
        r > x.y && (this.cancelHandle("lerpTo", void 0), (y = this.onMoveToEnd) == null || y.call(this)), o == null || o(i);
      })
    );
  }
}
th($f, [Wy]);
class sa extends $f {
  constructor(t) {
    super(t);
    V(this, "model");
    V(this, "managerSet");
    Zr.delete(this);
    const { materialManager: i } = t.userData;
    i && this.append(i);
  }
  retargetAnimations() {
    const t = this.model && fI(this.model, "lazyStates");
    if (!t)
      return;
    const {
      onFinishState: i,
      repeatState: r,
      managerRecordState: s,
      finishEventState: o
    } = t;
    for (const a of Object.values(s.get()))
      this.animations[a.name] = this.watch(
        a.retarget(
          this,
          r,
          i,
          o
        )
      );
    this.model = void 0;
  }
  get animation() {
    return super.animation;
  }
  set animation(t) {
    this.retargetAnimations(), super.animation = t;
  }
  addToRaycastSet(t) {
    return this.managerSet || (this.managerSet = !0, this.nativeObject3d.traverse((i) => Ds(i, this))), super.addToRaycastSet(t);
  }
}
V(sa, "componentName", "find"), V(sa, "defaults", BY), V(sa, "schema", FY);
th(sa, [
  nI,
  LE,
  yl
]);
const PR = /* @__PURE__ */ new Map(), iM = /* @__PURE__ */ new WeakSet();
class nC extends $f {
  constructor() {
    super(...arguments);
    V(this, "positionUpdate");
    V(this, "rotationUpdate");
    V(this, "refreshPhysicsState");
    V(this, "bvhVelocity");
    V(this, "bvhOnGround");
    V(this, "bvhRadius");
    V(this, "bvhHalfHeight");
    V(this, "bvhMap");
    V(this, "bvhCharacter");
    V(this, "_physics");
    V(this, "_gravity");
  }
  get velocity() {
    return this.bvhVelocity ? this.bvhVelocity : new yf(0, 0, 0);
  }
  set velocity(t) {
    this.bvhVelocity && Object.assign(this.bvhVelocity, t);
  }
  refreshPhysics() {
    if (this.refreshPhysicsState) {
      this.refreshPhysicsState.set({});
      return;
    }
    this.createEffect(() => {
      const { _physics: t } = this;
      if (!t)
        return;
      this.outerObject3d.parent !== bt && bt.attach(this.outerObject3d);
      const i = new Xn();
      return t === "map" || t === "map-debug" ? import("./enableBVHMap.921b02dd.mjs").then((r) => {
        r.default.call(this, i, t === "map-debug");
      }) : t === "character" && import("./enableBVHCharacter.b72ff1c7.mjs").then((r) => {
        r.default.call(this, i);
      }), () => {
        i.cancel();
      };
    }, [(this.refreshPhysicsState = new Je({})).get]);
  }
  get physics() {
    var t;
    return (t = this._physics) != null ? t : !1;
  }
  set physics(t) {
    this._physics = t, this.refreshPhysics();
  }
  get gravity() {
    var t;
    return (t = this._gravity) != null ? t : !0;
  }
  set gravity(t) {
    this._gravity = t;
  }
  intersects(t) {
    var i, r;
    return this.done || t.done || this === t ? !1 : t instanceof nC && (this.bvhMap && t.bvhCharacter || this.bvhCharacter && t.bvhMap) ? ((i = PR.get(this)) == null ? void 0 : i.has(t)) || ((r = PR.get(t)) == null ? void 0 : r.has(this)) || !1 : super.intersects(t);
  }
  get x() {
    return super.x;
  }
  set x(t) {
    var i;
    super.x = t, (i = this.positionUpdate) == null || i.updateX();
  }
  get y() {
    return super.y;
  }
  set y(t) {
    var i;
    super.y = t, (i = this.positionUpdate) == null || i.updateY();
  }
  get z() {
    return super.z;
  }
  set z(t) {
    var i;
    super.z = t, (i = this.positionUpdate) == null || i.updateZ();
  }
  get rotationX() {
    return super.rotationX;
  }
  set rotationX(t) {
    var i;
    super.rotationX = t, (i = this.rotationUpdate) == null || i.updateX();
  }
  get rotationY() {
    return super.rotationY;
  }
  set rotationY(t) {
    var i;
    super.rotationY = t, (i = this.rotationUpdate) == null || i.updateY();
  }
  get rotationZ() {
    return super.rotationZ;
  }
  set rotationZ(t) {
    var i;
    super.rotationZ = t, (i = this.rotationUpdate) == null || i.updateZ();
  }
  lookAt(t, i, r) {
    var s;
    super.lookAt(t, i, r), (s = this.rotationUpdate) == null || s.updateXYZ();
  }
  placeAt(t) {
    var i, r;
    super.placeAt(t), (i = this.positionUpdate) == null || i.updateXYZ(), (r = this.rotationUpdate) == null || r.updateXYZ(), iM.add(this);
  }
  lerpTo(t, i, r, s) {
    super.lerpTo(t, i, r, s, () => {
      var o;
      return (o = this.positionUpdate) == null ? void 0 : o.updateXYZ();
    });
  }
  stopMove() {
    super.stopMove();
  }
  stopKeyboardMove() {
    super.stopKeyboardMove();
  }
  moveTo(t, i, r, s) {
    super.moveTo(
      t,
      i,
      r,
      s,
      (o) => {
        var a, l;
        return o === void 0 ? (a = this.positionUpdate) == null ? void 0 : a.updateXZ() : (l = this.positionUpdate) == null ? void 0 : l.updateXYZ();
      }
    );
  }
}
class mh extends nC {
  constructor(e = new wn(), t) {
    super(e), this.object3d = e, this.nativeObject3d = e;
    const i = this.outerObject3d = new wn();
    Ds(i, this), !t && bt.add(i), i.add(e);
  }
  get innerRotationX() {
    return this.object3d.rotation.x * pl;
  }
  set innerRotationX(e) {
    this.object3d.rotation.x = e * Pi;
  }
  get innerRotationY() {
    return this.object3d.rotation.y * pl;
  }
  set innerRotationY(e) {
    this.object3d.rotation.y = e * Pi;
  }
  get innerRotationZ() {
    return this.object3d.rotation.z * pl;
  }
  set innerRotationZ(e) {
    this.object3d.rotation.z = e * Pi;
  }
  get innerRotation() {
    return this.innerRotationZ;
  }
  set innerRotation(e) {
    this.innerRotationZ = e;
  }
  get innerX() {
    return this.object3d.position.x * Ai;
  }
  get playAllAnimation() {
    return this.object3d.playAllAnimation;
  }
  set playAllAnimation(e) {
    this.object3d.playAllAnimation = e;
  }
  set innerX(e) {
    this.object3d.position.x = e * Ut;
  }
  get innerY() {
    return this.object3d.position.y * Ai;
  }
  set innerY(e) {
    this.object3d.position.y = e * Ut;
  }
  get innerZ() {
    return this.object3d.position.z * Ai;
  }
  set innerZ(e) {
    this.object3d.position.z = e * Ut;
  }
  set firstInnerY(e) {
    this.object3d.firstInnerY = e;
  }
  set firstInnerZ(e) {
    this.object3d.firstInnerZ = e;
  }
  set firstInnerX(e) {
    this.object3d.firstInnerX = e;
  }
  get width() {
    return this.object3d.scale.x * Ai;
  }
  set width(e) {
    this.object3d.scale.x = e * Ut;
  }
  get height() {
    return this.object3d.scale.y * Ai;
  }
  set height(e) {
    this.object3d.scale.y = e * Ut;
  }
  get depth() {
    return this.object3d.scale.z * Ai;
  }
  set depth(e) {
    this.object3d.scale.z = e * Ut;
  }
  get innerVisible() {
    return this.object3d.visible;
  }
  set innerVisible(e) {
    this.object3d.visible = e;
  }
  find(e, t) {
    const i = this.outerObject3d.getObjectByName(vn.sanitizeNodeName(e));
    if (!i)
      return;
    const r = Ds(i, new sa(i));
    return !t && this._append(r), r;
  }
  findAll(e) {
    const t = [];
    return e === void 0 ? this.outerObject3d.traverse((i) => {
      t.push(Ds(i, new sa(i)));
    }) : typeof e == "string" ? this.outerObject3d.traverse((i) => {
      i.name === e && t.push(Ds(i, new sa(i)));
    }) : typeof e == "function" ? this.outerObject3d.traverse((i) => {
      e(i.name) && t.push(Ds(i, new sa(i)));
    }) : this.outerObject3d.traverse((i) => {
      e.test(i.name) && t.push(Ds(i, new sa(i)));
    }), t;
  }
}
class Sa extends mh {
}
th(Sa, [nI]);
class Us extends Sa {
  constructor(e) {
    const t = new wi(e, _5);
    t.castShadow = !0, t.receiveShadow = !0, super(t);
  }
}
V(Us, "defaults", IE), V(Us, "schema", DE);
th(Us, [LE, yl]);
const iC = new ah(
  zs,
  zs,
  zs,
  1,
  1,
  1
);
class qy extends Us {
  constructor() {
    super(iC);
  }
}
V(qy, "componentName", "cube");
const K_ = /* @__PURE__ */ new WeakMap(), wI = (n) => {
  K_.has(n) && (K_.get(n)(), K_.delete(n));
}, AR = (n, e) => {
  wI(n);
  const t = n(e);
  t && K_.set(n, t);
};
class xK {
  constructor() {
    V(this, "done");
    V(this, "value");
    V(this, "callbacks", []);
  }
  then(e) {
    return this.callbacks.push(e), this.done && AR(e, this.value), new Xn(() => {
      TL(this.callbacks, e), wI(e);
    });
  }
  resolve(e) {
    for (const t of this.callbacks)
      AR(t, e);
    this.done = !0, this.value = e;
  }
}
const SI = (n) => {
  const e = new qD();
  return n.then((t) => {
    e.resolve(t);
  }), e;
};
class jv extends Sa {
  constructor(t) {
    super(new wi(iC, g5), t);
    V(this, "loadedGroup", new ul());
    V(this, "loaded", new xK());
    V(this, "_src");
    V(this, "_onLoad");
    V(this, "widthSet");
    V(this, "heightSet");
    V(this, "depthSet");
    V(this, "_boxVisible");
    V(this, "managerSet");
    this.outerObject3d.add(this.loadedGroup);
  }
  get src() {
    return this._src;
  }
  set src(t) {
    this._src = t, this.loaded.done && this.loadedGroup.clear(), this.cancelHandle(
      "src",
      t && (() => SI(this.load(t)).then((i) => {
        const r = this.resolveLoaded(i, t);
        this.loadedGroup.add(r), this.loaded.resolve(r), this.object3d.visible = !!this._boxVisible;
      }))
    );
  }
  get onLoad() {
    return this._onLoad;
  }
  set onLoad(t) {
    this._onLoad = t, this.cancelHandle("onLoad", t && (() => this.loaded.then(() => void t())));
  }
  get width() {
    return super.width;
  }
  set width(t) {
    super.width = t, this.widthSet = !0;
  }
  get height() {
    return super.height;
  }
  set height(t) {
    super.height = t, this.heightSet = !0;
  }
  get depth() {
    return super.depth;
  }
  set depth(t) {
    super.depth = t, this.depthSet = !0;
  }
  get innerRotationX() {
    return super.innerRotationX;
  }
  set innerRotationX(t) {
    super.innerRotationX = t, this.loadedGroup.rotation.x = this.object3d.rotation.x;
  }
  get innerRotationY() {
    return super.innerRotationY;
  }
  set innerRotationY(t) {
    super.innerRotationY = t, this.loadedGroup.rotation.y = this.object3d.rotation.y;
  }
  get innerRotationZ() {
    return super.innerRotationZ;
  }
  set innerRotationZ(t) {
    super.innerRotationZ = t, this.loadedGroup.rotation.z = this.object3d.rotation.z;
  }
  get innerX() {
    return super.innerX;
  }
  set innerX(t) {
    super.innerX = t, this.loadedGroup.position.x = this.object3d.position.x;
  }
  get innerY() {
    return super.innerY;
  }
  set innerY(t) {
    super.innerY = t, this.loadedGroup.position.y = this.object3d.position.y;
  }
  get firstInnerY() {
    return super.firstInnerY;
  }
  get playAllAnimation() {
    return super.playAllAnimation;
  }
  set playAllAnimation(t) {
    super.playAllAnimation = t;
  }
  set firstInnerY(t) {
    super.firstInnerY = t, this.outerObject3d.firstInnerY = t, this._firstInnerY = t;
  }
  get firstInnerZ() {
    return super.firstInnerZ;
  }
  set firstInnerZ(t) {
    super.firstInnerZ = t, this.outerObject3d.firstInnerZ = t, this._firstInnerZ = t;
  }
  get firstInnerX() {
    return super.firstInnerZ;
  }
  set firstInnerX(t) {
    super.firstInnerX = t, this.outerObject3d.firstInnerX = t, this._firstInnerX = t;
  }
  get innerZ() {
    return super.innerZ;
  }
  set innerZ(t) {
    super.innerZ = t, this.loadedGroup.position.z = this.object3d.position.z;
  }
  get innerVisible() {
    return this.loadedGroup.visible;
  }
  set innerVisible(t) {
    this.loadedGroup.visible = t;
  }
  get frustumCulled() {
    return super.frustumCulled;
  }
  set frustumCulled(t) {
    this.outerObject3d.frustumCulled = t, this.cancelHandle(
      "frustumCulled",
      () => this.loaded.then(() => {
        super.frustumCulled = t;
      })
    );
  }
  get castShadow() {
    return super.castShadow;
  }
  set castShadow(t) {
    this._castShadow = t, this.cancelHandle(
      "castShadow",
      () => this.loaded.then(() => {
        super.castShadow = t;
      })
    );
  }
  get receiveShadow() {
    return super.receiveShadow;
  }
  set receiveShadow(t) {
    this._receiveShadow = t, this.cancelHandle(
      "receiveShadow",
      () => this.loaded.then(() => {
        super.receiveShadow = t;
      })
    );
  }
  get boxVisible() {
    var t;
    return (t = this._boxVisible) != null ? t : this.object3d.visible;
  }
  set boxVisible(t) {
    this._boxVisible = t, this.object3d.visible = t;
  }
  get outline() {
    return super.outline;
  }
  set outline(t) {
    this._outline = t, this.cancelHandle(
      "outline",
      () => this.loaded.then((i) => {
        if (!!t)
          return eI(i), () => {
            tI(i);
          };
      })
    );
  }
  get bloom() {
    return super.bloom;
  }
  set bloom(t) {
    this._bloom = t, this.cancelHandle(
      "bloom",
      () => this.loaded.then((i) => {
        if (!!t)
          return ZE(i), () => {
            YE(i);
          };
      })
    );
  }
  addToRaycastSet(t) {
    const i = new Xn();
    return queueMicrotask(() => {
      i.done || (this._physics === "map" || this._physics === "map-debug" ? i.watch(
        this.loaded.then((r) => (this.managerSet || (this.managerSet = !0, r.traverse((s) => Ds(s, this))), t.add(r), () => {
          t.delete(r);
        }))
      ) : i.watch(super.addToRaycastSet(t)));
    }), i;
  }
  placeAt(t) {
    this.cancelHandle("placeAt", () => this.loaded.then(() => void super.placeAt(t)));
  }
  refreshPhysics() {
    this.cancelHandle("refreshPhysics", () => this.loaded.then(() => void super.refreshPhysics()));
  }
}
const wK = (n) => "loadedGroup" in n ? n.loadedGroup : "object3d" in n ? n.object3d : n.outerObject3d;
function SK(n) {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), i = n.clone();
  return MI(n, i, function(r, s) {
    e.set(s, r), t.set(r, s);
  }), i.traverse(function(r) {
    if (!r.isSkinnedMesh)
      return;
    const s = r, o = e.get(r), a = o.skeleton.bones;
    s.skeleton = o.skeleton.clone(), s.bindMatrix.copy(o.bindMatrix), s.skeleton.bones = a.map(function(l) {
      return t.get(l);
    }), s.bind(s.skeleton, s.bindMatrix);
  }), i;
}
function MI(n, e, t) {
  t(n, e);
  for (let i = 0; i < n.children.length; i++)
    MI(n.children[i], e.children[i], t);
}
const EI = /* @__PURE__ */ new WeakSet(), jhe = (n, e, t = n.animations) => {
  const i = e ? n.clone() : SK(n);
  return !e && EI.add(i), i.animations = t, i;
};
ft(() => {
  const n = Nn();
  if (!(n instanceof jv) || nt() !== un)
    return;
  const e = n.loadedGroup.children[0];
  if (!EI.has(e))
    return;
  const t = new oX(e);
  return bt.add(t), () => {
    bt.remove(t);
  };
}, [Nn, nt]);
const [RR, lv] = Be(!1);
class Cf {
  constructor(e) {
    this.options = e;
  }
}
const CI = {
  ...Iy,
  mouseControl: [Boolean, String],
  fov: Number,
  zoom: Number,
  near: Number,
  far: Number,
  active: Boolean,
  transition: [Boolean, Number],
  minPolarAngle: Number,
  maxPolarAngle: Number,
  minAzimuthAngle: Number,
  maxAzimuthAngle: Number,
  polarAngle: Number,
  azimuthAngle: Number,
  enableDamping: Boolean
};
ya(["minAzimuthAngle", "maxAzimuthAngle", "near", "far"]);
const TI = yt(
  [Oy],
  {
    mouseControl: !1,
    fov: 75,
    zoom: 1,
    near: uh,
    far: Mc,
    active: !1,
    transition: new Tn(!1),
    minPolarAngle: ZD,
    maxPolarAngle: YD,
    minAzimuthAngle: -1 / 0,
    maxAzimuthAngle: 1 / 0,
    polarAngle: new Tn(0),
    azimuthAngle: new Tn(0),
    enableDamping: !1
  },
  {
    mouseControl: new Cf({ true: !0, false: !1, drag: "drag" }),
    fov: new dt(30, 120, 5),
    zoom: new dt(0.1, 10),
    near: new dt(0.1, 1e4),
    far: new dt(0.1, 1e4),
    minPolarAngle: new dt(0, 180, 1),
    maxPolarAngle: new dt(0, 180, 1),
    polarAngle: new dt(0, 180),
    azimuthAngle: new dt(0, 360)
  }
), PI = {
  ...CI,
  target: [String, Object]
}, AI = yt(
  [TI],
  { target: void 0 }
), MK = {
  ...PI,
  enableZoom: Boolean,
  enableFly: Boolean,
  autoRotate: [Boolean, Number]
}, EK = yt(
  [AI],
  {
    innerZ: 500,
    mouseControl: "drag",
    enableZoom: !1,
    enableFly: !1,
    autoRotate: !1
  }
), [qhe, RI] = Be(!1), [CK, Xy] = di(), vh = No(CK);
window.addEventListener("blur", () => vh());
window.addEventListener("focus", () => vh());
document.addEventListener("visibilitychange", () => vh());
RI(() => vh());
const J_ = /* @__PURE__ */ new Set();
Xy(() => J_.clear());
let rM = !1;
const kI = () => {
  !rM || (rM = !1, vh());
};
document.addEventListener("keydown", (n) => {
  kI(), (n.key === "Shift" || n.key === "Meta") && J_.add(n.key), J_.has("Meta") && J_.has("Shift") && (vh(), rM = !0);
});
document.addEventListener("keyup", (n) => {
  (n.key === "Shift" || n.key === "Meta") && vh();
});
document.addEventListener("mousedown", kI);
const [LI, rC] = Be(
  []
), TK = nh(LI, rC), PK = ih(LI, rC), AK = {
  ...Lc,
  ...Vf
}, RK = yt(
  [Dc, Dv],
  { scaleZ: 0, depth: 0 }
), kK = new pD({ transparent: !0 });
class gc extends Sa {
  constructor() {
    super(new Fj(kK));
  }
  get depth() {
    return 0;
  }
  set depth(e) {
  }
  get scaleZ() {
    return 0;
  }
  set scaleZ(e) {
  }
}
V(gc, "componentName", "sprite"), V(gc, "defaults", RK), V(gc, "schema", AK);
th(gc, [yl]);
class qv extends gc {
  constructor(e) {
    super(), this.texture = `${QD}${e}Sprite.png`, this.scale = 0.5, this.castShadow = !1, this.receiveShadow = !1, ko.add(this);
  }
}
const m3 = class extends mh {
  constructor(t) {
    super();
    V(this, "midObject3d", this.outerObject3d);
    V(this, "_active");
    V(this, "orbitMode");
    V(this, "gyrateHandle");
    V(this, "_minPolarAngle", ZD);
    V(this, "_maxPolarAngle", YD);
    V(this, "_minAzimuthAngle", -1 / 0);
    V(this, "_maxAzimuthAngle", 1 / 0);
    V(this, "_polarAngle");
    V(this, "_azimuthAngle");
    V(this, "enableDamping", !1);
    V(this, "mouseControlState", new Je(!1));
    V(this, "mouseControlInit");
    V(this, "_gyroControl");
    this.camera = t, this.object3d.add(t), Ds(t, this), TK(t), this.then(() => {
      NA(t), PK(t);
    }), this.createEffect(() => {
      if (nt() !== un || nt() === t)
        return;
      const i = new lX(t);
      bt.add(i);
      const r = new qv("camera"), s = ph(r, this);
      return i.add(r.outerObject3d), () => {
        i.dispose(), bt.remove(i), s.cancel();
      };
    }, [nt]);
  }
  lookAt(t, i, r) {
    super.lookAt(t, i, r);
    const s = ui.setFromQuaternion(this.outerObject3d.quaternion);
    s.x += Math.PI, s.z += Math.PI, this.outerObject3d.setRotationFromEuler(s);
  }
  get fov() {
    return this.camera.fov;
  }
  set fov(t) {
    var i, r;
    this.camera.fov = t, (r = (i = this.camera).updateProjectionMatrix) == null || r.call(i);
  }
  get zoom() {
    return this.camera.zoom;
  }
  set zoom(t) {
    var i, r;
    this.camera.zoom = t, (r = (i = this.camera).updateProjectionMatrix) == null || r.call(i);
  }
  get near() {
    return this.camera.near;
  }
  set near(t) {
    var i, r;
    this.camera.near = t, (r = (i = this.camera).updateProjectionMatrix) == null || r.call(i);
  }
  get far() {
    return this.camera.far;
  }
  set far(t) {
    var i, r;
    this.camera.far = t, (r = (i = this.camera).updateProjectionMatrix) == null || r.call(i);
  }
  get active() {
    return !!this._active;
  }
  set active(t) {
    this._active = t, NA(this.camera), t && $Z(this.camera);
  }
  get transition() {
    return this.camera.userData.transition;
  }
  set transition(t) {
    this.camera.userData.transition = t;
  }
  getRay() {
    return m5.set(
      Dn(this.camera),
      rI(this.camera)
    );
  }
  append(t) {
    this._append(t), this.camera.add(t.outerObject3d);
  }
  attach(t) {
    this._append(t), this.camera.attach(t.outerObject3d);
  }
  get width() {
    return super.width;
  }
  set width(t) {
    const i = t * Ut;
    this.object3d.scale.x = i, this.camera.scale.x = 1 / i;
  }
  get height() {
    return super.height;
  }
  set height(t) {
    const i = t * Ut;
    this.object3d.scale.y = i, this.camera.scale.y = 1 / i;
  }
  get depth() {
    return super.depth;
  }
  set depth(t) {
    const i = t * Ut;
    this.object3d.scale.z = i, this.camera.scale.z = 1 / i;
  }
  _gyrate(t, i, r) {
    var o;
    const s = r ? this.object3d : this.midObject3d;
    ui.setFromQuaternion(s.quaternion), ui.y -= t * 2e-3, ui.y = Math.max(
      xm - this._maxAzimuthAngle * Pi,
      Math.min(xm - this._minAzimuthAngle * Pi, ui.y)
    ), ui.x -= i * 2e-3, ui.x = Math.max(
      xm - this._maxPolarAngle * Pi,
      Math.min(xm - this._minPolarAngle * Pi, ui.x)
    ), s.setRotationFromEuler(ui), !r && ((o = this.rotationUpdate) == null || o.updateXYZ());
  }
  gyrate(t, i, r) {
    var a;
    if (this.enableDamping && (t *= 0.5, i *= 0.5), this.orbitMode ? this._gyrate(t, i) : (this._gyrate(t, 0), this._gyrate(0, i, !0)), !this.enableDamping || r || !(t || i))
      return;
    (a = this.gyrateHandle) == null || a.cancel();
    let s = 1;
    const o = this.gyrateHandle = this.beforeRender(() => {
      s *= 0.95, this._gyrate(t * s, i * s), s <= 1e-3 && o.cancel();
    });
  }
  updateAngle() {
    m3.updateAngle(this, this);
  }
  get minPolarAngle() {
    return this._minPolarAngle;
  }
  set minPolarAngle(t) {
    this._minPolarAngle = t, this.updateAngle();
  }
  get maxPolarAngle() {
    return this._maxPolarAngle;
  }
  set maxPolarAngle(t) {
    this._maxPolarAngle = t, this.updateAngle();
  }
  get minAzimuthAngle() {
    return this._minAzimuthAngle;
  }
  set minAzimuthAngle(t) {
    this._minAzimuthAngle = t, this.updateAngle();
  }
  get maxAzimuthAngle() {
    return this._maxAzimuthAngle;
  }
  set maxAzimuthAngle(t) {
    this._maxAzimuthAngle = t, this.updateAngle();
  }
  setPolarAngle(t) {
    const { _minPolarAngle: i, _maxPolarAngle: r } = this;
    this.minPolarAngle = this.maxPolarAngle = t, this.queueMicrotask(() => {
      this.minPolarAngle = i, this.maxPolarAngle = r;
    });
  }
  setAzimuthAngle(t) {
    const { _minAzimuthAngle: i, _maxAzimuthAngle: r } = this;
    this.minAzimuthAngle = this.maxAzimuthAngle = t, this.queueMicrotask(() => {
      this.minAzimuthAngle = i, this.maxAzimuthAngle = r;
    });
  }
  get polarAngle() {
    return this._polarAngle;
  }
  set polarAngle(t) {
    this._polarAngle = t, t && this.setPolarAngle(t);
  }
  get azimuthAngle() {
    return this._azimuthAngle;
  }
  set azimuthAngle(t) {
    this._azimuthAngle = t, t && this.setAzimuthAngle(t);
  }
  get mouseControl() {
    return this.mouseControlState.get();
  }
  set mouseControl(t) {
    this.mouseControlState.set(t), !(!t || this.mouseControlInit) && (this.mouseControlInit = !0, import("./enableMouseControl.cce26206.mjs").then(
      (i) => i.default.call(this)
    ));
  }
  get gyroControl() {
    return !!this._gyroControl;
  }
  set gyroControl(t) {
    this._gyroControl = t;
    const i = ui, r = bu, s = r$, o = new Gi(
      -Math.sqrt(0.5),
      0,
      0,
      Math.sqrt(0.5)
    ), a = gl(this.object3d), l = 0, c = (d) => {
      var m, v, b;
      this.object3d.quaternion.copy(a), i.set(
        ((m = d.beta) != null ? m : 0) * Pi,
        ((v = d.alpha) != null ? v : 0) * Pi,
        -((b = d.gamma) != null ? b : 0) * Pi,
        "YXZ"
      ), this.object3d.quaternion.multiply(
        r.setFromEuler(i)
      );
      const p = -l * 0.5;
      s.set(
        0,
        Math.sin(p),
        0,
        Math.cos(p)
      ), this.object3d.quaternion.multiply(s), this.object3d.quaternion.multiply(o);
    };
    t && window.addEventListener("deviceorientation", c), this.cancelHandle(
      "gyroControl",
      t && (() => new Xn(
        () => window.removeEventListener("deviceorientation", c)
      ))
    );
  }
};
let Nm = m3;
V(Nm, "updateAngle", UV(
  (t) => t.gyrate(0, 0)
));
const LK = (n) => !!n && (Cc(n) || n instanceof bI);
class DI extends Nm {
  constructor(t) {
    super(t);
    V(this, "targetState", new Je(void 0));
    V(this, "foundState", new Je(void 0));
    V(this, "refresh", new Je({}));
    this.createEffect(() => {
      var o;
      const i = (o = this.getChild()) != null ? o : this.targetState.get();
      if (!i)
        return;
      const [[r]] = _I(i);
      if (r) {
        this.foundState.set(r);
        const a = PE(
          () => r.parent !== this && this.refresh.set({})
        );
        return () => {
          a.cancel();
        };
      }
      if (typeof i != "string")
        return;
      const s = cK((a) => a === i && this.refresh.set({}));
      return () => {
        s.cancel();
      };
    }, [this.targetState.get, this.refresh.get]);
  }
  getChild() {
    if (!this.children)
      return;
    const [t] = this.children;
    return LK(t) ? t : void 0;
  }
  get target() {
    return this.targetState.get();
  }
  set target(t) {
    this.targetState.set(t);
  }
  append(t) {
    var i;
    this._append(t), (i = this.parent) == null || i.outerObject3d.add(t.outerObject3d), this.refresh.set({});
  }
  attach(t) {
    var i;
    this._append(t), (i = this.parent) == null || i.outerObject3d.attach(t.outerObject3d), this.refresh.set({});
  }
}
class Iu extends DI {
  constructor(t = new ni(75, 1, uh, Mc)) {
    super(t);
    V(this, "enableZoomState", new Je(!1));
    V(this, "enableFlyState", new Je(!1));
    V(this, "autoRotateState", new Je(!1));
    this.innerZ = 500, this.orbitMode = !0, this.mouseControl = "drag", this.camera.rotation.y = 0, this.createEffect(() => {
      const i = this.foundState.get();
      if (!i)
        return;
      const r = Pn(() => {
        this.placeAt(Po(Wv(i.nativeObject3d)));
      });
      return () => {
        r.cancel();
      };
    }, [this.foundState.get]), this.createEffect(() => {
      const i = this.autoRotateState.get();
      if (nt() !== t || !i)
        return;
      const r = typeof i == "number" ? i : 2, s = Pn(() => {
        this.gyrate(r, 0, !0);
      });
      return () => {
        s.cancel();
      };
    }, [nt, this.autoRotateState.get]), this.createEffect(() => {
      if (Io() || nt() !== t || !this.mouseControlState.get())
        return;
      const i = new Xn();
      if (this.enableZoomState.get()) {
        const r = (s) => {
          s.preventDefault(), this.innerZ += s.deltaY, console.log(this.innerZ, "this.innerZ");
        };
        pn.addEventListener("wheel", r), i.then(() => pn.removeEventListener("wheel", r));
      }
      if (this.enableFlyState.get()) {
        const r = /* @__PURE__ */ new Set();
        i.watch(
          Pn(() => {
            if (r.has("Meta") || r.has("Control"))
              return;
            const a = r.has("Shift") ? 50 : 10;
            if (r.has("w") ? this.translateZ(-a) : r.has("s") && this.translateZ(a), r.has("a") || r.has("ArrowLeft") ? this.moveRight(-a) : (r.has("d") || r.has("ArrowRight")) && this.moveRight(a), r.has("w") || r.has("s") || r.has("a") || r.has("d")) {
              const l = Po(
                Dn(this.object3d)
              );
              this.innerZ = 0, this.placeAt(l);
            }
            r.has("Meta") || r.has("Control") || (r.has("ArrowDown") ? this.y -= a : r.has("ArrowUp") && (this.y += a));
          })
        );
        const s = (a) => {
          r.add(
            a.key.length === 1 ? a.key.toLocaleLowerCase() : a.key
          );
        }, o = (a) => {
          r.delete(
            a.key.length === 1 ? a.key.toLocaleLowerCase() : a.key
          );
        };
        document.addEventListener("keydown", s), document.addEventListener("keyup", o), i.watch(Xy(() => r.clear())), i.then(() => {
          document.removeEventListener("keydown", s), document.removeEventListener("keyup", o);
        });
      }
      return () => {
        i.cancel();
      };
    }, [
      nt,
      Io,
      this.enableZoomState.get,
      this.enableFlyState.get,
      this.mouseControlState.get
    ]);
  }
  get enableZoom() {
    return this.enableZoomState.get();
  }
  set enableZoom(t) {
    this.enableZoomState.set(t);
  }
  get enableFly() {
    return this.enableFlyState.get();
  }
  set enableFly(t) {
    this.enableFlyState.set(t);
  }
  get autoRotate() {
    return this.autoRotateState.get();
  }
  set autoRotate(t) {
    this.autoRotateState.set(t);
  }
}
V(Iu, "componentName", "orbitCamera"), V(Iu, "defaults", EK), V(Iu, "schema", MK);
const [DK, IK] = di(), [kR, OK] = Be(0), Ri = new Iu(un);
Ri.name = "default";
Ri.enableZoom = !0;
Ri.enableFly = !0;
Ri.mouseControl = !1;
Zr.delete(Ri);
IK((n) => {
  const e = n.getWorldPosition();
  Ri.x = e.x, Ri.y = e.y, Ri.z = e.z;
  const t = tC(n);
  Ri.innerZ = Math.max(t.x, t.y, t.z, 1) * Ai + 50;
});
lv((n) => {
  n || (Ri.setPolarAngle(90), Ri.setAzimuthAngle(90));
});
ft(() => {
  if (!(!lv() || nt() !== un || Io()))
    return Ri.mouseControl = "drag", pn.style.cursor = "grab", () => {
      Ri.mouseControl = !1, pn.style.cursor = "auto";
    };
}, [lv, Io, nt]);
ft(() => {
  if (nt() !== un || lv())
    return;
  const n = OK(
    (e) => Ri.innerZ = e
  );
  return () => {
    n.cancel();
  };
}, [nt, lv]);
const Xhe = new FD(), $he = new Z(), Zhe = new Z(), Yhe = new Gi(), Khe = {
  X: new Z(1, 0, 0),
  Y: new Z(0, 1, 0),
  Z: new Z(0, 0, 1)
};
const Jhe = new oh(), Qhe = new Z(0, 1, 0), ede = new Z(0, 0, 0), tde = new Pt(), nde = new Gi(), ide = new Gi(), rde = new Z(), sde = new Pt(), ode = new Z(1, 0, 0), ade = new Z(0, 1, 0), lde = new Z(0, 0, 1), cde = new Z(), ude = new Z(), hde = new Z();
const [NK, sM] = Be(!1), [zK, oM] = Be(10);
ft(() => {
  if (!sM())
    return;
  const n = oM(), e = new aX(n, n);
  return e.position.set(0, 0, 0), bt.add(e), () => {
    bt.remove(e);
  };
}, [sM, oM]);
const [dde, Fb] = Be(void 0), [fde, LR] = Be(!1), mu = new wi(
  new Av(zs, zs, 4, 4),
  g5
);
ft(() => {
  var i;
  if (!LR() || nt() !== un)
    return;
  bt.add(mu);
  const [n, e] = (i = Fb()) != null ? i : Lo();
  mu.scale.x = n * Ut, mu.scale.y = e * Ut;
  const t = Pn(() => {
    mu.quaternion.copy(un.quaternion), mu.position.copy(un.position), mu.translateZ(-4.9);
  });
  return () => {
    t.cancel(), bt.remove(mu);
  };
}, [LR, Fb, Lo, nt]);
const [pde, FK] = Be({
  turbidity: 10,
  rayleigh: 3,
  mieCoefficient: 5e-3,
  mieDirectionalG: 0.5,
  inclination: 0.49,
  azimuth: 0.25
});
class $y extends wi {
  constructor() {
    const e = $y.SkyShader, t = new Yn({
      name: "SkyShader",
      fragmentShader: e.fragmentShader,
      vertexShader: e.vertexShader,
      uniforms: gy.clone(e.uniforms),
      side: cr,
      depthWrite: !1
    });
    super(new ah(1, 1, 1), t), this.isSky = !0;
  }
}
$y.SkyShader = {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new Z() },
    up: { value: new Z(0, 1, 0) }
  },
  vertexShader: `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,
  fragmentShader: `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPos );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <encodings_fragment>

		}`
};
const [BK, UK] = Be(!1), DR = iE(() => {
  const n = new $y();
  return n.scale.setScalar(45e4), FK((e) => {
    const { uniforms: t } = n.material;
    t.turbidity.value = e.turbidity, t.rayleigh.value = e.rayleigh, t.mieCoefficient.value = e.mieCoefficient, t.mieDirectionalG.value = e.mieDirectionalG;
    const i = Math.PI * (e.inclination - 0.5), r = 2 * Math.PI * (e.azimuth - 0.5);
    Jn.x = Math.cos(r), Jn.y = Math.sin(r) * Math.sin(i), Jn.z = Math.sin(r) * Math.cos(i), t.sunPosition.value.copy(Jn);
  }), n;
});
let IR = !1;
UK((n) => {
  IR !== n && (IR = n, n ? bt.add(DR()) : bt.remove(DR()));
});
const OR = (n, e) => Math.abs(n * 0.5 / Math.cos(e.fov * 0.6 * Pi));
ft(() => {
  var c;
  const [n, e] = (c = Fb()) != null ? c : Lo(), [t, i, r] = B2(nt()), s = {
    width: t,
    height: e - (n - t) * e / n
  }, o = {
    width: n - (e - i) * n / e,
    height: i
  }, a = Math.min(t - s.width, i - s.height), l = Math.min(t - o.width, i - o.height);
  a > l ? kR(OR(n / r, un)) : kR(OR(e, un));
}, [Lo, Fb, nt, wf]);
const [hS, II] = di(), [VK, aM] = Be(!1), [NR, zR] = Be(
  void 0
);
ft(() => {
  if (!aM())
    return;
  const n = new w5({
    blendFunction: $t.ADD,
    mipmapBlur: !0,
    luminanceSmoothing: 0.3
  });
  NR(n);
  const e = qE((r) => n.intensity = r), t = $E(
    (r) => n.luminanceMaterial.threshold = r
  ), i = XE(
    (r) => Li(n, "mipmapBlurPass").radius = Math.min(
      r,
      0.9
    )
  );
  return () => {
    NR(void 0), n.dispose(), e.cancel(), t.cancel(), i.cancel();
  };
}, [aM]);
const [HK, lM] = Be(!1), [GK, cM] = Be(10), [FR, BR] = Be(
  void 0
);
ft(() => {
  if (!lM())
    return;
  const n = new OZ(nt(), {
    focusDistance: 0,
    focalLength: 0.048,
    bokehScale: cM(),
    height: 480
  });
  FR(n);
  const e = cM((t) => n.bokehScale = t);
  return () => {
    e.cancel(), FR(void 0), n.dispose();
  };
}, [lM, nt]);
const [WK, cv] = Be(!1), [UR, Bb] = Be(void 0);
ft(() => {
  if (!cv())
    return;
  const n = new $$(bt, nt());
  return UR(n), () => {
    UR(void 0), n.dispose();
  };
}, [cv, nt]);
const [jK, OI] = Be(2), [VR, HR] = Be(void 0);
ft(() => {
  const n = Bb();
  if (!cv() || !n)
    return;
  const e = new GZ(nt(), n.texture);
  VR(e);
  const { uniforms: t } = e.ssaoMaterial;
  e.radius = 0.05, e.samples = 32, e.uniforms.get("luminanceInfluence").value = 0, e.ssaoMaterial.distanceFalloff = e.ssaoMaterial.distanceThreshold = 1, e.ssaoMaterial.proximityThreshold = e.ssaoMaterial.proximityFalloff = 0.01;
  const i = OI((r) => t.intensity.value = r);
  return () => {
    VR(void 0), e.dispose(), i.cancel();
  };
}, [cv, nt, Bb]);
const [qK, uM] = Be(!1), [XK, NI] = Be(1), $K = `uniform float blur;
uniform float blurSharpness;
uniform int blurKernel;

// algorithm is from: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/denoise.js
vec3 denoise(vec3 center, sampler2D tex, vec2 uv, vec2 invTexSize, float blur, float blurSharpness, int blurKernel) {
    vec3 color;
    float total;
    vec3 col;
    float weight;

    for (int x = -blurKernel; x <= blurKernel; x++) {
        for (int y = -blurKernel; y <= blurKernel; y++) {
            col = textureLod(tex, uv + vec2(x, y) * invTexSize, 0.).rgb;
            weight = 1.0 - abs(dot(col - center, vec3(0.25)));
            weight = pow(weight, blurSharpness);
            color += col * weight;
            total += weight;
        }
    }

    return color / total;
}`, ZK = `#define MODE_DEFAULT             0
#define MODE_REFLECTIONS         1
#define MODE_RAW_REFLECTION      2
#define MODE_BLURRED_REFLECTIONS 3
#define MODE_INPUT               4
#define MODE_BLUR_MIX            5

#define FLOAT_EPSILON            0.00001

uniform sampler2D inputTexture;
uniform sampler2D reflectionsTexture;

uniform float samples;

#include <boxBlur>

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
    vec4 reflectionsTexel = texture2D(reflectionsTexture, vUv);
    ivec2 size = textureSize(reflectionsTexture, 0);
    vec2 invTexSize = 1. / vec2(size.x, size.y);

    vec3 reflectionClr = reflectionsTexel.xyz;

    if (blur > FLOAT_EPSILON) {
        vec3 blurredReflectionsColor = denoise(reflectionsTexel.rgb, reflectionsTexture, vUv, invTexSize, blur, blurSharpness, blurKernel);

        reflectionClr = mix(reflectionClr, blurredReflectionsColor.rgb, blur);
    }

#if RENDER_MODE == MODE_DEFAULT
    outputColor = vec4(inputColor.rgb + reflectionClr, 1.0);
#endif

#if RENDER_MODE == MODE_REFLECTIONS
    outputColor = vec4(reflectionClr, 1.0);
#endif

#if RENDER_MODE == MODE_RAW_REFLECTION
    outputColor = vec4(reflectionsTexel.xyz, 1.0);
#endif

#if RENDER_MODE == MODE_BLURRED_REFLECTIONS
    outputColor = vec4(blurredReflectionsTexel.xyz, 1.0);
#endif

#if RENDER_MODE == MODE_INPUT
    outputColor = vec4(inputColor.xyz, 1.0);
#endif

#if RENDER_MODE == MODE_BLUR_MIX
    outputColor = vec4(vec3(blur), 1.0);
#endif
}`, zI = `// source: https://github.com/mrdoob/three.js/blob/dev/examples/js/shaders/SSAOShader.js
vec3 getViewPosition(const float depth) {
    float clipW = _projectionMatrix[2][3] * depth + _projectionMatrix[3][3];
    vec4 clipPosition = vec4((vec3(vUv, depth) - 0.5) * 2.0, 1.0);
    clipPosition *= clipW;
    return (_inverseProjectionMatrix * clipPosition).xyz;
}

// source: https://github.com/mrdoob/three.js/blob/342946c8392639028da439b6dc0597e58209c696/examples/js/shaders/SAOShader.js#L123
float getViewZ(const in float depth) {
#ifdef PERSPECTIVE_CAMERA
    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
#else
    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
#endif
}

// credits for transforming screen position to world position: https://discourse.threejs.org/t/reconstruct-world-position-in-screen-space-from-depth-buffer/5532/2
vec3 screenSpaceToWorldSpace(const vec2 uv, const float depth) {
    vec4 ndc = vec4(
        (uv.x - 0.5) * 2.0,
        (uv.y - 0.5) * 2.0,
        (depth - 0.5) * 2.0,
        1.0);

    vec4 clip = _inverseProjectionMatrix * ndc;
    vec4 view = cameraMatrixWorld * (clip / clip.w);

    return view.xyz;
}

// vec2 worldSpaceToScreenSpace(vec3 worldPos){
//     vec4 ssPos = _projectionMatrix * inverse(cameraMatrixWorld) * vec4(worldPos, 1.0);
//     ssPos.xy /= ssPos.w;
//     ssPos.xy = ssPos.xy * 0.5 + 0.5;

//     return ssPos.xy;
// }

#define Scale (vec3(0.8, 0.8, 0.8))
#define K     (19.19)

vec3 hash(vec3 a) {
    a = fract(a * Scale);
    a += dot(a, a.yxz + K);
    return fract((a.xxy + a.yxx) * a.zyx);
}

// source: https://github.com/blender/blender/blob/594f47ecd2d5367ca936cf6fc6ec8168c2b360d0/source/blender/gpu/shaders/material/gpu_shader_material_fresnel.glsl
float fresnel_dielectric_cos(float cosi, float eta) {
    /* compute fresnel reflectance without explicitly computing
     * the refracted direction */
    float c = abs(cosi);
    float g = eta * eta - 1.0 + c * c;
    float result;

    if (g > 0.0) {
        g = sqrt(g);
        float A = (g - c) / (g + c);
        float B = (c * (g + c) - 1.0) / (c * (g - c) + 1.0);
        result = 0.5 * A * A * (1.0 + B * B);
    } else {
        result = 1.0; /* TIR (no refracted component) */
    }

    return result;
}

// source: https://github.com/blender/blender/blob/594f47ecd2d5367ca936cf6fc6ec8168c2b360d0/source/blender/gpu/shaders/material/gpu_shader_material_fresnel.glsl
float fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta) {
    /* compute fresnel reflectance without explicitly computing
     * the refracted direction */

    float cosine = dot(Incoming, Normal);
    return min(1.0, 5.0 * fresnel_dielectric_cos(cosine, eta));
}`, YK = `#define INV_EULER 0.36787944117144233

alpha = 0.0;

// alpha = velocityDisocclusion < FLOAT_EPSILON ? (alpha + 0.0075) : 0.0;
// alpha = clamp(alpha, 0.0, 1.0);

bool needsBlur = !didReproject || velocityDisocclusion > 0.5;

#ifdef boxBlur
if (needsBlur) inputColor = boxBlurredColor;
#endif

if (alpha == 1.0) {
    outputColor = accumulatedColor;
} else {
    float m = mix(alpha, 1.0, blend);

    // if there's been an abrupt change (e.g. teleporting) then we need to entirely use the input color
    if (needsBlur) m = 0.0;

    outputColor = accumulatedColor * m + inputColor * (1.0 - m);
}
`, KK = () => {
  try {
    const n = document.createElement("canvas");
    return !!(window.WebGL2RenderingContext && n.getContext("webgl2"));
  } catch {
    return !1;
  }
}, JK = KK();
class QK extends Yn {
  constructor() {
    super({
      type: "MRTMaterial",
      defines: {
        USE_UV: "",
        TEMPORAL_RESOLVE: ""
      },
      uniforms: {
        opacity: new Ne(1),
        normalMap: new Ne(null),
        normalScale: new Ne(new ze(1, 1)),
        uvTransform: new Ne(new ur()),
        roughness: new Ne(1),
        roughnessMap: new Ne(null)
      },
      vertexShader: `
                #ifdef USE_MRT
                 varying vec2 vHighPrecisionZW;
                #endif
                #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <common>
                #include <uv_pars_vertex>
                #include <displacementmap_pars_vertex>
                #include <normal_pars_vertex>
                #include <morphtarget_pars_vertex>
                #include <skinning_pars_vertex>
                #include <logdepthbuf_pars_vertex>
                #include <clipping_planes_pars_vertex>
                void main() {
                    #include <uv_vertex>
                    #include <beginnormal_vertex>
                    #include <morphnormal_vertex>
                    #include <skinbase_vertex>
                    #include <skinnormal_vertex>
                    #include <defaultnormal_vertex>
                    #include <normal_vertex>
                    #include <begin_vertex>
                    #include <morphtarget_vertex>
                    #include <skinning_vertex>
                    #include <displacementmap_vertex>
                    #include <project_vertex>
                    #include <logdepthbuf_vertex>
                    #include <clipping_planes_vertex>
                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                        vViewPosition = - mvPosition.xyz;
                    #endif
                    #ifdef USE_MRT
                        vHighPrecisionZW = gl_Position.zw;
                    #endif 
                    #ifdef USE_UV
                        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
                    #endif
                }
            `,
      fragmentShader: `
                 #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <packing>
                #include <uv_pars_fragment>
                #include <normal_pars_fragment>
                #include <bumpmap_pars_fragment>
                #include <normalmap_pars_fragment>
                #include <logdepthbuf_pars_fragment>
                #include <clipping_planes_pars_fragment>
                #include <roughnessmap_pars_fragment>
                
                #ifdef USE_MRT
                layout(location = 0) out vec4 gNormal;
                layout(location = 1) out vec4 gDepth;
                
                varying vec2 vHighPrecisionZW;
                #endif
                uniform float roughness;
                void main() {
                    #include <clipping_planes_fragment>
                    #include <logdepthbuf_fragment>
                    #include <normal_fragment_begin>
                    #include <normal_fragment_maps>

                    float roughnessFactor = roughness;
                    
                    if(roughness > 10.0e9){
                        roughnessFactor = 1.;
                    }else{
                        #ifdef useRoughnessMap
                            vec4 texelRoughness = texture2D( roughnessMap, vUv );
                            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
                            roughnessFactor *= texelRoughness.g;
                        #endif
                    }

                    vec3 normalColor = packNormalToRGB( normal );
                    #ifdef USE_MRT
                        float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                        vec4 depthColor = packDepthToRGBA( fragCoordZ );
                        gNormal = vec4( normalColor, roughnessFactor );
                        gDepth = depthColor;
                    #else
                        gl_FragColor = vec4(normalColor, roughnessFactor);
                    #endif
                }
            `,
      toneMapped: !1
    }), this.normalMapType = my, this.normalScale = new ze(1, 1), Object.defineProperty(this, "glslVersion", {
      get() {
        return "USE_MRT" in this.defines ? p2 : null;
      },
      set(e) {
      }
    });
  }
}
const eJ = `varying vec2 vUv;

void main() {
    vUv = position.xy * 0.5 + 0.5;
    gl_Position = vec4(position.xy, 1.0, 1.0);
}`, tJ = `varying vec2 vUv;

uniform sampler2D inputTexture;
uniform sampler2D accumulatedTexture;
uniform sampler2D normalTexture;
uniform sampler2D depthTexture;
uniform sampler2D envMap;

uniform mat4 _projectionMatrix;
uniform mat4 _inverseProjectionMatrix;
uniform mat4 cameraMatrixWorld;
uniform float cameraNear;
uniform float cameraFar;

uniform float rayDistance;
uniform float intensity;
uniform float maxDepthDifference;
uniform float roughnessFade;
uniform float maxRoughness;
uniform float fade;
uniform float thickness;
uniform float ior;

uniform float samples;

uniform float jitter;
uniform float jitterRoughness;

#define INVALID_RAY_COORDS vec2(-1.0);
#define EARLY_OUT_COLOR    vec4(0.0, 0.0, 0.0, 1.0)
#define FLOAT_EPSILON      0.00001

float nearMinusFar;
float nearMulFar;
float farMinusNear;

#include <packing>

// helper functions
#include <helperFunctions>

vec2 RayMarch(vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference);
vec2 BinarySearch(in vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference);
float fastGetViewZ(const in float depth);
vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness);

void main() {
    vec4 depthTexel = textureLod(depthTexture, vUv, 0.0);

    // filter out sky
    if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) {
        gl_FragColor = EARLY_OUT_COLOR;
        return;
    }

    float unpackedDepth = unpackRGBAToDepth(depthTexel);

    vec4 normalTexel = textureLod(normalTexture, vUv, 0.0);
    float roughness = normalTexel.a;

    float specular = 1.0 - roughness;

    // pre-calculated variables for the "fastGetViewZ" function
    nearMinusFar = cameraNear - cameraFar;
    nearMulFar = cameraNear * cameraFar;
    farMinusNear = cameraFar - cameraNear;

    normalTexel.rgb = unpackRGBToNormal(normalTexel.rgb);

    // view-space depth
    float depth = fastGetViewZ(unpackedDepth);

    // view-space position of the current texel
    vec3 viewPos = getViewPosition(depth);
    vec3 viewDir = normalize(viewPos);
    vec3 viewNormal = normalTexel.xyz;

    // world-space position of the current texel
    vec3 worldPos = screenSpaceToWorldSpace(vUv, unpackedDepth);

    // jitteriing
    vec3 jitt = vec3(0.0);

    if (jitterRoughness != 0.0 || jitter != 0.0) {
        vec3 randomJitter = hash(50.0 * samples * worldPos) - 0.5;
        float spread = ((2.0 - specular) + roughness * jitterRoughness);
        float jitterMix = jitter * 0.25 + jitterRoughness * roughness;
        if (jitterMix > 1.0) jitterMix = 1.0;
        jitt = mix(vec3(0.0), randomJitter * spread, jitterMix);
    }

    viewNormal += jitt;

    float fresnelFactor = fresnel_dielectric(viewDir, viewNormal, ior);

    vec3 iblRadiance = getIBLRadiance(-viewDir, viewNormal, 0.) * fresnelFactor;

    float lastFrameAlpha = textureLod(accumulatedTexture, vUv, 0.0).a;

    if (roughness > maxRoughness || (roughness > 1.0 - FLOAT_EPSILON && roughnessFade > 1.0 - FLOAT_EPSILON)) {
        gl_FragColor = vec4(iblRadiance, lastFrameAlpha);
        return;
    }

    // view-space reflected ray
    vec3 reflected = reflect(viewDir, viewNormal);

    vec3 rayDir = reflected * -viewPos.z;

    vec3 hitPos = viewPos;
    float rayHitDepthDifference;

    vec2 coords = RayMarch(rayDir, hitPos, rayHitDepthDifference);

    if (coords.x == -1.0) {
        gl_FragColor = vec4(iblRadiance, lastFrameAlpha);
        return;
    }

    vec4 SSRTexel = textureLod(inputTexture, coords.xy, 0.0);
    vec4 SSRTexelReflected = textureLod(accumulatedTexture, coords.xy, 0.0);

    vec3 SSR = SSRTexel.rgb + SSRTexelReflected.rgb;

    float roughnessFactor = mix(specular, 1.0, max(0.0, 1.0 - roughnessFade));

    vec2 coordsNDC = (coords.xy * 2.0 - 1.0);
    float screenFade = 0.1;
    float maxDimension = min(1.0, max(abs(coordsNDC.x), abs(coordsNDC.y)));
    float reflectionIntensity = 1.0 - (max(0.0, maxDimension - screenFade) / (1.0 - screenFade));
    reflectionIntensity = max(0., reflectionIntensity);

    vec3 finalSSR = mix(iblRadiance, SSR, reflectionIntensity) * roughnessFactor;

    // vec2 dCoords = smoothstep(0.2, 0.6, abs(vec2(0.5, 0.5) - coords.xy));
    // float screenEdgefactor = clamp(1.0 - (dCoords.x + dCoords.y), 0.0, 1.0);
    // vec3 finalSSR = mix(iblRadiance, SSR * screenEdgefactor, screenEdgefactor) * roughnessFactor;

    if (fade != 0.0) {
        vec3 hitWorldPos = screenSpaceToWorldSpace(coords, rayHitDepthDifference);

        // distance from the reflection point to what it's reflecting
        float reflectionDistance = distance(hitWorldPos, worldPos) + 1.0;

        float opacity = 1.0 / (reflectionDistance * fade * 0.1);
        if (opacity > 1.0) opacity = 1.0;
        finalSSR *= opacity;
    }

    finalSSR *= fresnelFactor * intensity;
    finalSSR = min(vec3(1.0), finalSSR);

    float alpha = hitPos.z == 1.0 ? 1.0 : SSRTexelReflected.a;
    alpha = min(lastFrameAlpha, alpha);

    gl_FragColor = vec4(finalSSR, alpha);
}

vec2 RayMarch(vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference) {
    dir = normalize(dir);
    dir *= rayDistance / float(steps);

    float depth;
    vec4 projectedCoord;
    vec4 lastProjectedCoord;
    float unpackedDepth;
    vec4 depthTexel;

    for (int i = 0; i < steps; i++) {
        hitPos += dir;

        projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);
        projectedCoord.xy /= projectedCoord.w;
        // [-1, 1] --> [0, 1] (NDC to screen position)
        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;

// the ray is outside the camera's frustum
#ifndef missedRays
        if (projectedCoord.x < 0.0 || projectedCoord.x > 1.0 || projectedCoord.y < 0.0 || projectedCoord.y > 1.0) {
            return INVALID_RAY_COORDS;
        }
#endif

        depthTexel = textureLod(depthTexture, projectedCoord.xy, 0.0);

        unpackedDepth = unpackRGBAToDepth(depthTexel);

        depth = fastGetViewZ(unpackedDepth);

        rayHitDepthDifference = depth - hitPos.z;

        if (rayHitDepthDifference >= 0.0 && rayHitDepthDifference < thickness) {
#if refineSteps == 0
            // filter out sky
            if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) return INVALID_RAY_COORDS;
#else
            return BinarySearch(dir, hitPos, rayHitDepthDifference);
#endif
        }

#ifndef missedRays
        // the ray is behind the camera
        if (hitPos.z > 0.0) {
            return INVALID_RAY_COORDS;
        }
#endif

        lastProjectedCoord = projectedCoord;
    }

    // since hitPos isn't used anywhere we can use it to mark that this reflection would have been invalid
    hitPos.z = 1.0;

#ifndef missedRays
    return INVALID_RAY_COORDS;
#endif

    rayHitDepthDifference = unpackedDepth;

    return projectedCoord.xy;
}

vec2 BinarySearch(in vec3 dir, inout vec3 hitPos, inout float rayHitDepthDifference) {
    float depth;
    vec4 projectedCoord;
    vec2 lastMinProjectedCoordXY;
    float unpackedDepth;
    vec4 depthTexel;

    for (int i = 0; i < refineSteps; i++) {
        projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);
        projectedCoord.xy /= projectedCoord.w;
        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;

        depthTexel = textureLod(depthTexture, projectedCoord.xy, 0.0);

        unpackedDepth = unpackRGBAToDepth(depthTexel);
        depth = fastGetViewZ(unpackedDepth);

        rayHitDepthDifference = depth - hitPos.z;

        dir *= 0.5;

        if (rayHitDepthDifference > 0.0) {
            hitPos -= dir;
        } else {
            hitPos += dir;
        }
    }

    // filter out sky
    if (dot(depthTexel.rgb, depthTexel.rgb) < FLOAT_EPSILON) return INVALID_RAY_COORDS;

    if (abs(rayHitDepthDifference) > maxDepthDifference) return INVALID_RAY_COORDS;

    projectedCoord = _projectionMatrix * vec4(hitPos, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;

    rayHitDepthDifference = unpackedDepth;

    return projectedCoord.xy;
}

// source: https://github.com/mrdoob/three.js/blob/342946c8392639028da439b6dc0597e58209c696/examples/js/shaders/SAOShader.js#L123
float fastGetViewZ(const in float depth) {
#ifdef PERSPECTIVE_CAMERA
    return nearMulFar / (farMinusNear * depth - cameraFar);
#else
    return depth * nearMinusFar - cameraNear;
#endif
}

#include <common>
#include <cube_uv_reflection_fragment>

// from: https://github.com/mrdoob/three.js/blob/d5b82d2ca410e2e24ca2f7320212dfbee0fe8e89/src/renderers/shaders/ShaderChunk/envmap_physical_pars_fragment.glsl.js#L22
vec3 getIBLRadiance(const in vec3 viewDir, const in vec3 normal, const in float roughness) {
#if defined(ENVMAP_TYPE_CUBE_UV)
    vec3 reflectVec = reflect(-viewDir, normal);

    // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
    reflectVec = normalize(mix(reflectVec, normal, roughness * roughness));
    reflectVec = inverseTransformDirection(reflectVec, viewMatrix);

    vec4 envMapColor = textureCubeUV(envMap, reflectVec, roughness);
    return envMapColor.rgb * intensity;
#else
    return vec3(0.0);
#endif
}`;
class nJ extends Yn {
  constructor() {
    super({
      type: "ReflectionsMaterial",
      uniforms: {
        inputTexture: new Ne(null),
        accumulatedTexture: new Ne(null),
        normalTexture: new Ne(null),
        depthTexture: new Ne(null),
        _projectionMatrix: new Ne(new Pt()),
        _inverseProjectionMatrix: new Ne(new Pt()),
        cameraMatrixWorld: new Ne(new Pt()),
        cameraNear: new Ne(0),
        cameraFar: new Ne(0),
        rayDistance: new Ne(0),
        intensity: new Ne(0),
        roughnessFade: new Ne(0),
        fade: new Ne(0),
        thickness: new Ne(0),
        ior: new Ne(0),
        maxDepthDifference: new Ne(0),
        jitter: new Ne(0),
        jitterRoughness: new Ne(0),
        maxRoughness: new Ne(0),
        samples: new Ne(0),
        viewMatrix: new Ne(new Pt())
      },
      defines: {
        steps: 20,
        refineSteps: 5,
        vWorldPosition: "worldPos"
      },
      fragmentShader: tJ.replace(
        "#include <helperFunctions>",
        zI
      ),
      vertexShader: eJ,
      toneMapped: !1,
      depthWrite: !1,
      depthTest: !1
    });
  }
}
const FI = (n) => {
  const e = [n], t = [];
  for (; e.length !== 0; ) {
    const i = e.shift();
    i.material && t.push(i);
    for (const r of i.children)
      r.visible && e.push(r);
  }
  return t;
};
class iJ extends Cr {
  constructor(t, i = {}) {
    super("ReflectionsPass");
    V(this, "ssrEffect");
    V(this, "cachedMaterials", /* @__PURE__ */ new WeakMap());
    V(this, "USE_MRT", !1);
    V(this, "webgl1DepthPass", null);
    V(this, "visibleMeshes", []);
    this.ssrEffect = t, this._scene = t._scene, this._camera = t._camera, this.fullscreenMaterial = new nJ(), t._camera.isPerspectiveCamera && (this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = "");
    const r = i.width || typeof window < "u" ? window.innerWidth : 2e3, s = i.height || typeof window < "u" ? window.innerHeight : 1e3;
    this.renderTarget = new On(r, s, {
      minFilter: Zt,
      magFilter: Zt,
      type: $r,
      depthBuffer: !1
    }), this.renderPass = new Vv(this._scene, this._camera), this.USE_MRT = JK, this.USE_MRT ? (this.gBuffersRenderTarget = new X9(
      r,
      s,
      2,
      {
        minFilter: Zt,
        magFilter: Zt
      }
    ), this.normalTexture = this.gBuffersRenderTarget.texture[0], this.depthTexture = this.gBuffersRenderTarget.texture[1]) : (this.webgl1DepthPass = new OE(this._scene, this._camera), this.webgl1DepthPass.renderTarget.minFilter = Zt, this.webgl1DepthPass.renderTarget.magFilter = Zt, this.webgl1DepthPass.renderTarget.texture.minFilter = Zt, this.webgl1DepthPass.renderTarget.texture.magFilter = Zt, this.webgl1DepthPass.setSize(
      typeof window < "u" ? window.innerWidth : 2e3,
      typeof window < "u" ? window.innerHeight : 1e3
    ), this.gBuffersRenderTarget = new On(r, s, {
      minFilter: Zt,
      magFilter: Zt
    }), this.normalTexture = this.gBuffersRenderTarget.texture, this.depthTexture = this.webgl1DepthPass.texture), this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture, this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture, this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture, this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld, this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix, this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse;
  }
  setSize(t, i) {
    this.renderTarget.setSize(
      t * this.ssrEffect.resolutionScale,
      i * this.ssrEffect.resolutionScale
    ), this.gBuffersRenderTarget.setSize(
      t * this.ssrEffect.resolutionScale,
      i * this.ssrEffect.resolutionScale
    ), this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture, this.fullscreenMaterial.needsUpdate = !0;
  }
  dispose() {
    this.renderTarget.dispose(), this.gBuffersRenderTarget.dispose(), this.renderPass.dispose(), this.USE_MRT || this.webgl1DepthPass.dispose(), this.fullscreenMaterial.dispose(), this.normalTexture = null, this.depthTexture = null, this.velocityTexture = null;
  }
  keepMaterialMapUpdated(t, i, r, s) {
    this.ssrEffect[s] ? i[r] !== t[r] && (t[r] = i[r], t.uniforms[r].value = i[r], i[r] ? t.defines[s] = "" : delete t.defines[s], t.needsUpdate = !0) : t[r] !== void 0 && (t[r] = void 0, t.uniforms[r].value = void 0, delete t.defines[s], t.needsUpdate = !0);
  }
  setMRTMaterialInScene() {
    this.visibleMeshes = FI(this._scene);
    for (const t of this.visibleMeshes)
      if (t.material) {
        const i = t.material;
        let [r, s] = this.cachedMaterials.get(t) || [];
        if (i !== r) {
          s && s.dispose(), s = new QK(), this.USE_MRT && (s.defines.USE_MRT = ""), s.normalScale = i.normalScale, s.uniforms.normalScale.value = i.normalScale;
          const o = i.map || i.normalMap || i.roughnessMap || i.metalnessMap;
          o && (s.uniforms.uvTransform.value = o.matrix), this.cachedMaterials.set(t, [i, s]);
        }
        this.keepMaterialMapUpdated(
          s,
          i,
          "normalMap",
          "useNormalMap"
        ), this.keepMaterialMapUpdated(
          s,
          i,
          "roughnessMap",
          "useRoughnessMap"
        ), s.uniforms.roughness.value = this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(t) ? i.roughness || 0 : 1e11, t.material = s;
      }
  }
  unsetMRTMaterialInScene() {
    var t;
    for (const i of this.visibleMeshes)
      if (((t = i.material) == null ? void 0 : t.type) === "MRTMaterial") {
        i.visible = !0;
        const [r] = this.cachedMaterials.get(i);
        i.material = r;
      }
  }
  render(t, i) {
    this.setMRTMaterialInScene(), t.setRenderTarget(this.gBuffersRenderTarget), this.renderPass.render(t, this.gBuffersRenderTarget), this.unsetMRTMaterialInScene(), this.USE_MRT || this.webgl1DepthPass.renderPass.render(
      t,
      this.webgl1DepthPass.renderTarget
    ), this.fullscreenMaterial.uniforms.inputTexture.value = i.texture, this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples, this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near, this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far, this.fullscreenMaterial.uniforms.viewMatrix.value.copy(
      this._camera.matrixWorldInverse
    ), t.setRenderTarget(this.renderTarget), t.render(this.scene, this.camera);
  }
}
const Ub = /* @__PURE__ */ new Set();
let BI;
const rJ = () => {
  BI = bt.background, bt.background = null;
  for (const n of Ub)
    n.visible = !1;
}, sJ = () => {
  bt.background = BI;
  for (const n of Ub)
    n.visible = !0;
}, GR = {
  intensity: 1,
  exponent: 1,
  distance: 6,
  fade: 0,
  roughnessFade: 1,
  thickness: 10,
  ior: 1.45,
  maxRoughness: 1,
  maxDepthDifference: 10,
  blend: 0.9,
  correction: 0.5,
  correctionRadius: 1,
  blur: 1,
  blurKernel: 2,
  blurSharpness: 0,
  jitter: 0.2,
  jitterRoughness: 0,
  steps: 1,
  refineSteps: 0,
  missedRays: !0,
  useNormalMap: !0,
  useRoughnessMap: !0,
  resolutionScale: 1,
  velocityResolutionScale: 1
}, oJ = `varying vec2 vUv;

void main() {
    vUv = position.xy * 0.5 + 0.5;
    gl_Position = vec4(position.xy, 1.0, 1.0);
}`, aJ = `// a basic shader to implement temporal resolving

uniform sampler2D inputTexture;
uniform sampler2D accumulatedTexture;
uniform sampler2D velocityTexture;
uniform sampler2D lastVelocityTexture;

uniform float blend;
uniform float correction;
uniform float exponent;
uniform float samples;
uniform vec2 invTexSize;

uniform mat4 curInverseProjectionMatrix;
uniform mat4 curCameraMatrixWorld;
uniform mat4 prevInverseProjectionMatrix;
uniform mat4 prevCameraMatrixWorld;

varying vec2 vUv;

#define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001
#define FLOAT_EPSILON                 0.00001
#define FLOAT_ONE_MINUS_EPSILON       0.99999

vec3 transformexponent;
vec3 undoColorTransformExponent;

// idea from: https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/
vec3 transformColor(vec3 color) {
    if (exponent == 1.0) return color;

    return pow(abs(color), transformexponent);
}

vec3 undoColorTransform(vec3 color) {
    if (exponent == 1.0) return color;

    return max(pow(abs(color), undoColorTransformExponent), vec3(0.0));
}

void main() {
    if (exponent != 1.0) {
        transformexponent = vec3(1.0 / exponent);
        undoColorTransformExponent = vec3(exponent);
    }

    vec4 inputTexel = textureLod(inputTexture, vUv, 0.0);
    vec4 accumulatedTexel;

    vec3 inputColor = transformColor(inputTexel.rgb);
    vec3 accumulatedColor;

    float alpha = inputTexel.a;

    // REPROJECT_START

    float velocityDisocclusion;
    bool didReproject = false;

#ifdef boxBlur
    vec3 boxBlurredColor = inputTexel.rgb;
#endif

    vec4 velocity = textureLod(velocityTexture, vUv, 0.0);
    bool isMoving = alpha < 1.0 || dot(velocity.xy, velocity.xy) > 0.0;

    if (isMoving) {
        vec3 minNeighborColor = inputColor;
        vec3 maxNeighborColor = inputColor;

        vec3 col;
        vec2 neighborUv;

        vec2 reprojectedUv = vUv - velocity.xy;
        vec4 lastVelocity = textureLod(lastVelocityTexture, reprojectedUv, 0.0);

        float depth = velocity.b;
        float closestDepth = depth;
        float lastClosestDepth = lastVelocity.b;
        float neighborDepth;
        float lastNeighborDepth;

        for (int x = -correctionRadius; x <= correctionRadius; x++) {
            for (int y = -correctionRadius; y <= correctionRadius; y++) {
                if (x != 0 || y != 0) {
                    neighborUv = vUv + vec2(x, y) * invTexSize;
                    vec4 neigborVelocity = textureLod(velocityTexture, neighborUv, 0.0);
                    neighborDepth = neigborVelocity.b;

                    col = textureLod(inputTexture, neighborUv, 0.0).xyz;

                    int absX = abs(x);
                    int absY = abs(y);

#ifdef dilation
                    if (absX == 1 && absY == 1) {
                        if (neighborDepth > closestDepth) {
                            velocity = neigborVelocity;
                            closestDepth = neighborDepth;
                        }

                        vec4 lastNeighborVelocity = textureLod(velocityTexture, vUv + vec2(x, y) * invTexSize, 0.0);
                        lastNeighborDepth = lastNeighborVelocity.b;

                        if (neighborDepth > closestDepth) {
                            lastVelocity = lastNeighborVelocity;
                            lastClosestDepth = lastNeighborDepth;
                        }
                    }
#endif

                    // the neighbor pixel is invalid if it's too far away from this pixel
                    if (abs(depth - neighborDepth) < MAX_NEIGHBOR_DEPTH_DIFFERENCE) {
#ifdef boxBlur
                        if (absX <= 2 && absY <= 2) boxBlurredColor += col;
#endif

                        col = transformColor(col);

                        minNeighborColor = min(col, minNeighborColor);
                        maxNeighborColor = max(col, maxNeighborColor);
                    }
                }
            }
        }

        // velocity
        float velocityLength = length(lastVelocity.xy - velocity.xy);

        // using the velocity to find disocclusions
        velocityDisocclusion = (velocityLength - 0.000005) * 10.0;
        velocityDisocclusion *= velocityDisocclusion;

        reprojectedUv = vUv - velocity.xy;

        // box blur

#ifdef boxBlur
        // box blur
        float pxRadius = correctionRadius > 5 ? 121.0 : pow(float(correctionRadius * 2 + 1), 2.0);
        boxBlurredColor /= pxRadius;
        boxBlurredColor = transformColor(boxBlurredColor);
#endif

        // the reprojected UV coordinates are inside the view
        if (reprojectedUv.x >= 0.0 && reprojectedUv.x <= 1.0 && reprojectedUv.y >= 0.0 && reprojectedUv.y <= 1.0) {
            accumulatedTexel = textureLod(accumulatedTexture, reprojectedUv, 0.0);
            accumulatedColor = transformColor(accumulatedTexel.rgb);

            vec3 clampedColor = clamp(accumulatedColor, minNeighborColor, maxNeighborColor);

            accumulatedColor = mix(accumulatedColor, clampedColor, correction);

            didReproject = true;
        } else {
            // reprojected UV coordinates are outside of screen
#ifdef boxBlur
            accumulatedColor = boxBlurredColor;
#else
            accumulatedColor = inputColor;
#endif
        }

        // this texel is marked as constantly moving (e.g. from a VideoTexture), so treat it accordingly
        if (velocity.r > FLOAT_ONE_MINUS_EPSILON && velocity.g > FLOAT_ONE_MINUS_EPSILON) {
            alpha = 0.0;
            velocityDisocclusion = 1.0;
        }
    } else {
        // there was no need to do neighborhood clamping, let's re-use the accumulated texel from the same UV coordinate
        accumulatedColor = transformColor(textureLod(accumulatedTexture, vUv, 0.0).rgb);
    }

    // REPROJECT_END

    vec3 outputColor = inputColor;

    // the user's shader to compose a final outputColor from the inputTexel and accumulatedTexel
#include <custom_compose_shader>

    gl_FragColor = vec4(undoColorTransform(outputColor), alpha);
}`;
class lJ extends Yn {
  constructor(e) {
    const t = aJ.replace("#include <custom_compose_shader>", e);
    super({
      type: "TemporalResolveMaterial",
      uniforms: {
        inputTexture: new Ne(null),
        accumulatedTexture: new Ne(null),
        velocityTexture: new Ne(null),
        lastVelocityTexture: new Ne(null),
        samples: new Ne(1),
        blend: new Ne(0.5),
        correction: new Ne(1),
        exponent: new Ne(1),
        invTexSize: new Ne(new ze())
      },
      defines: {
        correctionRadius: 1
      },
      vertexShader: oJ,
      fragmentShader: t
    });
  }
}
const cJ = `
		#ifdef USE_SKINNING
		#ifdef BONE_TEXTURE
			uniform sampler2D prevBoneTexture;
			mat4 getPrevBoneMatrix( const in float i ) {
				float j = i * 4.0;
				float x = mod( j, float( boneTextureSize ) );
				float y = floor( j / float( boneTextureSize ) );
				float dx = 1.0 / float( boneTextureSize );
				float dy = 1.0 / float( boneTextureSize );
				y = dy * ( y + 0.5 );
				vec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );
				vec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );
				vec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );
				vec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );
				mat4 bone = mat4( v1, v2, v3, v4 );
				return bone;
			}
		#else
			uniform mat4 prevBoneMatrices[ MAX_BONES ];
			mat4 getPrevBoneMatrix( const in float i ) {
				mat4 bone = prevBoneMatrices[ int(i) ];
				return bone;
			}
		#endif
		#endif
`, uJ = `
		vec3 transformed;

		// Get the normal
		${Nt.skinbase_vertex}
		${Nt.beginnormal_vertex}
		${Nt.skinnormal_vertex}
		${Nt.defaultnormal_vertex}

		// Get the current vertex position
		transformed = vec3( position );
		${Nt.skinning_vertex}
		newPosition = velocityMatrix * vec4( transformed, 1.0 );

		// Get the previous vertex position
		transformed = vec3( position );
		${Nt.skinbase_vertex.replace(/mat4 /g, "").replace(/getBoneMatrix/g, "getPrevBoneMatrix")}
		${Nt.skinning_vertex.replace(/vec4 /g, "")}
		prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );

		gl_Position = newPosition;
`;
class hJ extends Yn {
  constructor() {
    super({
      uniforms: {
        prevVelocityMatrix: { value: new Pt() },
        velocityMatrix: { value: new Pt() },
        prevBoneTexture: { value: null },
        interpolateGeometry: { value: 0 },
        intensity: { value: 1 },
        boneTexture: { value: null },
        alphaTest: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        opacity: { value: 1 }
      },
      vertexShader: `
                    #define MAX_BONES 1024
                    
                    ${Nt.skinning_pars_vertex}
                    ${cJ}
        
                    uniform mat4 velocityMatrix;
                    uniform mat4 prevVelocityMatrix;
                    uniform float interpolateGeometry;
                    varying vec4 prevPosition;
                    varying vec4 newPosition;
					varying vec2 vHighPrecisionZW;
        
                    void main() {
        
                        ${uJ}

						vHighPrecisionZW = gl_Position.zw;
        
                    }`,
      fragmentShader: `
                    uniform float intensity;
                    varying vec4 prevPosition;
                    varying vec4 newPosition;
					varying vec2 vHighPrecisionZW;
        
                    void main() {
						#ifdef FULL_MOVEMENT
						gl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );
						return;
						#endif

                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;
                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;
        
                        vec2 vel = pos1 - pos0;

						float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                        
                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );
        
                    }`
    }), this.isVelocityMaterial = !0;
  }
}
const dJ = new xt(0), fJ = ["visible", "wireframe", "side"];
class pJ extends Cr {
  constructor(t, i) {
    super("VelocityPass");
    V(this, "cachedMaterials", /* @__PURE__ */ new WeakMap());
    V(this, "lastCameraTransform", {
      position: new Z(),
      quaternion: new Gi()
    });
    V(this, "visibleMeshes", []);
    V(this, "renderedMeshesThisFrame", 0);
    V(this, "renderedMeshesLastFrame", 0);
    this._scene = t, this._camera = i, this.renderTarget = new On(
      (window == null ? void 0 : window.innerWidth) || 1e3,
      (window == null ? void 0 : window.innerHeight) || 1e3,
      {
        type: $r
      }
    );
  }
  setVelocityMaterialInScene() {
    var t, i;
    this.renderedMeshesThisFrame = 0, this.visibleMeshes = FI(this._scene);
    for (const r of this.visibleMeshes) {
      const s = r.material;
      let [o, a] = this.cachedMaterials.get(r) || [];
      if (s !== o && (a = new hJ(), r.material = a, (t = r.skeleton) != null && t.boneTexture && this.saveBoneTexture(r), this.cachedMaterials.set(r, [
        s,
        a
      ])), a.uniforms.velocityMatrix.value.multiplyMatrices(
        this._camera.projectionMatrix,
        r.modelViewMatrix
      ), r.userData.needsUpdatedReflections || s.map instanceof gD ? ("FULL_MOVEMENT" in a.defines || (a.needsUpdate = !0), a.defines.FULL_MOVEMENT = "") : "FULL_MOVEMENT" in a.defines && (delete a.defines.FULL_MOVEMENT, a.needsUpdate = !0), r.material = a, !!r.visible) {
        this.renderedMeshesThisFrame++;
        for (const l of fJ)
          a[l] = s[l];
        (i = r.skeleton) != null && i.boneTexture && (a.defines.USE_SKINNING = "", a.defines.BONE_TEXTURE = "", a.uniforms.boneTexture.value = r.skeleton.boneTexture);
      }
    }
  }
  saveBoneTexture(t) {
    let i = t.material.uniforms.prevBoneTexture.value;
    if (i && i.image.width === t.skeleton.boneTexture.width)
      i = t.material.uniforms.prevBoneTexture.value, i.image.data.set(t.skeleton.boneTexture.image.data);
    else {
      i == null || i.dispose();
      const r = t.skeleton.boneTexture.image.data.slice(), s = t.skeleton.boneTexture.image.width;
      i = new Ff(
        r,
        s,
        s,
        wr,
        Qs
      ), t.material.uniforms.prevBoneTexture.value = i, i.needsUpdate = !0;
    }
  }
  unsetVelocityMaterialInScene() {
    var t;
    for (const i of this.visibleMeshes)
      i.material.isVelocityMaterial && (i.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(
        this._camera.projectionMatrix,
        i.modelViewMatrix
      ), (t = i.skeleton) != null && t.boneTexture && this.saveBoneTexture(i), i.material = this.cachedMaterials.get(i)[0]);
  }
  setSize(t, i) {
    this.renderTarget.setSize(t, i);
  }
  renderVelocity(t) {
    if (t.setRenderTarget(this.renderTarget), this.renderedMeshesThisFrame > 0) {
      const { background: i } = this._scene;
      this._scene.background = dJ, t.render(this._scene, this._camera), this._scene.background = i;
    } else
      t.clearColor();
  }
  render(t) {
    this.setVelocityMaterialInScene(), (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0) && this.renderVelocity(t), this.unsetVelocityMaterialInScene(), this.renderedMeshesLastFrame = this.renderedMeshesThisFrame;
  }
}
const WR = new ze();
class mJ extends Cr {
  constructor(t, i, r, s = {}) {
    super("TemporalResolvePass");
    V(this, "velocityPass", null);
    V(this, "velocityResolutionScale", 1);
    V(this, "samples", 1);
    this._scene = t, this._camera = i, this.renderTarget = new On(1, 1, {
      minFilter: Zt,
      magFilter: Zt,
      type: $r,
      depthBuffer: !1
    }), this.velocityPass = new pJ(t, i), this.fullscreenMaterial = new lJ(
      r
    ), this.fullscreenMaterial.defines.correctionRadius = s.correctionRadius || 1, s.dilation && (this.fullscreenMaterial.defines.dilation = ""), s.boxBlur && (this.fullscreenMaterial.defines.boxBlur = ""), this.setupFramebuffers(1, 1), this.checkCanUseSharedVelocityTexture();
  }
  dispose() {
    this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture && (delete this._scene.userData.velocityTexture, delete this._scene.userData.lastVelocityTexture), this.renderTarget.dispose(), this.accumulatedTexture.dispose(), this.fullscreenMaterial.dispose(), this.velocityPass.dispose();
  }
  setSize(t, i) {
    this.renderTarget.setSize(t, i), this.velocityPass.setSize(
      t * this.velocityResolutionScale,
      i * this.velocityResolutionScale
    ), this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? kn : Zt, this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? kn : Zt, this.velocityPass.renderTarget.texture.needsUpdate = !0, this.fullscreenMaterial.uniforms.invTexSize.value.set(
      1 / t,
      1 / i
    ), this.setupFramebuffers(t, i);
  }
  setupFramebuffers(t, i) {
    this.accumulatedTexture && this.accumulatedTexture.dispose(), this.lastVelocityTexture && this.lastVelocityTexture.dispose(), this.accumulatedTexture = new nA(
      t,
      i,
      wr
    ), this.accumulatedTexture.minFilter = Zt, this.accumulatedTexture.magFilter = Zt, this.accumulatedTexture.type = $r, this.lastVelocityTexture = new nA(
      t * this.velocityResolutionScale,
      i * this.velocityResolutionScale,
      wr
    ), this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? kn : Zt, this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? kn : Zt, this.lastVelocityTexture.type = $r, this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture, this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture, this.fullscreenMaterial.needsUpdate = !0;
  }
  checkCanUseSharedVelocityTexture() {
    return this._scene.userData.velocityTexture && this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture ? this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value && (this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture, this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture, this.fullscreenMaterial.needsUpdate = !0) : this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value && (this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture, this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture, this.fullscreenMaterial.needsUpdate = !0, this._scene.userData.velocityTexture || (this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture, this._scene.userData.lastVelocityTexture = this.lastVelocityTexture)), this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value;
  }
  checkNeedsResample() {
    (Nb(this._camera) || UY(this._camera)) && (this.samples = 1);
  }
  render(t) {
    this.samples++, this.checkNeedsResample(), this.fullscreenMaterial.uniforms.samples.value = this.samples, t.setRenderTarget(this.renderTarget), t.render(this.scene, this.camera), t.copyFramebufferToTexture(WR, this.accumulatedTexture), t.setRenderTarget(this.velocityPass.renderTarget), t.copyFramebufferToTexture(WR, this.lastVelocityTexture);
  }
}
const jR = function(e, t) {
  let i = 1, r = 0;
  for (; e > 0; )
    i /= t, r += i * (e % t), e = ~~(e / t);
  return r;
}, vJ = (n) => {
  const e = [];
  let t = 1;
  const i = t + n;
  for (; t < i; t++)
    e.push([jR(t, 2) - 0.5, jR(t, 3) - 0.5]);
  return e;
}, gJ = ZK.replace("#include <helperFunctions>", zI).replace("#include <boxBlur>", $K), _J = ["blur", "blurSharpness", "blurKernel"];
class bJ extends Gf {
  constructor(t, i, r = GR) {
    super("SSREffect", gJ, {
      type: "FinalSSRMaterial",
      uniforms: /* @__PURE__ */ new Map([
        ["reflectionsTexture", new Ne(null)],
        ["blur", new Ne(0)],
        ["blurSharpness", new Ne(0)],
        ["blurKernel", new Ne(0)]
      ]),
      defines: /* @__PURE__ */ new Map([["RENDER_MODE", "0"]])
    });
    V(this, "haltonSequence", vJ(1024));
    V(this, "haltonIndex", 0);
    V(this, "selection", new zE());
    V(this, "lastSize");
    this._scene = t, this._camera = i, r = { ...GR, ...r, ...{
      boxBlur: !0,
      dilation: !0
    } }, this.temporalResolvePass = new mJ(
      t,
      i,
      YK,
      r
    ), this.uniforms.get("reflectionsTexture").value = this.temporalResolvePass.renderTarget.texture, this.reflectionsPass = new iJ(this, r), this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture, this.lastSize = {
      width: r.width,
      height: r.height,
      resolutionScale: r.resolutionScale,
      velocityResolutionScale: r.velocityResolutionScale
    }, this.setSize(r.width, r.height), this.makeOptionsReactive(r);
  }
  makeOptionsReactive(t) {
    let i = !1;
    const r = this.reflectionsPass.fullscreenMaterial.uniforms, s = Object.keys(
      r
    );
    for (const o of Object.keys(t))
      Object.defineProperty(this, o, {
        get() {
          return t[o];
        },
        set(a) {
          if (!(t[o] === a && i))
            switch (t[o] = a, _J.includes(o) || this.setSize(
              this.lastSize.width,
              this.lastSize.height,
              !0
            ), o) {
              case "resolutionScale":
                this.setSize(
                  this.lastSize.width,
                  this.lastSize.height
                );
                break;
              case "velocityResolutionScale":
                this.temporalResolvePass.velocityResolutionScale = a, this.setSize(
                  this.lastSize.width,
                  this.lastSize.height,
                  !0
                );
                break;
              case "blur":
                this.uniforms.get("blur").value = a;
                break;
              case "blurSharpness":
                this.uniforms.get("blurSharpness").value = a;
                break;
              case "blurKernel":
                this.uniforms.get("blurKernel").value = a;
                break;
              case "steps":
                this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(a), this.reflectionsPass.fullscreenMaterial.needsUpdate = i;
                break;
              case "refineSteps":
                this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(a), this.reflectionsPass.fullscreenMaterial.needsUpdate = i;
                break;
              case "missedRays":
                a ? this.reflectionsPass.fullscreenMaterial.defines.missedRays = "" : delete this.reflectionsPass.fullscreenMaterial.defines.missedRays, this.reflectionsPass.fullscreenMaterial.needsUpdate = i;
                break;
              case "correctionRadius":
                this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(a), this.temporalResolvePass.fullscreenMaterial.needsUpdate = i;
                break;
              case "blend":
                this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = a;
                break;
              case "correction":
                this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = a;
                break;
              case "exponent":
                this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = a;
                break;
              case "distance":
                r.rayDistance.value = a;
              default:
                s.includes(
                  o
                ) && (r[o].value = a);
            }
        }
      }), this[o] = t[o];
    i = !0;
  }
  setSize(t, i, r = !1) {
    !r && t === this.lastSize.width && i === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale && this.velocityResolutionScale === this.lastSize.velocityResolutionScale || (this.temporalResolvePass.setSize(t, i), this.reflectionsPass.setSize(t, i), this.lastSize = {
      width: t,
      height: i,
      resolutionScale: this.resolutionScale,
      velocityResolutionScale: this.velocityResolutionScale
    });
  }
  setIBLRadiance(t, i) {
    this._scene.traverse((r) => {
      var s;
      if (r.material) {
        const o = (s = i.properties.get(r.material)) == null ? void 0 : s.uniforms;
        o && "disableIBLRadiance" in o && (o.disableIBLRadiance.value = t);
      }
    });
  }
  dispose() {
    super.dispose(), this.reflectionsPass.dispose(), this.temporalResolvePass.dispose();
  }
  update(t, i) {
    rJ(), this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length;
    const [r, s] = this.haltonSequence[this.haltonIndex], { width: o, height: a } = this.lastSize;
    this.temporalResolvePass.velocityPass.render(t), this._camera.setViewOffset && this._camera.setViewOffset(o, a, r, s, o, a), this.reflectionsPass.render(t, i), this.temporalResolvePass.render(t), this._camera.clearViewOffset(), sJ();
  }
}
const [qR, XR] = Be(void 0);
ft(() => {
  if (!uM())
    return;
  const n = new bJ(bt, nt());
  qR(n);
  const e = NI(
    (t) => Bs(n, "intensity", t)
  );
  return () => {
    qR(void 0), n.dispose(), e.cancel();
  };
}, [uM, nt]);
const [yJ, hM] = Be(!1), [$R, ZR] = Be(void 0);
ft(() => {
  if (!hM())
    return;
  const n = new jZ({
    eskil: !0,
    offset: 0.35,
    darkness: 0.5
  });
  return $R(n), () => {
    $R(void 0), n.dispose();
  };
}, [hM, nt]);
const la = new K$(void 0, {
  frameBufferType: $r
});
la.multisampling = 4;
Ln((n) => n && la.setRenderer(n));
ft(() => {
  const n = new Vv(bt, nt());
  return la.addPass(n, 0), () => {
    la.removePass(n), n.dispose();
  };
}, [nt, Ln]);
ft(() => {
  if (!Ln())
    return;
  const [n, e] = Lo();
  la.setSize(n, e);
}, [Ln, Lo]);
ft(() => {
  if (!Ln())
    return;
  const n = Bb();
  n && la.addPass(n);
  const e = new W$(
    nt(),
    ...[
      zR(),
      mR(),
      XR(),
      HR(),
      dR(),
      BR(),
      ZR()
    ].filter(Boolean)
  );
  return la.addPass(e), () => {
    la.removePass(e), n && la.removePass(n), e.dispose();
  };
}, [
  nt,
  Ln,
  zR,
  mR,
  XR,
  HR,
  dR,
  BR,
  ZR,
  Bb
]);
let x_ = "medium";
class xJ {
  constructor() {
    V(this, "start", 0);
    V(this, "end", 0);
    V(this, "frameCount", 60);
    V(this, "frameTimes", []);
    V(this, "listenerEvent");
  }
  tickStart() {
    this.start = performance.now();
  }
  tick() {
    const t = performance.now() - this.start;
    this.frameTimes.push(t), this.calculatePerformance();
  }
  calculatePerformance() {
    if (this.frameTimes.length >= this.frameCount) {
      const e = this.frameTimes.reduce((t, i) => t + i, 0) / this.frameCount;
      e < 16 ? x_ = "high" : e < 50 ? x_ = "medium" : x_ = "low", this.listenerEvent && this.listenerEvent(x_), this.frameTimes.length = 0, this.frameCount = 120;
    }
  }
  addEventListener(e) {
    this.listenerEvent = e;
  }
}
const dS = new xJ();
ft(() => {
  const n = Ln();
  if (!n)
    return;
  const e = nt();
  if (Zu()) {
    const [i, r] = Lo(), s = i * 1, o = r * 0.5, a = rv();
    a.aspect = e.aspect = s / o, e.updateProjectionMatrix(), a.updateProjectionMatrix();
    const l = ku(() => {
      $1(), hS(), n.setViewport(0, 0, s, o), n.setScissor(0, 0, s, o), n.setScissorTest(!0), n.render(bt, a), n.setViewport(0, o, s, o), n.setScissor(0, o, s, o), n.render(bt, e), dS.tick(), K1();
    });
    return () => {
      l.cancel(), n.setViewport(0, 0, i, r), n.setScissor(0, 0, i, r), n.setScissorTest(!1), e.aspect = i / r, e.updateProjectionMatrix();
    };
  }
  if (wf()) {
    const i = ku(() => {
      $1(), hS(), n.render(bt, e), K1();
    });
    return () => {
      i.cancel();
    };
  }
  const t = ku(() => {
    $1(), hS(), dS.tickStart(), n.render, la.render(Iv[0]), dS.tick(), K1();
  });
  return () => {
    t.cancel();
  };
}, [wf, nt, rv, Zu, Lo, Ln]);
const wJ = /* @__PURE__ */ new Map(), SJ = new Rq(), MJ = (n) => Mr(
  wJ,
  n.join(","),
  () => SJ.load(n, void 0, Ry(n.join(",")))
), [EJ, dM] = Be(void 0), [sC, uv] = Be([]), CJ = nh(sC, uv), TJ = ih(sC, uv), [oC, hv] = Be([]), PJ = nh(
  oC,
  hv
), AJ = ih(
  oC,
  hv
), RJ = LL(
  oC,
  hv
), YR = {
  studio: "studio.jpg",
  day: "day.hdr",
  night: "night.hdr"
}, kJ = {
  ...Fv,
  texture: String,
  helper: Boolean
}, LJ = yt(
  [Bv],
  { texture: "studio", helper: !0 }
);
class Ou extends Wy {
  constructor() {
    super();
    V(this, "_texture", "studio");
    V(this, "helperState", new Je(!0));
    PJ(this), this.createEffect(() => {
      if (nt() !== un || !this.helperState.get())
        return;
      const t = ph(new qv("light"), this);
      return () => {
        t.cancel();
      };
    }, [nt, this.helperState.get]);
  }
  dispose() {
    return this.done ? this : (super.dispose(), AJ(this), this);
  }
  get texture() {
    return this._texture;
  }
  set texture(t) {
    this._texture = t, RJ();
  }
  get helper() {
    return this.helperState.get();
  }
  set helper(t) {
    this.helperState.set(t);
  }
}
V(Ou, "componentName", "environment"), V(Ou, "defaults", LJ), V(Ou, "schema", kJ);
var UI = { exports: {} }, aC = { exports: {} }, VI = function(e, t) {
  return function() {
    for (var r = new Array(arguments.length), s = 0; s < r.length; s++)
      r[s] = arguments[s];
    return e.apply(t, r);
  };
}, DJ = VI, gh = Object.prototype.toString;
function lC(n) {
  return gh.call(n) === "[object Array]";
}
function fM(n) {
  return typeof n > "u";
}
function IJ(n) {
  return n !== null && !fM(n) && n.constructor !== null && !fM(n.constructor) && typeof n.constructor.isBuffer == "function" && n.constructor.isBuffer(n);
}
function OJ(n) {
  return gh.call(n) === "[object ArrayBuffer]";
}
function NJ(n) {
  return typeof FormData < "u" && n instanceof FormData;
}
function zJ(n) {
  var e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && n.buffer instanceof ArrayBuffer, e;
}
function FJ(n) {
  return typeof n == "string";
}
function BJ(n) {
  return typeof n == "number";
}
function HI(n) {
  return n !== null && typeof n == "object";
}
function Q_(n) {
  if (gh.call(n) !== "[object Object]")
    return !1;
  var e = Object.getPrototypeOf(n);
  return e === null || e === Object.prototype;
}
function UJ(n) {
  return gh.call(n) === "[object Date]";
}
function VJ(n) {
  return gh.call(n) === "[object File]";
}
function HJ(n) {
  return gh.call(n) === "[object Blob]";
}
function GI(n) {
  return gh.call(n) === "[object Function]";
}
function GJ(n) {
  return HI(n) && GI(n.pipe);
}
function WJ(n) {
  return typeof URLSearchParams < "u" && n instanceof URLSearchParams;
}
function jJ(n) {
  return n.trim ? n.trim() : n.replace(/^\s+|\s+$/g, "");
}
function qJ() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function cC(n, e) {
  if (!(n === null || typeof n > "u"))
    if (typeof n != "object" && (n = [n]), lC(n))
      for (var t = 0, i = n.length; t < i; t++)
        e.call(null, n[t], t, n);
    else
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && e.call(null, n[r], r, n);
}
function pM() {
  var n = {};
  function e(r, s) {
    Q_(n[s]) && Q_(r) ? n[s] = pM(n[s], r) : Q_(r) ? n[s] = pM({}, r) : lC(r) ? n[s] = r.slice() : n[s] = r;
  }
  for (var t = 0, i = arguments.length; t < i; t++)
    cC(arguments[t], e);
  return n;
}
function XJ(n, e, t) {
  return cC(e, function(r, s) {
    t && typeof r == "function" ? n[s] = DJ(r, t) : n[s] = r;
  }), n;
}
function $J(n) {
  return n.charCodeAt(0) === 65279 && (n = n.slice(1)), n;
}
var Vs = {
  isArray: lC,
  isArrayBuffer: OJ,
  isBuffer: IJ,
  isFormData: NJ,
  isArrayBufferView: zJ,
  isString: FJ,
  isNumber: BJ,
  isObject: HI,
  isPlainObject: Q_,
  isUndefined: fM,
  isDate: UJ,
  isFile: VJ,
  isBlob: HJ,
  isFunction: GI,
  isStream: GJ,
  isURLSearchParams: WJ,
  isStandardBrowserEnv: qJ,
  forEach: cC,
  merge: pM,
  extend: XJ,
  trim: jJ,
  stripBOM: $J
}, vd = Vs;
function KR(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var WI = function(e, t, i) {
  if (!t)
    return e;
  var r;
  if (i)
    r = i(t);
  else if (vd.isURLSearchParams(t))
    r = t.toString();
  else {
    var s = [];
    vd.forEach(t, function(l, c) {
      l === null || typeof l > "u" || (vd.isArray(l) ? c = c + "[]" : l = [l], vd.forEach(l, function(p) {
        vd.isDate(p) ? p = p.toISOString() : vd.isObject(p) && (p = JSON.stringify(p)), s.push(KR(c) + "=" + KR(p));
      }));
    }), r = s.join("&");
  }
  if (r) {
    var o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + r;
  }
  return e;
}, ZJ = Vs;
function Zy() {
  this.handlers = [];
}
Zy.prototype.use = function(e, t, i) {
  return this.handlers.push({
    fulfilled: e,
    rejected: t,
    synchronous: i ? i.synchronous : !1,
    runWhen: i ? i.runWhen : null
  }), this.handlers.length - 1;
};
Zy.prototype.eject = function(e) {
  this.handlers[e] && (this.handlers[e] = null);
};
Zy.prototype.forEach = function(e) {
  ZJ.forEach(this.handlers, function(i) {
    i !== null && e(i);
  });
};
var YJ = Zy, KJ = Vs, JJ = function(e, t) {
  KJ.forEach(e, function(r, s) {
    s !== t && s.toUpperCase() === t.toUpperCase() && (e[t] = r, delete e[s]);
  });
}, jI = function(e, t, i, r, s) {
  return e.config = t, i && (e.code = i), e.request = r, e.response = s, e.isAxiosError = !0, e.toJSON = function() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code
    };
  }, e;
}, fS, JR;
function qI() {
  if (JR)
    return fS;
  JR = 1;
  var n = jI;
  return fS = function(t, i, r, s, o) {
    var a = new Error(t);
    return n(a, i, r, s, o);
  }, fS;
}
var pS, QR;
function QJ() {
  if (QR)
    return pS;
  QR = 1;
  var n = qI();
  return pS = function(t, i, r) {
    var s = r.config.validateStatus;
    !r.status || !s || s(r.status) ? t(r) : i(n(
      "Request failed with status code " + r.status,
      r.config,
      null,
      r.request,
      r
    ));
  }, pS;
}
var mS, e4;
function eQ() {
  if (e4)
    return mS;
  e4 = 1;
  var n = Vs;
  return mS = n.isStandardBrowserEnv() ? function() {
    return {
      write: function(i, r, s, o, a, l) {
        var c = [];
        c.push(i + "=" + encodeURIComponent(r)), n.isNumber(s) && c.push("expires=" + new Date(s).toGMTString()), n.isString(o) && c.push("path=" + o), n.isString(a) && c.push("domain=" + a), l === !0 && c.push("secure"), document.cookie = c.join("; ");
      },
      read: function(i) {
        var r = document.cookie.match(new RegExp("(^|;\\s*)(" + i + ")=([^;]*)"));
        return r ? decodeURIComponent(r[3]) : null;
      },
      remove: function(i) {
        this.write(i, "", Date.now() - 864e5);
      }
    };
  }() : function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }(), mS;
}
var vS, t4;
function tQ() {
  return t4 || (t4 = 1, vS = function(e) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e);
  }), vS;
}
var gS, n4;
function nQ() {
  return n4 || (n4 = 1, gS = function(e, t) {
    return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
  }), gS;
}
var _S, i4;
function iQ() {
  if (i4)
    return _S;
  i4 = 1;
  var n = tQ(), e = nQ();
  return _S = function(i, r) {
    return i && !n(r) ? e(i, r) : r;
  }, _S;
}
var bS, r4;
function rQ() {
  if (r4)
    return bS;
  r4 = 1;
  var n = Vs, e = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return bS = function(i) {
    var r = {}, s, o, a;
    return i && n.forEach(i.split(`
`), function(c) {
      if (a = c.indexOf(":"), s = n.trim(c.substr(0, a)).toLowerCase(), o = n.trim(c.substr(a + 1)), s) {
        if (r[s] && e.indexOf(s) >= 0)
          return;
        s === "set-cookie" ? r[s] = (r[s] ? r[s] : []).concat([o]) : r[s] = r[s] ? r[s] + ", " + o : o;
      }
    }), r;
  }, bS;
}
var yS, s4;
function sQ() {
  if (s4)
    return yS;
  s4 = 1;
  var n = Vs;
  return yS = n.isStandardBrowserEnv() ? function() {
    var t = /(msie|trident)/i.test(navigator.userAgent), i = document.createElement("a"), r;
    function s(o) {
      var a = o;
      return t && (i.setAttribute("href", a), a = i.href), i.setAttribute("href", a), {
        href: i.href,
        protocol: i.protocol ? i.protocol.replace(/:$/, "") : "",
        host: i.host,
        search: i.search ? i.search.replace(/^\?/, "") : "",
        hash: i.hash ? i.hash.replace(/^#/, "") : "",
        hostname: i.hostname,
        port: i.port,
        pathname: i.pathname.charAt(0) === "/" ? i.pathname : "/" + i.pathname
      };
    }
    return r = s(window.location.href), function(a) {
      var l = n.isString(a) ? s(a) : a;
      return l.protocol === r.protocol && l.host === r.host;
    };
  }() : function() {
    return function() {
      return !0;
    };
  }(), yS;
}
var xS, o4;
function a4() {
  if (o4)
    return xS;
  o4 = 1;
  var n = Vs, e = QJ(), t = eQ(), i = WI, r = iQ(), s = rQ(), o = sQ(), a = qI();
  return xS = function(c) {
    return new Promise(function(p, m) {
      var v = c.data, b = c.headers, x = c.responseType;
      n.isFormData(v) && delete b["Content-Type"];
      var y = new XMLHttpRequest();
      if (c.auth) {
        var S = c.auth.username || "", C = c.auth.password ? unescape(encodeURIComponent(c.auth.password)) : "";
        b.Authorization = "Basic " + btoa(S + ":" + C);
      }
      var M = r(c.baseURL, c.url);
      y.open(c.method.toUpperCase(), i(M, c.params, c.paramsSerializer), !0), y.timeout = c.timeout;
      function T() {
        if (!!y) {
          var D = "getAllResponseHeaders" in y ? s(y.getAllResponseHeaders()) : null, I = !x || x === "text" || x === "json" ? y.responseText : y.response, k = {
            data: I,
            status: y.status,
            statusText: y.statusText,
            headers: D,
            config: c,
            request: y
          };
          e(p, m, k), y = null;
        }
      }
      if ("onloadend" in y ? y.onloadend = T : y.onreadystatechange = function() {
        !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(T);
      }, y.onabort = function() {
        !y || (m(a("Request aborted", c, "ECONNABORTED", y)), y = null);
      }, y.onerror = function() {
        m(a("Network Error", c, null, y)), y = null;
      }, y.ontimeout = function() {
        var I = "timeout of " + c.timeout + "ms exceeded";
        c.timeoutErrorMessage && (I = c.timeoutErrorMessage), m(a(
          I,
          c,
          c.transitional && c.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          y
        )), y = null;
      }, n.isStandardBrowserEnv()) {
        var P = (c.withCredentials || o(M)) && c.xsrfCookieName ? t.read(c.xsrfCookieName) : void 0;
        P && (b[c.xsrfHeaderName] = P);
      }
      "setRequestHeader" in y && n.forEach(b, function(I, k) {
        typeof v > "u" && k.toLowerCase() === "content-type" ? delete b[k] : y.setRequestHeader(k, I);
      }), n.isUndefined(c.withCredentials) || (y.withCredentials = !!c.withCredentials), x && x !== "json" && (y.responseType = c.responseType), typeof c.onDownloadProgress == "function" && y.addEventListener("progress", c.onDownloadProgress), typeof c.onUploadProgress == "function" && y.upload && y.upload.addEventListener("progress", c.onUploadProgress), c.cancelToken && c.cancelToken.promise.then(function(I) {
        !y || (y.abort(), m(I), y = null);
      }), v || (v = null), y.send(v);
    });
  }, xS;
}
var br = Vs, l4 = JJ, oQ = jI, aQ = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function c4(n, e) {
  !br.isUndefined(n) && br.isUndefined(n["Content-Type"]) && (n["Content-Type"] = e);
}
function lQ() {
  var n;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (n = a4()), n;
}
function cQ(n, e, t) {
  if (br.isString(n))
    try {
      return (e || JSON.parse)(n), br.trim(n);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (t || JSON.stringify)(n);
}
var Yy = {
  transitional: {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  adapter: lQ(),
  transformRequest: [function(e, t) {
    return l4(t, "Accept"), l4(t, "Content-Type"), br.isFormData(e) || br.isArrayBuffer(e) || br.isBuffer(e) || br.isStream(e) || br.isFile(e) || br.isBlob(e) ? e : br.isArrayBufferView(e) ? e.buffer : br.isURLSearchParams(e) ? (c4(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : br.isObject(e) || t && t["Content-Type"] === "application/json" ? (c4(t, "application/json"), cQ(e)) : e;
  }],
  transformResponse: [function(e) {
    var t = this.transitional, i = t && t.silentJSONParsing, r = t && t.forcedJSONParsing, s = !i && this.responseType === "json";
    if (s || r && br.isString(e) && e.length)
      try {
        return JSON.parse(e);
      } catch (o) {
        if (s)
          throw o.name === "SyntaxError" ? oQ(o, this, "E_JSON_PARSE") : o;
      }
    return e;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  }
};
Yy.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
br.forEach(["delete", "get", "head"], function(e) {
  Yy.headers[e] = {};
});
br.forEach(["post", "put", "patch"], function(e) {
  Yy.headers[e] = br.merge(aQ);
});
var uC = Yy, uQ = Vs, hQ = uC, dQ = function(e, t, i) {
  var r = this || hQ;
  return uQ.forEach(i, function(o) {
    e = o.call(r, e, t);
  }), e;
}, wS, u4;
function XI() {
  return u4 || (u4 = 1, wS = function(e) {
    return !!(e && e.__CANCEL__);
  }), wS;
}
var h4 = Vs, SS = dQ, fQ = XI(), pQ = uC;
function MS(n) {
  n.cancelToken && n.cancelToken.throwIfRequested();
}
var mQ = function(e) {
  MS(e), e.headers = e.headers || {}, e.data = SS.call(
    e,
    e.data,
    e.headers,
    e.transformRequest
  ), e.headers = h4.merge(
    e.headers.common || {},
    e.headers[e.method] || {},
    e.headers
  ), h4.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(r) {
      delete e.headers[r];
    }
  );
  var t = e.adapter || pQ.adapter;
  return t(e).then(function(r) {
    return MS(e), r.data = SS.call(
      e,
      r.data,
      r.headers,
      e.transformResponse
    ), r;
  }, function(r) {
    return fQ(r) || (MS(e), r && r.response && (r.response.data = SS.call(
      e,
      r.response.data,
      r.response.headers,
      e.transformResponse
    ))), Promise.reject(r);
  });
}, kr = Vs, $I = function(e, t) {
  t = t || {};
  var i = {}, r = ["url", "method", "data"], s = ["headers", "auth", "proxy", "params"], o = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ], a = ["validateStatus"];
  function l(m, v) {
    return kr.isPlainObject(m) && kr.isPlainObject(v) ? kr.merge(m, v) : kr.isPlainObject(v) ? kr.merge({}, v) : kr.isArray(v) ? v.slice() : v;
  }
  function c(m) {
    kr.isUndefined(t[m]) ? kr.isUndefined(e[m]) || (i[m] = l(void 0, e[m])) : i[m] = l(e[m], t[m]);
  }
  kr.forEach(r, function(v) {
    kr.isUndefined(t[v]) || (i[v] = l(void 0, t[v]));
  }), kr.forEach(s, c), kr.forEach(o, function(v) {
    kr.isUndefined(t[v]) ? kr.isUndefined(e[v]) || (i[v] = l(void 0, e[v])) : i[v] = l(void 0, t[v]);
  }), kr.forEach(a, function(v) {
    v in t ? i[v] = l(e[v], t[v]) : v in e && (i[v] = l(void 0, e[v]));
  });
  var d = r.concat(s).concat(o).concat(a), p = Object.keys(e).concat(Object.keys(t)).filter(function(v) {
    return d.indexOf(v) === -1;
  });
  return kr.forEach(p, c), i;
};
const vQ = "axios", gQ = "0.21.4", _Q = "Promise based HTTP client for the browser and node.js", bQ = "index.js", yQ = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
}, xQ = {
  type: "git",
  url: "https://github.com/axios/axios.git"
}, wQ = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
], SQ = "Matt Zabriskie", MQ = "MIT", EQ = {
  url: "https://github.com/axios/axios/issues"
}, CQ = "https://axios-http.com", TQ = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
}, PQ = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}, AQ = "dist/axios.min.js", RQ = "dist/axios.min.js", kQ = "./index.d.ts", LQ = {
  "follow-redirects": "^1.14.0"
}, DQ = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
], IQ = {
  name: vQ,
  version: gQ,
  description: _Q,
  main: bQ,
  scripts: yQ,
  repository: xQ,
  keywords: wQ,
  author: SQ,
  license: MQ,
  bugs: EQ,
  homepage: CQ,
  devDependencies: TQ,
  browser: PQ,
  jsdelivr: AQ,
  unpkg: RQ,
  typings: kQ,
  dependencies: LQ,
  bundlesize: DQ
};
var ZI = IQ, hC = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(n, e) {
  hC[n] = function(i) {
    return typeof i === n || "a" + (e < 1 ? "n " : " ") + n;
  };
});
var d4 = {}, OQ = ZI.version.split(".");
function YI(n, e) {
  for (var t = e ? e.split(".") : OQ, i = n.split("."), r = 0; r < 3; r++) {
    if (t[r] > i[r])
      return !0;
    if (t[r] < i[r])
      return !1;
  }
  return !1;
}
hC.transitional = function(e, t, i) {
  var r = t && YI(t);
  function s(o, a) {
    return "[Axios v" + ZI.version + "] Transitional option '" + o + "'" + a + (i ? ". " + i : "");
  }
  return function(o, a, l) {
    if (e === !1)
      throw new Error(s(a, " has been removed in " + t));
    return r && !d4[a] && (d4[a] = !0, console.warn(
      s(
        a,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(o, a, l) : !0;
  };
};
function NQ(n, e, t) {
  if (typeof n != "object")
    throw new TypeError("options must be an object");
  for (var i = Object.keys(n), r = i.length; r-- > 0; ) {
    var s = i[r], o = e[s];
    if (o) {
      var a = n[s], l = a === void 0 || o(a, s, n);
      if (l !== !0)
        throw new TypeError("option " + s + " must be " + l);
      continue;
    }
    if (t !== !0)
      throw Error("Unknown option " + s);
  }
}
var zQ = {
  isOlderVersion: YI,
  assertOptions: NQ,
  validators: hC
}, KI = Vs, FQ = WI, f4 = YJ, p4 = mQ, Ky = $I, JI = zQ, gd = JI.validators;
function Xv(n) {
  this.defaults = n, this.interceptors = {
    request: new f4(),
    response: new f4()
  };
}
Xv.prototype.request = function(e) {
  typeof e == "string" ? (e = arguments[1] || {}, e.url = arguments[0]) : e = e || {}, e = Ky(this.defaults, e), e.method ? e.method = e.method.toLowerCase() : this.defaults.method ? e.method = this.defaults.method.toLowerCase() : e.method = "get";
  var t = e.transitional;
  t !== void 0 && JI.assertOptions(t, {
    silentJSONParsing: gd.transitional(gd.boolean, "1.0.0"),
    forcedJSONParsing: gd.transitional(gd.boolean, "1.0.0"),
    clarifyTimeoutError: gd.transitional(gd.boolean, "1.0.0")
  }, !1);
  var i = [], r = !0;
  this.interceptors.request.forEach(function(m) {
    typeof m.runWhen == "function" && m.runWhen(e) === !1 || (r = r && m.synchronous, i.unshift(m.fulfilled, m.rejected));
  });
  var s = [];
  this.interceptors.response.forEach(function(m) {
    s.push(m.fulfilled, m.rejected);
  });
  var o;
  if (!r) {
    var a = [p4, void 0];
    for (Array.prototype.unshift.apply(a, i), a = a.concat(s), o = Promise.resolve(e); a.length; )
      o = o.then(a.shift(), a.shift());
    return o;
  }
  for (var l = e; i.length; ) {
    var c = i.shift(), d = i.shift();
    try {
      l = c(l);
    } catch (p) {
      d(p);
      break;
    }
  }
  try {
    o = p4(l);
  } catch (p) {
    return Promise.reject(p);
  }
  for (; s.length; )
    o = o.then(s.shift(), s.shift());
  return o;
};
Xv.prototype.getUri = function(e) {
  return e = Ky(this.defaults, e), FQ(e.url, e.params, e.paramsSerializer).replace(/^\?/, "");
};
KI.forEach(["delete", "get", "head", "options"], function(e) {
  Xv.prototype[e] = function(t, i) {
    return this.request(Ky(i || {}, {
      method: e,
      url: t,
      data: (i || {}).data
    }));
  };
});
KI.forEach(["post", "put", "patch"], function(e) {
  Xv.prototype[e] = function(t, i, r) {
    return this.request(Ky(r || {}, {
      method: e,
      url: t,
      data: i
    }));
  };
});
var BQ = Xv, ES, m4;
function QI() {
  if (m4)
    return ES;
  m4 = 1;
  function n(e) {
    this.message = e;
  }
  return n.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, n.prototype.__CANCEL__ = !0, ES = n, ES;
}
var CS, v4;
function UQ() {
  if (v4)
    return CS;
  v4 = 1;
  var n = QI();
  function e(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    var i;
    this.promise = new Promise(function(o) {
      i = o;
    });
    var r = this;
    t(function(o) {
      r.reason || (r.reason = new n(o), i(r.reason));
    });
  }
  return e.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, e.source = function() {
    var i, r = new e(function(o) {
      i = o;
    });
    return {
      token: r,
      cancel: i
    };
  }, CS = e, CS;
}
var TS, g4;
function VQ() {
  return g4 || (g4 = 1, TS = function(e) {
    return function(i) {
      return e.apply(null, i);
    };
  }), TS;
}
var PS, _4;
function HQ() {
  return _4 || (_4 = 1, PS = function(e) {
    return typeof e == "object" && e.isAxiosError === !0;
  }), PS;
}
var b4 = Vs, GQ = VI, eb = BQ, WQ = $I, jQ = uC;
function eO(n) {
  var e = new eb(n), t = GQ(eb.prototype.request, e);
  return b4.extend(t, eb.prototype, e), b4.extend(t, e), t;
}
var Oo = eO(jQ);
Oo.Axios = eb;
Oo.create = function(e) {
  return eO(WQ(Oo.defaults, e));
};
Oo.Cancel = QI();
Oo.CancelToken = UQ();
Oo.isCancel = XI();
Oo.all = function(e) {
  return Promise.all(e);
};
Oo.spread = VQ();
Oo.isAxiosError = HQ();
aC.exports = Oo;
aC.exports.default = Oo;
(function(n) {
  n.exports = aC.exports;
})(UI);
const qQ = /* @__PURE__ */ OV(UI.exports);
function w_(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var tO = { exports: {} };
/*!

JSZip v3.9.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
(function(n, e) {
  (function(t) {
    n.exports = t();
  })(function() {
    return function t(i, r, s) {
      function o(c, d) {
        if (!r[c]) {
          if (!i[c]) {
            var p = typeof w_ == "function" && w_;
            if (!d && p)
              return p(c, !0);
            if (a)
              return a(c, !0);
            var m = new Error("Cannot find module '" + c + "'");
            throw m.code = "MODULE_NOT_FOUND", m;
          }
          var v = r[c] = { exports: {} };
          i[c][0].call(v.exports, function(b) {
            var x = i[c][1][b];
            return o(x || b);
          }, v, v.exports, t, i, r, s);
        }
        return r[c].exports;
      }
      for (var a = typeof w_ == "function" && w_, l = 0; l < s.length; l++)
        o(s[l]);
      return o;
    }({ 1: [function(t, i, r) {
      var s = t("./utils"), o = t("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(l) {
        for (var c, d, p, m, v, b, x, y = [], S = 0, C = l.length, M = C, T = s.getTypeOf(l) !== "string"; S < l.length; )
          M = C - S, p = T ? (c = l[S++], d = S < C ? l[S++] : 0, S < C ? l[S++] : 0) : (c = l.charCodeAt(S++), d = S < C ? l.charCodeAt(S++) : 0, S < C ? l.charCodeAt(S++) : 0), m = c >> 2, v = (3 & c) << 4 | d >> 4, b = 1 < M ? (15 & d) << 2 | p >> 6 : 64, x = 2 < M ? 63 & p : 64, y.push(a.charAt(m) + a.charAt(v) + a.charAt(b) + a.charAt(x));
        return y.join("");
      }, r.decode = function(l) {
        var c, d, p, m, v, b, x = 0, y = 0, S = "data:";
        if (l.substr(0, S.length) === S)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var C, M = 3 * (l = l.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && M--, l.charAt(l.length - 2) === a.charAt(64) && M--, M % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (C = o.uint8array ? new Uint8Array(0 | M) : new Array(0 | M); x < l.length; )
          c = a.indexOf(l.charAt(x++)) << 2 | (m = a.indexOf(l.charAt(x++))) >> 4, d = (15 & m) << 4 | (v = a.indexOf(l.charAt(x++))) >> 2, p = (3 & v) << 6 | (b = a.indexOf(l.charAt(x++))), C[y++] = c, v !== 64 && (C[y++] = d), b !== 64 && (C[y++] = p);
        return C;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(t, i, r) {
      var s = t("./external"), o = t("./stream/DataWorker"), a = t("./stream/Crc32Probe"), l = t("./stream/DataLengthProbe");
      function c(d, p, m, v, b) {
        this.compressedSize = d, this.uncompressedSize = p, this.crc32 = m, this.compression = v, this.compressedContent = b;
      }
      c.prototype = { getContentWorker: function() {
        var d = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), p = this;
        return d.on("end", function() {
          if (this.streamInfo.data_length !== p.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), d;
      }, getCompressedWorker: function() {
        return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(d, p, m) {
        return d.pipe(new a()).pipe(new l("uncompressedSize")).pipe(p.compressWorker(m)).pipe(new l("compressedSize")).withStreamInfo("compression", p);
      }, i.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, i, r) {
      var s = t("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function(o) {
        return new s("STORE compression");
      }, uncompressWorker: function() {
        return new s("STORE decompression");
      } }, r.DEFLATE = t("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, i, r) {
      var s = t("./utils"), o = function() {
        for (var a, l = [], c = 0; c < 256; c++) {
          a = c;
          for (var d = 0; d < 8; d++)
            a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[c] = a;
        }
        return l;
      }();
      i.exports = function(a, l) {
        return a !== void 0 && a.length ? s.getTypeOf(a) !== "string" ? function(c, d, p, m) {
          var v = o, b = m + p;
          c ^= -1;
          for (var x = m; x < b; x++)
            c = c >>> 8 ^ v[255 & (c ^ d[x])];
          return -1 ^ c;
        }(0 | l, a, a.length, 0) : function(c, d, p, m) {
          var v = o, b = m + p;
          c ^= -1;
          for (var x = m; x < b; x++)
            c = c >>> 8 ^ v[255 & (c ^ d.charCodeAt(x))];
          return -1 ^ c;
        }(0 | l, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(t, i, r) {
      r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(t, i, r) {
      var s = null;
      s = typeof Promise < "u" ? Promise : t("lie"), i.exports = { Promise: s };
    }, { lie: 37 }], 7: [function(t, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = t("pako"), a = t("./utils"), l = t("./stream/GenericWorker"), c = s ? "uint8array" : "array";
      function d(p, m) {
        l.call(this, "FlateWorker/" + p), this._pako = null, this._pakoAction = p, this._pakoOptions = m, this.meta = {};
      }
      r.magic = "\b\0", a.inherits(d, l), d.prototype.processChunk = function(p) {
        this.meta = p.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(c, p.data), !1);
      }, d.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, d.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, d.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var p = this;
        this._pako.onData = function(m) {
          p.push({ data: m, meta: p.meta });
        };
      }, r.compressWorker = function(p) {
        return new d("Deflate", p);
      }, r.uncompressWorker = function() {
        return new d("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, i, r) {
      function s(v, b) {
        var x, y = "";
        for (x = 0; x < b; x++)
          y += String.fromCharCode(255 & v), v >>>= 8;
        return y;
      }
      function o(v, b, x, y, S, C) {
        var M, T, P = v.file, D = v.compression, I = C !== c.utf8encode, k = a.transformTo("string", C(P.name)), O = a.transformTo("string", c.utf8encode(P.name)), B = P.comment, Y = a.transformTo("string", C(B)), G = a.transformTo("string", c.utf8encode(B)), K = O.length !== P.name.length, A = G.length !== B.length, J = "", xe = "", se = "", oe = P.dir, Q = P.date, ce = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        b && !x || (ce.crc32 = v.crc32, ce.compressedSize = v.compressedSize, ce.uncompressedSize = v.uncompressedSize);
        var te = 0;
        b && (te |= 8), I || !K && !A || (te |= 2048);
        var ee = 0, Re = 0;
        oe && (ee |= 16), S === "UNIX" ? (Re = 798, ee |= function(Se, Ee) {
          var gt = Se;
          return Se || (gt = Ee ? 16893 : 33204), (65535 & gt) << 16;
        }(P.unixPermissions, oe)) : (Re = 20, ee |= function(Se) {
          return 63 & (Se || 0);
        }(P.dosPermissions)), M = Q.getUTCHours(), M <<= 6, M |= Q.getUTCMinutes(), M <<= 5, M |= Q.getUTCSeconds() / 2, T = Q.getUTCFullYear() - 1980, T <<= 4, T |= Q.getUTCMonth() + 1, T <<= 5, T |= Q.getUTCDate(), K && (xe = s(1, 1) + s(d(k), 4) + O, J += "up" + s(xe.length, 2) + xe), A && (se = s(1, 1) + s(d(Y), 4) + G, J += "uc" + s(se.length, 2) + se);
        var ye = "";
        return ye += `
\0`, ye += s(te, 2), ye += D.magic, ye += s(M, 2), ye += s(T, 2), ye += s(ce.crc32, 4), ye += s(ce.compressedSize, 4), ye += s(ce.uncompressedSize, 4), ye += s(k.length, 2), ye += s(J.length, 2), { fileRecord: p.LOCAL_FILE_HEADER + ye + k + J, dirRecord: p.CENTRAL_FILE_HEADER + s(Re, 2) + ye + s(Y.length, 2) + "\0\0\0\0" + s(ee, 4) + s(y, 4) + k + J + Y };
      }
      var a = t("../utils"), l = t("../stream/GenericWorker"), c = t("../utf8"), d = t("../crc32"), p = t("../signature");
      function m(v, b, x, y) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = b, this.zipPlatform = x, this.encodeFileName = y, this.streamFiles = v, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(m, l), m.prototype.push = function(v) {
        var b = v.meta.percent || 0, x = this.entriesCount, y = this._sources.length;
        this.accumulate ? this.contentBuffer.push(v) : (this.bytesWritten += v.data.length, l.prototype.push.call(this, { data: v.data, meta: { currentFile: this.currentFile, percent: x ? (b + 100 * (x - y - 1)) / x : 100 } }));
      }, m.prototype.openedSource = function(v) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = v.file.name;
        var b = this.streamFiles && !v.file.dir;
        if (b) {
          var x = o(v, b, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: x.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, m.prototype.closedSource = function(v) {
        this.accumulate = !1;
        var b = this.streamFiles && !v.file.dir, x = o(v, b, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(x.dirRecord), b)
          this.push({ data: function(y) {
            return p.DATA_DESCRIPTOR + s(y.crc32, 4) + s(y.compressedSize, 4) + s(y.uncompressedSize, 4);
          }(v), meta: { percent: 100 } });
        else
          for (this.push({ data: x.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, m.prototype.flush = function() {
        for (var v = this.bytesWritten, b = 0; b < this.dirRecords.length; b++)
          this.push({ data: this.dirRecords[b], meta: { percent: 100 } });
        var x = this.bytesWritten - v, y = function(S, C, M, T, P) {
          var D = a.transformTo("string", P(T));
          return p.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(S, 2) + s(S, 2) + s(C, 4) + s(M, 4) + s(D.length, 2) + D;
        }(this.dirRecords.length, x, v, this.zipComment, this.encodeFileName);
        this.push({ data: y, meta: { percent: 100 } });
      }, m.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, m.prototype.registerPrevious = function(v) {
        this._sources.push(v);
        var b = this;
        return v.on("data", function(x) {
          b.processChunk(x);
        }), v.on("end", function() {
          b.closedSource(b.previous.streamInfo), b._sources.length ? b.prepareNextSource() : b.end();
        }), v.on("error", function(x) {
          b.error(x);
        }), this;
      }, m.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, m.prototype.error = function(v) {
        var b = this._sources;
        if (!l.prototype.error.call(this, v))
          return !1;
        for (var x = 0; x < b.length; x++)
          try {
            b[x].error(v);
          } catch {
          }
        return !0;
      }, m.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var v = this._sources, b = 0; b < v.length; b++)
          v[b].lock();
      }, i.exports = m;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, i, r) {
      var s = t("../compressions"), o = t("./ZipFileWorker");
      r.generateWorker = function(a, l, c) {
        var d = new o(l.streamFiles, c, l.platform, l.encodeFileName), p = 0;
        try {
          a.forEach(function(m, v) {
            p++;
            var b = function(C, M) {
              var T = C || M, P = s[T];
              if (!P)
                throw new Error(T + " is not a valid compression method !");
              return P;
            }(v.options.compression, l.compression), x = v.options.compressionOptions || l.compressionOptions || {}, y = v.dir, S = v.date;
            v._compressWorker(b, x).withStreamInfo("file", { name: m, dir: y, date: S, comment: v.comment || "", unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions }).pipe(d);
          }), d.entriesCount = p;
        } catch (m) {
          d.error(m);
        }
        return d;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, i, r) {
      function s() {
        if (!(this instanceof s))
          return new s();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new s();
          for (var a in this)
            typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      (s.prototype = t("./object")).loadAsync = t("./load"), s.support = t("./support"), s.defaults = t("./defaults"), s.version = "3.9.1", s.loadAsync = function(o, a) {
        return new s().loadAsync(o, a);
      }, s.external = t("./external"), i.exports = s;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, i, r) {
      var s = t("./utils"), o = t("./external"), a = t("./utf8"), l = t("./zipEntries"), c = t("./stream/Crc32Probe"), d = t("./nodejsUtils");
      function p(m) {
        return new o.Promise(function(v, b) {
          var x = m.decompressed.getContentWorker().pipe(new c());
          x.on("error", function(y) {
            b(y);
          }).on("end", function() {
            x.streamInfo.crc32 !== m.decompressed.crc32 ? b(new Error("Corrupted zip : CRC32 mismatch")) : v();
          }).resume();
        });
      }
      i.exports = function(m, v) {
        var b = this;
        return v = s.extend(v || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), d.isNode && d.isStream(m) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", m, !0, v.optimizedBinaryString, v.base64).then(function(x) {
          var y = new l(v);
          return y.load(x), y;
        }).then(function(x) {
          var y = [o.Promise.resolve(x)], S = x.files;
          if (v.checkCRC32)
            for (var C = 0; C < S.length; C++)
              y.push(p(S[C]));
          return o.Promise.all(y);
        }).then(function(x) {
          for (var y = x.shift(), S = y.files, C = 0; C < S.length; C++) {
            var M = S[C], T = M.fileNameStr, P = s.resolve(M.fileNameStr);
            b.file(P, M.decompressed, { binary: !0, optimizedBinaryString: !0, date: M.date, dir: M.dir, comment: M.fileCommentStr.length ? M.fileCommentStr : null, unixPermissions: M.unixPermissions, dosPermissions: M.dosPermissions, createFolders: v.createFolders }), M.dir || (b.file(P).unsafeOriginalName = T);
          }
          return y.zipComment.length && (b.comment = y.zipComment), b;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, i, r) {
      var s = t("../utils"), o = t("../stream/GenericWorker");
      function a(l, c) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(c);
      }
      s.inherits(a, o), a.prototype._bindStream = function(l) {
        var c = this;
        (this._stream = l).pause(), l.on("data", function(d) {
          c.push({ data: d, meta: { percent: 0 } });
        }).on("error", function(d) {
          c.isPaused ? this.generatedError = d : c.error(d);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, a.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, i.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, i, r) {
      var s = t("readable-stream").Readable;
      function o(a, l, c) {
        s.call(this, l), this._helper = a;
        var d = this;
        a.on("data", function(p, m) {
          d.push(p) || d._helper.pause(), c && c(m);
        }).on("error", function(p) {
          d.emit("error", p);
        }).on("end", function() {
          d.push(null);
        });
      }
      t("../utils").inherits(o, s), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, i, r) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(s, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(s, o);
        if (typeof s == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(s, o);
      }, allocBuffer: function(s) {
        if (Buffer.alloc)
          return Buffer.alloc(s);
        var o = new Buffer(s);
        return o.fill(0), o;
      }, isBuffer: function(s) {
        return Buffer.isBuffer(s);
      }, isStream: function(s) {
        return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function";
      } };
    }, {}], 15: [function(t, i, r) {
      function s(P, D, I) {
        var k, O = a.getTypeOf(D), B = a.extend(I || {}, d);
        B.date = B.date || new Date(), B.compression !== null && (B.compression = B.compression.toUpperCase()), typeof B.unixPermissions == "string" && (B.unixPermissions = parseInt(B.unixPermissions, 8)), B.unixPermissions && 16384 & B.unixPermissions && (B.dir = !0), B.dosPermissions && 16 & B.dosPermissions && (B.dir = !0), B.dir && (P = S(P)), B.createFolders && (k = y(P)) && C.call(this, k, !0);
        var Y = O === "string" && B.binary === !1 && B.base64 === !1;
        I && I.binary !== void 0 || (B.binary = !Y), (D instanceof p && D.uncompressedSize === 0 || B.dir || !D || D.length === 0) && (B.base64 = !1, B.binary = !0, D = "", B.compression = "STORE", O = "string");
        var G = null;
        G = D instanceof p || D instanceof l ? D : b.isNode && b.isStream(D) ? new x(P, D) : a.prepareContent(P, D, B.binary, B.optimizedBinaryString, B.base64);
        var K = new m(P, G, B);
        this.files[P] = K;
      }
      var o = t("./utf8"), a = t("./utils"), l = t("./stream/GenericWorker"), c = t("./stream/StreamHelper"), d = t("./defaults"), p = t("./compressedObject"), m = t("./zipObject"), v = t("./generate"), b = t("./nodejsUtils"), x = t("./nodejs/NodejsStreamInputAdapter"), y = function(P) {
        P.slice(-1) === "/" && (P = P.substring(0, P.length - 1));
        var D = P.lastIndexOf("/");
        return 0 < D ? P.substring(0, D) : "";
      }, S = function(P) {
        return P.slice(-1) !== "/" && (P += "/"), P;
      }, C = function(P, D) {
        return D = D !== void 0 ? D : d.createFolders, P = S(P), this.files[P] || s.call(this, P, null, { dir: !0, createFolders: D }), this.files[P];
      };
      function M(P) {
        return Object.prototype.toString.call(P) === "[object RegExp]";
      }
      var T = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(P) {
        var D, I, k;
        for (D in this.files)
          k = this.files[D], (I = D.slice(this.root.length, D.length)) && D.slice(0, this.root.length) === this.root && P(I, k);
      }, filter: function(P) {
        var D = [];
        return this.forEach(function(I, k) {
          P(I, k) && D.push(k);
        }), D;
      }, file: function(P, D, I) {
        if (arguments.length !== 1)
          return P = this.root + P, s.call(this, P, D, I), this;
        if (M(P)) {
          var k = P;
          return this.filter(function(B, Y) {
            return !Y.dir && k.test(B);
          });
        }
        var O = this.files[this.root + P];
        return O && !O.dir ? O : null;
      }, folder: function(P) {
        if (!P)
          return this;
        if (M(P))
          return this.filter(function(O, B) {
            return B.dir && P.test(O);
          });
        var D = this.root + P, I = C.call(this, D), k = this.clone();
        return k.root = I.name, k;
      }, remove: function(P) {
        P = this.root + P;
        var D = this.files[P];
        if (D || (P.slice(-1) !== "/" && (P += "/"), D = this.files[P]), D && !D.dir)
          delete this.files[P];
        else
          for (var I = this.filter(function(O, B) {
            return B.name.slice(0, P.length) === P;
          }), k = 0; k < I.length; k++)
            delete this.files[I[k].name];
        return this;
      }, generate: function(P) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(P) {
        var D, I = {};
        try {
          if ((I = a.extend(P || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = I.type.toLowerCase(), I.compression = I.compression.toUpperCase(), I.type === "binarystring" && (I.type = "string"), !I.type)
            throw new Error("No output type specified.");
          a.checkSupport(I.type), I.platform !== "darwin" && I.platform !== "freebsd" && I.platform !== "linux" && I.platform !== "sunos" || (I.platform = "UNIX"), I.platform === "win32" && (I.platform = "DOS");
          var k = I.comment || this.comment || "";
          D = v.generateWorker(this, I, k);
        } catch (O) {
          (D = new l("error")).error(O);
        }
        return new c(D, I.type || "string", I.mimeType);
      }, generateAsync: function(P, D) {
        return this.generateInternalStream(P).accumulate(D);
      }, generateNodeStream: function(P, D) {
        return (P = P || {}).type || (P.type = "nodebuffer"), this.generateInternalStream(P).toNodejsStream(D);
      } };
      i.exports = T;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, i, r) {
      i.exports = t("stream");
    }, { stream: void 0 }], 17: [function(t, i, r) {
      var s = t("./DataReader");
      function o(a) {
        s.call(this, a);
        for (var l = 0; l < this.data.length; l++)
          a[l] = 255 & a[l];
      }
      t("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, o.prototype.lastIndexOfSignature = function(a) {
        for (var l = a.charCodeAt(0), c = a.charCodeAt(1), d = a.charCodeAt(2), p = a.charCodeAt(3), m = this.length - 4; 0 <= m; --m)
          if (this.data[m] === l && this.data[m + 1] === c && this.data[m + 2] === d && this.data[m + 3] === p)
            return m - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(a) {
        var l = a.charCodeAt(0), c = a.charCodeAt(1), d = a.charCodeAt(2), p = a.charCodeAt(3), m = this.readData(4);
        return l === m[0] && c === m[1] && d === m[2] && p === m[3];
      }, o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0)
          return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, i, r) {
      var s = t("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function(a) {
      }, readInt: function(a) {
        var l, c = 0;
        for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--)
          c = (c << 8) + this.byteAt(l);
        return this.index += a, c;
      }, readString: function(a) {
        return s.transformTo("string", this.readData(a));
      }, readData: function(a) {
      }, lastIndexOfSignature: function(a) {
      }, readAndCheckSignature: function(a) {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(t, i, r) {
      var s = t("./Uint8ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      t("../utils").inherits(o, s), o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, i, r) {
      var s = t("./DataReader");
      function o(a) {
        s.call(this, a);
      }
      t("../utils").inherits(o, s), o.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, o.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, o.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, i, r) {
      var s = t("./ArrayReader");
      function o(a) {
        s.call(this, a);
      }
      t("../utils").inherits(o, s), o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0)
          return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, i, r) {
      var s = t("../utils"), o = t("../support"), a = t("./ArrayReader"), l = t("./StringReader"), c = t("./NodeBufferReader"), d = t("./Uint8ArrayReader");
      i.exports = function(p) {
        var m = s.getTypeOf(p);
        return s.checkSupport(m), m !== "string" || o.uint8array ? m === "nodebuffer" ? new c(p) : o.uint8array ? new d(s.transformTo("uint8array", p)) : new a(s.transformTo("array", p)) : new l(p);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, i, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(t, i, r) {
      var s = t("./GenericWorker"), o = t("../utils");
      function a(l) {
        s.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, s), a.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, i, r) {
      var s = t("./GenericWorker"), o = t("../crc32");
      function a() {
        s.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(a, s), a.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, i.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, i, r) {
      var s = t("../utils"), o = t("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      s.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, i, r) {
      var s = t("../utils"), o = t("./GenericWorker");
      function a(l) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(d) {
          c.dataIsReady = !0, c.data = d, c.max = d && d.length || 0, c.type = s.getTypeOf(d), c.isPaused || c._tickAndRepeat();
        }, function(d) {
          c.error(d);
        });
      }
      s.inherits(a, o), a.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, s.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (s.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var l = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, c);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, i, r) {
      function s(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      s.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, a) {
        return this._listeners[o].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, a) {
        if (this._listeners[o])
          for (var l = 0; l < this._listeners[o].length; l++)
            this._listeners[o][l].call(this, a);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var a = this;
        return o.on("data", function(l) {
          a.processChunk(l);
        }), o.on("end", function() {
          a.end();
        }), o.on("error", function(l) {
          a.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, a) {
        return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo)
          this.extraStreamInfo.hasOwnProperty(o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = s;
    }, {}], 29: [function(t, i, r) {
      var s = t("../utils"), o = t("./ConvertWorker"), a = t("./GenericWorker"), l = t("../base64"), c = t("../support"), d = t("../external"), p = null;
      if (c.nodestream)
        try {
          p = t("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function m(b, x) {
        return new d.Promise(function(y, S) {
          var C = [], M = b._internalType, T = b._outputType, P = b._mimeType;
          b.on("data", function(D, I) {
            C.push(D), x && x(I);
          }).on("error", function(D) {
            C = [], S(D);
          }).on("end", function() {
            try {
              var D = function(I, k, O) {
                switch (I) {
                  case "blob":
                    return s.newBlob(s.transformTo("arraybuffer", k), O);
                  case "base64":
                    return l.encode(k);
                  default:
                    return s.transformTo(I, k);
                }
              }(T, function(I, k) {
                var O, B = 0, Y = null, G = 0;
                for (O = 0; O < k.length; O++)
                  G += k[O].length;
                switch (I) {
                  case "string":
                    return k.join("");
                  case "array":
                    return Array.prototype.concat.apply([], k);
                  case "uint8array":
                    for (Y = new Uint8Array(G), O = 0; O < k.length; O++)
                      Y.set(k[O], B), B += k[O].length;
                    return Y;
                  case "nodebuffer":
                    return Buffer.concat(k);
                  default:
                    throw new Error("concat : unsupported type '" + I + "'");
                }
              }(M, C), P);
              y(D);
            } catch (I) {
              S(I);
            }
            C = [];
          }).resume();
        });
      }
      function v(b, x, y) {
        var S = x;
        switch (x) {
          case "blob":
          case "arraybuffer":
            S = "uint8array";
            break;
          case "base64":
            S = "string";
        }
        try {
          this._internalType = S, this._outputType = x, this._mimeType = y, s.checkSupport(S), this._worker = b.pipe(new o(S)), b.lock();
        } catch (C) {
          this._worker = new a("error"), this._worker.error(C);
        }
      }
      v.prototype = { accumulate: function(b) {
        return m(this, b);
      }, on: function(b, x) {
        var y = this;
        return b === "data" ? this._worker.on(b, function(S) {
          x.call(y, S.data, S.meta);
        }) : this._worker.on(b, function() {
          s.delay(x, arguments, y);
        }), this;
      }, resume: function() {
        return s.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(b) {
        if (s.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new p(this, { objectMode: this._outputType !== "nodebuffer" }, b);
      } }, i.exports = v;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, i, r) {
      if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", r.nodebuffer = typeof Buffer < "u", r.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        r.blob = !1;
      else {
        var s = new ArrayBuffer(0);
        try {
          r.blob = new Blob([s], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(s), r.blob = o.getBlob("application/zip").size === 0;
          } catch {
            r.blob = !1;
          }
        }
      }
      try {
        r.nodestream = !!t("readable-stream").Readable;
      } catch {
        r.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(t, i, r) {
      for (var s = t("./utils"), o = t("./support"), a = t("./nodejsUtils"), l = t("./stream/GenericWorker"), c = new Array(256), d = 0; d < 256; d++)
        c[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      c[254] = c[254] = 1;
      function p() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function m() {
        l.call(this, "utf-8 encode");
      }
      r.utf8encode = function(v) {
        return o.nodebuffer ? a.newBufferFrom(v, "utf-8") : function(b) {
          var x, y, S, C, M, T = b.length, P = 0;
          for (C = 0; C < T; C++)
            (64512 & (y = b.charCodeAt(C))) == 55296 && C + 1 < T && (64512 & (S = b.charCodeAt(C + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (S - 56320), C++), P += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4;
          for (x = o.uint8array ? new Uint8Array(P) : new Array(P), C = M = 0; M < P; C++)
            (64512 & (y = b.charCodeAt(C))) == 55296 && C + 1 < T && (64512 & (S = b.charCodeAt(C + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (S - 56320), C++), y < 128 ? x[M++] = y : (y < 2048 ? x[M++] = 192 | y >>> 6 : (y < 65536 ? x[M++] = 224 | y >>> 12 : (x[M++] = 240 | y >>> 18, x[M++] = 128 | y >>> 12 & 63), x[M++] = 128 | y >>> 6 & 63), x[M++] = 128 | 63 & y);
          return x;
        }(v);
      }, r.utf8decode = function(v) {
        return o.nodebuffer ? s.transformTo("nodebuffer", v).toString("utf-8") : function(b) {
          var x, y, S, C, M = b.length, T = new Array(2 * M);
          for (x = y = 0; x < M; )
            if ((S = b[x++]) < 128)
              T[y++] = S;
            else if (4 < (C = c[S]))
              T[y++] = 65533, x += C - 1;
            else {
              for (S &= C === 2 ? 31 : C === 3 ? 15 : 7; 1 < C && x < M; )
                S = S << 6 | 63 & b[x++], C--;
              1 < C ? T[y++] = 65533 : S < 65536 ? T[y++] = S : (S -= 65536, T[y++] = 55296 | S >> 10 & 1023, T[y++] = 56320 | 1023 & S);
            }
          return T.length !== y && (T.subarray ? T = T.subarray(0, y) : T.length = y), s.applyFromCharCode(T);
        }(v = s.transformTo(o.uint8array ? "uint8array" : "array", v));
      }, s.inherits(p, l), p.prototype.processChunk = function(v) {
        var b = s.transformTo(o.uint8array ? "uint8array" : "array", v.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var x = b;
            (b = new Uint8Array(x.length + this.leftOver.length)).set(this.leftOver, 0), b.set(x, this.leftOver.length);
          } else
            b = this.leftOver.concat(b);
          this.leftOver = null;
        }
        var y = function(C, M) {
          var T;
          for ((M = M || C.length) > C.length && (M = C.length), T = M - 1; 0 <= T && (192 & C[T]) == 128; )
            T--;
          return T < 0 || T === 0 ? M : T + c[C[T]] > M ? T : M;
        }(b), S = b;
        y !== b.length && (o.uint8array ? (S = b.subarray(0, y), this.leftOver = b.subarray(y, b.length)) : (S = b.slice(0, y), this.leftOver = b.slice(y, b.length))), this.push({ data: r.utf8decode(S), meta: v.meta });
      }, p.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: r.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, r.Utf8DecodeWorker = p, s.inherits(m, l), m.prototype.processChunk = function(v) {
        this.push({ data: r.utf8encode(v.data), meta: v.meta });
      }, r.Utf8EncodeWorker = m;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, i, r) {
      var s = t("./support"), o = t("./base64"), a = t("./nodejsUtils"), l = t("set-immediate-shim"), c = t("./external");
      function d(y) {
        return y;
      }
      function p(y, S) {
        for (var C = 0; C < y.length; ++C)
          S[C] = 255 & y.charCodeAt(C);
        return S;
      }
      r.newBlob = function(y, S) {
        r.checkSupport("blob");
        try {
          return new Blob([y], { type: S });
        } catch {
          try {
            var C = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return C.append(y), C.getBlob(S);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var m = { stringifyByChunk: function(y, S, C) {
        var M = [], T = 0, P = y.length;
        if (P <= C)
          return String.fromCharCode.apply(null, y);
        for (; T < P; )
          S === "array" || S === "nodebuffer" ? M.push(String.fromCharCode.apply(null, y.slice(T, Math.min(T + C, P)))) : M.push(String.fromCharCode.apply(null, y.subarray(T, Math.min(T + C, P)))), T += C;
        return M.join("");
      }, stringifyByChar: function(y) {
        for (var S = "", C = 0; C < y.length; C++)
          S += String.fromCharCode(y[C]);
        return S;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function v(y) {
        var S = 65536, C = r.getTypeOf(y), M = !0;
        if (C === "uint8array" ? M = m.applyCanBeUsed.uint8array : C === "nodebuffer" && (M = m.applyCanBeUsed.nodebuffer), M)
          for (; 1 < S; )
            try {
              return m.stringifyByChunk(y, C, S);
            } catch {
              S = Math.floor(S / 2);
            }
        return m.stringifyByChar(y);
      }
      function b(y, S) {
        for (var C = 0; C < y.length; C++)
          S[C] = y[C];
        return S;
      }
      r.applyFromCharCode = v;
      var x = {};
      x.string = { string: d, array: function(y) {
        return p(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return x.string.uint8array(y).buffer;
      }, uint8array: function(y) {
        return p(y, new Uint8Array(y.length));
      }, nodebuffer: function(y) {
        return p(y, a.allocBuffer(y.length));
      } }, x.array = { string: v, array: d, arraybuffer: function(y) {
        return new Uint8Array(y).buffer;
      }, uint8array: function(y) {
        return new Uint8Array(y);
      }, nodebuffer: function(y) {
        return a.newBufferFrom(y);
      } }, x.arraybuffer = { string: function(y) {
        return v(new Uint8Array(y));
      }, array: function(y) {
        return b(new Uint8Array(y), new Array(y.byteLength));
      }, arraybuffer: d, uint8array: function(y) {
        return new Uint8Array(y);
      }, nodebuffer: function(y) {
        return a.newBufferFrom(new Uint8Array(y));
      } }, x.uint8array = { string: v, array: function(y) {
        return b(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return y.buffer;
      }, uint8array: d, nodebuffer: function(y) {
        return a.newBufferFrom(y);
      } }, x.nodebuffer = { string: v, array: function(y) {
        return b(y, new Array(y.length));
      }, arraybuffer: function(y) {
        return x.nodebuffer.uint8array(y).buffer;
      }, uint8array: function(y) {
        return b(y, new Uint8Array(y.length));
      }, nodebuffer: d }, r.transformTo = function(y, S) {
        if (S = S || "", !y)
          return S;
        r.checkSupport(y);
        var C = r.getTypeOf(S);
        return x[C][y](S);
      }, r.resolve = function(y) {
        for (var S = y.split("/"), C = [], M = 0; M < S.length; M++) {
          var T = S[M];
          T === "." || T === "" && M !== 0 && M !== S.length - 1 || (T === ".." ? C.pop() : C.push(T));
        }
        return C.join("/");
      }, r.getTypeOf = function(y) {
        return typeof y == "string" ? "string" : Object.prototype.toString.call(y) === "[object Array]" ? "array" : s.nodebuffer && a.isBuffer(y) ? "nodebuffer" : s.uint8array && y instanceof Uint8Array ? "uint8array" : s.arraybuffer && y instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, r.checkSupport = function(y) {
        if (!s[y.toLowerCase()])
          throw new Error(y + " is not supported by this platform");
      }, r.MAX_VALUE_16BITS = 65535, r.MAX_VALUE_32BITS = -1, r.pretty = function(y) {
        var S, C, M = "";
        for (C = 0; C < (y || "").length; C++)
          M += "\\x" + ((S = y.charCodeAt(C)) < 16 ? "0" : "") + S.toString(16).toUpperCase();
        return M;
      }, r.delay = function(y, S, C) {
        l(function() {
          y.apply(C || null, S || []);
        });
      }, r.inherits = function(y, S) {
        function C() {
        }
        C.prototype = S.prototype, y.prototype = new C();
      }, r.extend = function() {
        var y, S, C = {};
        for (y = 0; y < arguments.length; y++)
          for (S in arguments[y])
            arguments[y].hasOwnProperty(S) && C[S] === void 0 && (C[S] = arguments[y][S]);
        return C;
      }, r.prepareContent = function(y, S, C, M, T) {
        return c.Promise.resolve(S).then(function(P) {
          return s.blob && (P instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(P)) !== -1) && typeof FileReader < "u" ? new c.Promise(function(D, I) {
            var k = new FileReader();
            k.onload = function(O) {
              D(O.target.result);
            }, k.onerror = function(O) {
              I(O.target.error);
            }, k.readAsArrayBuffer(P);
          }) : P;
        }).then(function(P) {
          var D = r.getTypeOf(P);
          return D ? (D === "arraybuffer" ? P = r.transformTo("uint8array", P) : D === "string" && (T ? P = o.decode(P) : C && M !== !0 && (P = function(I) {
            return p(I, s.uint8array ? new Uint8Array(I.length) : new Array(I.length));
          }(P))), P) : c.Promise.reject(new Error("Can't read the data of '" + y + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(t, i, r) {
      var s = t("./reader/readerFor"), o = t("./utils"), a = t("./signature"), l = t("./zipEntry"), c = (t("./utf8"), t("./support"));
      function d(p) {
        this.files = [], this.loadOptions = p;
      }
      d.prototype = { checkSignature: function(p) {
        if (!this.reader.readAndCheckSignature(p)) {
          this.reader.index -= 4;
          var m = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(m) + ", expected " + o.pretty(p) + ")");
        }
      }, isSignature: function(p, m) {
        var v = this.reader.index;
        this.reader.setIndex(p);
        var b = this.reader.readString(4) === m;
        return this.reader.setIndex(v), b;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var p = this.reader.readData(this.zipCommentLength), m = c.uint8array ? "uint8array" : "array", v = o.transformTo(m, p);
        this.zipComment = this.loadOptions.decodeFileName(v);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var p, m, v, b = this.zip64EndOfCentralSize - 44; 0 < b; )
          p = this.reader.readInt(2), m = this.reader.readInt(4), v = this.reader.readData(m), this.zip64ExtensibleData[p] = { id: p, length: m, value: v };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var p, m;
        for (p = 0; p < this.files.length; p++)
          m = this.files[p], this.reader.setIndex(m.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), m.readLocalPart(this.reader), m.handleUTF8(), m.processAttributes();
      }, readCentralDir: function() {
        var p;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
          (p = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(p);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var p = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (p < 0)
          throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(p);
        var m = p;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (p = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(p), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var v = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (v += 20, v += 12 + this.zip64EndOfCentralSize);
        var b = m - v;
        if (0 < b)
          this.isSignature(m, a.CENTRAL_FILE_HEADER) || (this.reader.zero = b);
        else if (b < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(b) + " bytes.");
      }, prepareReader: function(p) {
        this.reader = s(p);
      }, load: function(p) {
        this.prepareReader(p), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = d;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, i, r) {
      var s = t("./reader/readerFor"), o = t("./utils"), a = t("./compressedObject"), l = t("./crc32"), c = t("./utf8"), d = t("./compressions"), p = t("./support");
      function m(v, b) {
        this.options = v, this.loadOptions = b;
      }
      m.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(v) {
        var b, x;
        if (v.skip(22), this.fileNameLength = v.readInt(2), x = v.readInt(2), this.fileName = v.readData(this.fileNameLength), v.skip(x), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((b = function(y) {
          for (var S in d)
            if (d.hasOwnProperty(S) && d[S].magic === y)
              return d[S];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, b, v.readData(this.compressedSize));
      }, readCentralPart: function(v) {
        this.versionMadeBy = v.readInt(2), v.skip(2), this.bitFlag = v.readInt(2), this.compressionMethod = v.readString(2), this.date = v.readDate(), this.crc32 = v.readInt(4), this.compressedSize = v.readInt(4), this.uncompressedSize = v.readInt(4);
        var b = v.readInt(2);
        if (this.extraFieldsLength = v.readInt(2), this.fileCommentLength = v.readInt(2), this.diskNumberStart = v.readInt(2), this.internalFileAttributes = v.readInt(2), this.externalFileAttributes = v.readInt(4), this.localHeaderOffset = v.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        v.skip(b), this.readExtraFields(v), this.parseZIP64ExtraField(v), this.fileComment = v.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var v = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), v == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), v == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function(v) {
        if (this.extraFields[1]) {
          var b = s(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = b.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = b.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = b.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = b.readInt(4));
        }
      }, readExtraFields: function(v) {
        var b, x, y, S = v.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); v.index + 4 < S; )
          b = v.readInt(2), x = v.readInt(2), y = v.readData(x), this.extraFields[b] = { id: b, length: x, value: y };
        v.setIndex(S);
      }, handleUTF8: function() {
        var v = p.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var b = this.findExtraFieldUnicodePath();
          if (b !== null)
            this.fileNameStr = b;
          else {
            var x = o.transformTo(v, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(x);
          }
          var y = this.findExtraFieldUnicodeComment();
          if (y !== null)
            this.fileCommentStr = y;
          else {
            var S = o.transformTo(v, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(S);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var v = this.extraFields[28789];
        if (v) {
          var b = s(v.value);
          return b.readInt(1) !== 1 || l(this.fileName) !== b.readInt(4) ? null : c.utf8decode(b.readData(v.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var v = this.extraFields[25461];
        if (v) {
          var b = s(v.value);
          return b.readInt(1) !== 1 || l(this.fileComment) !== b.readInt(4) ? null : c.utf8decode(b.readData(v.length - 5));
        }
        return null;
      } }, i.exports = m;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, i, r) {
      function s(b, x, y) {
        this.name = b, this.dir = y.dir, this.date = y.date, this.comment = y.comment, this.unixPermissions = y.unixPermissions, this.dosPermissions = y.dosPermissions, this._data = x, this._dataBinary = y.binary, this.options = { compression: y.compression, compressionOptions: y.compressionOptions };
      }
      var o = t("./stream/StreamHelper"), a = t("./stream/DataWorker"), l = t("./utf8"), c = t("./compressedObject"), d = t("./stream/GenericWorker");
      s.prototype = { internalStream: function(b) {
        var x = null, y = "string";
        try {
          if (!b)
            throw new Error("No output type specified.");
          var S = (y = b.toLowerCase()) === "string" || y === "text";
          y !== "binarystring" && y !== "text" || (y = "string"), x = this._decompressWorker();
          var C = !this._dataBinary;
          C && !S && (x = x.pipe(new l.Utf8EncodeWorker())), !C && S && (x = x.pipe(new l.Utf8DecodeWorker()));
        } catch (M) {
          (x = new d("error")).error(M);
        }
        return new o(x, y, "");
      }, async: function(b, x) {
        return this.internalStream(b).accumulate(x);
      }, nodeStream: function(b, x) {
        return this.internalStream(b || "nodebuffer").toNodejsStream(x);
      }, _compressWorker: function(b, x) {
        if (this._data instanceof c && this._data.compression.magic === b.magic)
          return this._data.getCompressedWorker();
        var y = this._decompressWorker();
        return this._dataBinary || (y = y.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(y, b, x);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof d ? this._data : new a(this._data);
      } };
      for (var p = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], m = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, v = 0; v < p.length; v++)
        s.prototype[p[v]] = m;
      i.exports = s;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, i, r) {
      (function(s) {
        var o, a, l = s.MutationObserver || s.WebKitMutationObserver;
        if (l) {
          var c = 0, d = new l(b), p = s.document.createTextNode("");
          d.observe(p, { characterData: !0 }), o = function() {
            p.data = c = ++c % 2;
          };
        } else if (s.setImmediate || s.MessageChannel === void 0)
          o = "document" in s && "onreadystatechange" in s.document.createElement("script") ? function() {
            var x = s.document.createElement("script");
            x.onreadystatechange = function() {
              b(), x.onreadystatechange = null, x.parentNode.removeChild(x), x = null;
            }, s.document.documentElement.appendChild(x);
          } : function() {
            setTimeout(b, 0);
          };
        else {
          var m = new s.MessageChannel();
          m.port1.onmessage = b, o = function() {
            m.port2.postMessage(0);
          };
        }
        var v = [];
        function b() {
          var x, y;
          a = !0;
          for (var S = v.length; S; ) {
            for (y = v, v = [], x = -1; ++x < S; )
              y[x]();
            S = v.length;
          }
          a = !1;
        }
        i.exports = function(x) {
          v.push(x) !== 1 || a || o();
        };
      }).call(this, typeof sl < "u" ? sl : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(t, i, r) {
      var s = t("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], c = ["FULFILLED"], d = ["PENDING"];
      function p(S) {
        if (typeof S != "function")
          throw new TypeError("resolver must be a function");
        this.state = d, this.queue = [], this.outcome = void 0, S !== o && x(this, S);
      }
      function m(S, C, M) {
        this.promise = S, typeof C == "function" && (this.onFulfilled = C, this.callFulfilled = this.otherCallFulfilled), typeof M == "function" && (this.onRejected = M, this.callRejected = this.otherCallRejected);
      }
      function v(S, C, M) {
        s(function() {
          var T;
          try {
            T = C(M);
          } catch (P) {
            return a.reject(S, P);
          }
          T === S ? a.reject(S, new TypeError("Cannot resolve promise with itself")) : a.resolve(S, T);
        });
      }
      function b(S) {
        var C = S && S.then;
        if (S && (typeof S == "object" || typeof S == "function") && typeof C == "function")
          return function() {
            C.apply(S, arguments);
          };
      }
      function x(S, C) {
        var M = !1;
        function T(I) {
          M || (M = !0, a.reject(S, I));
        }
        function P(I) {
          M || (M = !0, a.resolve(S, I));
        }
        var D = y(function() {
          C(P, T);
        });
        D.status === "error" && T(D.value);
      }
      function y(S, C) {
        var M = {};
        try {
          M.value = S(C), M.status = "success";
        } catch (T) {
          M.status = "error", M.value = T;
        }
        return M;
      }
      (i.exports = p).prototype.finally = function(S) {
        if (typeof S != "function")
          return this;
        var C = this.constructor;
        return this.then(function(M) {
          return C.resolve(S()).then(function() {
            return M;
          });
        }, function(M) {
          return C.resolve(S()).then(function() {
            throw M;
          });
        });
      }, p.prototype.catch = function(S) {
        return this.then(null, S);
      }, p.prototype.then = function(S, C) {
        if (typeof S != "function" && this.state === c || typeof C != "function" && this.state === l)
          return this;
        var M = new this.constructor(o);
        return this.state !== d ? v(M, this.state === c ? S : C, this.outcome) : this.queue.push(new m(M, S, C)), M;
      }, m.prototype.callFulfilled = function(S) {
        a.resolve(this.promise, S);
      }, m.prototype.otherCallFulfilled = function(S) {
        v(this.promise, this.onFulfilled, S);
      }, m.prototype.callRejected = function(S) {
        a.reject(this.promise, S);
      }, m.prototype.otherCallRejected = function(S) {
        v(this.promise, this.onRejected, S);
      }, a.resolve = function(S, C) {
        var M = y(b, C);
        if (M.status === "error")
          return a.reject(S, M.value);
        var T = M.value;
        if (T)
          x(S, T);
        else {
          S.state = c, S.outcome = C;
          for (var P = -1, D = S.queue.length; ++P < D; )
            S.queue[P].callFulfilled(C);
        }
        return S;
      }, a.reject = function(S, C) {
        S.state = l, S.outcome = C;
        for (var M = -1, T = S.queue.length; ++M < T; )
          S.queue[M].callRejected(C);
        return S;
      }, p.resolve = function(S) {
        return S instanceof this ? S : a.resolve(new this(o), S);
      }, p.reject = function(S) {
        var C = new this(o);
        return a.reject(C, S);
      }, p.all = function(S) {
        var C = this;
        if (Object.prototype.toString.call(S) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var M = S.length, T = !1;
        if (!M)
          return this.resolve([]);
        for (var P = new Array(M), D = 0, I = -1, k = new this(o); ++I < M; )
          O(S[I], I);
        return k;
        function O(B, Y) {
          C.resolve(B).then(function(G) {
            P[Y] = G, ++D !== M || T || (T = !0, a.resolve(k, P));
          }, function(G) {
            T || (T = !0, a.reject(k, G));
          });
        }
      }, p.race = function(S) {
        var C = this;
        if (Object.prototype.toString.call(S) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var M = S.length, T = !1;
        if (!M)
          return this.resolve([]);
        for (var P = -1, D = new this(o); ++P < M; )
          I = S[P], C.resolve(I).then(function(k) {
            T || (T = !0, a.resolve(D, k));
          }, function(k) {
            T || (T = !0, a.reject(D, k));
          });
        var I;
        return D;
      };
    }, { immediate: 36 }], 38: [function(t, i, r) {
      var s = {};
      (0, t("./lib/utils/common").assign)(s, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), i.exports = s;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, i, r) {
      var s = t("./zlib/deflate"), o = t("./utils/common"), a = t("./utils/strings"), l = t("./zlib/messages"), c = t("./zlib/zstream"), d = Object.prototype.toString, p = 0, m = -1, v = 0, b = 8;
      function x(S) {
        if (!(this instanceof x))
          return new x(S);
        this.options = o.assign({ level: m, method: b, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: v, to: "" }, S || {});
        var C = this.options;
        C.raw && 0 < C.windowBits ? C.windowBits = -C.windowBits : C.gzip && 0 < C.windowBits && C.windowBits < 16 && (C.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var M = s.deflateInit2(this.strm, C.level, C.method, C.windowBits, C.memLevel, C.strategy);
        if (M !== p)
          throw new Error(l[M]);
        if (C.header && s.deflateSetHeader(this.strm, C.header), C.dictionary) {
          var T;
          if (T = typeof C.dictionary == "string" ? a.string2buf(C.dictionary) : d.call(C.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(C.dictionary) : C.dictionary, (M = s.deflateSetDictionary(this.strm, T)) !== p)
            throw new Error(l[M]);
          this._dict_set = !0;
        }
      }
      function y(S, C) {
        var M = new x(C);
        if (M.push(S, !0), M.err)
          throw M.msg || l[M.err];
        return M.result;
      }
      x.prototype.push = function(S, C) {
        var M, T, P = this.strm, D = this.options.chunkSize;
        if (this.ended)
          return !1;
        T = C === ~~C ? C : C === !0 ? 4 : 0, typeof S == "string" ? P.input = a.string2buf(S) : d.call(S) === "[object ArrayBuffer]" ? P.input = new Uint8Array(S) : P.input = S, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new o.Buf8(D), P.next_out = 0, P.avail_out = D), (M = s.deflate(P, T)) !== 1 && M !== p)
            return this.onEnd(M), !(this.ended = !0);
          P.avail_out !== 0 && (P.avail_in !== 0 || T !== 4 && T !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(P.output, P.next_out))) : this.onData(o.shrinkBuf(P.output, P.next_out)));
        } while ((0 < P.avail_in || P.avail_out === 0) && M !== 1);
        return T === 4 ? (M = s.deflateEnd(this.strm), this.onEnd(M), this.ended = !0, M === p) : T !== 2 || (this.onEnd(p), !(P.avail_out = 0));
      }, x.prototype.onData = function(S) {
        this.chunks.push(S);
      }, x.prototype.onEnd = function(S) {
        S === p && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = S, this.msg = this.strm.msg;
      }, r.Deflate = x, r.deflate = y, r.deflateRaw = function(S, C) {
        return (C = C || {}).raw = !0, y(S, C);
      }, r.gzip = function(S, C) {
        return (C = C || {}).gzip = !0, y(S, C);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, i, r) {
      var s = t("./zlib/inflate"), o = t("./utils/common"), a = t("./utils/strings"), l = t("./zlib/constants"), c = t("./zlib/messages"), d = t("./zlib/zstream"), p = t("./zlib/gzheader"), m = Object.prototype.toString;
      function v(x) {
        if (!(this instanceof v))
          return new v(x);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, x || {});
        var y = this.options;
        y.raw && 0 <= y.windowBits && y.windowBits < 16 && (y.windowBits = -y.windowBits, y.windowBits === 0 && (y.windowBits = -15)), !(0 <= y.windowBits && y.windowBits < 16) || x && x.windowBits || (y.windowBits += 32), 15 < y.windowBits && y.windowBits < 48 && (15 & y.windowBits) == 0 && (y.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var S = s.inflateInit2(this.strm, y.windowBits);
        if (S !== l.Z_OK)
          throw new Error(c[S]);
        this.header = new p(), s.inflateGetHeader(this.strm, this.header);
      }
      function b(x, y) {
        var S = new v(y);
        if (S.push(x, !0), S.err)
          throw S.msg || c[S.err];
        return S.result;
      }
      v.prototype.push = function(x, y) {
        var S, C, M, T, P, D, I = this.strm, k = this.options.chunkSize, O = this.options.dictionary, B = !1;
        if (this.ended)
          return !1;
        C = y === ~~y ? y : y === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof x == "string" ? I.input = a.binstring2buf(x) : m.call(x) === "[object ArrayBuffer]" ? I.input = new Uint8Array(x) : I.input = x, I.next_in = 0, I.avail_in = I.input.length;
        do {
          if (I.avail_out === 0 && (I.output = new o.Buf8(k), I.next_out = 0, I.avail_out = k), (S = s.inflate(I, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && O && (D = typeof O == "string" ? a.string2buf(O) : m.call(O) === "[object ArrayBuffer]" ? new Uint8Array(O) : O, S = s.inflateSetDictionary(this.strm, D)), S === l.Z_BUF_ERROR && B === !0 && (S = l.Z_OK, B = !1), S !== l.Z_STREAM_END && S !== l.Z_OK)
            return this.onEnd(S), !(this.ended = !0);
          I.next_out && (I.avail_out !== 0 && S !== l.Z_STREAM_END && (I.avail_in !== 0 || C !== l.Z_FINISH && C !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (M = a.utf8border(I.output, I.next_out), T = I.next_out - M, P = a.buf2string(I.output, M), I.next_out = T, I.avail_out = k - T, T && o.arraySet(I.output, I.output, M, T, 0), this.onData(P)) : this.onData(o.shrinkBuf(I.output, I.next_out)))), I.avail_in === 0 && I.avail_out === 0 && (B = !0);
        } while ((0 < I.avail_in || I.avail_out === 0) && S !== l.Z_STREAM_END);
        return S === l.Z_STREAM_END && (C = l.Z_FINISH), C === l.Z_FINISH ? (S = s.inflateEnd(this.strm), this.onEnd(S), this.ended = !0, S === l.Z_OK) : C !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(I.avail_out = 0));
      }, v.prototype.onData = function(x) {
        this.chunks.push(x);
      }, v.prototype.onEnd = function(x) {
        x === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
      }, r.Inflate = v, r.inflate = b, r.inflateRaw = function(x, y) {
        return (y = y || {}).raw = !0, b(x, y);
      }, r.ungzip = b;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, i, r) {
      var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      r.assign = function(l) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var d = c.shift();
          if (d) {
            if (typeof d != "object")
              throw new TypeError(d + "must be non-object");
            for (var p in d)
              d.hasOwnProperty(p) && (l[p] = d[p]);
          }
        }
        return l;
      }, r.shrinkBuf = function(l, c) {
        return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
      };
      var o = { arraySet: function(l, c, d, p, m) {
        if (c.subarray && l.subarray)
          l.set(c.subarray(d, d + p), m);
        else
          for (var v = 0; v < p; v++)
            l[m + v] = c[d + v];
      }, flattenChunks: function(l) {
        var c, d, p, m, v, b;
        for (c = p = 0, d = l.length; c < d; c++)
          p += l[c].length;
        for (b = new Uint8Array(p), c = m = 0, d = l.length; c < d; c++)
          v = l[c], b.set(v, m), m += v.length;
        return b;
      } }, a = { arraySet: function(l, c, d, p, m) {
        for (var v = 0; v < p; v++)
          l[m + v] = c[d + v];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      r.setTyped = function(l) {
        l ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, o)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, a));
      }, r.setTyped(s);
    }, {}], 42: [function(t, i, r) {
      var s = t("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new s.Buf8(256), c = 0; c < 256; c++)
        l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function d(p, m) {
        if (m < 65537 && (p.subarray && a || !p.subarray && o))
          return String.fromCharCode.apply(null, s.shrinkBuf(p, m));
        for (var v = "", b = 0; b < m; b++)
          v += String.fromCharCode(p[b]);
        return v;
      }
      l[254] = l[254] = 1, r.string2buf = function(p) {
        var m, v, b, x, y, S = p.length, C = 0;
        for (x = 0; x < S; x++)
          (64512 & (v = p.charCodeAt(x))) == 55296 && x + 1 < S && (64512 & (b = p.charCodeAt(x + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (b - 56320), x++), C += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
        for (m = new s.Buf8(C), x = y = 0; y < C; x++)
          (64512 & (v = p.charCodeAt(x))) == 55296 && x + 1 < S && (64512 & (b = p.charCodeAt(x + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (b - 56320), x++), v < 128 ? m[y++] = v : (v < 2048 ? m[y++] = 192 | v >>> 6 : (v < 65536 ? m[y++] = 224 | v >>> 12 : (m[y++] = 240 | v >>> 18, m[y++] = 128 | v >>> 12 & 63), m[y++] = 128 | v >>> 6 & 63), m[y++] = 128 | 63 & v);
        return m;
      }, r.buf2binstring = function(p) {
        return d(p, p.length);
      }, r.binstring2buf = function(p) {
        for (var m = new s.Buf8(p.length), v = 0, b = m.length; v < b; v++)
          m[v] = p.charCodeAt(v);
        return m;
      }, r.buf2string = function(p, m) {
        var v, b, x, y, S = m || p.length, C = new Array(2 * S);
        for (v = b = 0; v < S; )
          if ((x = p[v++]) < 128)
            C[b++] = x;
          else if (4 < (y = l[x]))
            C[b++] = 65533, v += y - 1;
          else {
            for (x &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && v < S; )
              x = x << 6 | 63 & p[v++], y--;
            1 < y ? C[b++] = 65533 : x < 65536 ? C[b++] = x : (x -= 65536, C[b++] = 55296 | x >> 10 & 1023, C[b++] = 56320 | 1023 & x);
          }
        return d(C, b);
      }, r.utf8border = function(p, m) {
        var v;
        for ((m = m || p.length) > p.length && (m = p.length), v = m - 1; 0 <= v && (192 & p[v]) == 128; )
          v--;
        return v < 0 || v === 0 ? m : v + l[p[v]] > m ? v : m;
      };
    }, { "./common": 41 }], 43: [function(t, i, r) {
      i.exports = function(s, o, a, l) {
        for (var c = 65535 & s | 0, d = s >>> 16 & 65535 | 0, p = 0; a !== 0; ) {
          for (a -= p = 2e3 < a ? 2e3 : a; d = d + (c = c + o[l++] | 0) | 0, --p; )
            ;
          c %= 65521, d %= 65521;
        }
        return c | d << 16 | 0;
      };
    }, {}], 44: [function(t, i, r) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(t, i, r) {
      var s = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var c = 0; c < 8; c++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      i.exports = function(o, a, l, c) {
        var d = s, p = c + l;
        o ^= -1;
        for (var m = c; m < p; m++)
          o = o >>> 8 ^ d[255 & (o ^ a[m])];
        return -1 ^ o;
      };
    }, {}], 46: [function(t, i, r) {
      var s, o = t("../utils/common"), a = t("./trees"), l = t("./adler32"), c = t("./crc32"), d = t("./messages"), p = 0, m = 4, v = 0, b = -2, x = -1, y = 4, S = 2, C = 8, M = 9, T = 286, P = 30, D = 19, I = 2 * T + 1, k = 15, O = 3, B = 258, Y = B + O + 1, G = 42, K = 113, A = 1, J = 2, xe = 3, se = 4;
      function oe(L, fe) {
        return L.msg = d[fe], fe;
      }
      function Q(L) {
        return (L << 1) - (4 < L ? 9 : 0);
      }
      function ce(L) {
        for (var fe = L.length; 0 <= --fe; )
          L[fe] = 0;
      }
      function te(L) {
        var fe = L.state, ae = fe.pending;
        ae > L.avail_out && (ae = L.avail_out), ae !== 0 && (o.arraySet(L.output, fe.pending_buf, fe.pending_out, ae, L.next_out), L.next_out += ae, fe.pending_out += ae, L.total_out += ae, L.avail_out -= ae, fe.pending -= ae, fe.pending === 0 && (fe.pending_out = 0));
      }
      function ee(L, fe) {
        a._tr_flush_block(L, 0 <= L.block_start ? L.block_start : -1, L.strstart - L.block_start, fe), L.block_start = L.strstart, te(L.strm);
      }
      function Re(L, fe) {
        L.pending_buf[L.pending++] = fe;
      }
      function ye(L, fe) {
        L.pending_buf[L.pending++] = fe >>> 8 & 255, L.pending_buf[L.pending++] = 255 & fe;
      }
      function Se(L, fe) {
        var ae, $, j = L.max_chain_length, re = L.strstart, Te = L.prev_length, Ce = L.nice_match, F = L.strstart > L.w_size - Y ? L.strstart - (L.w_size - Y) : 0, U = L.window, he = L.w_mask, me = L.prev, Ae = L.strstart + B, Ve = U[re + Te - 1], $e = U[re + Te];
        L.prev_length >= L.good_match && (j >>= 2), Ce > L.lookahead && (Ce = L.lookahead);
        do
          if (U[(ae = fe) + Te] === $e && U[ae + Te - 1] === Ve && U[ae] === U[re] && U[++ae] === U[re + 1]) {
            re += 2, ae++;
            do
              ;
            while (U[++re] === U[++ae] && U[++re] === U[++ae] && U[++re] === U[++ae] && U[++re] === U[++ae] && U[++re] === U[++ae] && U[++re] === U[++ae] && U[++re] === U[++ae] && U[++re] === U[++ae] && re < Ae);
            if ($ = B - (Ae - re), re = Ae - B, Te < $) {
              if (L.match_start = fe, Ce <= (Te = $))
                break;
              Ve = U[re + Te - 1], $e = U[re + Te];
            }
          }
        while ((fe = me[fe & he]) > F && --j != 0);
        return Te <= L.lookahead ? Te : L.lookahead;
      }
      function Ee(L) {
        var fe, ae, $, j, re, Te, Ce, F, U, he, me = L.w_size;
        do {
          if (j = L.window_size - L.lookahead - L.strstart, L.strstart >= me + (me - Y)) {
            for (o.arraySet(L.window, L.window, me, me, 0), L.match_start -= me, L.strstart -= me, L.block_start -= me, fe = ae = L.hash_size; $ = L.head[--fe], L.head[fe] = me <= $ ? $ - me : 0, --ae; )
              ;
            for (fe = ae = me; $ = L.prev[--fe], L.prev[fe] = me <= $ ? $ - me : 0, --ae; )
              ;
            j += me;
          }
          if (L.strm.avail_in === 0)
            break;
          if (Te = L.strm, Ce = L.window, F = L.strstart + L.lookahead, U = j, he = void 0, he = Te.avail_in, U < he && (he = U), ae = he === 0 ? 0 : (Te.avail_in -= he, o.arraySet(Ce, Te.input, Te.next_in, he, F), Te.state.wrap === 1 ? Te.adler = l(Te.adler, Ce, he, F) : Te.state.wrap === 2 && (Te.adler = c(Te.adler, Ce, he, F)), Te.next_in += he, Te.total_in += he, he), L.lookahead += ae, L.lookahead + L.insert >= O)
            for (re = L.strstart - L.insert, L.ins_h = L.window[re], L.ins_h = (L.ins_h << L.hash_shift ^ L.window[re + 1]) & L.hash_mask; L.insert && (L.ins_h = (L.ins_h << L.hash_shift ^ L.window[re + O - 1]) & L.hash_mask, L.prev[re & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = re, re++, L.insert--, !(L.lookahead + L.insert < O)); )
              ;
        } while (L.lookahead < Y && L.strm.avail_in !== 0);
      }
      function gt(L, fe) {
        for (var ae, $; ; ) {
          if (L.lookahead < Y) {
            if (Ee(L), L.lookahead < Y && fe === p)
              return A;
            if (L.lookahead === 0)
              break;
          }
          if (ae = 0, L.lookahead >= O && (L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + O - 1]) & L.hash_mask, ae = L.prev[L.strstart & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = L.strstart), ae !== 0 && L.strstart - ae <= L.w_size - Y && (L.match_length = Se(L, ae)), L.match_length >= O)
            if ($ = a._tr_tally(L, L.strstart - L.match_start, L.match_length - O), L.lookahead -= L.match_length, L.match_length <= L.max_lazy_match && L.lookahead >= O) {
              for (L.match_length--; L.strstart++, L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + O - 1]) & L.hash_mask, ae = L.prev[L.strstart & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = L.strstart, --L.match_length != 0; )
                ;
              L.strstart++;
            } else
              L.strstart += L.match_length, L.match_length = 0, L.ins_h = L.window[L.strstart], L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + 1]) & L.hash_mask;
          else
            $ = a._tr_tally(L, 0, L.window[L.strstart]), L.lookahead--, L.strstart++;
          if ($ && (ee(L, !1), L.strm.avail_out === 0))
            return A;
        }
        return L.insert = L.strstart < O - 1 ? L.strstart : O - 1, fe === m ? (ee(L, !0), L.strm.avail_out === 0 ? xe : se) : L.last_lit && (ee(L, !1), L.strm.avail_out === 0) ? A : J;
      }
      function qe(L, fe) {
        for (var ae, $, j; ; ) {
          if (L.lookahead < Y) {
            if (Ee(L), L.lookahead < Y && fe === p)
              return A;
            if (L.lookahead === 0)
              break;
          }
          if (ae = 0, L.lookahead >= O && (L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + O - 1]) & L.hash_mask, ae = L.prev[L.strstart & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = L.strstart), L.prev_length = L.match_length, L.prev_match = L.match_start, L.match_length = O - 1, ae !== 0 && L.prev_length < L.max_lazy_match && L.strstart - ae <= L.w_size - Y && (L.match_length = Se(L, ae), L.match_length <= 5 && (L.strategy === 1 || L.match_length === O && 4096 < L.strstart - L.match_start) && (L.match_length = O - 1)), L.prev_length >= O && L.match_length <= L.prev_length) {
            for (j = L.strstart + L.lookahead - O, $ = a._tr_tally(L, L.strstart - 1 - L.prev_match, L.prev_length - O), L.lookahead -= L.prev_length - 1, L.prev_length -= 2; ++L.strstart <= j && (L.ins_h = (L.ins_h << L.hash_shift ^ L.window[L.strstart + O - 1]) & L.hash_mask, ae = L.prev[L.strstart & L.w_mask] = L.head[L.ins_h], L.head[L.ins_h] = L.strstart), --L.prev_length != 0; )
              ;
            if (L.match_available = 0, L.match_length = O - 1, L.strstart++, $ && (ee(L, !1), L.strm.avail_out === 0))
              return A;
          } else if (L.match_available) {
            if (($ = a._tr_tally(L, 0, L.window[L.strstart - 1])) && ee(L, !1), L.strstart++, L.lookahead--, L.strm.avail_out === 0)
              return A;
          } else
            L.match_available = 1, L.strstart++, L.lookahead--;
        }
        return L.match_available && ($ = a._tr_tally(L, 0, L.window[L.strstart - 1]), L.match_available = 0), L.insert = L.strstart < O - 1 ? L.strstart : O - 1, fe === m ? (ee(L, !0), L.strm.avail_out === 0 ? xe : se) : L.last_lit && (ee(L, !1), L.strm.avail_out === 0) ? A : J;
      }
      function Ze(L, fe, ae, $, j) {
        this.good_length = L, this.max_lazy = fe, this.nice_length = ae, this.max_chain = $, this.func = j;
      }
      function je() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = C, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * I), this.dyn_dtree = new o.Buf16(2 * (2 * P + 1)), this.bl_tree = new o.Buf16(2 * (2 * D + 1)), ce(this.dyn_ltree), ce(this.dyn_dtree), ce(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(k + 1), this.heap = new o.Buf16(2 * T + 1), ce(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * T + 1), ce(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function st(L) {
        var fe;
        return L && L.state ? (L.total_in = L.total_out = 0, L.data_type = S, (fe = L.state).pending = 0, fe.pending_out = 0, fe.wrap < 0 && (fe.wrap = -fe.wrap), fe.status = fe.wrap ? G : K, L.adler = fe.wrap === 2 ? 0 : 1, fe.last_flush = p, a._tr_init(fe), v) : oe(L, b);
      }
      function Ie(L) {
        var fe = st(L);
        return fe === v && function(ae) {
          ae.window_size = 2 * ae.w_size, ce(ae.head), ae.max_lazy_match = s[ae.level].max_lazy, ae.good_match = s[ae.level].good_length, ae.nice_match = s[ae.level].nice_length, ae.max_chain_length = s[ae.level].max_chain, ae.strstart = 0, ae.block_start = 0, ae.lookahead = 0, ae.insert = 0, ae.match_length = ae.prev_length = O - 1, ae.match_available = 0, ae.ins_h = 0;
        }(L.state), fe;
      }
      function Le(L, fe, ae, $, j, re) {
        if (!L)
          return b;
        var Te = 1;
        if (fe === x && (fe = 6), $ < 0 ? (Te = 0, $ = -$) : 15 < $ && (Te = 2, $ -= 16), j < 1 || M < j || ae !== C || $ < 8 || 15 < $ || fe < 0 || 9 < fe || re < 0 || y < re)
          return oe(L, b);
        $ === 8 && ($ = 9);
        var Ce = new je();
        return (L.state = Ce).strm = L, Ce.wrap = Te, Ce.gzhead = null, Ce.w_bits = $, Ce.w_size = 1 << Ce.w_bits, Ce.w_mask = Ce.w_size - 1, Ce.hash_bits = j + 7, Ce.hash_size = 1 << Ce.hash_bits, Ce.hash_mask = Ce.hash_size - 1, Ce.hash_shift = ~~((Ce.hash_bits + O - 1) / O), Ce.window = new o.Buf8(2 * Ce.w_size), Ce.head = new o.Buf16(Ce.hash_size), Ce.prev = new o.Buf16(Ce.w_size), Ce.lit_bufsize = 1 << j + 6, Ce.pending_buf_size = 4 * Ce.lit_bufsize, Ce.pending_buf = new o.Buf8(Ce.pending_buf_size), Ce.d_buf = 1 * Ce.lit_bufsize, Ce.l_buf = 3 * Ce.lit_bufsize, Ce.level = fe, Ce.strategy = re, Ce.method = ae, Ie(L);
      }
      s = [new Ze(0, 0, 0, 0, function(L, fe) {
        var ae = 65535;
        for (ae > L.pending_buf_size - 5 && (ae = L.pending_buf_size - 5); ; ) {
          if (L.lookahead <= 1) {
            if (Ee(L), L.lookahead === 0 && fe === p)
              return A;
            if (L.lookahead === 0)
              break;
          }
          L.strstart += L.lookahead, L.lookahead = 0;
          var $ = L.block_start + ae;
          if ((L.strstart === 0 || L.strstart >= $) && (L.lookahead = L.strstart - $, L.strstart = $, ee(L, !1), L.strm.avail_out === 0) || L.strstart - L.block_start >= L.w_size - Y && (ee(L, !1), L.strm.avail_out === 0))
            return A;
        }
        return L.insert = 0, fe === m ? (ee(L, !0), L.strm.avail_out === 0 ? xe : se) : (L.strstart > L.block_start && (ee(L, !1), L.strm.avail_out), A);
      }), new Ze(4, 4, 8, 4, gt), new Ze(4, 5, 16, 8, gt), new Ze(4, 6, 32, 32, gt), new Ze(4, 4, 16, 16, qe), new Ze(8, 16, 32, 32, qe), new Ze(8, 16, 128, 128, qe), new Ze(8, 32, 128, 256, qe), new Ze(32, 128, 258, 1024, qe), new Ze(32, 258, 258, 4096, qe)], r.deflateInit = function(L, fe) {
        return Le(L, fe, C, 15, 8, 0);
      }, r.deflateInit2 = Le, r.deflateReset = Ie, r.deflateResetKeep = st, r.deflateSetHeader = function(L, fe) {
        return L && L.state ? L.state.wrap !== 2 ? b : (L.state.gzhead = fe, v) : b;
      }, r.deflate = function(L, fe) {
        var ae, $, j, re;
        if (!L || !L.state || 5 < fe || fe < 0)
          return L ? oe(L, b) : b;
        if ($ = L.state, !L.output || !L.input && L.avail_in !== 0 || $.status === 666 && fe !== m)
          return oe(L, L.avail_out === 0 ? -5 : b);
        if ($.strm = L, ae = $.last_flush, $.last_flush = fe, $.status === G)
          if ($.wrap === 2)
            L.adler = 0, Re($, 31), Re($, 139), Re($, 8), $.gzhead ? (Re($, ($.gzhead.text ? 1 : 0) + ($.gzhead.hcrc ? 2 : 0) + ($.gzhead.extra ? 4 : 0) + ($.gzhead.name ? 8 : 0) + ($.gzhead.comment ? 16 : 0)), Re($, 255 & $.gzhead.time), Re($, $.gzhead.time >> 8 & 255), Re($, $.gzhead.time >> 16 & 255), Re($, $.gzhead.time >> 24 & 255), Re($, $.level === 9 ? 2 : 2 <= $.strategy || $.level < 2 ? 4 : 0), Re($, 255 & $.gzhead.os), $.gzhead.extra && $.gzhead.extra.length && (Re($, 255 & $.gzhead.extra.length), Re($, $.gzhead.extra.length >> 8 & 255)), $.gzhead.hcrc && (L.adler = c(L.adler, $.pending_buf, $.pending, 0)), $.gzindex = 0, $.status = 69) : (Re($, 0), Re($, 0), Re($, 0), Re($, 0), Re($, 0), Re($, $.level === 9 ? 2 : 2 <= $.strategy || $.level < 2 ? 4 : 0), Re($, 3), $.status = K);
          else {
            var Te = C + ($.w_bits - 8 << 4) << 8;
            Te |= (2 <= $.strategy || $.level < 2 ? 0 : $.level < 6 ? 1 : $.level === 6 ? 2 : 3) << 6, $.strstart !== 0 && (Te |= 32), Te += 31 - Te % 31, $.status = K, ye($, Te), $.strstart !== 0 && (ye($, L.adler >>> 16), ye($, 65535 & L.adler)), L.adler = 1;
          }
        if ($.status === 69)
          if ($.gzhead.extra) {
            for (j = $.pending; $.gzindex < (65535 & $.gzhead.extra.length) && ($.pending !== $.pending_buf_size || ($.gzhead.hcrc && $.pending > j && (L.adler = c(L.adler, $.pending_buf, $.pending - j, j)), te(L), j = $.pending, $.pending !== $.pending_buf_size)); )
              Re($, 255 & $.gzhead.extra[$.gzindex]), $.gzindex++;
            $.gzhead.hcrc && $.pending > j && (L.adler = c(L.adler, $.pending_buf, $.pending - j, j)), $.gzindex === $.gzhead.extra.length && ($.gzindex = 0, $.status = 73);
          } else
            $.status = 73;
        if ($.status === 73)
          if ($.gzhead.name) {
            j = $.pending;
            do {
              if ($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > j && (L.adler = c(L.adler, $.pending_buf, $.pending - j, j)), te(L), j = $.pending, $.pending === $.pending_buf_size)) {
                re = 1;
                break;
              }
              re = $.gzindex < $.gzhead.name.length ? 255 & $.gzhead.name.charCodeAt($.gzindex++) : 0, Re($, re);
            } while (re !== 0);
            $.gzhead.hcrc && $.pending > j && (L.adler = c(L.adler, $.pending_buf, $.pending - j, j)), re === 0 && ($.gzindex = 0, $.status = 91);
          } else
            $.status = 91;
        if ($.status === 91)
          if ($.gzhead.comment) {
            j = $.pending;
            do {
              if ($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > j && (L.adler = c(L.adler, $.pending_buf, $.pending - j, j)), te(L), j = $.pending, $.pending === $.pending_buf_size)) {
                re = 1;
                break;
              }
              re = $.gzindex < $.gzhead.comment.length ? 255 & $.gzhead.comment.charCodeAt($.gzindex++) : 0, Re($, re);
            } while (re !== 0);
            $.gzhead.hcrc && $.pending > j && (L.adler = c(L.adler, $.pending_buf, $.pending - j, j)), re === 0 && ($.status = 103);
          } else
            $.status = 103;
        if ($.status === 103 && ($.gzhead.hcrc ? ($.pending + 2 > $.pending_buf_size && te(L), $.pending + 2 <= $.pending_buf_size && (Re($, 255 & L.adler), Re($, L.adler >> 8 & 255), L.adler = 0, $.status = K)) : $.status = K), $.pending !== 0) {
          if (te(L), L.avail_out === 0)
            return $.last_flush = -1, v;
        } else if (L.avail_in === 0 && Q(fe) <= Q(ae) && fe !== m)
          return oe(L, -5);
        if ($.status === 666 && L.avail_in !== 0)
          return oe(L, -5);
        if (L.avail_in !== 0 || $.lookahead !== 0 || fe !== p && $.status !== 666) {
          var Ce = $.strategy === 2 ? function(F, U) {
            for (var he; ; ) {
              if (F.lookahead === 0 && (Ee(F), F.lookahead === 0)) {
                if (U === p)
                  return A;
                break;
              }
              if (F.match_length = 0, he = a._tr_tally(F, 0, F.window[F.strstart]), F.lookahead--, F.strstart++, he && (ee(F, !1), F.strm.avail_out === 0))
                return A;
            }
            return F.insert = 0, U === m ? (ee(F, !0), F.strm.avail_out === 0 ? xe : se) : F.last_lit && (ee(F, !1), F.strm.avail_out === 0) ? A : J;
          }($, fe) : $.strategy === 3 ? function(F, U) {
            for (var he, me, Ae, Ve, $e = F.window; ; ) {
              if (F.lookahead <= B) {
                if (Ee(F), F.lookahead <= B && U === p)
                  return A;
                if (F.lookahead === 0)
                  break;
              }
              if (F.match_length = 0, F.lookahead >= O && 0 < F.strstart && (me = $e[Ae = F.strstart - 1]) === $e[++Ae] && me === $e[++Ae] && me === $e[++Ae]) {
                Ve = F.strstart + B;
                do
                  ;
                while (me === $e[++Ae] && me === $e[++Ae] && me === $e[++Ae] && me === $e[++Ae] && me === $e[++Ae] && me === $e[++Ae] && me === $e[++Ae] && me === $e[++Ae] && Ae < Ve);
                F.match_length = B - (Ve - Ae), F.match_length > F.lookahead && (F.match_length = F.lookahead);
              }
              if (F.match_length >= O ? (he = a._tr_tally(F, 1, F.match_length - O), F.lookahead -= F.match_length, F.strstart += F.match_length, F.match_length = 0) : (he = a._tr_tally(F, 0, F.window[F.strstart]), F.lookahead--, F.strstart++), he && (ee(F, !1), F.strm.avail_out === 0))
                return A;
            }
            return F.insert = 0, U === m ? (ee(F, !0), F.strm.avail_out === 0 ? xe : se) : F.last_lit && (ee(F, !1), F.strm.avail_out === 0) ? A : J;
          }($, fe) : s[$.level].func($, fe);
          if (Ce !== xe && Ce !== se || ($.status = 666), Ce === A || Ce === xe)
            return L.avail_out === 0 && ($.last_flush = -1), v;
          if (Ce === J && (fe === 1 ? a._tr_align($) : fe !== 5 && (a._tr_stored_block($, 0, 0, !1), fe === 3 && (ce($.head), $.lookahead === 0 && ($.strstart = 0, $.block_start = 0, $.insert = 0))), te(L), L.avail_out === 0))
            return $.last_flush = -1, v;
        }
        return fe !== m ? v : $.wrap <= 0 ? 1 : ($.wrap === 2 ? (Re($, 255 & L.adler), Re($, L.adler >> 8 & 255), Re($, L.adler >> 16 & 255), Re($, L.adler >> 24 & 255), Re($, 255 & L.total_in), Re($, L.total_in >> 8 & 255), Re($, L.total_in >> 16 & 255), Re($, L.total_in >> 24 & 255)) : (ye($, L.adler >>> 16), ye($, 65535 & L.adler)), te(L), 0 < $.wrap && ($.wrap = -$.wrap), $.pending !== 0 ? v : 1);
      }, r.deflateEnd = function(L) {
        var fe;
        return L && L.state ? (fe = L.state.status) !== G && fe !== 69 && fe !== 73 && fe !== 91 && fe !== 103 && fe !== K && fe !== 666 ? oe(L, b) : (L.state = null, fe === K ? oe(L, -3) : v) : b;
      }, r.deflateSetDictionary = function(L, fe) {
        var ae, $, j, re, Te, Ce, F, U, he = fe.length;
        if (!L || !L.state || (re = (ae = L.state).wrap) === 2 || re === 1 && ae.status !== G || ae.lookahead)
          return b;
        for (re === 1 && (L.adler = l(L.adler, fe, he, 0)), ae.wrap = 0, he >= ae.w_size && (re === 0 && (ce(ae.head), ae.strstart = 0, ae.block_start = 0, ae.insert = 0), U = new o.Buf8(ae.w_size), o.arraySet(U, fe, he - ae.w_size, ae.w_size, 0), fe = U, he = ae.w_size), Te = L.avail_in, Ce = L.next_in, F = L.input, L.avail_in = he, L.next_in = 0, L.input = fe, Ee(ae); ae.lookahead >= O; ) {
          for ($ = ae.strstart, j = ae.lookahead - (O - 1); ae.ins_h = (ae.ins_h << ae.hash_shift ^ ae.window[$ + O - 1]) & ae.hash_mask, ae.prev[$ & ae.w_mask] = ae.head[ae.ins_h], ae.head[ae.ins_h] = $, $++, --j; )
            ;
          ae.strstart = $, ae.lookahead = O - 1, Ee(ae);
        }
        return ae.strstart += ae.lookahead, ae.block_start = ae.strstart, ae.insert = ae.lookahead, ae.lookahead = 0, ae.match_length = ae.prev_length = O - 1, ae.match_available = 0, L.next_in = Ce, L.input = F, L.avail_in = Te, ae.wrap = re, v;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, i, r) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(t, i, r) {
      i.exports = function(s, o) {
        var a, l, c, d, p, m, v, b, x, y, S, C, M, T, P, D, I, k, O, B, Y, G, K, A, J;
        a = s.state, l = s.next_in, A = s.input, c = l + (s.avail_in - 5), d = s.next_out, J = s.output, p = d - (o - s.avail_out), m = d + (s.avail_out - 257), v = a.dmax, b = a.wsize, x = a.whave, y = a.wnext, S = a.window, C = a.hold, M = a.bits, T = a.lencode, P = a.distcode, D = (1 << a.lenbits) - 1, I = (1 << a.distbits) - 1;
        e:
          do {
            M < 15 && (C += A[l++] << M, M += 8, C += A[l++] << M, M += 8), k = T[C & D];
            t:
              for (; ; ) {
                if (C >>>= O = k >>> 24, M -= O, (O = k >>> 16 & 255) === 0)
                  J[d++] = 65535 & k;
                else {
                  if (!(16 & O)) {
                    if ((64 & O) == 0) {
                      k = T[(65535 & k) + (C & (1 << O) - 1)];
                      continue t;
                    }
                    if (32 & O) {
                      a.mode = 12;
                      break e;
                    }
                    s.msg = "invalid literal/length code", a.mode = 30;
                    break e;
                  }
                  B = 65535 & k, (O &= 15) && (M < O && (C += A[l++] << M, M += 8), B += C & (1 << O) - 1, C >>>= O, M -= O), M < 15 && (C += A[l++] << M, M += 8, C += A[l++] << M, M += 8), k = P[C & I];
                  n:
                    for (; ; ) {
                      if (C >>>= O = k >>> 24, M -= O, !(16 & (O = k >>> 16 & 255))) {
                        if ((64 & O) == 0) {
                          k = P[(65535 & k) + (C & (1 << O) - 1)];
                          continue n;
                        }
                        s.msg = "invalid distance code", a.mode = 30;
                        break e;
                      }
                      if (Y = 65535 & k, M < (O &= 15) && (C += A[l++] << M, (M += 8) < O && (C += A[l++] << M, M += 8)), v < (Y += C & (1 << O) - 1)) {
                        s.msg = "invalid distance too far back", a.mode = 30;
                        break e;
                      }
                      if (C >>>= O, M -= O, (O = d - p) < Y) {
                        if (x < (O = Y - O) && a.sane) {
                          s.msg = "invalid distance too far back", a.mode = 30;
                          break e;
                        }
                        if (K = S, (G = 0) === y) {
                          if (G += b - O, O < B) {
                            for (B -= O; J[d++] = S[G++], --O; )
                              ;
                            G = d - Y, K = J;
                          }
                        } else if (y < O) {
                          if (G += b + y - O, (O -= y) < B) {
                            for (B -= O; J[d++] = S[G++], --O; )
                              ;
                            if (G = 0, y < B) {
                              for (B -= O = y; J[d++] = S[G++], --O; )
                                ;
                              G = d - Y, K = J;
                            }
                          }
                        } else if (G += y - O, O < B) {
                          for (B -= O; J[d++] = S[G++], --O; )
                            ;
                          G = d - Y, K = J;
                        }
                        for (; 2 < B; )
                          J[d++] = K[G++], J[d++] = K[G++], J[d++] = K[G++], B -= 3;
                        B && (J[d++] = K[G++], 1 < B && (J[d++] = K[G++]));
                      } else {
                        for (G = d - Y; J[d++] = J[G++], J[d++] = J[G++], J[d++] = J[G++], 2 < (B -= 3); )
                          ;
                        B && (J[d++] = J[G++], 1 < B && (J[d++] = J[G++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (l < c && d < m);
        l -= B = M >> 3, C &= (1 << (M -= B << 3)) - 1, s.next_in = l, s.next_out = d, s.avail_in = l < c ? c - l + 5 : 5 - (l - c), s.avail_out = d < m ? m - d + 257 : 257 - (d - m), a.hold = C, a.bits = M;
      };
    }, {}], 49: [function(t, i, r) {
      var s = t("../utils/common"), o = t("./adler32"), a = t("./crc32"), l = t("./inffast"), c = t("./inftrees"), d = 1, p = 2, m = 0, v = -2, b = 1, x = 852, y = 592;
      function S(G) {
        return (G >>> 24 & 255) + (G >>> 8 & 65280) + ((65280 & G) << 8) + ((255 & G) << 24);
      }
      function C() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new s.Buf16(320), this.work = new s.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function M(G) {
        var K;
        return G && G.state ? (K = G.state, G.total_in = G.total_out = K.total = 0, G.msg = "", K.wrap && (G.adler = 1 & K.wrap), K.mode = b, K.last = 0, K.havedict = 0, K.dmax = 32768, K.head = null, K.hold = 0, K.bits = 0, K.lencode = K.lendyn = new s.Buf32(x), K.distcode = K.distdyn = new s.Buf32(y), K.sane = 1, K.back = -1, m) : v;
      }
      function T(G) {
        var K;
        return G && G.state ? ((K = G.state).wsize = 0, K.whave = 0, K.wnext = 0, M(G)) : v;
      }
      function P(G, K) {
        var A, J;
        return G && G.state ? (J = G.state, K < 0 ? (A = 0, K = -K) : (A = 1 + (K >> 4), K < 48 && (K &= 15)), K && (K < 8 || 15 < K) ? v : (J.window !== null && J.wbits !== K && (J.window = null), J.wrap = A, J.wbits = K, T(G))) : v;
      }
      function D(G, K) {
        var A, J;
        return G ? (J = new C(), (G.state = J).window = null, (A = P(G, K)) !== m && (G.state = null), A) : v;
      }
      var I, k, O = !0;
      function B(G) {
        if (O) {
          var K;
          for (I = new s.Buf32(512), k = new s.Buf32(32), K = 0; K < 144; )
            G.lens[K++] = 8;
          for (; K < 256; )
            G.lens[K++] = 9;
          for (; K < 280; )
            G.lens[K++] = 7;
          for (; K < 288; )
            G.lens[K++] = 8;
          for (c(d, G.lens, 0, 288, I, 0, G.work, { bits: 9 }), K = 0; K < 32; )
            G.lens[K++] = 5;
          c(p, G.lens, 0, 32, k, 0, G.work, { bits: 5 }), O = !1;
        }
        G.lencode = I, G.lenbits = 9, G.distcode = k, G.distbits = 5;
      }
      function Y(G, K, A, J) {
        var xe, se = G.state;
        return se.window === null && (se.wsize = 1 << se.wbits, se.wnext = 0, se.whave = 0, se.window = new s.Buf8(se.wsize)), J >= se.wsize ? (s.arraySet(se.window, K, A - se.wsize, se.wsize, 0), se.wnext = 0, se.whave = se.wsize) : (J < (xe = se.wsize - se.wnext) && (xe = J), s.arraySet(se.window, K, A - J, xe, se.wnext), (J -= xe) ? (s.arraySet(se.window, K, A - J, J, 0), se.wnext = J, se.whave = se.wsize) : (se.wnext += xe, se.wnext === se.wsize && (se.wnext = 0), se.whave < se.wsize && (se.whave += xe))), 0;
      }
      r.inflateReset = T, r.inflateReset2 = P, r.inflateResetKeep = M, r.inflateInit = function(G) {
        return D(G, 15);
      }, r.inflateInit2 = D, r.inflate = function(G, K) {
        var A, J, xe, se, oe, Q, ce, te, ee, Re, ye, Se, Ee, gt, qe, Ze, je, st, Ie, Le, L, fe, ae, $, j = 0, re = new s.Buf8(4), Te = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!G || !G.state || !G.output || !G.input && G.avail_in !== 0)
          return v;
        (A = G.state).mode === 12 && (A.mode = 13), oe = G.next_out, xe = G.output, ce = G.avail_out, se = G.next_in, J = G.input, Q = G.avail_in, te = A.hold, ee = A.bits, Re = Q, ye = ce, fe = m;
        e:
          for (; ; )
            switch (A.mode) {
              case b:
                if (A.wrap === 0) {
                  A.mode = 13;
                  break;
                }
                for (; ee < 16; ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                if (2 & A.wrap && te === 35615) {
                  re[A.check = 0] = 255 & te, re[1] = te >>> 8 & 255, A.check = a(A.check, re, 2, 0), ee = te = 0, A.mode = 2;
                  break;
                }
                if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & te) << 8) + (te >> 8)) % 31) {
                  G.msg = "incorrect header check", A.mode = 30;
                  break;
                }
                if ((15 & te) != 8) {
                  G.msg = "unknown compression method", A.mode = 30;
                  break;
                }
                if (ee -= 4, L = 8 + (15 & (te >>>= 4)), A.wbits === 0)
                  A.wbits = L;
                else if (L > A.wbits) {
                  G.msg = "invalid window size", A.mode = 30;
                  break;
                }
                A.dmax = 1 << L, G.adler = A.check = 1, A.mode = 512 & te ? 10 : 12, ee = te = 0;
                break;
              case 2:
                for (; ee < 16; ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                if (A.flags = te, (255 & A.flags) != 8) {
                  G.msg = "unknown compression method", A.mode = 30;
                  break;
                }
                if (57344 & A.flags) {
                  G.msg = "unknown header flags set", A.mode = 30;
                  break;
                }
                A.head && (A.head.text = te >> 8 & 1), 512 & A.flags && (re[0] = 255 & te, re[1] = te >>> 8 & 255, A.check = a(A.check, re, 2, 0)), ee = te = 0, A.mode = 3;
              case 3:
                for (; ee < 32; ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                A.head && (A.head.time = te), 512 & A.flags && (re[0] = 255 & te, re[1] = te >>> 8 & 255, re[2] = te >>> 16 & 255, re[3] = te >>> 24 & 255, A.check = a(A.check, re, 4, 0)), ee = te = 0, A.mode = 4;
              case 4:
                for (; ee < 16; ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                A.head && (A.head.xflags = 255 & te, A.head.os = te >> 8), 512 & A.flags && (re[0] = 255 & te, re[1] = te >>> 8 & 255, A.check = a(A.check, re, 2, 0)), ee = te = 0, A.mode = 5;
              case 5:
                if (1024 & A.flags) {
                  for (; ee < 16; ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  A.length = te, A.head && (A.head.extra_len = te), 512 & A.flags && (re[0] = 255 & te, re[1] = te >>> 8 & 255, A.check = a(A.check, re, 2, 0)), ee = te = 0;
                } else
                  A.head && (A.head.extra = null);
                A.mode = 6;
              case 6:
                if (1024 & A.flags && (Q < (Se = A.length) && (Se = Q), Se && (A.head && (L = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), s.arraySet(A.head.extra, J, se, Se, L)), 512 & A.flags && (A.check = a(A.check, J, Se, se)), Q -= Se, se += Se, A.length -= Se), A.length))
                  break e;
                A.length = 0, A.mode = 7;
              case 7:
                if (2048 & A.flags) {
                  if (Q === 0)
                    break e;
                  for (Se = 0; L = J[se + Se++], A.head && L && A.length < 65536 && (A.head.name += String.fromCharCode(L)), L && Se < Q; )
                    ;
                  if (512 & A.flags && (A.check = a(A.check, J, Se, se)), Q -= Se, se += Se, L)
                    break e;
                } else
                  A.head && (A.head.name = null);
                A.length = 0, A.mode = 8;
              case 8:
                if (4096 & A.flags) {
                  if (Q === 0)
                    break e;
                  for (Se = 0; L = J[se + Se++], A.head && L && A.length < 65536 && (A.head.comment += String.fromCharCode(L)), L && Se < Q; )
                    ;
                  if (512 & A.flags && (A.check = a(A.check, J, Se, se)), Q -= Se, se += Se, L)
                    break e;
                } else
                  A.head && (A.head.comment = null);
                A.mode = 9;
              case 9:
                if (512 & A.flags) {
                  for (; ee < 16; ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  if (te !== (65535 & A.check)) {
                    G.msg = "header crc mismatch", A.mode = 30;
                    break;
                  }
                  ee = te = 0;
                }
                A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), G.adler = A.check = 0, A.mode = 12;
                break;
              case 10:
                for (; ee < 32; ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                G.adler = A.check = S(te), ee = te = 0, A.mode = 11;
              case 11:
                if (A.havedict === 0)
                  return G.next_out = oe, G.avail_out = ce, G.next_in = se, G.avail_in = Q, A.hold = te, A.bits = ee, 2;
                G.adler = A.check = 1, A.mode = 12;
              case 12:
                if (K === 5 || K === 6)
                  break e;
              case 13:
                if (A.last) {
                  te >>>= 7 & ee, ee -= 7 & ee, A.mode = 27;
                  break;
                }
                for (; ee < 3; ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                switch (A.last = 1 & te, ee -= 1, 3 & (te >>>= 1)) {
                  case 0:
                    A.mode = 14;
                    break;
                  case 1:
                    if (B(A), A.mode = 20, K !== 6)
                      break;
                    te >>>= 2, ee -= 2;
                    break e;
                  case 2:
                    A.mode = 17;
                    break;
                  case 3:
                    G.msg = "invalid block type", A.mode = 30;
                }
                te >>>= 2, ee -= 2;
                break;
              case 14:
                for (te >>>= 7 & ee, ee -= 7 & ee; ee < 32; ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                if ((65535 & te) != (te >>> 16 ^ 65535)) {
                  G.msg = "invalid stored block lengths", A.mode = 30;
                  break;
                }
                if (A.length = 65535 & te, ee = te = 0, A.mode = 15, K === 6)
                  break e;
              case 15:
                A.mode = 16;
              case 16:
                if (Se = A.length) {
                  if (Q < Se && (Se = Q), ce < Se && (Se = ce), Se === 0)
                    break e;
                  s.arraySet(xe, J, se, Se, oe), Q -= Se, se += Se, ce -= Se, oe += Se, A.length -= Se;
                  break;
                }
                A.mode = 12;
                break;
              case 17:
                for (; ee < 14; ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                if (A.nlen = 257 + (31 & te), te >>>= 5, ee -= 5, A.ndist = 1 + (31 & te), te >>>= 5, ee -= 5, A.ncode = 4 + (15 & te), te >>>= 4, ee -= 4, 286 < A.nlen || 30 < A.ndist) {
                  G.msg = "too many length or distance symbols", A.mode = 30;
                  break;
                }
                A.have = 0, A.mode = 18;
              case 18:
                for (; A.have < A.ncode; ) {
                  for (; ee < 3; ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  A.lens[Te[A.have++]] = 7 & te, te >>>= 3, ee -= 3;
                }
                for (; A.have < 19; )
                  A.lens[Te[A.have++]] = 0;
                if (A.lencode = A.lendyn, A.lenbits = 7, ae = { bits: A.lenbits }, fe = c(0, A.lens, 0, 19, A.lencode, 0, A.work, ae), A.lenbits = ae.bits, fe) {
                  G.msg = "invalid code lengths set", A.mode = 30;
                  break;
                }
                A.have = 0, A.mode = 19;
              case 19:
                for (; A.have < A.nlen + A.ndist; ) {
                  for (; Ze = (j = A.lencode[te & (1 << A.lenbits) - 1]) >>> 16 & 255, je = 65535 & j, !((qe = j >>> 24) <= ee); ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  if (je < 16)
                    te >>>= qe, ee -= qe, A.lens[A.have++] = je;
                  else {
                    if (je === 16) {
                      for ($ = qe + 2; ee < $; ) {
                        if (Q === 0)
                          break e;
                        Q--, te += J[se++] << ee, ee += 8;
                      }
                      if (te >>>= qe, ee -= qe, A.have === 0) {
                        G.msg = "invalid bit length repeat", A.mode = 30;
                        break;
                      }
                      L = A.lens[A.have - 1], Se = 3 + (3 & te), te >>>= 2, ee -= 2;
                    } else if (je === 17) {
                      for ($ = qe + 3; ee < $; ) {
                        if (Q === 0)
                          break e;
                        Q--, te += J[se++] << ee, ee += 8;
                      }
                      ee -= qe, L = 0, Se = 3 + (7 & (te >>>= qe)), te >>>= 3, ee -= 3;
                    } else {
                      for ($ = qe + 7; ee < $; ) {
                        if (Q === 0)
                          break e;
                        Q--, te += J[se++] << ee, ee += 8;
                      }
                      ee -= qe, L = 0, Se = 11 + (127 & (te >>>= qe)), te >>>= 7, ee -= 7;
                    }
                    if (A.have + Se > A.nlen + A.ndist) {
                      G.msg = "invalid bit length repeat", A.mode = 30;
                      break;
                    }
                    for (; Se--; )
                      A.lens[A.have++] = L;
                  }
                }
                if (A.mode === 30)
                  break;
                if (A.lens[256] === 0) {
                  G.msg = "invalid code -- missing end-of-block", A.mode = 30;
                  break;
                }
                if (A.lenbits = 9, ae = { bits: A.lenbits }, fe = c(d, A.lens, 0, A.nlen, A.lencode, 0, A.work, ae), A.lenbits = ae.bits, fe) {
                  G.msg = "invalid literal/lengths set", A.mode = 30;
                  break;
                }
                if (A.distbits = 6, A.distcode = A.distdyn, ae = { bits: A.distbits }, fe = c(p, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, ae), A.distbits = ae.bits, fe) {
                  G.msg = "invalid distances set", A.mode = 30;
                  break;
                }
                if (A.mode = 20, K === 6)
                  break e;
              case 20:
                A.mode = 21;
              case 21:
                if (6 <= Q && 258 <= ce) {
                  G.next_out = oe, G.avail_out = ce, G.next_in = se, G.avail_in = Q, A.hold = te, A.bits = ee, l(G, ye), oe = G.next_out, xe = G.output, ce = G.avail_out, se = G.next_in, J = G.input, Q = G.avail_in, te = A.hold, ee = A.bits, A.mode === 12 && (A.back = -1);
                  break;
                }
                for (A.back = 0; Ze = (j = A.lencode[te & (1 << A.lenbits) - 1]) >>> 16 & 255, je = 65535 & j, !((qe = j >>> 24) <= ee); ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                if (Ze && (240 & Ze) == 0) {
                  for (st = qe, Ie = Ze, Le = je; Ze = (j = A.lencode[Le + ((te & (1 << st + Ie) - 1) >> st)]) >>> 16 & 255, je = 65535 & j, !(st + (qe = j >>> 24) <= ee); ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  te >>>= st, ee -= st, A.back += st;
                }
                if (te >>>= qe, ee -= qe, A.back += qe, A.length = je, Ze === 0) {
                  A.mode = 26;
                  break;
                }
                if (32 & Ze) {
                  A.back = -1, A.mode = 12;
                  break;
                }
                if (64 & Ze) {
                  G.msg = "invalid literal/length code", A.mode = 30;
                  break;
                }
                A.extra = 15 & Ze, A.mode = 22;
              case 22:
                if (A.extra) {
                  for ($ = A.extra; ee < $; ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  A.length += te & (1 << A.extra) - 1, te >>>= A.extra, ee -= A.extra, A.back += A.extra;
                }
                A.was = A.length, A.mode = 23;
              case 23:
                for (; Ze = (j = A.distcode[te & (1 << A.distbits) - 1]) >>> 16 & 255, je = 65535 & j, !((qe = j >>> 24) <= ee); ) {
                  if (Q === 0)
                    break e;
                  Q--, te += J[se++] << ee, ee += 8;
                }
                if ((240 & Ze) == 0) {
                  for (st = qe, Ie = Ze, Le = je; Ze = (j = A.distcode[Le + ((te & (1 << st + Ie) - 1) >> st)]) >>> 16 & 255, je = 65535 & j, !(st + (qe = j >>> 24) <= ee); ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  te >>>= st, ee -= st, A.back += st;
                }
                if (te >>>= qe, ee -= qe, A.back += qe, 64 & Ze) {
                  G.msg = "invalid distance code", A.mode = 30;
                  break;
                }
                A.offset = je, A.extra = 15 & Ze, A.mode = 24;
              case 24:
                if (A.extra) {
                  for ($ = A.extra; ee < $; ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  A.offset += te & (1 << A.extra) - 1, te >>>= A.extra, ee -= A.extra, A.back += A.extra;
                }
                if (A.offset > A.dmax) {
                  G.msg = "invalid distance too far back", A.mode = 30;
                  break;
                }
                A.mode = 25;
              case 25:
                if (ce === 0)
                  break e;
                if (Se = ye - ce, A.offset > Se) {
                  if ((Se = A.offset - Se) > A.whave && A.sane) {
                    G.msg = "invalid distance too far back", A.mode = 30;
                    break;
                  }
                  Ee = Se > A.wnext ? (Se -= A.wnext, A.wsize - Se) : A.wnext - Se, Se > A.length && (Se = A.length), gt = A.window;
                } else
                  gt = xe, Ee = oe - A.offset, Se = A.length;
                for (ce < Se && (Se = ce), ce -= Se, A.length -= Se; xe[oe++] = gt[Ee++], --Se; )
                  ;
                A.length === 0 && (A.mode = 21);
                break;
              case 26:
                if (ce === 0)
                  break e;
                xe[oe++] = A.length, ce--, A.mode = 21;
                break;
              case 27:
                if (A.wrap) {
                  for (; ee < 32; ) {
                    if (Q === 0)
                      break e;
                    Q--, te |= J[se++] << ee, ee += 8;
                  }
                  if (ye -= ce, G.total_out += ye, A.total += ye, ye && (G.adler = A.check = A.flags ? a(A.check, xe, ye, oe - ye) : o(A.check, xe, ye, oe - ye)), ye = ce, (A.flags ? te : S(te)) !== A.check) {
                    G.msg = "incorrect data check", A.mode = 30;
                    break;
                  }
                  ee = te = 0;
                }
                A.mode = 28;
              case 28:
                if (A.wrap && A.flags) {
                  for (; ee < 32; ) {
                    if (Q === 0)
                      break e;
                    Q--, te += J[se++] << ee, ee += 8;
                  }
                  if (te !== (4294967295 & A.total)) {
                    G.msg = "incorrect length check", A.mode = 30;
                    break;
                  }
                  ee = te = 0;
                }
                A.mode = 29;
              case 29:
                fe = 1;
                break e;
              case 30:
                fe = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return v;
            }
        return G.next_out = oe, G.avail_out = ce, G.next_in = se, G.avail_in = Q, A.hold = te, A.bits = ee, (A.wsize || ye !== G.avail_out && A.mode < 30 && (A.mode < 27 || K !== 4)) && Y(G, G.output, G.next_out, ye - G.avail_out) ? (A.mode = 31, -4) : (Re -= G.avail_in, ye -= G.avail_out, G.total_in += Re, G.total_out += ye, A.total += ye, A.wrap && ye && (G.adler = A.check = A.flags ? a(A.check, xe, ye, G.next_out - ye) : o(A.check, xe, ye, G.next_out - ye)), G.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (Re == 0 && ye === 0 || K === 4) && fe === m && (fe = -5), fe);
      }, r.inflateEnd = function(G) {
        if (!G || !G.state)
          return v;
        var K = G.state;
        return K.window && (K.window = null), G.state = null, m;
      }, r.inflateGetHeader = function(G, K) {
        var A;
        return G && G.state ? (2 & (A = G.state).wrap) == 0 ? v : ((A.head = K).done = !1, m) : v;
      }, r.inflateSetDictionary = function(G, K) {
        var A, J = K.length;
        return G && G.state ? (A = G.state).wrap !== 0 && A.mode !== 11 ? v : A.mode === 11 && o(1, K, J, 0) !== A.check ? -3 : Y(G, K, J, J) ? (A.mode = 31, -4) : (A.havedict = 1, m) : v;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, i, r) {
      var s = t("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(d, p, m, v, b, x, y, S) {
        var C, M, T, P, D, I, k, O, B, Y = S.bits, G = 0, K = 0, A = 0, J = 0, xe = 0, se = 0, oe = 0, Q = 0, ce = 0, te = 0, ee = null, Re = 0, ye = new s.Buf16(16), Se = new s.Buf16(16), Ee = null, gt = 0;
        for (G = 0; G <= 15; G++)
          ye[G] = 0;
        for (K = 0; K < v; K++)
          ye[p[m + K]]++;
        for (xe = Y, J = 15; 1 <= J && ye[J] === 0; J--)
          ;
        if (J < xe && (xe = J), J === 0)
          return b[x++] = 20971520, b[x++] = 20971520, S.bits = 1, 0;
        for (A = 1; A < J && ye[A] === 0; A++)
          ;
        for (xe < A && (xe = A), G = Q = 1; G <= 15; G++)
          if (Q <<= 1, (Q -= ye[G]) < 0)
            return -1;
        if (0 < Q && (d === 0 || J !== 1))
          return -1;
        for (Se[1] = 0, G = 1; G < 15; G++)
          Se[G + 1] = Se[G] + ye[G];
        for (K = 0; K < v; K++)
          p[m + K] !== 0 && (y[Se[p[m + K]]++] = K);
        if (I = d === 0 ? (ee = Ee = y, 19) : d === 1 ? (ee = o, Re -= 257, Ee = a, gt -= 257, 256) : (ee = l, Ee = c, -1), G = A, D = x, oe = K = te = 0, T = -1, P = (ce = 1 << (se = xe)) - 1, d === 1 && 852 < ce || d === 2 && 592 < ce)
          return 1;
        for (; ; ) {
          for (k = G - oe, B = y[K] < I ? (O = 0, y[K]) : y[K] > I ? (O = Ee[gt + y[K]], ee[Re + y[K]]) : (O = 96, 0), C = 1 << G - oe, A = M = 1 << se; b[D + (te >> oe) + (M -= C)] = k << 24 | O << 16 | B | 0, M !== 0; )
            ;
          for (C = 1 << G - 1; te & C; )
            C >>= 1;
          if (C !== 0 ? (te &= C - 1, te += C) : te = 0, K++, --ye[G] == 0) {
            if (G === J)
              break;
            G = p[m + y[K]];
          }
          if (xe < G && (te & P) !== T) {
            for (oe === 0 && (oe = xe), D += A, Q = 1 << (se = G - oe); se + oe < J && !((Q -= ye[se + oe]) <= 0); )
              se++, Q <<= 1;
            if (ce += 1 << se, d === 1 && 852 < ce || d === 2 && 592 < ce)
              return 1;
            b[T = te & P] = xe << 24 | se << 16 | D - x | 0;
          }
        }
        return te !== 0 && (b[D + te] = G - oe << 24 | 64 << 16 | 0), S.bits = xe, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(t, i, r) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(t, i, r) {
      var s = t("../utils/common"), o = 0, a = 1;
      function l(j) {
        for (var re = j.length; 0 <= --re; )
          j[re] = 0;
      }
      var c = 0, d = 29, p = 256, m = p + 1 + d, v = 30, b = 19, x = 2 * m + 1, y = 15, S = 16, C = 7, M = 256, T = 16, P = 17, D = 18, I = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], O = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Y = new Array(2 * (m + 2));
      l(Y);
      var G = new Array(2 * v);
      l(G);
      var K = new Array(512);
      l(K);
      var A = new Array(256);
      l(A);
      var J = new Array(d);
      l(J);
      var xe, se, oe, Q = new Array(v);
      function ce(j, re, Te, Ce, F) {
        this.static_tree = j, this.extra_bits = re, this.extra_base = Te, this.elems = Ce, this.max_length = F, this.has_stree = j && j.length;
      }
      function te(j, re) {
        this.dyn_tree = j, this.max_code = 0, this.stat_desc = re;
      }
      function ee(j) {
        return j < 256 ? K[j] : K[256 + (j >>> 7)];
      }
      function Re(j, re) {
        j.pending_buf[j.pending++] = 255 & re, j.pending_buf[j.pending++] = re >>> 8 & 255;
      }
      function ye(j, re, Te) {
        j.bi_valid > S - Te ? (j.bi_buf |= re << j.bi_valid & 65535, Re(j, j.bi_buf), j.bi_buf = re >> S - j.bi_valid, j.bi_valid += Te - S) : (j.bi_buf |= re << j.bi_valid & 65535, j.bi_valid += Te);
      }
      function Se(j, re, Te) {
        ye(j, Te[2 * re], Te[2 * re + 1]);
      }
      function Ee(j, re) {
        for (var Te = 0; Te |= 1 & j, j >>>= 1, Te <<= 1, 0 < --re; )
          ;
        return Te >>> 1;
      }
      function gt(j, re, Te) {
        var Ce, F, U = new Array(y + 1), he = 0;
        for (Ce = 1; Ce <= y; Ce++)
          U[Ce] = he = he + Te[Ce - 1] << 1;
        for (F = 0; F <= re; F++) {
          var me = j[2 * F + 1];
          me !== 0 && (j[2 * F] = Ee(U[me]++, me));
        }
      }
      function qe(j) {
        var re;
        for (re = 0; re < m; re++)
          j.dyn_ltree[2 * re] = 0;
        for (re = 0; re < v; re++)
          j.dyn_dtree[2 * re] = 0;
        for (re = 0; re < b; re++)
          j.bl_tree[2 * re] = 0;
        j.dyn_ltree[2 * M] = 1, j.opt_len = j.static_len = 0, j.last_lit = j.matches = 0;
      }
      function Ze(j) {
        8 < j.bi_valid ? Re(j, j.bi_buf) : 0 < j.bi_valid && (j.pending_buf[j.pending++] = j.bi_buf), j.bi_buf = 0, j.bi_valid = 0;
      }
      function je(j, re, Te, Ce) {
        var F = 2 * re, U = 2 * Te;
        return j[F] < j[U] || j[F] === j[U] && Ce[re] <= Ce[Te];
      }
      function st(j, re, Te) {
        for (var Ce = j.heap[Te], F = Te << 1; F <= j.heap_len && (F < j.heap_len && je(re, j.heap[F + 1], j.heap[F], j.depth) && F++, !je(re, Ce, j.heap[F], j.depth)); )
          j.heap[Te] = j.heap[F], Te = F, F <<= 1;
        j.heap[Te] = Ce;
      }
      function Ie(j, re, Te) {
        var Ce, F, U, he, me = 0;
        if (j.last_lit !== 0)
          for (; Ce = j.pending_buf[j.d_buf + 2 * me] << 8 | j.pending_buf[j.d_buf + 2 * me + 1], F = j.pending_buf[j.l_buf + me], me++, Ce === 0 ? Se(j, F, re) : (Se(j, (U = A[F]) + p + 1, re), (he = I[U]) !== 0 && ye(j, F -= J[U], he), Se(j, U = ee(--Ce), Te), (he = k[U]) !== 0 && ye(j, Ce -= Q[U], he)), me < j.last_lit; )
            ;
        Se(j, M, re);
      }
      function Le(j, re) {
        var Te, Ce, F, U = re.dyn_tree, he = re.stat_desc.static_tree, me = re.stat_desc.has_stree, Ae = re.stat_desc.elems, Ve = -1;
        for (j.heap_len = 0, j.heap_max = x, Te = 0; Te < Ae; Te++)
          U[2 * Te] !== 0 ? (j.heap[++j.heap_len] = Ve = Te, j.depth[Te] = 0) : U[2 * Te + 1] = 0;
        for (; j.heap_len < 2; )
          U[2 * (F = j.heap[++j.heap_len] = Ve < 2 ? ++Ve : 0)] = 1, j.depth[F] = 0, j.opt_len--, me && (j.static_len -= he[2 * F + 1]);
        for (re.max_code = Ve, Te = j.heap_len >> 1; 1 <= Te; Te--)
          st(j, U, Te);
        for (F = Ae; Te = j.heap[1], j.heap[1] = j.heap[j.heap_len--], st(j, U, 1), Ce = j.heap[1], j.heap[--j.heap_max] = Te, j.heap[--j.heap_max] = Ce, U[2 * F] = U[2 * Te] + U[2 * Ce], j.depth[F] = (j.depth[Te] >= j.depth[Ce] ? j.depth[Te] : j.depth[Ce]) + 1, U[2 * Te + 1] = U[2 * Ce + 1] = F, j.heap[1] = F++, st(j, U, 1), 2 <= j.heap_len; )
          ;
        j.heap[--j.heap_max] = j.heap[1], function($e, Me) {
          var lt, Ye, ht, Xe, Mt, At, Bt = Me.dyn_tree, pe = Me.max_code, ot = Me.stat_desc.static_tree, De = Me.stat_desc.has_stree, tt = Me.stat_desc.extra_bits, Qe = Me.stat_desc.extra_base, Ft = Me.stat_desc.max_length, An = 0;
          for (Xe = 0; Xe <= y; Xe++)
            $e.bl_count[Xe] = 0;
          for (Bt[2 * $e.heap[$e.heap_max] + 1] = 0, lt = $e.heap_max + 1; lt < x; lt++)
            Ft < (Xe = Bt[2 * Bt[2 * (Ye = $e.heap[lt]) + 1] + 1] + 1) && (Xe = Ft, An++), Bt[2 * Ye + 1] = Xe, pe < Ye || ($e.bl_count[Xe]++, Mt = 0, Qe <= Ye && (Mt = tt[Ye - Qe]), At = Bt[2 * Ye], $e.opt_len += At * (Xe + Mt), De && ($e.static_len += At * (ot[2 * Ye + 1] + Mt)));
          if (An !== 0) {
            do {
              for (Xe = Ft - 1; $e.bl_count[Xe] === 0; )
                Xe--;
              $e.bl_count[Xe]--, $e.bl_count[Xe + 1] += 2, $e.bl_count[Ft]--, An -= 2;
            } while (0 < An);
            for (Xe = Ft; Xe !== 0; Xe--)
              for (Ye = $e.bl_count[Xe]; Ye !== 0; )
                pe < (ht = $e.heap[--lt]) || (Bt[2 * ht + 1] !== Xe && ($e.opt_len += (Xe - Bt[2 * ht + 1]) * Bt[2 * ht], Bt[2 * ht + 1] = Xe), Ye--);
          }
        }(j, re), gt(U, Ve, j.bl_count);
      }
      function L(j, re, Te) {
        var Ce, F, U = -1, he = re[1], me = 0, Ae = 7, Ve = 4;
        for (he === 0 && (Ae = 138, Ve = 3), re[2 * (Te + 1) + 1] = 65535, Ce = 0; Ce <= Te; Ce++)
          F = he, he = re[2 * (Ce + 1) + 1], ++me < Ae && F === he || (me < Ve ? j.bl_tree[2 * F] += me : F !== 0 ? (F !== U && j.bl_tree[2 * F]++, j.bl_tree[2 * T]++) : me <= 10 ? j.bl_tree[2 * P]++ : j.bl_tree[2 * D]++, U = F, Ve = (me = 0) === he ? (Ae = 138, 3) : F === he ? (Ae = 6, 3) : (Ae = 7, 4));
      }
      function fe(j, re, Te) {
        var Ce, F, U = -1, he = re[1], me = 0, Ae = 7, Ve = 4;
        for (he === 0 && (Ae = 138, Ve = 3), Ce = 0; Ce <= Te; Ce++)
          if (F = he, he = re[2 * (Ce + 1) + 1], !(++me < Ae && F === he)) {
            if (me < Ve)
              for (; Se(j, F, j.bl_tree), --me != 0; )
                ;
            else
              F !== 0 ? (F !== U && (Se(j, F, j.bl_tree), me--), Se(j, T, j.bl_tree), ye(j, me - 3, 2)) : me <= 10 ? (Se(j, P, j.bl_tree), ye(j, me - 3, 3)) : (Se(j, D, j.bl_tree), ye(j, me - 11, 7));
            U = F, Ve = (me = 0) === he ? (Ae = 138, 3) : F === he ? (Ae = 6, 3) : (Ae = 7, 4);
          }
      }
      l(Q);
      var ae = !1;
      function $(j, re, Te, Ce) {
        ye(j, (c << 1) + (Ce ? 1 : 0), 3), function(F, U, he, me) {
          Ze(F), me && (Re(F, he), Re(F, ~he)), s.arraySet(F.pending_buf, F.window, U, he, F.pending), F.pending += he;
        }(j, re, Te, !0);
      }
      r._tr_init = function(j) {
        ae || (function() {
          var re, Te, Ce, F, U, he = new Array(y + 1);
          for (F = Ce = 0; F < d - 1; F++)
            for (J[F] = Ce, re = 0; re < 1 << I[F]; re++)
              A[Ce++] = F;
          for (A[Ce - 1] = F, F = U = 0; F < 16; F++)
            for (Q[F] = U, re = 0; re < 1 << k[F]; re++)
              K[U++] = F;
          for (U >>= 7; F < v; F++)
            for (Q[F] = U << 7, re = 0; re < 1 << k[F] - 7; re++)
              K[256 + U++] = F;
          for (Te = 0; Te <= y; Te++)
            he[Te] = 0;
          for (re = 0; re <= 143; )
            Y[2 * re + 1] = 8, re++, he[8]++;
          for (; re <= 255; )
            Y[2 * re + 1] = 9, re++, he[9]++;
          for (; re <= 279; )
            Y[2 * re + 1] = 7, re++, he[7]++;
          for (; re <= 287; )
            Y[2 * re + 1] = 8, re++, he[8]++;
          for (gt(Y, m + 1, he), re = 0; re < v; re++)
            G[2 * re + 1] = 5, G[2 * re] = Ee(re, 5);
          xe = new ce(Y, I, p + 1, m, y), se = new ce(G, k, 0, v, y), oe = new ce(new Array(0), O, 0, b, C);
        }(), ae = !0), j.l_desc = new te(j.dyn_ltree, xe), j.d_desc = new te(j.dyn_dtree, se), j.bl_desc = new te(j.bl_tree, oe), j.bi_buf = 0, j.bi_valid = 0, qe(j);
      }, r._tr_stored_block = $, r._tr_flush_block = function(j, re, Te, Ce) {
        var F, U, he = 0;
        0 < j.level ? (j.strm.data_type === 2 && (j.strm.data_type = function(me) {
          var Ae, Ve = 4093624447;
          for (Ae = 0; Ae <= 31; Ae++, Ve >>>= 1)
            if (1 & Ve && me.dyn_ltree[2 * Ae] !== 0)
              return o;
          if (me.dyn_ltree[18] !== 0 || me.dyn_ltree[20] !== 0 || me.dyn_ltree[26] !== 0)
            return a;
          for (Ae = 32; Ae < p; Ae++)
            if (me.dyn_ltree[2 * Ae] !== 0)
              return a;
          return o;
        }(j)), Le(j, j.l_desc), Le(j, j.d_desc), he = function(me) {
          var Ae;
          for (L(me, me.dyn_ltree, me.l_desc.max_code), L(me, me.dyn_dtree, me.d_desc.max_code), Le(me, me.bl_desc), Ae = b - 1; 3 <= Ae && me.bl_tree[2 * B[Ae] + 1] === 0; Ae--)
            ;
          return me.opt_len += 3 * (Ae + 1) + 5 + 5 + 4, Ae;
        }(j), F = j.opt_len + 3 + 7 >>> 3, (U = j.static_len + 3 + 7 >>> 3) <= F && (F = U)) : F = U = Te + 5, Te + 4 <= F && re !== -1 ? $(j, re, Te, Ce) : j.strategy === 4 || U === F ? (ye(j, 2 + (Ce ? 1 : 0), 3), Ie(j, Y, G)) : (ye(j, 4 + (Ce ? 1 : 0), 3), function(me, Ae, Ve, $e) {
          var Me;
          for (ye(me, Ae - 257, 5), ye(me, Ve - 1, 5), ye(me, $e - 4, 4), Me = 0; Me < $e; Me++)
            ye(me, me.bl_tree[2 * B[Me] + 1], 3);
          fe(me, me.dyn_ltree, Ae - 1), fe(me, me.dyn_dtree, Ve - 1);
        }(j, j.l_desc.max_code + 1, j.d_desc.max_code + 1, he + 1), Ie(j, j.dyn_ltree, j.dyn_dtree)), qe(j), Ce && Ze(j);
      }, r._tr_tally = function(j, re, Te) {
        return j.pending_buf[j.d_buf + 2 * j.last_lit] = re >>> 8 & 255, j.pending_buf[j.d_buf + 2 * j.last_lit + 1] = 255 & re, j.pending_buf[j.l_buf + j.last_lit] = 255 & Te, j.last_lit++, re === 0 ? j.dyn_ltree[2 * Te]++ : (j.matches++, re--, j.dyn_ltree[2 * (A[Te] + p + 1)]++, j.dyn_dtree[2 * ee(re)]++), j.last_lit === j.lit_bufsize - 1;
      }, r._tr_align = function(j) {
        ye(j, 2, 3), Se(j, M, Y), function(re) {
          re.bi_valid === 16 ? (Re(re, re.bi_buf), re.bi_buf = 0, re.bi_valid = 0) : 8 <= re.bi_valid && (re.pending_buf[re.pending++] = 255 & re.bi_buf, re.bi_buf >>= 8, re.bi_valid -= 8);
        }(j);
      };
    }, { "../utils/common": 41 }], 53: [function(t, i, r) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(t, i, r) {
      i.exports = typeof setImmediate == "function" ? setImmediate : function() {
        var s = [].slice.apply(arguments);
        s.splice(1, 0, 0), setTimeout.apply(null, s);
      };
    }, {}] }, {}, [10])(10);
  });
})(tO);
const nO = tO.exports, XQ = "mixverse", $Q = 1, lm = "model-file";
class ZQ {
  constructor() {
    V(this, "db");
  }
  async get(e, t, i) {
    this.db = await this.initDataBase();
    let r = this.db.transaction([lm], "readwrite").objectStore(lm).get(e);
    return new Promise((s, o) => {
      r.onsuccess = (a) => {
        let l = a.target.result;
        l ? s(l) : (s({ blob: t, version: i }), this.put(e, t, i).catch(() => {
          o();
        }));
      }, r.onerror = function(a) {
        console.log("error", a), o();
      };
    });
  }
  async put(e, t, i, r) {
    if (!t)
      return Promise.reject(!1);
    let s = {
      ssn: e,
      version: i,
      blob: ""
    };
    s.blob = t;
    const o = r ? "put" : "add";
    let a = this.db.transaction([lm], "readwrite").objectStore(lm)[o](s);
    return new Promise((l, c) => {
      a.onsuccess = function() {
        console.log("glb\u6570\u636E\u6DFB\u52A0\u6210\u529F"), l(s.blob);
      }, a.onerror = function(d) {
        console.log("glb\u6570\u636E\u6DFB\u52A0\u5931\u8D25", d), c();
      };
    });
  }
  initDataBase() {
    if (!window.indexedDB)
      return;
    let e = indexedDB.open(XQ, $Q);
    return new Promise((t, i) => {
      e.onerror = function() {
        i();
      }, e.onupgradeneeded = function(r) {
        r.currentTarget.result.createObjectStore(
          lm,
          { keyPath: "ssn" }
        );
      }, e.onsuccess = function(r) {
        console.log("onsuccess: create db success "), t(r.target.result);
      };
    });
  }
}
const y4 = new ZQ(), S_ = new nO(), YQ = "https://d1ktb2pux2fae3.cloudfront.net/template/";
class wm {
  constructor() {
  }
  static loaderZipModel() {
    return this.modelAssets.model ? this.modelAssets.model : (console.time("load"), new Promise((e, t) => {
      qQ.get(this.Url, { responseType: "arraybuffer" }).then((i) => {
        let r = new window.File([i.data], "zipFile", { type: "zip" });
        const s = new nO();
        s.loadAsync(r).then((o) => {
          let a = o.files;
          console.timeEnd("load");
          for (let l in a)
            a[l].dir || s.file(l).async("arraybuffer").then((c) => {
              let d = new Blob([c]), p = window.URL.createObjectURL(d);
              l.includes("House_Dx_Shader_V9") && (this.modelAssets.model = p), e(p);
            });
        });
      });
    }));
  }
  static async loaderChunkFile(e) {
    return new Promise(async (t, i) => {
      const { blob: r, version: s } = await y4.get(e);
      if (r) {
        const o = window.URL.createObjectURL(r);
        t(o);
      }
      await this.loaderMergeFile(e, s, r, t);
    });
  }
  static async loaderMergeFile(e, t, i, r) {
    return new Promise((s, o) => {
      const a = new km();
      a.setResponseType("json"), a.load(e, async ({ name: l, total: c, version: d }) => {
        if (d === t && i)
          return;
        const p = [];
        for (let y = 0; y < c; y++) {
          const S = YQ + l + y;
          p.push(this.loaderChunkBold(S));
        }
        const m = await Promise.all(p), v = new Blob(m, { type: "application/octet-stream;charset=utf-8" }), b = window.URL.createObjectURL(v), x = !v || d !== t;
        r(b), await y4.put(e, v, d, x), s(b);
      });
    });
  }
  static loaderChunkBold(e) {
    return new Promise((t, i) => {
      const r = new km();
      r.setResponseType("arraybuffer"), r.load(e, (s) => {
        let o = new window.File([s], "zipFile", { type: "zip" });
        S_.loadAsync(o).then(function(a) {
          let l = a.files;
          for (let c in l)
            c && S_.file(c).async("arraybuffer").then((d) => {
              let p = new Blob([d]);
              t(p);
            });
        }).catch((a) => {
          i(a);
        });
      });
    });
  }
  static loaderBold(e) {
    return new Promise((t, i) => {
      const r = new km();
      r.setResponseType("arraybuffer"), r.load(e, (s) => {
        console.log(s.data, "resp");
        let o = new window.File([s], "zipFile", { type: "zip" });
        S_.loadAsync(o).then(function(a) {
          let l = a.files;
          console.log(l, "fileList");
          for (let c in l)
            console.log(c, "key"), c && S_.file(c).async("arraybuffer").then((d) => {
              let p = new Blob([d]), m = window.URL.createObjectURL(p);
              t(m);
            });
        }).catch((a) => {
          i(a);
        });
      });
    });
  }
}
V(wm, "modelAssets", { model: "" }), V(wm, "Url", "https://nft-ic.oss-cn-shanghai.aliyuncs.com/model.zip"), V(wm, "ModelUrl", { house: "" }), V(wm, "cacheUlr", ["https://nft-ic.oss-cn-shanghai.aliyuncs.com/House_Dx_Shader_V9.FBX"]);
const KQ = /* @__PURE__ */ new Map(), JQ = new DD(), QQ = new l5(), x4 = new ME(), eee = async (n, e) => {
  e && x4.once(n, () => queueMicrotask(e));
  const t = await Mr(KQ, n, async () => {
    const i = n.startsWith("https://unpkg.com/");
    return i && ky(), (n.toLowerCase().endsWith(".hdr") || n.toLowerCase().includes("hdr") ? QQ : JQ).load(
      await wm.checkUrl(n),
      (o) => {
        o.wrapS = o.wrapT = qr, o.encoding = Tt, o.flipY = !0, o.magFilter = kn, o.needsUpdate = !0, o.anisotropy = 20, o.minFilter = kn, o.generateMipmaps = !1, x4.setState(n), i && Ly();
      },
      Ry(n)
    );
  });
  return t.constructor === Ff ? t : t.clone();
}, [tee, iO] = Be(!0), [nee, dv] = Be(!0), [iee, mM] = Be(
  void 0
), fv = new Ou();
fv.texture = void 0;
fv.helper = !1;
Zr.delete(fv);
const rO = (n) => n in YR ? TE + Li(YR, n) : n;
ft(() => {
  const n = hv().at(-1), e = Ln();
  if (!(n != null && n.texture) || !e || n.texture === "dynamic")
    return;
  let t = !0;
  return (async () => {
    const i = await eee(rO(n.texture), () => {
      t && setTimeout(() => {
        const r = new g2(e);
        i.encoding = Tt;
        let s = r.fromEquirectangular(i).texture;
        bt.environment = s, bt.background = s, i.dispose(), r.dispose();
      }, 100);
    });
    i.encoding = Tt;
  })(), () => {
    t = !1, bt.environment = null;
  };
}, [hv, Ln]);
ft(() => {
  const n = dv();
  if (!n || typeof n == "string")
    return;
  const e = new Xn();
  return Promise.resolve().then(() => _ie).then((t) => {
    const i = t.default, r = new i();
    r.helper = !1, r.intensity = 0.5, r.y = Mc, r.z = Mc, Zr.delete(r), e.watch(iO((s) => r.castShadow = s)), e.then(() => r.dispose());
  }), () => {
    e.cancel();
  };
}, [dv, ml]);
ft(() => {
  const n = dv(), e = typeof n == "string" ? n : mM();
  if (!!e)
    return fv.texture = e, () => {
      fv.texture = void 0;
    };
}, [mM, dv]);
ft(() => {
  var i;
  const n = dM(), e = Tb(), t = (i = uv().at(-1)) == null ? void 0 : i.texture;
  if (t)
    if (Array.isArray(t))
      bt.background = MJ(t);
    else {
      let r = !0;
      const s = Wr(
        rO(t),
        () => r && (bt.background = s)
      );
      return s.mapping = _b, () => {
        r = !1;
      };
    }
  else
    n ? bt.background = Wr(n) : e ? e === "transparent" ? bt.background = null : bt.background = new xt(e) : bt.background = new xt(0);
}, [Tb, dM, uv]);
const ree = {
  ..._s,
  texture: [String, Array]
}, see = yt([bs], {
  texture: void 0
});
class Nu extends Ii {
  constructor() {
    super();
    V(this, "_texture");
    CJ(this);
  }
  dispose() {
    return this.done ? this : (super.dispose(), TJ(this), this);
  }
  get texture() {
    return this._texture;
  }
  set texture(t) {
    this._texture = t, sC([...uv()]);
  }
}
V(Nu, "componentName", "skybox"), V(Nu, "defaults", see), V(Nu, "schema", ree);
const [oee, aee] = Be(
  !0
), [lee, cee] = Be(20), [uee, hee] = Be(0), [dee, Mu] = Be("middle"), [fee, _c] = Be("medium"), [pee, sO] = Be(!1), vM = new Nu();
Zr.delete(vM);
const dC = {
  get defaultShadow() {
    return iO();
  },
  set defaultShadow(n) {
    tee(n);
  },
  get defaultLight() {
    return dv();
  },
  set defaultLight(n) {
    nee(n);
  },
  get environment() {
    return mM();
  },
  set environment(n) {
    iee(n);
  },
  get skybox() {
    return vM.texture;
  },
  set skybox(n) {
    vM.texture = n;
  },
  get uiLayer() {
    return j2();
  },
  set uiLayer(n) {
    ZY(n);
  },
  get gridHelper() {
    return sM();
  },
  set gridHelper(n) {
    NK(n);
  },
  get gridHelperSize() {
    return oM();
  },
  set gridHelperSize(n) {
    zK(n);
  },
  get stats() {
    return sO();
  },
  set stats(n) {
    pee(n);
  },
  get gravity() {
    return cee();
  },
  set gravity(n) {
    lee(n);
  },
  get repulsion() {
    return hee();
  },
  set repulsion(n) {
    uee(n);
  },
  get centripetal() {
    return ml();
  },
  set centripetal(n) {
    dK(n);
  },
  get antiAlias() {
    return aee();
  },
  set antiAlias(n) {
    oee(n);
  },
  get pixelRatio() {
    return W2();
  },
  set pixelRatio(n) {
    $Y(n);
  },
  get fps() {
    return A2();
  },
  set fps(n) {
    LX(n);
  },
  get logarithmicDepth() {
    return $D();
  },
  set logarithmicDepth(n) {
    EX(n);
  },
  get exposure() {
    return V2();
  },
  set exposure(n) {
    jY(n);
  },
  get shadowResolution() {
    return _c();
  },
  set shadowResolution(n) {
    fee(n);
  },
  get shadowDistance() {
    return Mu();
  },
  set shadowDistance(n) {
    dee(n);
  },
  get pbr() {
    return H2();
  },
  set pbr(n) {
    qY(n);
  },
  get bokehScale() {
    return cM();
  },
  set bokehScale(n) {
    GK(n);
  },
  get bloom() {
    return aM();
  },
  set bloom(n) {
    VK(n);
  },
  get bloomIntensity() {
    return qE();
  },
  set bloomIntensity(n) {
    IY(n);
  },
  get bloomThreshold() {
    return $E();
  },
  set bloomThreshold(n) {
    NY(n);
  },
  get bloomRadius() {
    return XE();
  },
  set bloomRadius(n) {
    OY(n);
  },
  get ssr() {
    return uM();
  },
  set ssr(n) {
    qK(n);
  },
  get ssrIntensity() {
    return NI();
  },
  set ssrIntensity(n) {
    XK(n);
  },
  get ssao() {
    return cv();
  },
  set ssao(n) {
    WK(n);
  },
  get ssaoIntensity() {
    return OI();
  },
  set ssaoIntensity(n) {
    jK(n);
  },
  get outlineColor() {
    return Z5();
  },
  set outlineColor(n) {
    AY(n);
  },
  get outlineHiddenColor() {
    return Y5();
  },
  set outlineHiddenColor(n) {
    RY(n);
  },
  get outlinePattern() {
    return K5();
  },
  set outlinePattern(n) {
    kY(n);
  },
  get outlinePulse() {
    return J5();
  },
  set outlinePulse(n) {
    LY(n);
  },
  get outlineStrength() {
    return Q5();
  },
  set outlineStrength(n) {
    DY(n);
  },
  get bokeh() {
    return lM();
  },
  set bokeh(n) {
    HK(n);
  },
  get vignette() {
    return hM();
  },
  set vignette(n) {
    yJ(n);
  },
  get texture() {
    return dM();
  },
  set texture(n) {
    EJ(n);
  },
  get color() {
    return Tb();
  },
  set color(n) {
    MX(n);
  }
}, Zf = {
  ...Iy,
  helper: Boolean,
  color: String,
  intensity: Number,
  castShadow: Boolean,
  shadowResolution: String
}, oO = new Cf({
  low: "low",
  medium: "medium",
  high: "high"
}), Yf = yt(
  [Oy],
  {
    color: "#ffffff",
    intensity: 1,
    castShadow: !1,
    shadowResolution: new Tn("medium"),
    helper: !0
  },
  {
    intensity: new dt(0, 2),
    shadowResolution: oO
  },
  { color: !0, castShadow: !0 }
), mee = {
  ...Zf,
  shadowDistance: String
}, fC = new Cf({
  near: "near",
  middle: "middle",
  far: "far"
}), vee = yt(
  [Yf],
  { shadowDistance: new Tn("middle") },
  { shadowDistance: fC }
), Jy = {
  defaultShadow: Boolean,
  defaultLight: [String, Boolean],
  environment: String,
  skybox: [String, Array],
  uiLayer: Boolean,
  gridHelper: Boolean,
  gridHelperSize: Number,
  stats: Boolean,
  gravity: Number,
  repulsion: Number,
  centripetal: Boolean,
  antiAlias: [Boolean, String],
  logarithmicDepth: Boolean,
  pixelRatio: Number,
  fps: Number,
  exposure: Number,
  shadowResolution: String,
  shadowDistance: String,
  pbr: Boolean,
  bloom: Boolean,
  bloomIntensity: Number,
  bloomThreshold: Number,
  bloomRadius: Number,
  ssr: Boolean,
  ssrIntensity: Number,
  ssao: Boolean,
  ssaoIntensity: Number,
  outlineColor: String,
  outlineHiddenColor: String,
  outlinePattern: String,
  outlinePulse: Number,
  outlineStrength: Number,
  bokeh: Boolean,
  bokehScale: Number,
  vignette: Boolean,
  texture: String,
  color: String
};
ya([
  "antiAlias",
  "pixelRatio",
  "gravity",
  "repulsion",
  "centripetal",
  "pbr",
  "ssaoIntensity"
]);
const Mo = yt(
  [],
  { ...dC },
  {
    defaultLight: new Cf({
      true: !0,
      false: !1,
      studio: "studio",
      day: "day",
      night: "night"
    }),
    pixelRatio: new dt(1, 2, 1),
    fps: new dt(30, 60, 30),
    exposure: new dt(0, 2),
    shadowResolution: oO,
    shadowDistance: fC,
    bokehScale: new dt(0, 20),
    bloomIntensity: new dt(0, 10),
    bloomThreshold: new dt(0, 1),
    bloomRadius: new dt(0, 1),
    ssrIntensity: new dt(0, 2),
    ssaoIntensity: new dt(0, 4),
    outlinePulse: new dt(0, 2),
    outlineStrength: new dt(0, 4),
    gravity: new dt(0, 20),
    repulsion: new dt(0, 10),
    antiAlias: new Cf({ MSAA: "MSAA", SMAA: "SMAA", false: !1 }),
    gridHelperSize: new dt(10, 1e3, 10)
  }
), [pC, Tf] = Be([]), gee = nh(pC, Tf), _ee = ih(pC, Tf), aO = No(LL(pC, Tf)), Xr = {
  get autoMount() {
    return G2();
  },
  set autoMount(n) {
    XY(n);
  },
  get firstLoadBeforeRender() {
    return k2();
  },
  set firstLoadBeforeRender(n) {
    OX(n);
  }
}, lO = {};
for (const n of Object.keys(Jy))
  Object.defineProperty(Xr, n, {
    get() {
      return Li(dC, n);
    },
    set(e) {
      lO[n] = e, aO();
    },
    enumerable: !0
  });
const Qy = (n, e, t) => {
  const i = n[e];
  return i instanceof Tn ? t ? i.value : void 0 : t ? i != null ? i : "" : i;
}, bee = (n, e, t) => {
  const i = e[t];
  return i instanceof Tn ? n === i.value || n === void 0 : n === i || n === "";
}, cO = {};
for (const n of Object.keys(Mo))
  cO[n] = Qy(Mo, n);
ft(
  function() {
    const n = {};
    for (const e of [cO, ...Tf(), lO])
      for (const [t, i] of Object.entries(e))
        i !== void 0 && (n[t] = i);
    Object.assign(dC, n);
  },
  [Tf]
);
const Vb = window;
"__THREE__" in Vb && (Vb.__THREE__ += " - Lingo3D Beta " + e5);
"__LINGO3D__" in Vb && console.warn("multiple versions of Lingo3D detected");
Vb.__LINGO3D__ = !0;
const mC = new _E(fl, 32, 32);
class ex extends Us {
  constructor() {
    super(mC);
  }
}
V(ex, "componentName", "sphere");
const yee = new vE(fl, zs, 16);
class tx extends Us {
  constructor() {
    super(yee);
  }
}
V(tx, "componentName", "cone");
const uO = new wy(
  fl,
  fl,
  zs,
  16
);
class nx extends Us {
  constructor() {
    super(uO);
  }
}
V(nx, "componentName", "cylinder");
const xee = new gE(fl);
class ix extends Us {
  constructor() {
    super(xee);
  }
}
V(ix, "componentName", "octahedron");
const rx = new bE(61 * Ut);
rx.rotateY(45 * Pi);
rx.rotateX(125 * Pi);
rx.translate(0, -0.2, 0.2);
class sx extends Us {
  constructor() {
    super(rx);
  }
}
V(sx, "componentName", "tetrahedron");
const wee = new yE(40 * Ut, 1 * Ut, 8, 32);
class ox extends Us {
  constructor() {
    super(wee);
  }
}
V(ox, "componentName", "torus");
const See = {
  ...DE
}, Mee = yt([IE], {
  scaleZ: 0,
  depth: 0
}), vC = new Av(
  zs,
  zs,
  1,
  1
);
class qd extends Us {
  constructor() {
    super(vC), this.object3d.scale.z = WD;
  }
  get depth() {
    return 0;
  }
  set depth(e) {
  }
  get scaleZ() {
    return 0;
  }
  set scaleZ(e) {
  }
}
V(qd, "componentName", "plane"), V(qd, "defaults", Mee), V(qd, "schema", See);
const Eee = {
  ...DE
}, Cee = yt([IE], {
  scaleZ: 0,
  depth: 0
}), Tee = new mE(fl, 32);
class Xd extends Us {
  constructor() {
    super(Tee), this.object3d.scale.z = WD;
  }
  get depth() {
    return 0;
  }
  set depth(e) {
  }
  get scaleZ() {
    return 0;
  }
  set scaleZ(e) {
  }
}
V(Xd, "componentName", "circle"), V(Xd, "defaults", Cee), V(Xd, "schema", Eee);
const AS = /* @__PURE__ */ new Map(), gC = (n, e) => {
  if (AS.has(e))
    return AS.get(e);
  const t = new Z();
  return Ud.setFromObject(n).getSize(t), AS.set(e, t), t;
}, RS = /* @__PURE__ */ new Map(), hO = (n, e) => {
  if (RS.has(e)) {
    const [s, o, a] = RS.get(e);
    return n.scale.multiplyScalar(s), n.position.copy(o).multiplyScalar(-1), a;
  }
  const t = gC(n, e).clone(), i = 1 / t.y;
  n.scale.multiplyScalar(i);
  const r = Wv(n);
  return n.position.copy(r).multiplyScalar(-1), t.multiplyScalar(i), RS.set(e, [i, r, t]), t;
}, Pee = {
  metalnessFactor: Number,
  roughnessFactor: Number,
  opacityFactor: Number,
  envFactor: Number,
  reflection: Boolean
}, Aee = yt(
  [],
  {
    metalnessFactor: new Tn(0),
    roughnessFactor: new Tn(1),
    opacityFactor: new Tn(1),
    envFactor: new Tn(1),
    reflection: !1
  },
  {
    metalnessFactor: new dt(-2, 2),
    roughnessFactor: new dt(0, 4),
    opacityFactor: new dt(0, 4),
    envFactor: new dt(0, 4)
  }
), dO = {
  ...Lc,
  src: String,
  onLoad: Function,
  boxVisible: Boolean
}, fO = yt(
  [Dc],
  {
    src: void 0,
    onLoad: void 0,
    boxVisible: !1
  }
), _C = {
  ...dO,
  ...Pee,
  resize: Boolean
}, bC = yt(
  [fO, Aee],
  { resize: !0 }
), pO = (n) => {
  var t;
  const e = n.split("/");
  return (t = e.at(-1)) != null && t.includes(".") ? (e.pop(), e.join("/")) : n;
}, mO = (n) => n.startsWith("./") || n.startsWith("../"), Ree = (n, e) => {
  for (var t = "", i = 0, r = -1, s = 0, o, a = 0; a <= n.length; ++a) {
    if (a < n.length)
      o = n.charCodeAt(a);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(r === a - 1 || s === 1))
        if (r !== a - 1 && s === 2) {
          if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
            if (t.length > 2) {
              var l = t.lastIndexOf("/");
              if (l !== t.length - 1) {
                l === -1 ? (t = "", i = 0) : (t = t.slice(0, l), i = t.length - 1 - t.lastIndexOf("/")), r = a, s = 0;
                continue;
              }
            } else if (t.length === 2 || t.length === 1) {
              t = "", i = 0, r = a, s = 0;
              continue;
            }
          }
          e && (t.length > 0 ? t += "/.." : t = "..", i = 2);
        } else
          t.length > 0 ? t += "/" + n.slice(r + 1, a) : t = n.slice(r + 1, a), i = a - r - 1;
      r = a, s = 0;
    } else
      o === 46 && s !== -1 ? ++s : s = -1;
  }
  return t;
}, kee = (n) => {
  if (n.length === 0)
    return ".";
  var e = n.charCodeAt(0) === 47, t = n.charCodeAt(n.length - 1) === 47;
  return n = Ree(n, !e), n.length === 0 && !e && (n = "."), n.length > 0 && t && (n += "/"), e ? "/" + n : n;
}, Lee = (...n) => {
  if (n.length === 0)
    return ".";
  for (var e, t = 0; t < n.length; ++t) {
    var i = n[t];
    i.length > 0 && (e === void 0 ? e = i : e += "/" + i);
  }
  return e === void 0 ? "." : kee(e);
}, [vO, pv] = Be(void 0), [Dee, gM] = Be(void 0), w4 = (n) => {
  kD.setURLModifier(n);
}, yC = /* @__PURE__ */ new Map(), _M = /* @__PURE__ */ new Map(), xC = /* @__PURE__ */ new Map(), Iee = (n) => {
  var e, t;
  return (t = yC.get(n)) != null ? t : (e = dy(n)[1]) == null ? void 0 : e.toLowerCase();
}, gO = (n, e = ((t) => (t = dy(n.webkitRelativePath)[1]) == null ? void 0 : t.toLowerCase())()) => Mr(_M, n, () => {
  const i = URL.createObjectURL(n);
  return e && yC.set(i, e), xC.set(i, n), i;
}), bM = /* @__PURE__ */ new Map();
ft(() => {
  const n = gM();
  if (!!n) {
    for (const e of n)
      bM.set(e.webkitRelativePath, e);
    return () => {
      for (const e of _M.values())
        URL.revokeObjectURL(e);
      bM.clear(), yC.clear(), _M.clear(), xC.clear();
    };
  }
}, [gM]);
ft(() => {
  var e;
  const n = (e = pv()) == null ? void 0 : e.webkitRelativePath;
  if (!!n)
    return w4((t) => {
      if (mO(t)) {
        const i = bM.get(Lee(pO(n), t));
        if (i)
          return gO(i);
      }
      return t;
    }), () => {
      w4(void 0);
    };
}, [pv]);
const [_O, Hb] = Be([]), Oee = nh(_O, Hb), Nee = ih(_O, Hb);
ft(() => {
  const n = Ln(), e = Hb();
  if (!n || !e.length)
    return;
  const t = zX(() => {
    for (const [i] of e)
      i.outerObject3d.visible = !1, "loadedGroup" in i && (i.loadedGroup.visible = !1);
    for (const [i, r] of e)
      r.position.copy(Dn(i.outerObject3d)), r.update(n, bt);
    for (const [i] of e)
      i.outerObject3d.visible = !0, "loadedGroup" in i && (i.loadedGroup.visible = !0);
  });
  return () => {
    t.cancel();
  };
}, [Ln, Hb]);
const M_ = (n, e, t) => {
  var r, s;
  const i = (s = (r = n.userData)[e]) != null ? s : r[e] = Li(n, e);
  Bs(
    n,
    e,
    t === void 0 ? i : Math.max(i || 0, 0.25) * t
  );
}, S4 = (n, e, t) => {
  var r, s;
  const i = (s = (r = n.userData)[e]) != null ? s : r[e] = Li(n, e);
  Bs(
    n,
    e,
    t === void 0 ? i : t
  );
};
class zee extends Ii {
  constructor() {
    super(...arguments);
    V(this, "_metalnessFactor");
    V(this, "_roughnessFactor");
    V(this, "_opacityFactor");
    V(this, "_envFactor");
    V(this, "_reflection");
  }
  _refreshFactors(t, i) {
    const {
      _metalnessFactor: r,
      _roughnessFactor: s,
      _opacityFactor: o,
      _envFactor: a,
      _reflection: l
    } = this;
    let c;
    if (l) {
      const d = new rD(256);
      c = d.texture;
      const p = new iD(uh, 10, d), m = [this, p];
      Oee(m), t.then(() => {
        d.dispose(), c = void 0, Nee(m);
      });
    }
    for (const d of i) {
      const p = d.nativeMaterial;
      if (p.wireframe)
        return;
      r !== void 0 && M_(
        p,
        "metalness",
        r !== 0 ? r : void 0
      ), s !== void 0 && M_(
        p,
        "roughness",
        s !== 1 ? s : void 0
      ), o !== void 0 && (M_(p, "opacity", o), S4(
        p,
        "transparent",
        o <= 1 ? !0 : void 0
      )), a !== void 0 && M_(
        p,
        "envMapIntensity",
        a !== 1 ? a : void 0
      ), l !== void 0 && S4(p, "envMap", c);
    }
  }
  refreshFactors() {
    this.cancelHandle("refreshFactors", () => {
      const t = new Xn();
      return queueMicrotask(() => {
        t.done || this._refreshFactors(
          t,
          zv(this.nativeObject3d, this)
        );
      }), t;
    });
  }
  get metalnessFactor() {
    return this._metalnessFactor;
  }
  set metalnessFactor(t) {
    this._metalnessFactor = t, this.refreshFactors();
  }
  get roughnessFactor() {
    return this._roughnessFactor;
  }
  set roughnessFactor(t) {
    this._roughnessFactor = t, this.refreshFactors();
  }
  get opacityFactor() {
    return this._opacityFactor;
  }
  set opacityFactor(t) {
    this._opacityFactor = t, this.refreshFactors();
  }
  get envFactor() {
    return this._envFactor;
  }
  set envFactor(t) {
    this._envFactor = t, this.refreshFactors();
  }
  get reflection() {
    var t;
    return (t = this._reflection) != null ? t : !1;
  }
  set reflection(t) {
    this._reflection = t, this.refreshFactors();
  }
}
class gs extends jv {
  constructor(t) {
    super(t);
    V(this, "loadingState", new Je(0));
    V(this, "serializeAnimations");
    V(this, "_resize");
    this.unmounted = t;
  }
  playAnimation(t) {
    this.cancelHandle(
      "modelPlayAnimation",
      () => this.loadingState.get((i, r) => {
        i || (r.cancel(), super.playAnimation(t));
      })
    );
  }
  stopAnimation() {
    this.cancelHandle(
      "modelStopAnimation",
      () => this.loadingState.get((t, i) => {
        t || (i.cancel(), super.stopAnimation());
      })
    );
  }
  async loadAnimation(t, i = t) {
    var c;
    ((c = this.serializeAnimations) != null ? c : this.serializeAnimations = {})[i] = t;
    const r = (await this.load(t)).animations[0];
    if (!r)
      return;
    const { onFinishState: s, repeatState: o, finishEventState: a } = this.lazyStates(), l = this.animations[i] = this.watch(
      new ra(i, r, await this.loaded, o, s, a)
    );
    this.append(l);
  }
  get animations() {
    return super.animations;
  }
  set animations(t) {
    for (const [i, r] of Object.entries(t))
      typeof r == "string" ? this.loadAnimation(r, i) : this.animations[i] = r;
  }
  async load(t) {
    R2();
    const i = new qD();
    this.loadingState.set(this.loadingState.get() + 1);
    const r = Iee(t);
    if (!t)
      throw i.resolve(), setTimeout(() => this.loadingState.set(this.loadingState.get() - 1)), Fd(), new Error("Unsupported file extension " + r);
    const s = r === "fbx" ? await import("./loadFBX.fcb07ac9.mjs") : await import("./loadGLTF.47defb8a.mjs");
    let o;
    try {
      o = await s.default(t, !this.unmounted);
    } catch {
      throw i.resolve(), setTimeout(() => this.loadingState.set(this.loadingState.get() - 1)), Fd(), new Error("Failed to load model, check if src is correct");
    }
    return i.resolve(), setTimeout(() => this.loadingState.set(this.loadingState.get() - 1)), Fd(), o;
  }
  get resize() {
    var t;
    return (t = this._resize) != null ? t : !0;
  }
  set resize(t) {
    this._resize = t, this.loaded.done && (this.src = this._src);
  }
  resolveLoaded(t, i) {
    if (this.unmounted)
      return t;
    let r = null, s = !1;
    const { onFinishState: o, repeatState: a, finishEventState: l } = this.lazyStates();
    this.playAllAnimation && (r = new zD(t));
    for (const d of t.animations) {
      s = !0;
      const p = this.animations[d.name] = this.watch(
        new ra(d.name, d, t, a, o, l)
      );
      this.playAllAnimation && (r == null || r.clipAction(d).play().setLoop($L, 1 / 0)), this.append(p);
    }
    this.playAllAnimation && r && s && ku(() => {
      r && r.update(Iv[0]);
    });
    const c = this._resize === !1 ? gC(t, i) : hO(t, i);
    return !this.widthSet && (this.object3d.scale.x = c.x), !this.heightSet && (this.object3d.scale.y = c.y), !this.depthSet && (this.object3d.scale.z = c.z), t;
  }
  find(t, i) {
    const r = super.find(t, i);
    return r && (r.model = this), r;
  }
  findAll(t) {
    const i = super.findAll(t);
    for (const r of i)
      r.model = this;
    return i;
  }
  refreshFactors() {
    this.cancelHandle("refreshFactorsLoaded", () => {
      const t = this.loaded.then(
        (i) => queueMicrotask(() => {
          t.done || this._refreshFactors(t, zv(i, this, !0));
        })
      );
      return t;
    });
  }
}
V(gs, "componentName", "model"), V(gs, "defaults", bC), V(gs, "schema", _C);
th(gs, [zee]);
const Fee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: gs
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var rt = function() {
  return rt = Object.assign || function(e) {
    for (var t, i = 1, r = arguments.length; i < r; i++) {
      t = arguments[i];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, rt.apply(this, arguments);
};
function wC(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}
function cn(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function fn(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      s.push(r.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return s;
}
function $n(n, e, t) {
  if (t || arguments.length === 2)
    for (var i = 0, r = e.length, s; i < r; i++)
      (s || !(i in e)) && (s || (s = Array.prototype.slice.call(e, 0, i)), s[i] = e[i]);
  return n.concat(s || Array.prototype.slice.call(e));
}
var Un;
(function(n) {
  n.Start = "xstate.start", n.Stop = "xstate.stop", n.Raise = "xstate.raise", n.Send = "xstate.send", n.Cancel = "xstate.cancel", n.NullEvent = "", n.Assign = "xstate.assign", n.After = "xstate.after", n.DoneState = "done.state", n.DoneInvoke = "done.invoke", n.Log = "xstate.log", n.Init = "xstate.init", n.Invoke = "xstate.invoke", n.ErrorExecution = "error.execution", n.ErrorCommunication = "error.communication", n.ErrorPlatform = "error.platform", n.ErrorCustom = "xstate.error", n.Update = "xstate.update", n.Pure = "xstate.pure", n.Choose = "xstate.choose";
})(Un || (Un = {}));
var Pc;
(function(n) {
  n.Parent = "#_parent", n.Internal = "#_internal";
})(Pc || (Pc = {}));
var yM = Un.Start, SC = Un.Stop, Pf = Un.Raise, Af = Un.Send, bO = Un.Cancel, Bee = Un.NullEvent, yO = Un.Assign;
Un.After;
Un.DoneState;
var xO = Un.Log, Uee = Un.Init, xM = Un.Invoke;
Un.ErrorExecution;
var M4 = Un.ErrorPlatform, Vee = Un.ErrorCustom, wO = Un.Update, Hee = Un.Choose, Gee = Un.Pure, SO = ".", E4 = {}, wM = "xstate.guard", Wee = "", xi = process.env.NODE_ENV === "production", E_;
function MC(n, e, t) {
  t === void 0 && (t = SO);
  var i = zm(n, t), r = zm(e, t);
  return bn(r) ? bn(i) ? r === i : !1 : bn(i) ? i in r : Object.keys(i).every(function(s) {
    return s in r ? MC(i[s], r[s]) : !1;
  });
}
function MO(n) {
  try {
    return bn(n) || typeof n == "number" ? "".concat(n) : n.type;
  } catch {
    throw new Error("Events must be strings or objects with a string event.type property.");
  }
}
function SM(n, e) {
  try {
    return Kf(n) ? n : n.toString().split(e);
  } catch {
    throw new Error("'".concat(n, "' is not a valid state path."));
  }
}
function jee(n) {
  return typeof n == "object" && "value" in n && "context" in n && "event" in n && "_event" in n;
}
function zm(n, e) {
  if (jee(n))
    return n.value;
  if (Kf(n))
    return Gb(n);
  if (typeof n != "string")
    return n;
  var t = SM(n, e);
  return Gb(t);
}
function Gb(n) {
  if (n.length === 1)
    return n[0];
  for (var e = {}, t = e, i = 0; i < n.length - 1; i++)
    i === n.length - 2 ? t[n[i]] = n[i + 1] : (t[n[i]] = {}, t = t[n[i]]);
  return e;
}
function Sm(n, e) {
  for (var t = {}, i = Object.keys(n), r = 0; r < i.length; r++) {
    var s = i[r];
    t[s] = e(n[s], s, n, r);
  }
  return t;
}
function C4(n, e, t) {
  var i, r, s = {};
  try {
    for (var o = cn(Object.keys(n)), a = o.next(); !a.done; a = o.next()) {
      var l = a.value, c = n[l];
      !t(c) || (s[l] = e(c, l, n));
    }
  } catch (d) {
    i = {
      error: d
    };
  } finally {
    try {
      a && !a.done && (r = o.return) && r.call(o);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return s;
}
var qee = function(n) {
  return function(e) {
    var t, i, r = e;
    try {
      for (var s = cn(n), o = s.next(); !o.done; o = s.next()) {
        var a = o.value;
        r = r[a];
      }
    } catch (l) {
      t = {
        error: l
      };
    } finally {
      try {
        o && !o.done && (i = s.return) && i.call(s);
      } finally {
        if (t)
          throw t.error;
      }
    }
    return r;
  };
};
function Xee(n, e) {
  return function(t) {
    var i, r, s = t;
    try {
      for (var o = cn(n), a = o.next(); !a.done; a = o.next()) {
        var l = a.value;
        s = s[e][l];
      }
    } catch (c) {
      i = {
        error: c
      };
    } finally {
      try {
        a && !a.done && (r = o.return) && r.call(o);
      } finally {
        if (i)
          throw i.error;
      }
    }
    return s;
  };
}
function tb(n) {
  if (!n)
    return [[]];
  if (bn(n))
    return [[n]];
  var e = ci(Object.keys(n).map(function(t) {
    var i = n[t];
    return typeof i != "string" && (!i || !Object.keys(i).length) ? [[t]] : tb(n[t]).map(function(r) {
      return [t].concat(r);
    });
  }));
  return e;
}
function ci(n) {
  var e;
  return (e = []).concat.apply(e, $n([], fn(n), !1));
}
function EO(n) {
  return Kf(n) ? n : [n];
}
function Eo(n) {
  return n === void 0 ? [] : EO(n);
}
function Wb(n, e, t) {
  var i, r;
  if (Bn(n))
    return n(e, t.data);
  var s = {};
  try {
    for (var o = cn(Object.keys(n)), a = o.next(); !a.done; a = o.next()) {
      var l = a.value, c = n[l];
      Bn(c) ? s[l] = c(e, t.data) : s[l] = c;
    }
  } catch (d) {
    i = {
      error: d
    };
  } finally {
    try {
      a && !a.done && (r = o.return) && r.call(o);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return s;
}
function $ee(n) {
  return /^(done|error)\./.test(n);
}
function T4(n) {
  return !!(n instanceof Promise || n !== null && (Bn(n) || typeof n == "object") && Bn(n.then));
}
function Zee(n) {
  return n !== null && typeof n == "object" && "transition" in n && typeof n.transition == "function";
}
function Yee(n, e) {
  var t, i, r = fn([[], []], 2), s = r[0], o = r[1];
  try {
    for (var a = cn(n), l = a.next(); !l.done; l = a.next()) {
      var c = l.value;
      e(c) ? s.push(c) : o.push(c);
    }
  } catch (d) {
    t = {
      error: d
    };
  } finally {
    try {
      l && !l.done && (i = a.return) && i.call(a);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return [s, o];
}
function CO(n, e) {
  return Sm(n.states, function(t, i) {
    if (!!t) {
      var r = (bn(e) ? void 0 : e[i]) || (t ? t.current : void 0);
      if (!!r)
        return {
          current: r,
          states: CO(t, r)
        };
    }
  });
}
function Kee(n, e) {
  return {
    current: e,
    states: CO(n, e)
  };
}
function P4(n, e, t, i) {
  xi || yr(!!n, "Attempting to update undefined context");
  var r = n && t.reduce(function(s, o) {
    var a, l, c = o.assignment, d = {
      state: i,
      action: o,
      _event: e
    }, p = {};
    if (Bn(c))
      p = c(s, e.data, d);
    else
      try {
        for (var m = cn(Object.keys(c)), v = m.next(); !v.done; v = m.next()) {
          var b = v.value, x = c[b];
          p[b] = Bn(x) ? x(s, e.data, d) : x;
        }
      } catch (y) {
        a = {
          error: y
        };
      } finally {
        try {
          v && !v.done && (l = m.return) && l.call(m);
        } finally {
          if (a)
            throw a.error;
        }
      }
    return Object.assign({}, s, p);
  }, n);
  return r;
}
var yr = function() {
};
xi || (yr = function(n, e) {
  var t = n instanceof Error ? n : void 0;
  if (!(!t && n) && console !== void 0) {
    var i = ["Warning: ".concat(e)];
    t && i.push(t), console.warn.apply(console, i);
  }
});
function Kf(n) {
  return Array.isArray(n);
}
function Bn(n) {
  return typeof n == "function";
}
function bn(n) {
  return typeof n == "string";
}
function TO(n, e) {
  if (!!n)
    return bn(n) ? {
      type: wM,
      name: n,
      predicate: e ? e[n] : void 0
    } : Bn(n) ? {
      type: wM,
      name: n.name,
      predicate: n
    } : n;
}
function Jee(n) {
  try {
    return "subscribe" in n && Bn(n.subscribe);
  } catch {
    return !1;
  }
}
var ac = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
E_ = {}, E_[ac] = function() {
  return this;
}, E_[Symbol.observable] = function() {
  return this;
};
function Ku(n) {
  return !!n && "__xstatenode" in n;
}
function Qee(n) {
  return !!n && typeof n.send == "function";
}
function EC(n, e) {
  return bn(n) || typeof n == "number" ? rt({
    type: n
  }, e) : n;
}
function _r(n, e) {
  if (!bn(n) && "$$type" in n && n.$$type === "scxml")
    return n;
  var t = EC(n);
  return rt({
    name: t.type,
    data: t,
    $$type: "scxml",
    type: "external"
  }, e);
}
function _d(n, e) {
  var t = EO(e).map(function(i) {
    return typeof i > "u" || typeof i == "string" || Ku(i) ? {
      target: i,
      event: n
    } : rt(rt({}, i), {
      event: n
    });
  });
  return t;
}
function ete(n) {
  if (!(n === void 0 || n === Wee))
    return Eo(n);
}
function tte(n, e, t) {
  if (!xi) {
    var i = n.stack ? " Stacktrace was '".concat(n.stack, "'") : "";
    if (n === e)
      console.error("Missing onError handler for invocation '".concat(t, "', error was '").concat(n, "'.").concat(i));
    else {
      var r = e.stack ? " Stacktrace was '".concat(e.stack, "'") : "";
      console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '".concat(t, "'. ") + "Original error: '".concat(n, "'. ").concat(i, " Current error is '").concat(e, "'.").concat(r));
    }
  }
}
function PO(n, e, t, i, r) {
  var s = n.options.guards, o = {
    state: r,
    cond: e,
    _event: i
  };
  if (e.type === wM)
    return ((s == null ? void 0 : s[e.name]) || e.predicate)(t, i.data, o);
  var a = s == null ? void 0 : s[e.type];
  if (!a)
    throw new Error("Guard '".concat(e.type, "' is not implemented on machine '").concat(n.id, "'."));
  return a(t, i.data, o);
}
function AO(n) {
  return typeof n == "string" ? {
    type: n
  } : n;
}
function nb(n, e, t) {
  var i = function() {
  }, r = typeof n == "object", s = r ? n : null;
  return {
    next: ((r ? n.next : n) || i).bind(s),
    error: ((r ? n.error : e) || i).bind(s),
    complete: ((r ? n.complete : t) || i).bind(s)
  };
}
function C_(n, e) {
  return "".concat(n, ":invocation[").concat(e, "]");
}
var $d = /* @__PURE__ */ _r({
  type: Uee
});
function MM(n, e) {
  return e && e[n] || void 0;
}
function mv(n, e) {
  var t;
  if (bn(n) || typeof n == "number") {
    var i = MM(n, e);
    Bn(i) ? t = {
      type: n,
      exec: i
    } : i ? t = i : t = {
      type: n,
      exec: void 0
    };
  } else if (Bn(n))
    t = {
      type: n.name || n.toString(),
      exec: n
    };
  else {
    var i = MM(n.type, e);
    if (Bn(i))
      t = rt(rt({}, n), {
        exec: i
      });
    else if (i) {
      var r = i.type || n.type;
      t = rt(rt(rt({}, i), n), {
        type: r
      });
    } else
      t = n;
  }
  return t;
}
var lc = function(n, e) {
  if (!n)
    return [];
  var t = Kf(n) ? n : [n];
  return t.map(function(i) {
    return mv(i, e);
  });
};
function CC(n) {
  var e = mv(n);
  return rt(rt({
    id: bn(n) ? n : e.id
  }, e), {
    type: e.type
  });
}
function nte(n) {
  return bn(n) ? {
    type: Pf,
    event: n
  } : RO(n, {
    to: Pc.Internal
  });
}
function ite(n) {
  return {
    type: Pf,
    _event: _r(n.event)
  };
}
function RO(n, e) {
  return {
    to: e ? e.to : void 0,
    type: Af,
    event: Bn(n) ? n : EC(n),
    delay: e ? e.delay : void 0,
    id: e && e.id !== void 0 ? e.id : Bn(n) ? n.name : MO(n)
  };
}
function rte(n, e, t, i) {
  var r = {
    _event: t
  }, s = _r(Bn(n.event) ? n.event(e, t.data, r) : n.event), o;
  if (bn(n.delay)) {
    var a = i && i[n.delay];
    o = Bn(a) ? a(e, t.data, r) : a;
  } else
    o = Bn(n.delay) ? n.delay(e, t.data, r) : n.delay;
  var l = Bn(n.to) ? n.to(e, t.data, r) : n.to;
  return rt(rt({}, n), {
    to: l,
    _event: s,
    event: s.data,
    delay: o
  });
}
var ste = function(n, e, t) {
  return rt(rt({}, n), {
    value: bn(n.expr) ? n.expr : n.expr(e, t.data, {
      _event: t
    })
  });
}, ote = function(n) {
  return {
    type: bO,
    sendId: n
  };
};
function ate(n) {
  var e = CC(n);
  return {
    type: Un.Start,
    activity: e,
    exec: void 0
  };
}
function lte(n) {
  var e = Bn(n) ? n : CC(n);
  return {
    type: Un.Stop,
    activity: e,
    exec: void 0
  };
}
function cte(n, e, t) {
  var i = Bn(n.activity) ? n.activity(e, t.data) : n.activity, r = typeof i == "string" ? {
    id: i
  } : i, s = {
    type: Un.Stop,
    activity: r
  };
  return s;
}
function ute(n, e) {
  var t = e ? "#".concat(e) : "";
  return "".concat(Un.After, "(").concat(n, ")").concat(t);
}
function T_(n, e) {
  var t = "".concat(Un.DoneState, ".").concat(n), i = {
    type: t,
    data: e
  };
  return i.toString = function() {
    return t;
  }, i;
}
function ib(n, e) {
  var t = "".concat(Un.DoneInvoke, ".").concat(n), i = {
    type: t,
    data: e
  };
  return i.toString = function() {
    return t;
  }, i;
}
function Mm(n, e) {
  var t = "".concat(Un.ErrorPlatform, ".").concat(n), i = {
    type: t,
    data: e
  };
  return i.toString = function() {
    return t;
  }, i;
}
var hte = function(n) {
  var e, t, i = [];
  try {
    for (var r = cn(n), s = r.next(); !s.done; s = r.next())
      for (var o = s.value, a = 0; a < o.length; ) {
        if (o[a].type === yO) {
          i.push(o[a]), o.splice(a, 1);
          continue;
        }
        a++;
      }
  } catch (l) {
    e = {
      error: l
    };
  } finally {
    try {
      s && !s.done && (t = r.return) && t.call(r);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return i;
};
function jb(n, e, t, i, r, s, o) {
  o === void 0 && (o = !1);
  var a = o ? [] : hte(r), l = a.length ? P4(t, i, a, e) : t, c = o ? [t] : void 0, d = [];
  function p(b) {
    var x;
    switch (b.type) {
      case Pf:
        return ite(b);
      case Af:
        var y = rte(b, l, i, n.options.delays);
        return xi || yr(
          !bn(b.delay) || typeof y.delay == "number",
          "No delay reference for delay expression '".concat(b.delay, "' was found on machine '").concat(n.id, "'")
        ), s && y.to !== Pc.Internal && d.push(y), y;
      case xO: {
        var S = ste(b, l, i);
        return s == null || s(S, l, i), S;
      }
      case Hee: {
        var C = b, M = (x = C.conds.find(function(K) {
          var A = TO(K.cond, n.options.guards);
          return !A || PO(n, A, l, i, s ? void 0 : e);
        })) === null || x === void 0 ? void 0 : x.actions;
        if (!M)
          return [];
        var T = fn(jb(n, e, l, i, [lc(Eo(M), n.options.actions)], s, o), 2), P = T[0], D = T[1];
        return l = D, c == null || c.push(l), P;
      }
      case Gee: {
        var M = b.get(l, i.data);
        if (!M)
          return [];
        var I = fn(jb(n, e, l, i, [lc(Eo(M), n.options.actions)], s, o), 2), k = I[0], O = I[1];
        return l = O, c == null || c.push(l), k;
      }
      case SC: {
        var S = cte(b, l, i);
        return s == null || s(S, t, i), S;
      }
      case yO: {
        l = P4(l, i, [b], s ? void 0 : e), c == null || c.push(l);
        break;
      }
      default:
        var B = mv(b, n.options.actions), Y = B.exec;
        if (s)
          s(B, l, i);
        else if (Y && c) {
          var G = c.length - 1;
          B = rt(rt({}, B), {
            exec: function(K) {
              for (var A = [], J = 1; J < arguments.length; J++)
                A[J - 1] = arguments[J];
              Y.apply(void 0, $n([c[G]], fn(A), !1));
            }
          });
        }
        return B;
    }
  }
  function m(b) {
    var x, y, S = [];
    try {
      for (var C = cn(b), M = C.next(); !M.done; M = C.next()) {
        var T = M.value, P = p(T);
        P && (S = S.concat(P));
      }
    } catch (D) {
      x = {
        error: D
      };
    } finally {
      try {
        M && !M.done && (y = C.return) && y.call(C);
      } finally {
        if (x)
          throw x.error;
      }
    }
    return d.forEach(function(D) {
      s(D, l, i);
    }), d.length = 0, S;
  }
  var v = ci(r.map(m));
  return [v, l];
}
var Cd = function(n, e) {
  var t = e(n);
  return t;
};
function kO(n) {
  var e;
  return e = {
    id: n,
    send: function() {
    },
    subscribe: function() {
      return {
        unsubscribe: function() {
        }
      };
    },
    getSnapshot: function() {
    },
    toJSON: function() {
      return {
        id: n
      };
    }
  }, e[ac] = function() {
    return this;
  }, e;
}
function dte(n, e, t, i) {
  var r, s = AO(n.src), o = (r = e == null ? void 0 : e.options.services) === null || r === void 0 ? void 0 : r[s.type], a = n.data ? Wb(n.data, t, i) : void 0, l = o ? LO(o, n.id, a) : kO(n.id);
  return l.meta = n, l;
}
function LO(n, e, t) {
  var i = kO(e);
  if (i.deferred = !0, Ku(n)) {
    var r = i.state = Cd(void 0, function() {
      return (t ? n.withContext(t) : n).initialState;
    });
    i.getSnapshot = function() {
      return r;
    };
  }
  return i;
}
function fte(n) {
  try {
    return typeof n.send == "function";
  } catch {
    return !1;
  }
}
function pte(n) {
  return fte(n) && "id" in n;
}
function mte(n) {
  var e;
  return rt((e = {
    subscribe: function() {
      return {
        unsubscribe: function() {
        }
      };
    },
    id: "anonymous",
    getSnapshot: function() {
    }
  }, e[ac] = function() {
    return this;
  }, e), n);
}
var qb = function(n) {
  return n.type === "atomic" || n.type === "final";
};
function DO(n) {
  return Object.keys(n.states).map(function(e) {
    return n.states[e];
  });
}
function vv(n) {
  return DO(n).filter(function(e) {
    return e.type !== "history";
  });
}
function IO(n) {
  var e = [n];
  return qb(n) ? e : e.concat(ci(vv(n).map(IO)));
}
function Em(n, e) {
  var t, i, r, s, o, a, l, c, d = new Set(n), p = EM(d), m = new Set(e);
  try {
    for (var v = cn(m), b = v.next(); !b.done; b = v.next())
      for (var x = b.value, y = x.parent; y && !m.has(y); )
        m.add(y), y = y.parent;
  } catch (O) {
    t = {
      error: O
    };
  } finally {
    try {
      b && !b.done && (i = v.return) && i.call(v);
    } finally {
      if (t)
        throw t.error;
    }
  }
  var S = EM(m);
  try {
    for (var C = cn(m), M = C.next(); !M.done; M = C.next()) {
      var x = M.value;
      if (x.type === "compound" && (!S.get(x) || !S.get(x).length))
        p.get(x) ? p.get(x).forEach(function(B) {
          return m.add(B);
        }) : x.initialStateNodes.forEach(function(B) {
          return m.add(B);
        });
      else if (x.type === "parallel")
        try {
          for (var T = (o = void 0, cn(vv(x))), P = T.next(); !P.done; P = T.next()) {
            var D = P.value;
            m.has(D) || (m.add(D), p.get(D) ? p.get(D).forEach(function(B) {
              return m.add(B);
            }) : D.initialStateNodes.forEach(function(B) {
              return m.add(B);
            }));
          }
        } catch (B) {
          o = {
            error: B
          };
        } finally {
          try {
            P && !P.done && (a = T.return) && a.call(T);
          } finally {
            if (o)
              throw o.error;
          }
        }
    }
  } catch (O) {
    r = {
      error: O
    };
  } finally {
    try {
      M && !M.done && (s = C.return) && s.call(C);
    } finally {
      if (r)
        throw r.error;
    }
  }
  try {
    for (var I = cn(m), k = I.next(); !k.done; k = I.next())
      for (var x = k.value, y = x.parent; y && !m.has(y); )
        m.add(y), y = y.parent;
  } catch (O) {
    l = {
      error: O
    };
  } finally {
    try {
      k && !k.done && (c = I.return) && c.call(I);
    } finally {
      if (l)
        throw l.error;
    }
  }
  return m;
}
function OO(n, e) {
  var t = e.get(n);
  if (!t)
    return {};
  if (n.type === "compound") {
    var i = t[0];
    if (i) {
      if (qb(i))
        return i.key;
    } else
      return {};
  }
  var r = {};
  return t.forEach(function(s) {
    r[s.key] = OO(s, e);
  }), r;
}
function EM(n) {
  var e, t, i = /* @__PURE__ */ new Map();
  try {
    for (var r = cn(n), s = r.next(); !s.done; s = r.next()) {
      var o = s.value;
      i.has(o) || i.set(o, []), o.parent && (i.has(o.parent) || i.set(o.parent, []), i.get(o.parent).push(o));
    }
  } catch (a) {
    e = {
      error: a
    };
  } finally {
    try {
      s && !s.done && (t = r.return) && t.call(r);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return i;
}
function vte(n, e) {
  var t = Em([n], e);
  return OO(n, EM(t));
}
function Td(n, e) {
  return Array.isArray(n) ? n.some(function(t) {
    return t === e;
  }) : n instanceof Set ? n.has(e) : !1;
}
function gte(n) {
  return $n([], fn(new Set(ci($n([], fn(n.map(function(e) {
    return e.ownEvents;
  })), !1)))), !1);
}
function rb(n, e) {
  return e.type === "compound" ? vv(e).some(function(t) {
    return t.type === "final" && Td(n, t);
  }) : e.type === "parallel" ? vv(e).every(function(t) {
    return rb(n, t);
  }) : !1;
}
function _te(n) {
  return n === void 0 && (n = []), n.reduce(function(e, t) {
    return t.meta !== void 0 && (e[t.id] = t.meta), e;
  }, {});
}
function A4(n) {
  return new Set(ci(n.map(function(e) {
    return e.tags;
  })));
}
function NO(n, e) {
  if (n === e)
    return !0;
  if (n === void 0 || e === void 0)
    return !1;
  if (bn(n) || bn(e))
    return n === e;
  var t = Object.keys(n), i = Object.keys(e);
  return t.length === i.length && t.every(function(r) {
    return NO(n[r], e[r]);
  });
}
function bte(n) {
  return typeof n != "object" || n === null ? !1 : "value" in n && "_event" in n;
}
function yte(n, e) {
  var t = n.exec, i = rt(rt({}, n), {
    exec: t !== void 0 ? function() {
      return t(e.context, e.event, {
        action: n,
        state: e,
        _event: e._event
      });
    } : void 0
  });
  return i;
}
var na = /* @__PURE__ */ function() {
  function n(e) {
    var t = this, i;
    this.actions = [], this.activities = E4, this.meta = {}, this.events = [], this.value = e.value, this.context = e.context, this._event = e._event, this._sessionid = e._sessionid, this.event = this._event.data, this.historyValue = e.historyValue, this.history = e.history, this.actions = e.actions || [], this.activities = e.activities || E4, this.meta = _te(e.configuration), this.events = e.events || [], this.matches = this.matches.bind(this), this.toStrings = this.toStrings.bind(this), this.configuration = e.configuration, this.transitions = e.transitions, this.children = e.children, this.done = !!e.done, this.tags = (i = Array.isArray(e.tags) ? new Set(e.tags) : e.tags) !== null && i !== void 0 ? i : /* @__PURE__ */ new Set(), this.machine = e.machine, Object.defineProperty(this, "nextEvents", {
      get: function() {
        return gte(t.configuration);
      }
    });
  }
  return n.from = function(e, t) {
    if (e instanceof n)
      return e.context !== t ? new n({
        value: e.value,
        context: t,
        _event: e._event,
        _sessionid: null,
        historyValue: e.historyValue,
        history: e.history,
        actions: [],
        activities: e.activities,
        meta: {},
        events: [],
        configuration: [],
        transitions: [],
        children: {}
      }) : e;
    var i = $d;
    return new n({
      value: e,
      context: t,
      _event: i,
      _sessionid: null,
      historyValue: void 0,
      history: void 0,
      actions: [],
      activities: void 0,
      meta: void 0,
      events: [],
      configuration: [],
      transitions: [],
      children: {}
    });
  }, n.create = function(e) {
    return new n(e);
  }, n.inert = function(e, t) {
    if (e instanceof n) {
      if (!e.actions.length)
        return e;
      var i = $d;
      return new n({
        value: e.value,
        context: t,
        _event: i,
        _sessionid: null,
        historyValue: e.historyValue,
        history: e.history,
        activities: e.activities,
        configuration: e.configuration,
        transitions: [],
        children: {}
      });
    }
    return n.from(e, t);
  }, n.prototype.toStrings = function(e, t) {
    var i = this;
    if (e === void 0 && (e = this.value), t === void 0 && (t = "."), bn(e))
      return [e];
    var r = Object.keys(e);
    return r.concat.apply(r, $n([], fn(r.map(function(s) {
      return i.toStrings(e[s], t).map(function(o) {
        return s + t + o;
      });
    })), !1));
  }, n.prototype.toJSON = function() {
    var e = this;
    e.configuration, e.transitions;
    var t = e.tags;
    e.machine;
    var i = wC(e, ["configuration", "transitions", "tags", "machine"]);
    return rt(rt({}, i), {
      tags: Array.from(t)
    });
  }, n.prototype.matches = function(e) {
    return MC(e, this.value);
  }, n.prototype.hasTag = function(e) {
    return this.tags.has(e);
  }, n.prototype.can = function(e) {
    var t;
    xi && yr(!!this.machine, "state.can(...) used outside of a machine-created State object; this will always return false.");
    var i = (t = this.machine) === null || t === void 0 ? void 0 : t.getTransitionData(this, e);
    return !!(i != null && i.transitions.length) && i.transitions.some(function(r) {
      return r.target !== void 0 || r.actions.length;
    });
  }, n;
}(), xte = {
  deferEvents: !1
}, R4 = /* @__PURE__ */ function() {
  function n(e) {
    this.processingEvent = !1, this.queue = [], this.initialized = !1, this.options = rt(rt({}, xte), e);
  }
  return n.prototype.initialize = function(e) {
    if (this.initialized = !0, e) {
      if (!this.options.deferEvents) {
        this.schedule(e);
        return;
      }
      this.process(e);
    }
    this.flushEvents();
  }, n.prototype.schedule = function(e) {
    if (!this.initialized || this.processingEvent) {
      this.queue.push(e);
      return;
    }
    if (this.queue.length !== 0)
      throw new Error("Event queue should be empty when it is not processing events");
    this.process(e), this.flushEvents();
  }, n.prototype.clear = function() {
    this.queue = [];
  }, n.prototype.flushEvents = function() {
    for (var e = this.queue.shift(); e; )
      this.process(e), e = this.queue.shift();
  }, n.prototype.process = function(e) {
    this.processingEvent = !0;
    try {
      e();
    } catch (t) {
      throw this.clear(), t;
    } finally {
      this.processingEvent = !1;
    }
  }, n;
}(), kS = /* @__PURE__ */ new Map(), wte = 0, P_ = {
  bookId: function() {
    return "x:".concat(wte++);
  },
  register: function(n, e) {
    return kS.set(n, e), n;
  },
  get: function(n) {
    return kS.get(n);
  },
  free: function(n) {
    kS.delete(n);
  }
};
function TC() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  xi || console.warn("XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues");
}
function Ste() {
  var n = TC();
  if (n && "__xstate__" in n)
    return n.__xstate__;
}
function Mte(n) {
  if (!!TC()) {
    var e = Ste();
    e && e.register(n);
  }
}
function Ete(n, e) {
  e === void 0 && (e = {});
  var t = n.initialState, i = /* @__PURE__ */ new Set(), r = [], s = !1, o = function() {
    if (!s) {
      for (s = !0; r.length > 0; ) {
        var c = r.shift();
        t = n.transition(t, c, l), i.forEach(function(d) {
          return d.next(t);
        });
      }
      s = !1;
    }
  }, a = mte({
    id: e.id,
    send: function(c) {
      r.push(c), o();
    },
    getSnapshot: function() {
      return t;
    },
    subscribe: function(c, d, p) {
      var m = nb(c, d, p);
      return i.add(m), m.next(t), {
        unsubscribe: function() {
          i.delete(m);
        }
      };
    }
  }), l = {
    parent: e.parent,
    self: a,
    id: e.id || "anonymous",
    observers: i
  };
  return t = n.start ? n.start(l) : t, a;
}
var Cte = {
  sync: !1,
  autoForward: !1
}, or;
(function(n) {
  n[n.NotStarted = 0] = "NotStarted", n[n.Running = 1] = "Running", n[n.Stopped = 2] = "Stopped";
})(or || (or = {}));
var Tte = /* @__PURE__ */ function() {
  function n(e, t) {
    t === void 0 && (t = n.defaultOptions);
    var i = this;
    this.machine = e, this.delayedEventsMap = {}, this.listeners = /* @__PURE__ */ new Set(), this.contextListeners = /* @__PURE__ */ new Set(), this.stopListeners = /* @__PURE__ */ new Set(), this.doneListeners = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Set(), this.sendListeners = /* @__PURE__ */ new Set(), this.initialized = !1, this.status = or.NotStarted, this.children = /* @__PURE__ */ new Map(), this.forwardTo = /* @__PURE__ */ new Set(), this._outgoingQueue = [], this.init = this.start, this.send = function(d, p) {
      if (Kf(d))
        return i.batch(d), i.state;
      var m = _r(EC(d, p));
      if (i.status === or.Stopped)
        return xi || yr(!1, 'Event "'.concat(m.name, '" was sent to stopped service "').concat(i.machine.id, `". This service has already reached its final state, and will not transition.
Event: `).concat(JSON.stringify(m.data))), i.state;
      if (i.status !== or.Running && !i.options.deferEvents)
        throw new Error('Event "'.concat(m.name, '" was sent to uninitialized service "').concat(
          i.machine.id,
          `". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.
Event: `
        ).concat(JSON.stringify(m.data)));
      return i.scheduler.schedule(function() {
        i.forward(m);
        var v = i._nextState(m);
        i.update(v, m);
      }), i._state;
    }, this.sendTo = function(d, p, m) {
      var v = i.parent && (p === Pc.Parent || i.parent.id === p), b = v ? i.parent : bn(p) ? i.children.get(p) || P_.get(p) : Qee(p) ? p : void 0;
      if (!b) {
        if (!v)
          throw new Error("Unable to send event to child '".concat(p, "' from service '").concat(i.id, "'."));
        xi || yr(!1, "Service '".concat(i.id, "' has no parent: unable to send event ").concat(d.type));
        return;
      }
      if ("machine" in b) {
        if (i.status !== or.Stopped || i.parent !== b || i.state.done) {
          var x = rt(rt({}, d), {
            name: d.name === Vee ? "".concat(Mm(i.id)) : d.name,
            origin: i.sessionId
          });
          !m && i.machine.config.predictableActionArguments ? i._outgoingQueue.push([b, x]) : b.send(x);
        }
      } else
        !m && i.machine.config.predictableActionArguments ? i._outgoingQueue.push([b, d.data]) : b.send(d.data);
    }, this._exec = function(d, p, m, v) {
      v === void 0 && (v = i.machine.options.actions);
      var b = d.exec || MM(d.type, v), x = Bn(b) ? b : b ? b.exec : d.exec;
      if (x)
        try {
          return x(p, m.data, i.machine.config.predictableActionArguments ? {
            action: d,
            _event: m
          } : {
            action: d,
            state: i.state,
            _event: m
          });
        } catch (G) {
          throw i.parent && i.parent.send({
            type: "xstate.error",
            data: G
          }), G;
        }
      switch (d.type) {
        case Af:
          var y = d;
          if (typeof y.delay == "number") {
            i.defer(y);
            return;
          } else
            y.to ? i.sendTo(y._event, y.to, m === $d) : i.send(y._event);
          break;
        case bO:
          i.cancel(d.sendId);
          break;
        case yM: {
          if (i.status !== or.Running)
            return;
          var S = d.activity;
          if (!i.machine.config.predictableActionArguments && !i.state.activities[S.id || S.type])
            break;
          if (S.type === Un.Invoke) {
            var C = AO(S.src), M = i.machine.options.services ? i.machine.options.services[C.type] : void 0, T = S.id, P = S.data;
            xi || yr(
              !("forward" in S),
              "`forward` property is deprecated (found in invocation of '".concat(S.src, "' in in machine '").concat(i.machine.id, "'). ") + "Please use `autoForward` instead."
            );
            var D = "autoForward" in S ? S.autoForward : !!S.forward;
            if (!M) {
              xi || yr(!1, "No service found for invocation '".concat(S.src, "' in machine '").concat(i.machine.id, "'."));
              return;
            }
            var I = P ? Wb(P, p, m) : void 0;
            if (typeof M == "string")
              return;
            var k = Bn(M) ? M(p, m.data, {
              data: I,
              src: C,
              meta: S.meta
            }) : M;
            if (!k)
              return;
            var O = void 0;
            Ku(k) && (k = I ? k.withContext(I) : k, O = {
              autoForward: D
            }), i.spawn(k, T, O);
          } else
            i.spawnActivity(S);
          break;
        }
        case SC: {
          i.stopChild(d.activity.id);
          break;
        }
        case xO:
          var B = d.label, Y = d.value;
          B ? i.logger(B, Y) : i.logger(Y);
          break;
        default:
          xi || yr(!1, "No implementation found for action type '".concat(d.type, "'"));
          break;
      }
    };
    var r = rt(rt({}, n.defaultOptions), t), s = r.clock, o = r.logger, a = r.parent, l = r.id, c = l !== void 0 ? l : e.id;
    this.id = c, this.logger = o, this.clock = s, this.parent = a, this.options = r, this.scheduler = new R4({
      deferEvents: this.options.deferEvents
    }), this.sessionId = P_.bookId();
  }
  return Object.defineProperty(n.prototype, "initialState", {
    get: function() {
      var e = this;
      return this._initialState ? this._initialState : Cd(this, function() {
        return e._initialState = e.machine.initialState, e._initialState;
      });
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "state", {
    get: function() {
      return xi || yr(this.status !== or.NotStarted, "Attempted to read state from uninitialized service '".concat(this.id, "'. Make sure the service is started first.")), this._state;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.execute = function(e, t) {
    var i, r;
    try {
      for (var s = cn(e.actions), o = s.next(); !o.done; o = s.next()) {
        var a = o.value;
        this.exec(a, e, t);
      }
    } catch (l) {
      i = {
        error: l
      };
    } finally {
      try {
        o && !o.done && (r = s.return) && r.call(s);
      } finally {
        if (i)
          throw i.error;
      }
    }
  }, n.prototype.update = function(e, t) {
    var i, r, s, o, a, l, c, d, p = this;
    if (e._sessionid = this.sessionId, this._state = e, (!this.machine.config.predictableActionArguments || t === $d) && this.options.execute)
      this.execute(this.state);
    else
      for (var m = void 0; m = this._outgoingQueue.shift(); )
        m[0].send(m[1]);
    if (this.children.forEach(function(O) {
      p.state.children[O.id] = O;
    }), this.devTools && this.devTools.send(t.data, e), e.event)
      try {
        for (var v = cn(this.eventListeners), b = v.next(); !b.done; b = v.next()) {
          var x = b.value;
          x(e.event);
        }
      } catch (O) {
        i = {
          error: O
        };
      } finally {
        try {
          b && !b.done && (r = v.return) && r.call(v);
        } finally {
          if (i)
            throw i.error;
        }
      }
    try {
      for (var y = cn(this.listeners), S = y.next(); !S.done; S = y.next()) {
        var x = S.value;
        x(e, e.event);
      }
    } catch (O) {
      s = {
        error: O
      };
    } finally {
      try {
        S && !S.done && (o = y.return) && o.call(y);
      } finally {
        if (s)
          throw s.error;
      }
    }
    try {
      for (var C = cn(this.contextListeners), M = C.next(); !M.done; M = C.next()) {
        var T = M.value;
        T(this.state.context, this.state.history ? this.state.history.context : void 0);
      }
    } catch (O) {
      a = {
        error: O
      };
    } finally {
      try {
        M && !M.done && (l = C.return) && l.call(C);
      } finally {
        if (a)
          throw a.error;
      }
    }
    if (this.state.done) {
      var P = e.configuration.find(function(O) {
        return O.type === "final" && O.parent === p.machine;
      }), D = P && P.doneData ? Wb(P.doneData, e.context, t) : void 0;
      try {
        for (var I = cn(this.doneListeners), k = I.next(); !k.done; k = I.next()) {
          var x = k.value;
          x(ib(this.id, D));
        }
      } catch (O) {
        c = {
          error: O
        };
      } finally {
        try {
          k && !k.done && (d = I.return) && d.call(I);
        } finally {
          if (c)
            throw c.error;
        }
      }
      this._stop(), this._stopChildren();
    }
  }, n.prototype.onTransition = function(e) {
    return this.listeners.add(e), this.status === or.Running && e(this.state, this.state.event), this;
  }, n.prototype.subscribe = function(e, t, i) {
    var r = this, s = nb(e, t, i);
    this.listeners.add(s.next), this.status !== or.NotStarted && s.next(this.state);
    var o = function() {
      r.doneListeners.delete(o), r.stopListeners.delete(o), s.complete();
    };
    return this.status === or.Stopped ? s.complete() : (this.onDone(o), this.onStop(o)), {
      unsubscribe: function() {
        r.listeners.delete(s.next), r.doneListeners.delete(o), r.stopListeners.delete(o);
      }
    };
  }, n.prototype.onEvent = function(e) {
    return this.eventListeners.add(e), this;
  }, n.prototype.onSend = function(e) {
    return this.sendListeners.add(e), this;
  }, n.prototype.onChange = function(e) {
    return this.contextListeners.add(e), this;
  }, n.prototype.onStop = function(e) {
    return this.stopListeners.add(e), this;
  }, n.prototype.onDone = function(e) {
    return this.doneListeners.add(e), this;
  }, n.prototype.off = function(e) {
    return this.listeners.delete(e), this.eventListeners.delete(e), this.sendListeners.delete(e), this.stopListeners.delete(e), this.doneListeners.delete(e), this.contextListeners.delete(e), this;
  }, n.prototype.start = function(e) {
    var t = this;
    if (this.status === or.Running)
      return this;
    this.machine._init(), P_.register(this.sessionId, this), this.initialized = !0, this.status = or.Running;
    var i = e === void 0 ? this.initialState : Cd(this, function() {
      return bte(e) ? t.machine.resolveState(e) : t.machine.resolveState(na.from(e, t.machine.context));
    });
    return this.options.devTools && this.attachDev(), this.scheduler.initialize(function() {
      t.update(i, $d);
    }), this;
  }, n.prototype._stopChildren = function() {
    this.children.forEach(function(e) {
      Bn(e.stop) && e.stop();
    }), this.children.clear();
  }, n.prototype._stop = function() {
    var e, t, i, r, s, o, a, l, c, d;
    try {
      for (var p = cn(this.listeners), m = p.next(); !m.done; m = p.next()) {
        var v = m.value;
        this.listeners.delete(v);
      }
    } catch (I) {
      e = {
        error: I
      };
    } finally {
      try {
        m && !m.done && (t = p.return) && t.call(p);
      } finally {
        if (e)
          throw e.error;
      }
    }
    try {
      for (var b = cn(this.stopListeners), x = b.next(); !x.done; x = b.next()) {
        var v = x.value;
        v(), this.stopListeners.delete(v);
      }
    } catch (I) {
      i = {
        error: I
      };
    } finally {
      try {
        x && !x.done && (r = b.return) && r.call(b);
      } finally {
        if (i)
          throw i.error;
      }
    }
    try {
      for (var y = cn(this.contextListeners), S = y.next(); !S.done; S = y.next()) {
        var v = S.value;
        this.contextListeners.delete(v);
      }
    } catch (I) {
      s = {
        error: I
      };
    } finally {
      try {
        S && !S.done && (o = y.return) && o.call(y);
      } finally {
        if (s)
          throw s.error;
      }
    }
    try {
      for (var C = cn(this.doneListeners), M = C.next(); !M.done; M = C.next()) {
        var v = M.value;
        this.doneListeners.delete(v);
      }
    } catch (I) {
      a = {
        error: I
      };
    } finally {
      try {
        M && !M.done && (l = C.return) && l.call(C);
      } finally {
        if (a)
          throw a.error;
      }
    }
    if (!this.initialized)
      return this;
    this.initialized = !1, this.status = or.Stopped, this._initialState = void 0;
    try {
      for (var T = cn(Object.keys(this.delayedEventsMap)), P = T.next(); !P.done; P = T.next()) {
        var D = P.value;
        this.clock.clearTimeout(this.delayedEventsMap[D]);
      }
    } catch (I) {
      c = {
        error: I
      };
    } finally {
      try {
        P && !P.done && (d = T.return) && d.call(T);
      } finally {
        if (c)
          throw c.error;
      }
    }
    this.scheduler.clear(), this.scheduler = new R4({
      deferEvents: this.options.deferEvents
    });
  }, n.prototype.stop = function() {
    var e = this, t = this.scheduler;
    return this._stop(), t.schedule(function() {
      var i = _r({
        type: "xstate.stop"
      }), r = Cd(e, function() {
        var s = ci($n([], fn(e.state.configuration), !1).sort(function(d, p) {
          return p.order - d.order;
        }).map(function(d) {
          return lc(d.onExit, e.machine.options.actions);
        })), o = fn(jb(e.machine, e.state, e.state.context, i, [s], e.machine.config.predictableActionArguments ? e._exec : void 0, e.machine.config.predictableActionArguments || e.machine.config.preserveActionOrder), 2), a = o[0], l = o[1], c = new na({
          value: e.state.value,
          context: l,
          _event: i,
          _sessionid: e.sessionId,
          historyValue: void 0,
          history: e.state,
          actions: a.filter(function(d) {
            return d.type !== Pf && (d.type !== Af || !!d.to && d.to !== Pc.Internal);
          }),
          activities: {},
          events: [],
          configuration: [],
          transitions: [],
          children: {},
          done: e.state.done,
          tags: e.state.tags,
          machine: e.machine
        });
        return c.changed = !0, c;
      });
      e.update(r, i), e._stopChildren(), P_.free(e.sessionId);
    }), this;
  }, n.prototype.batch = function(e) {
    var t = this;
    if (this.status === or.NotStarted && this.options.deferEvents)
      xi || yr(!1, "".concat(e.length, ' event(s) were sent to uninitialized service "').concat(this.machine.id, `" and are deferred. Make sure .start() is called for this service.
Event: `).concat(JSON.stringify(event)));
    else if (this.status !== or.Running)
      throw new Error(
        "".concat(e.length, ' event(s) were sent to uninitialized service "').concat(this.machine.id, '". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.')
      );
    if (!!e.length) {
      var i = !!this.machine.config.predictableActionArguments && this._exec;
      this.scheduler.schedule(function() {
        var r, s, o = t.state, a = !1, l = [], c = function(v) {
          var b = _r(v);
          t.forward(b), o = Cd(t, function() {
            return t.machine.transition(o, b, void 0, i || void 0);
          }), l.push.apply(l, $n([], fn(t.machine.config.predictableActionArguments ? o.actions : o.actions.map(function(x) {
            return yte(x, o);
          })), !1)), a = a || !!o.changed;
        };
        try {
          for (var d = cn(e), p = d.next(); !p.done; p = d.next()) {
            var m = p.value;
            c(m);
          }
        } catch (v) {
          r = {
            error: v
          };
        } finally {
          try {
            p && !p.done && (s = d.return) && s.call(d);
          } finally {
            if (r)
              throw r.error;
          }
        }
        o.changed = a, o.actions = l, t.update(o, _r(e[e.length - 1]));
      });
    }
  }, n.prototype.sender = function(e) {
    return this.send.bind(this, e);
  }, n.prototype._nextState = function(e, t) {
    var i = this;
    t === void 0 && (t = !!this.machine.config.predictableActionArguments && this._exec);
    var r = _r(e);
    if (r.name.indexOf(M4) === 0 && !this.state.nextEvents.some(function(o) {
      return o.indexOf(M4) === 0;
    }))
      throw r.data.data;
    var s = Cd(this, function() {
      return i.machine.transition(i.state, r, void 0, t || void 0);
    });
    return s;
  }, n.prototype.nextState = function(e) {
    return this._nextState(e, !1);
  }, n.prototype.forward = function(e) {
    var t, i;
    try {
      for (var r = cn(this.forwardTo), s = r.next(); !s.done; s = r.next()) {
        var o = s.value, a = this.children.get(o);
        if (!a)
          throw new Error("Unable to forward event '".concat(e, "' from interpreter '").concat(this.id, "' to nonexistant child '").concat(o, "'."));
        a.send(e);
      }
    } catch (l) {
      t = {
        error: l
      };
    } finally {
      try {
        s && !s.done && (i = r.return) && i.call(r);
      } finally {
        if (t)
          throw t.error;
      }
    }
  }, n.prototype.defer = function(e) {
    var t = this;
    this.delayedEventsMap[e.id] = this.clock.setTimeout(function() {
      e.to ? t.sendTo(e._event, e.to, !0) : t.send(e._event);
    }, e.delay);
  }, n.prototype.cancel = function(e) {
    this.clock.clearTimeout(this.delayedEventsMap[e]), delete this.delayedEventsMap[e];
  }, n.prototype.exec = function(e, t, i) {
    i === void 0 && (i = this.machine.options.actions), this._exec(e, t.context, t._event, i);
  }, n.prototype.removeChild = function(e) {
    var t;
    this.children.delete(e), this.forwardTo.delete(e), (t = this.state) === null || t === void 0 || delete t.children[e];
  }, n.prototype.stopChild = function(e) {
    var t = this.children.get(e);
    !t || (this.removeChild(e), Bn(t.stop) && t.stop());
  }, n.prototype.spawn = function(e, t, i) {
    if (this.status !== or.Running)
      return LO(e, t);
    if (T4(e))
      return this.spawnPromise(Promise.resolve(e), t);
    if (Bn(e))
      return this.spawnCallback(e, t);
    if (pte(e))
      return this.spawnActor(e, t);
    if (Jee(e))
      return this.spawnObservable(e, t);
    if (Ku(e))
      return this.spawnMachine(e, rt(rt({}, i), {
        id: t
      }));
    if (Zee(e))
      return this.spawnBehavior(e, t);
    throw new Error('Unable to spawn entity "'.concat(t, '" of type "').concat(typeof e, '".'));
  }, n.prototype.spawnMachine = function(e, t) {
    var i = this;
    t === void 0 && (t = {});
    var r = new n(e, rt(rt({}, this.options), {
      parent: this,
      id: t.id || e.id
    })), s = rt(rt({}, Cte), t);
    s.sync && r.onTransition(function(a) {
      i.send(wO, {
        state: a,
        id: r.id
      });
    });
    var o = r;
    return this.children.set(r.id, o), s.autoForward && this.forwardTo.add(r.id), r.onDone(function(a) {
      i.removeChild(r.id), i.send(_r(a, {
        origin: r.id
      }));
    }).start(), o;
  }, n.prototype.spawnBehavior = function(e, t) {
    var i = Ete(e, {
      id: t,
      parent: this
    });
    return this.children.set(t, i), i;
  }, n.prototype.spawnPromise = function(e, t) {
    var i, r = this, s = !1, o;
    e.then(function(l) {
      s || (o = l, r.removeChild(t), r.send(_r(ib(t, l), {
        origin: t
      })));
    }, function(l) {
      if (!s) {
        r.removeChild(t);
        var c = Mm(t, l);
        try {
          r.send(_r(c, {
            origin: t
          }));
        } catch (d) {
          tte(l, d, t), r.devTools && r.devTools.send(c, r.state), r.machine.strict && r.stop();
        }
      }
    });
    var a = (i = {
      id: t,
      send: function() {
      },
      subscribe: function(l, c, d) {
        var p = nb(l, c, d), m = !1;
        return e.then(function(v) {
          m || (p.next(v), !m && p.complete());
        }, function(v) {
          m || p.error(v);
        }), {
          unsubscribe: function() {
            return m = !0;
          }
        };
      },
      stop: function() {
        s = !0;
      },
      toJSON: function() {
        return {
          id: t
        };
      },
      getSnapshot: function() {
        return o;
      }
    }, i[ac] = function() {
      return this;
    }, i);
    return this.children.set(t, a), a;
  }, n.prototype.spawnCallback = function(e, t) {
    var i, r = this, s = !1, o = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), l, c = function(m) {
      l = m, a.forEach(function(v) {
        return v(m);
      }), !s && r.send(_r(m, {
        origin: t
      }));
    }, d;
    try {
      d = e(c, function(m) {
        o.add(m);
      });
    } catch (m) {
      this.send(Mm(t, m));
    }
    if (T4(d))
      return this.spawnPromise(d, t);
    var p = (i = {
      id: t,
      send: function(m) {
        return o.forEach(function(v) {
          return v(m);
        });
      },
      subscribe: function(m) {
        var v = nb(m);
        return a.add(v.next), {
          unsubscribe: function() {
            a.delete(v.next);
          }
        };
      },
      stop: function() {
        s = !0, Bn(d) && d();
      },
      toJSON: function() {
        return {
          id: t
        };
      },
      getSnapshot: function() {
        return l;
      }
    }, i[ac] = function() {
      return this;
    }, i);
    return this.children.set(t, p), p;
  }, n.prototype.spawnObservable = function(e, t) {
    var i, r = this, s, o = e.subscribe(function(l) {
      s = l, r.send(_r(l, {
        origin: t
      }));
    }, function(l) {
      r.removeChild(t), r.send(_r(Mm(t, l), {
        origin: t
      }));
    }, function() {
      r.removeChild(t), r.send(_r(ib(t), {
        origin: t
      }));
    }), a = (i = {
      id: t,
      send: function() {
      },
      subscribe: function(l, c, d) {
        return e.subscribe(l, c, d);
      },
      stop: function() {
        return o.unsubscribe();
      },
      getSnapshot: function() {
        return s;
      },
      toJSON: function() {
        return {
          id: t
        };
      }
    }, i[ac] = function() {
      return this;
    }, i);
    return this.children.set(t, a), a;
  }, n.prototype.spawnActor = function(e, t) {
    return this.children.set(t, e), e;
  }, n.prototype.spawnActivity = function(e) {
    var t = this.machine.options && this.machine.options.activities ? this.machine.options.activities[e.type] : void 0;
    if (!t) {
      xi || yr(!1, "No implementation found for activity '".concat(e.type, "'"));
      return;
    }
    var i = t(this.state.context, e);
    this.spawnEffect(e.id, i);
  }, n.prototype.spawnEffect = function(e, t) {
    var i;
    this.children.set(e, (i = {
      id: e,
      send: function() {
      },
      subscribe: function() {
        return {
          unsubscribe: function() {
          }
        };
      },
      stop: t || void 0,
      getSnapshot: function() {
      },
      toJSON: function() {
        return {
          id: e
        };
      }
    }, i[ac] = function() {
      return this;
    }, i));
  }, n.prototype.attachDev = function() {
    var e = TC();
    if (this.options.devTools && e) {
      if (e.__REDUX_DEVTOOLS_EXTENSION__) {
        var t = typeof this.options.devTools == "object" ? this.options.devTools : void 0;
        this.devTools = e.__REDUX_DEVTOOLS_EXTENSION__.connect(rt(rt({
          name: this.id,
          autoPause: !0,
          stateSanitizer: function(i) {
            return {
              value: i.value,
              context: i.context,
              actions: i.actions
            };
          }
        }, t), {
          features: rt({
            jump: !1,
            skip: !1
          }, t ? t.features : void 0)
        }), this.machine), this.devTools.init(this.state);
      }
      Mte(this);
    }
  }, n.prototype.toJSON = function() {
    return {
      id: this.id
    };
  }, n.prototype[ac] = function() {
    return this;
  }, n.prototype.getSnapshot = function() {
    return this.status === or.NotStarted ? this.initialState : this._state;
  }, n.defaultOptions = {
    execute: !0,
    deferEvents: !0,
    clock: {
      setTimeout: function(e, t) {
        return setTimeout(e, t);
      },
      clearTimeout: function(e) {
        return clearTimeout(e);
      }
    },
    logger: /* @__PURE__ */ console.log.bind(console),
    devTools: !1
  }, n.interpret = zO, n;
}();
function zO(n, e) {
  var t = new Tte(n, e);
  return t;
}
function Pte(n) {
  if (typeof n == "string") {
    var e = {
      type: n
    };
    return e.toString = function() {
      return n;
    }, e;
  }
  return n;
}
function A_(n) {
  return rt(rt({
    type: xM
  }, n), {
    toJSON: function() {
      n.onDone, n.onError;
      var e = wC(n, ["onDone", "onError"]);
      return rt(rt({}, e), {
        type: xM,
        src: Pte(n.src)
      });
    }
  });
}
var Pd = "", CM = "#", cm = "*", bd = {}, yd = function(n) {
  return n[0] === CM;
}, Ate = function() {
  return {
    actions: {},
    guards: {},
    services: {},
    activities: {},
    delays: {}
  };
}, Rte = function(n, e, t) {
  var i = t.slice(0, -1).some(function(s) {
    return !("cond" in s) && !("in" in s) && (bn(s.target) || Ku(s.target));
  }), r = e === Pd ? "the transient event" : "event '".concat(e, "'");
  yr(!i, "One or more transitions for ".concat(r, " on state '").concat(n.id, "' are unreachable. ") + "Make sure that the default transition is the last one defined.");
}, kte = /* @__PURE__ */ function() {
  function n(e, t, i, r) {
    i === void 0 && (i = "context" in e ? e.context : void 0);
    var s = this, o;
    this.config = e, this._context = i, this.order = -1, this.__xstatenode = !0, this.__cache = {
      events: void 0,
      relativeValue: /* @__PURE__ */ new Map(),
      initialStateValue: void 0,
      initialState: void 0,
      on: void 0,
      transitions: void 0,
      candidates: {},
      delayedTransitions: void 0
    }, this.idMap = {}, this.tags = [], this.options = Object.assign(Ate(), t), this.parent = r == null ? void 0 : r.parent, this.key = this.config.key || (r == null ? void 0 : r.key) || this.config.id || "(machine)", this.machine = this.parent ? this.parent.machine : this, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : SO), this.id = this.config.id || $n([this.machine.key], fn(this.path), !1).join(this.delimiter), this.version = this.parent ? this.parent.version : this.config.version, this.type = this.config.type || (this.config.parallel ? "parallel" : this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.schema = this.parent ? this.machine.schema : (o = this.config.schema) !== null && o !== void 0 ? o : {}, this.description = this.config.description, xi || yr(!("parallel" in this.config), 'The "parallel" property is deprecated and will be removed in version 4.1. '.concat(this.config.parallel ? "Replace with `type: 'parallel'`" : "Use `type: '".concat(this.type, "'`"), " in the config for state node '").concat(this.id, "' instead.")), this.initial = this.config.initial, this.states = this.config.states ? Sm(this.config.states, function(c, d) {
      var p, m = new n(c, {}, void 0, {
        parent: s,
        key: d
      });
      return Object.assign(s.idMap, rt((p = {}, p[m.id] = m, p), m.idMap)), m;
    }) : bd;
    var a = 0;
    function l(c) {
      var d, p;
      c.order = a++;
      try {
        for (var m = cn(DO(c)), v = m.next(); !v.done; v = m.next()) {
          var b = v.value;
          l(b);
        }
      } catch (x) {
        d = {
          error: x
        };
      } finally {
        try {
          v && !v.done && (p = m.return) && p.call(m);
        } finally {
          if (d)
            throw d.error;
        }
      }
    }
    l(this), this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this._transient = !!this.config.always || (this.config.on ? Array.isArray(this.config.on) ? this.config.on.some(function(c) {
      var d = c.event;
      return d === Pd;
    }) : Pd in this.config.on : !1), this.strict = !!this.config.strict, this.onEntry = Eo(this.config.entry || this.config.onEntry).map(function(c) {
      return mv(c);
    }), this.onExit = Eo(this.config.exit || this.config.onExit).map(function(c) {
      return mv(c);
    }), this.meta = this.config.meta, this.doneData = this.type === "final" ? this.config.data : void 0, this.invoke = Eo(this.config.invoke).map(function(c, d) {
      var p, m;
      if (Ku(c)) {
        var v = C_(s.id, d);
        return s.machine.options.services = rt((p = {}, p[v] = c, p), s.machine.options.services), A_({
          src: v,
          id: v
        });
      } else if (bn(c.src)) {
        var v = c.id || C_(s.id, d);
        return A_(rt(rt({}, c), {
          id: v,
          src: c.src
        }));
      } else if (Ku(c.src) || Bn(c.src)) {
        var v = c.id || C_(s.id, d);
        return s.machine.options.services = rt((m = {}, m[v] = c.src, m), s.machine.options.services), A_(rt(rt({
          id: v
        }, c), {
          src: v
        }));
      } else {
        var b = c.src;
        return A_(rt(rt({
          id: C_(s.id, d)
        }, c), {
          src: b
        }));
      }
    }), this.activities = Eo(this.config.activities).concat(this.invoke).map(function(c) {
      return CC(c);
    }), this.transition = this.transition.bind(this), this.tags = Eo(this.config.tags);
  }
  return n.prototype._init = function() {
    this.__cache.transitions || IO(this).forEach(function(e) {
      return e.on;
    });
  }, n.prototype.withConfig = function(e, t) {
    var i = this.options, r = i.actions, s = i.activities, o = i.guards, a = i.services, l = i.delays;
    return new n(this.config, {
      actions: rt(rt({}, r), e.actions),
      activities: rt(rt({}, s), e.activities),
      guards: rt(rt({}, o), e.guards),
      services: rt(rt({}, a), e.services),
      delays: rt(rt({}, l), e.delays)
    }, t != null ? t : this.context);
  }, n.prototype.withContext = function(e) {
    return new n(this.config, this.options, e);
  }, Object.defineProperty(n.prototype, "context", {
    get: function() {
      return Bn(this._context) ? this._context() : this._context;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "definition", {
    get: function() {
      return {
        id: this.id,
        key: this.key,
        version: this.version,
        context: this.context,
        type: this.type,
        initial: this.initial,
        history: this.history,
        states: Sm(this.states, function(e) {
          return e.definition;
        }),
        on: this.on,
        transitions: this.transitions,
        entry: this.onEntry,
        exit: this.onExit,
        activities: this.activities || [],
        meta: this.meta,
        order: this.order || -1,
        data: this.doneData,
        invoke: this.invoke,
        description: this.description,
        tags: this.tags
      };
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.toJSON = function() {
    return this.definition;
  }, Object.defineProperty(n.prototype, "on", {
    get: function() {
      if (this.__cache.on)
        return this.__cache.on;
      var e = this.transitions;
      return this.__cache.on = e.reduce(function(t, i) {
        return t[i.eventType] = t[i.eventType] || [], t[i.eventType].push(i), t;
      }, {});
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "after", {
    get: function() {
      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "transitions", {
    get: function() {
      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.getCandidates = function(e) {
    if (this.__cache.candidates[e])
      return this.__cache.candidates[e];
    var t = e === Pd, i = this.transitions.filter(function(r) {
      var s = r.eventType === e;
      return t ? s : s || r.eventType === cm;
    });
    return this.__cache.candidates[e] = i, i;
  }, n.prototype.getDelayedTransitions = function() {
    var e = this, t = this.config.after;
    if (!t)
      return [];
    var i = function(s, o) {
      var a = Bn(s) ? "".concat(e.id, ":delay[").concat(o, "]") : s, l = ute(a, e.id);
      return e.onEntry.push(RO(l, {
        delay: s
      })), e.onExit.push(ote(l)), l;
    }, r = Kf(t) ? t.map(function(s, o) {
      var a = i(s.delay, o);
      return rt(rt({}, s), {
        event: a
      });
    }) : ci(Object.keys(t).map(function(s, o) {
      var a = t[s], l = bn(a) ? {
        target: a
      } : a, c = isNaN(+s) ? s : +s, d = i(c, o);
      return Eo(l).map(function(p) {
        return rt(rt({}, p), {
          event: d,
          delay: c
        });
      });
    }));
    return r.map(function(s) {
      var o = s.delay;
      return rt(rt({}, e.formatTransition(s)), {
        delay: o
      });
    });
  }, n.prototype.getStateNodes = function(e) {
    var t, i = this;
    if (!e)
      return [];
    var r = e instanceof na ? e.value : zm(e, this.delimiter);
    if (bn(r)) {
      var s = this.getStateNode(r).initial;
      return s !== void 0 ? this.getStateNodes((t = {}, t[r] = s, t)) : [this, this.states[r]];
    }
    var o = Object.keys(r), a = [this];
    return a.push.apply(a, $n([], fn(ci(o.map(function(l) {
      return i.getStateNode(l).getStateNodes(r[l]);
    }))), !1)), a;
  }, n.prototype.handles = function(e) {
    var t = MO(e);
    return this.events.includes(t);
  }, n.prototype.resolveState = function(e) {
    var t = e instanceof na ? e : na.create(e), i = Array.from(Em([], this.getStateNodes(t.value)));
    return new na(rt(rt({}, t), {
      value: this.resolve(t.value),
      configuration: i,
      done: rb(i, this),
      tags: A4(i),
      machine: this.machine
    }));
  }, n.prototype.transitionLeafNode = function(e, t, i) {
    var r = this.getStateNode(e), s = r.next(t, i);
    return !s || !s.transitions.length ? this.next(t, i) : s;
  }, n.prototype.transitionCompoundNode = function(e, t, i) {
    var r = Object.keys(e), s = this.getStateNode(r[0]), o = s._transition(e[r[0]], t, i);
    return !o || !o.transitions.length ? this.next(t, i) : o;
  }, n.prototype.transitionParallelNode = function(e, t, i) {
    var r, s, o = {};
    try {
      for (var a = cn(Object.keys(e)), l = a.next(); !l.done; l = a.next()) {
        var c = l.value, d = e[c];
        if (!!d) {
          var p = this.getStateNode(c), m = p._transition(d, t, i);
          m && (o[c] = m);
        }
      }
    } catch (C) {
      r = {
        error: C
      };
    } finally {
      try {
        l && !l.done && (s = a.return) && s.call(a);
      } finally {
        if (r)
          throw r.error;
      }
    }
    var v = Object.keys(o).map(function(C) {
      return o[C];
    }), b = ci(v.map(function(C) {
      return C.transitions;
    })), x = v.some(function(C) {
      return C.transitions.length > 0;
    });
    if (!x)
      return this.next(t, i);
    var y = ci(v.map(function(C) {
      return C.entrySet;
    })), S = ci(Object.keys(o).map(function(C) {
      return o[C].configuration;
    }));
    return {
      transitions: b,
      entrySet: y,
      exitSet: ci(v.map(function(C) {
        return C.exitSet;
      })),
      configuration: S,
      source: t,
      actions: ci(Object.keys(o).map(function(C) {
        return o[C].actions;
      }))
    };
  }, n.prototype._transition = function(e, t, i) {
    return bn(e) ? this.transitionLeafNode(e, t, i) : Object.keys(e).length === 1 ? this.transitionCompoundNode(e, t, i) : this.transitionParallelNode(e, t, i);
  }, n.prototype.getTransitionData = function(e, t) {
    return this._transition(e.value, e, _r(t));
  }, n.prototype.next = function(e, t) {
    var i, r, s = this, o = t.name, a = [], l = [], c;
    try {
      for (var d = cn(this.getCandidates(o)), p = d.next(); !p.done; p = d.next()) {
        var m = p.value, v = m.cond, b = m.in, x = e.context, y = b ? bn(b) && yd(b) ? e.matches(zm(this.getStateNodeById(b).path, this.delimiter)) : MC(zm(b, this.delimiter), qee(this.path.slice(0, -2))(e.value)) : !0, S = !1;
        try {
          S = !v || PO(this.machine, v, x, t, e);
        } catch (P) {
          throw new Error("Unable to evaluate guard '".concat(v.name || v.type, "' in transition for event '").concat(o, "' in state node '").concat(this.id, `':
`).concat(P.message));
        }
        if (S && y) {
          m.target !== void 0 && (l = m.target), a.push.apply(a, $n([], fn(m.actions), !1)), c = m;
          break;
        }
      }
    } catch (P) {
      i = {
        error: P
      };
    } finally {
      try {
        p && !p.done && (r = d.return) && r.call(d);
      } finally {
        if (i)
          throw i.error;
      }
    }
    if (!!c) {
      if (!l.length)
        return {
          transitions: [c],
          entrySet: [],
          exitSet: [],
          configuration: e.value ? [this] : [],
          source: e,
          actions: a
        };
      var C = ci(l.map(function(P) {
        return s.getRelativeStateNodes(P, e.historyValue);
      })), M = !!c.internal, T = [];
      return M || l.forEach(function(P) {
        T.push.apply(T, $n([], fn(s.getExternalReentryNodes(P)), !1));
      }), {
        transitions: [c],
        entrySet: T,
        exitSet: M ? [] : [this],
        configuration: C,
        source: e,
        actions: a
      };
    }
  }, n.prototype.getExternalReentryNodes = function(e) {
    for (var t = [], i = fn(e.order > this.order ? [e, this] : [this, e], 2), r = i[0], s = i[1]; r && r !== s; )
      t.push(r), r = r.parent;
    return r !== s ? [] : (t.push(s), t);
  }, n.prototype.getActions = function(e, t, i, r, s, o, a) {
    var l, c, d, p, m = this, v = Em([], o ? this.getStateNodes(o.value) : [this]);
    try {
      for (var b = cn(e), x = b.next(); !x.done; x = b.next()) {
        var y = x.value;
        (!Td(v, y) || Td(i.entrySet, y.parent) && !Td(i.entrySet, y)) && i.entrySet.push(y);
      }
    } catch (B) {
      l = {
        error: B
      };
    } finally {
      try {
        x && !x.done && (c = b.return) && c.call(b);
      } finally {
        if (l)
          throw l.error;
      }
    }
    try {
      for (var S = cn(v), C = S.next(); !C.done; C = S.next()) {
        var y = C.value;
        (!Td(e, y) || Td(i.exitSet, y.parent)) && i.exitSet.push(y);
      }
    } catch (B) {
      d = {
        error: B
      };
    } finally {
      try {
        C && !C.done && (p = S.return) && p.call(S);
      } finally {
        if (d)
          throw d.error;
      }
    }
    var M = ci(i.entrySet.map(function(B) {
      var Y = [];
      if (B.type !== "final")
        return Y;
      var G = B.parent;
      if (!G.parent)
        return Y;
      Y.push(
        T_(B.id, B.doneData),
        T_(G.id, B.doneData ? Wb(B.doneData, r, s) : void 0)
      );
      var K = G.parent;
      return K.type === "parallel" && vv(K).every(function(A) {
        return rb(i.configuration, A);
      }) && Y.push(T_(K.id)), Y;
    }));
    i.exitSet.sort(function(B, Y) {
      return Y.order - B.order;
    }), i.entrySet.sort(function(B, Y) {
      return B.order - Y.order;
    });
    var T = new Set(i.entrySet), P = new Set(i.exitSet), D = Array.from(T).map(function(B) {
      var Y = B.onEntry, G = B.activities.map(function(K) {
        return ate(K);
      });
      return lc(a ? $n($n([], fn(Y), !1), fn(G), !1) : $n($n([], fn(G), !1), fn(Y), !1), m.machine.options.actions);
    }).concat([M.map(nte)]), I = Array.from(P).map(function(B) {
      return lc($n($n([], fn(B.onExit), !1), fn(B.activities.map(function(Y) {
        return lte(Y);
      })), !1), m.machine.options.actions);
    }), k = I.concat([lc(i.actions, this.machine.options.actions)]).concat(D);
    if (t) {
      var O = lc(ci($n([], fn(e), !1).sort(function(B, Y) {
        return Y.order - B.order;
      }).map(function(B) {
        return B.onExit;
      })), this.machine.options.actions).filter(function(B) {
        return B.type !== Pf && (B.type !== Af || !!B.to && B.to !== Pc.Internal);
      });
      return k.concat([O]);
    }
    return k;
  }, n.prototype.transition = function(e, t, i, r) {
    e === void 0 && (e = this.initialState);
    var s = _r(t), o;
    if (e instanceof na)
      o = i === void 0 ? e : this.resolveState(na.from(e, i));
    else {
      var a = bn(e) ? this.resolve(Gb(this.getResolvedPath(e))) : this.resolve(e), l = i != null ? i : this.machine.context;
      o = this.resolveState(na.from(a, l));
    }
    if (!xi && s.name === cm)
      throw new Error("An event cannot have the wildcard type ('".concat(cm, "')"));
    if (this.strict && !this.events.includes(s.name) && !$ee(s.name))
      throw new Error("Machine '".concat(this.id, "' does not accept event '").concat(s.name, "'"));
    var c = this._transition(o.value, o, s) || {
      transitions: [],
      configuration: [],
      entrySet: [],
      exitSet: [],
      source: o,
      actions: []
    }, d = Em([], this.getStateNodes(o.value)), p = c.configuration.length ? Em(d, c.configuration) : d;
    return c.configuration = $n([], fn(p), !1), this.resolveTransition(c, o, o.context, r, s);
  }, n.prototype.resolveRaisedTransition = function(e, t, i, r) {
    var s, o = e.actions;
    return e = this.transition(e, t, void 0, r), e._event = i, e.event = i.data, (s = e.actions).unshift.apply(s, $n([], fn(o), !1)), e;
  }, n.prototype.resolveTransition = function(e, t, i, r, s) {
    var o, a, l, c, d = this;
    s === void 0 && (s = $d);
    var p = e.configuration, m = !t || e.transitions.length > 0, v = m ? e.configuration : t ? t.configuration : [], b = rb(v, this), x = m ? vte(this.machine, p) : void 0, y = t ? t.historyValue ? t.historyValue : e.source ? this.machine.historyValue(t.value) : void 0 : void 0, S = this.getActions(new Set(v), b, e, i, s, t, r), C = t ? rt({}, t.activities) : {};
    try {
      for (var M = cn(S), T = M.next(); !T.done; T = M.next()) {
        var P = T.value;
        try {
          for (var D = (l = void 0, cn(P)), I = D.next(); !I.done; I = D.next()) {
            var k = I.value;
            k.type === yM ? C[k.activity.id || k.activity.type] = k : k.type === SC && (C[k.activity.id || k.activity.type] = !1);
          }
        } catch (ye) {
          l = {
            error: ye
          };
        } finally {
          try {
            I && !I.done && (c = D.return) && c.call(D);
          } finally {
            if (l)
              throw l.error;
          }
        }
      }
    } catch (ye) {
      o = {
        error: ye
      };
    } finally {
      try {
        T && !T.done && (a = M.return) && a.call(M);
      } finally {
        if (o)
          throw o.error;
      }
    }
    var O = fn(jb(this, t, i, s, S, r, this.machine.config.predictableActionArguments || this.machine.config.preserveActionOrder), 2), B = O[0], Y = O[1], G = fn(Yee(B, function(ye) {
      return ye.type === Pf || ye.type === Af && ye.to === Pc.Internal;
    }), 2), K = G[0], A = G[1], J = B.filter(function(ye) {
      var Se;
      return ye.type === yM && ((Se = ye.activity) === null || Se === void 0 ? void 0 : Se.type) === xM;
    }), xe = J.reduce(function(ye, Se) {
      return ye[Se.activity.id] = dte(Se.activity, d.machine, Y, s), ye;
    }, t ? rt({}, t.children) : {}), se = new na({
      value: x || t.value,
      context: Y,
      _event: s,
      _sessionid: t ? t._sessionid : null,
      historyValue: x ? y ? Kee(y, x) : void 0 : t ? t.historyValue : void 0,
      history: !x || e.source ? t : void 0,
      actions: x ? A : [],
      activities: x ? C : t ? t.activities : {},
      events: [],
      configuration: v,
      transitions: e.transitions,
      children: xe,
      done: b,
      tags: A4(v),
      machine: this
    }), oe = i !== Y;
    se.changed = s.name === wO || oe;
    var Q = se.history;
    Q && delete Q.history;
    var ce = !b && (this._transient || p.some(function(ye) {
      return ye._transient;
    }));
    if (!m && (!ce || s.name === Pd))
      return se;
    var te = se;
    if (!b)
      for (ce && (te = this.resolveRaisedTransition(te, {
        type: Bee
      }, s, r)); K.length; ) {
        var ee = K.shift();
        te = this.resolveRaisedTransition(te, ee._event, s, r);
      }
    var Re = te.changed || (Q ? !!te.actions.length || oe || typeof Q.value != typeof te.value || !NO(te.value, Q.value) : void 0);
    return te.changed = Re, te.history = Q, te;
  }, n.prototype.getStateNode = function(e) {
    if (yd(e))
      return this.machine.getStateNodeById(e);
    if (!this.states)
      throw new Error("Unable to retrieve child state '".concat(e, "' from '").concat(this.id, "'; no child states exist."));
    var t = this.states[e];
    if (!t)
      throw new Error("Child state '".concat(e, "' does not exist on '").concat(this.id, "'"));
    return t;
  }, n.prototype.getStateNodeById = function(e) {
    var t = yd(e) ? e.slice(CM.length) : e;
    if (t === this.id)
      return this;
    var i = this.machine.idMap[t];
    if (!i)
      throw new Error("Child state node '#".concat(t, "' does not exist on machine '").concat(this.id, "'"));
    return i;
  }, n.prototype.getStateNodeByPath = function(e) {
    if (typeof e == "string" && yd(e))
      try {
        return this.getStateNodeById(e.slice(1));
      } catch {
      }
    for (var t = SM(e, this.delimiter).slice(), i = this; t.length; ) {
      var r = t.shift();
      if (!r.length)
        break;
      i = i.getStateNode(r);
    }
    return i;
  }, n.prototype.resolve = function(e) {
    var t, i = this;
    if (!e)
      return this.initialStateValue || bd;
    switch (this.type) {
      case "parallel":
        return Sm(this.initialStateValue, function(s, o) {
          return s ? i.getStateNode(o).resolve(e[o] || s) : bd;
        });
      case "compound":
        if (bn(e)) {
          var r = this.getStateNode(e);
          return r.type === "parallel" || r.type === "compound" ? (t = {}, t[e] = r.initialStateValue, t) : e;
        }
        return Object.keys(e).length ? Sm(e, function(s, o) {
          return s ? i.getStateNode(o).resolve(s) : bd;
        }) : this.initialStateValue || {};
      default:
        return e || bd;
    }
  }, n.prototype.getResolvedPath = function(e) {
    if (yd(e)) {
      var t = this.machine.idMap[e.slice(CM.length)];
      if (!t)
        throw new Error("Unable to find state node '".concat(e, "'"));
      return t.path;
    }
    return SM(e, this.delimiter);
  }, Object.defineProperty(n.prototype, "initialStateValue", {
    get: function() {
      var e;
      if (this.__cache.initialStateValue)
        return this.__cache.initialStateValue;
      var t;
      if (this.type === "parallel")
        t = C4(this.states, function(i) {
          return i.initialStateValue || bd;
        }, function(i) {
          return i.type !== "history";
        });
      else if (this.initial !== void 0) {
        if (!this.states[this.initial])
          throw new Error("Initial state '".concat(this.initial, "' not found on '").concat(this.key, "'"));
        t = qb(this.states[this.initial]) ? this.initial : (e = {}, e[this.initial] = this.states[this.initial].initialStateValue, e);
      } else
        t = {};
      return this.__cache.initialStateValue = t, this.__cache.initialStateValue;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.getInitialState = function(e, t) {
    this._init();
    var i = this.getStateNodes(e);
    return this.resolveTransition({
      configuration: i,
      entrySet: i,
      exitSet: [],
      transitions: [],
      source: void 0,
      actions: []
    }, void 0, t != null ? t : this.machine.context, void 0);
  }, Object.defineProperty(n.prototype, "initialState", {
    get: function() {
      var e = this.initialStateValue;
      if (!e)
        throw new Error("Cannot retrieve initial state from simple state '".concat(this.id, "'."));
      return this.getInitialState(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "target", {
    get: function() {
      var e;
      if (this.type === "history") {
        var t = this.config;
        bn(t.target) ? e = yd(t.target) ? Gb(this.machine.getStateNodeById(t.target).path.slice(this.path.length - 1)) : t.target : e = t.target;
      }
      return e;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.getRelativeStateNodes = function(e, t, i) {
    return i === void 0 && (i = !0), i ? e.type === "history" ? e.resolveHistory(t) : e.initialStateNodes : [e];
  }, Object.defineProperty(n.prototype, "initialStateNodes", {
    get: function() {
      var e = this;
      if (qb(this))
        return [this];
      if (this.type === "compound" && !this.initial)
        return xi || yr(!1, "Compound state node '".concat(this.id, "' has no initial state.")), [this];
      var t = tb(this.initialStateValue);
      return ci(t.map(function(i) {
        return e.getFromRelativePath(i);
      }));
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.getFromRelativePath = function(e) {
    if (!e.length)
      return [this];
    var t = fn(e), i = t[0], r = t.slice(1);
    if (!this.states)
      throw new Error("Cannot retrieve subPath '".concat(i, "' from node with no states"));
    var s = this.getStateNode(i);
    if (s.type === "history")
      return s.resolveHistory();
    if (!this.states[i])
      throw new Error("Child state '".concat(i, "' does not exist on '").concat(this.id, "'"));
    return this.states[i].getFromRelativePath(r);
  }, n.prototype.historyValue = function(e) {
    if (!!Object.keys(this.states).length)
      return {
        current: e || this.initialStateValue,
        states: C4(this.states, function(t, i) {
          if (!e)
            return t.historyValue();
          var r = bn(e) ? void 0 : e[i];
          return t.historyValue(r || t.initialStateValue);
        }, function(t) {
          return !t.history;
        })
      };
  }, n.prototype.resolveHistory = function(e) {
    var t = this;
    if (this.type !== "history")
      return [this];
    var i = this.parent;
    if (!e) {
      var r = this.target;
      return r ? ci(tb(r).map(function(o) {
        return i.getFromRelativePath(o);
      })) : i.initialStateNodes;
    }
    var s = Xee(i.path, "states")(e).current;
    return bn(s) ? [i.getStateNode(s)] : ci(tb(s).map(function(o) {
      return t.history === "deep" ? i.getFromRelativePath(o) : [i.states[o[0]]];
    }));
  }, Object.defineProperty(n.prototype, "stateIds", {
    get: function() {
      var e = this, t = ci(Object.keys(this.states).map(function(i) {
        return e.states[i].stateIds;
      }));
      return [this.id].concat(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "events", {
    get: function() {
      var e, t, i, r;
      if (this.__cache.events)
        return this.__cache.events;
      var s = this.states, o = new Set(this.ownEvents);
      if (s)
        try {
          for (var a = cn(Object.keys(s)), l = a.next(); !l.done; l = a.next()) {
            var c = l.value, d = s[c];
            if (d.states)
              try {
                for (var p = (i = void 0, cn(d.events)), m = p.next(); !m.done; m = p.next()) {
                  var v = m.value;
                  o.add("".concat(v));
                }
              } catch (b) {
                i = {
                  error: b
                };
              } finally {
                try {
                  m && !m.done && (r = p.return) && r.call(p);
                } finally {
                  if (i)
                    throw i.error;
                }
              }
          }
        } catch (b) {
          e = {
            error: b
          };
        } finally {
          try {
            l && !l.done && (t = a.return) && t.call(a);
          } finally {
            if (e)
              throw e.error;
          }
        }
      return this.__cache.events = Array.from(o);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "ownEvents", {
    get: function() {
      var e = new Set(this.transitions.filter(function(t) {
        return !(!t.target && !t.actions.length && t.internal);
      }).map(function(t) {
        return t.eventType;
      }));
      return Array.from(e);
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.resolveTarget = function(e) {
    var t = this;
    if (e !== void 0)
      return e.map(function(i) {
        if (!bn(i))
          return i;
        var r = i[0] === t.delimiter;
        if (r && !t.parent)
          return t.getStateNodeByPath(i.slice(1));
        var s = r ? t.key + i : i;
        if (t.parent)
          try {
            var o = t.parent.getStateNodeByPath(s);
            return o;
          } catch (a) {
            throw new Error("Invalid transition definition for state node '".concat(t.id, `':
`).concat(a.message));
          }
        else
          return t.getStateNodeByPath(s);
      });
  }, n.prototype.formatTransition = function(e) {
    var t = this, i = ete(e.target), r = "internal" in e ? e.internal : i ? i.some(function(l) {
      return bn(l) && l[0] === t.delimiter;
    }) : !0, s = this.machine.options.guards, o = this.resolveTarget(i), a = rt(rt({}, e), {
      actions: lc(Eo(e.actions)),
      cond: TO(e.cond, s),
      target: o,
      source: this,
      internal: r,
      eventType: e.event,
      toJSON: function() {
        return rt(rt({}, a), {
          target: a.target ? a.target.map(function(l) {
            return "#".concat(l.id);
          }) : void 0,
          source: "#".concat(t.id)
        });
      }
    });
    return a;
  }, n.prototype.formatTransitions = function() {
    var e, t, i = this, r;
    if (!this.config.on)
      r = [];
    else if (Array.isArray(this.config.on))
      r = this.config.on;
    else {
      var s = this.config.on, o = cm, a = s[o], l = a === void 0 ? [] : a, c = wC(s, [typeof o == "symbol" ? o : o + ""]);
      r = ci(Object.keys(c).map(function(C) {
        !xi && C === Pd && yr(!1, "Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. " + 'Please check the `on` configuration for "#'.concat(i.id, '".'));
        var M = _d(C, c[C]);
        return xi || Rte(i, C, M), M;
      }).concat(_d(cm, l)));
    }
    var d = this.config.always ? _d("", this.config.always) : [], p = this.config.onDone ? _d(String(T_(this.id)), this.config.onDone) : [];
    xi || yr(!(this.config.onDone && !this.parent), 'Root nodes cannot have an ".onDone" transition. Please check the config of "'.concat(this.id, '".'));
    var m = ci(this.invoke.map(function(C) {
      var M = [];
      return C.onDone && M.push.apply(M, $n([], fn(_d(String(ib(C.id)), C.onDone)), !1)), C.onError && M.push.apply(M, $n([], fn(_d(String(Mm(C.id)), C.onError)), !1)), M;
    })), v = this.after, b = ci($n($n($n($n([], fn(p), !1), fn(m), !1), fn(r), !1), fn(d), !1).map(function(C) {
      return Eo(C).map(function(M) {
        return i.formatTransition(M);
      });
    }));
    try {
      for (var x = cn(v), y = x.next(); !y.done; y = x.next()) {
        var S = y.value;
        b.push(S);
      }
    } catch (C) {
      e = {
        error: C
      };
    } finally {
      try {
        y && !y.done && (t = x.return) && t.call(x);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return b;
  }, n;
}(), k4 = !1;
function Lte(n, e) {
  return !xi && !n.predictableActionArguments && !k4 && (k4 = !0, console.warn("It is highly recommended to set `predictableActionArguments` to `true` when using `createMachine`. https://xstate.js.org/docs/guides/actions.html")), new kte(n, e);
}
const Dte = {
  ..._C,
  spineName: String,
  preset: String,
  strideForward: Number,
  strideRight: Number,
  strideMove: Boolean,
  strideMode: String
}, FO = yt(
  [bC],
  {
    spineName: void 0,
    preset: "default",
    strideForward: 0,
    strideRight: 0,
    strideMove: !1,
    strideMode: "aim",
    scale: 1.7,
    scaleX: 1.7,
    scaleY: 1.7,
    scaleZ: 1.7,
    width: 20,
    depth: 20,
    animation: "idle",
    src: P2
  },
  {
    strideForward: new dt(-10, 10),
    strideRight: new dt(-10, 10)
  }
), Ite = Lte({
  predictableActionArguments: !0,
  states: {
    idle: {
      on: {
        RUN_START: "running",
        RUN_BACKWARDS_START: "runningBackwards",
        JUMP_START: "jumping"
      }
    },
    running: {
      on: {
        RUN_STOP: "idle",
        RUN_BACKWARDS_START: "runningBackwards",
        JUMP_START: "jumping"
      }
    },
    runningBackwards: {
      on: {
        RUN_STOP: "idle",
        RUN_START: "running",
        JUMP_START: "jumping"
      }
    },
    jumping: {
      on: {
        JUMP_STOP: "idle"
      }
    }
  },
  initial: "idle"
});
class Zd extends gs {
  constructor() {
    super();
    V(this, "poseService", zO(Ite));
    V(this, "poseAnimationState", new Je(void 0));
    V(this, "animationState", new Je(void 0));
    V(this, "spineNameState", new Je(void 0));
    V(this, "srcState", new Je(P2));
    V(this, "animationsState", new Je({}));
    V(this, "presetState", new Je("default"));
    V(this, "strideForwardState", new Je(0));
    V(this, "strideRightState", new Je(0));
    V(this, "strideMoveState", new Je(!1));
    V(this, "strideModeState", new Je("aim"));
    V(this, "jumpHeight", 10);
    this.width = 20, this.depth = 20, this.scale = 1.7, this.createEffect(() => {
      var c;
      super.animation = (c = this.animationState.get()) != null ? c : this.poseAnimationState.get();
    }, [this.animationState.get, this.poseAnimationState.get]);
    const [t, i] = Be(void 0), [r, s] = Be(void 0);
    this.createEffect(() => {
      const c = this.spineNameState.get();
      super.src = this.srcState.get(), r(void 0), t(void 0);
      const d = this.loaded.then((p) => {
        if (t("other"), c) {
          r(this.find(c, !0)), c === "mixamorigSpine" ? t("mixamo") : c === "Spine" && (p.getObjectByName("Wolf3D_Body") || p.getObjectByName("Wolf3D_Avatar")) && t("readyplayerme");
          return;
        }
        if (p.getObjectByName("Wolf3D_Body") || p.getObjectByName("Wolf3D_Avatar")) {
          r(this.find("Spine", !0)), t("readyplayerme");
          return;
        }
        const m = this.find("mixamorigSpine", !0);
        r(m), m && t("mixamo");
      });
      return () => {
        d.cancel();
      };
    }, [this.srcState.get, this.spineNameState.get]);
    const [o, a] = Be("idle");
    this.createEffect(() => {
      const c = i();
      if (!c)
        return;
      const p = this.presetState.get() === "rifle" ? "rifle-" : "", m = this.srcState.get(), v = m.split("/");
      v.pop();
      let b = v.join("/") + "/";
      if (c === "readyplayerme")
        b = KD + "readyplayerme/";
      else if (m !== P2)
        return super.animations = this.animationsState.get(), this.poseAnimationState.set(a()), () => {
          this.poseAnimationState.set(void 0);
        };
      return super.animations = {
        idle: b + p + "idle.fbx",
        running: b + p + "running.fbx",
        runningBackwards: b + p + "running-backwards.fbx",
        jumping: b + p + "falling.fbx",
        death: b + "death.fbx",
        ...this.animationsState.get()
      }, this.poseAnimationState.set(a()), () => {
        this.poseAnimationState.set(void 0), super.animations = {};
      };
    }, [
      this.presetState.get,
      this.srcState.get,
      i,
      this.animationsState.get
    ]);
    const { poseService: l } = this;
    this.createEffect(() => {
      const c = a();
      if (this.poseAnimationState.set(c), c !== "jumping")
        return;
      ml() ? (Jn.set(this.velocity.x, this.jumpHeight, this.velocity.z), Jn.applyMatrix4(this.outerObject3d.matrixWorld), Object.assign(this.velocity, Jn.multiplyScalar(0.2))) : this.velocity.y = this.jumpHeight;
      const d = Pn(() => {
        this.velocity.y === 0 && l.send("JUMP_STOP");
      });
      return () => {
        d.cancel();
      };
    }, [a]), l.onTransition(
      (c) => c.changed && o(c.value)
    ).start(), this.then(() => l.stop()), this.createEffect(() => {
      const c = this.loadedGroup.children[0];
      if (!c)
        return;
      const { strideForward: d, strideRight: p, strideMove: m } = this;
      if (!d && !p) {
        l.send("RUN_STOP");
        return;
      }
      let v = this.strideModeState.get();
      v === "aim" && !("runningBackwards" in this.animations) && (v = "free");
      const b = v === "aim" ? d > 0 : !1, x = b ? -d : d, y = b ? p : -p, S = 90 - Math.atan2(-x, -y) * pl, C = s(), M = C == null ? void 0 : C.outerObject3d.quaternion.clone(), T = c.quaternion.clone(), P = II(() => {
        l.send(
          b ? "RUN_BACKWARDS_START" : "RUN_START"
        );
        const D = c.quaternion.clone();
        let I;
        v === "aim" && C && M && (c.quaternion.copy(T), C.outerObject3d.quaternion.copy(M), I = C.pointAt(1e3)), c.quaternion.setFromEuler(
          ui.set(0, S * Pi, 0)
        );
        const k = c.quaternion.clone();
        if (c.quaternion.copy(D).slerp(k, $u(0.2)), I && (C == null || C.lookAt(I)), !m)
          return;
        const { x: O, y: B } = xX(
          0,
          0,
          S + 90,
          Math.max(Math.abs(d), Math.abs(p))
        );
        this.moveForward(b ? B : -B), this.moveRight(b ? O : -O);
      });
      return () => {
        v === "aim" && !this.strideForward && !this.strideRight && c.quaternion.set(0, 0, 0, 0), P.cancel();
      };
    }, [
      this.animationsState.get,
      this.strideModeState.get,
      this.strideMoveState.get,
      this.strideForwardState.get,
      this.strideRightState.get,
      s
    ]);
  }
  get animation() {
    return this.animationState.get();
  }
  set animation(t) {
    this.animationState.set(t);
  }
  get spineName() {
    return this.spineNameState.get();
  }
  set spineName(t) {
    this.spineNameState.set(t);
  }
  get resize() {
    return super.resize;
  }
  set resize(t) {
  }
  get src() {
    return this.srcState.get();
  }
  set src(t) {
    this.srcState.set(t);
  }
  get animations() {
    return super.animations;
  }
  set animations(t) {
    this.animationsState.set(t);
  }
  get preset() {
    return this.presetState.get();
  }
  set preset(t) {
    this.presetState.set(t);
  }
  get strideForward() {
    return this.strideForwardState.get();
  }
  set strideForward(t) {
    this.strideForwardState.set(t);
  }
  get strideRight() {
    return this.strideRightState.get();
  }
  set strideRight(t) {
    this.strideRightState.set(t);
  }
  get strideMove() {
    return this.strideMoveState.get();
  }
  set strideMove(t) {
    this.strideMoveState.set(t);
  }
  get strideMode() {
    return this.strideModeState.get();
  }
  set strideMode(t) {
    this.strideModeState.set(t);
  }
  jump(t = 10) {
    this.jumpHeight = t, this.poseService.send("JUMP_START");
  }
}
V(Zd, "componentName", "dummy"), V(Zd, "defaults", FO), V(Zd, "schema", Dte);
const Ote = {
  ...Lc,
  preset: String,
  repeatX: Number,
  repeatZ: Number
}, Nte = yt(
  [Dc],
  {
    preset: "industrial0",
    repeatX: 1,
    repeatZ: 1
  }
), zte = {
  ...Ote,
  repeatY: Number
}, Fte = yt([Nte], {
  repeatY: 1
}), R_ = (n, e, t) => {
  const i = new gs();
  return i.src = n, i.rotationY = t, e.append(i), i;
}, k_ = (n, e, t, i, r, s) => {
  const o = t * n.length * 0.5 - e;
  let a = 0;
  if (s) {
    for (const l of n)
      l.z += e * i, l.x += a++ * t - o;
    return;
  }
  for (const l of n)
    l.x += e * r, l.z += a++ * t - o;
};
class Bte extends Sa {
  constructor(t) {
    super();
    V(this, "presetState", new Je("industrial0"));
    V(this, "repeatXState", new Je(1));
    V(this, "repeatZState", new Je(1));
    t.append(this), ko.add(this), this.createEffect(() => {
      const i = Math.max(Math.floor(this.repeatXState.get()), 1), r = Math.max(Math.floor(this.repeatZState.get()), 1), s = AX + this.presetState.get() + ".glb", o = lr.exports.range(i).map(() => R_(s, this, 0)), a = lr.exports.range(i).map(() => R_(s, this, 180)), l = lr.exports.range(r).map(() => R_(s, this, 90)), c = lr.exports.range(r).map(() => R_(s, this, 270)), d = o[0].loaded.then(() => {
        const p = o[0].depth, m = p * 0.5;
        k_(
          o,
          m,
          p,
          i,
          r,
          !1
        ), k_(
          a,
          -m,
          -p,
          i,
          r,
          !1
        ), k_(
          l,
          -m,
          -p,
          i,
          r,
          !0
        ), k_(
          c,
          m,
          p,
          i,
          r,
          !0
        );
      });
      return () => {
        d.cancel();
        for (const p of o)
          p.dispose();
        for (const p of a)
          p.dispose();
        for (const p of l)
          p.dispose();
        for (const p of c)
          p.dispose();
      };
    }, [this.presetState.get, this.repeatXState.get, this.repeatZState.get]);
  }
  get preset() {
    return this.presetState.get();
  }
  set preset(t) {
    this.presetState.set(t);
  }
  get repeatX() {
    return this.repeatXState.get();
  }
  set repeatX(t) {
    this.repeatXState.set(t);
  }
  get repeatZ() {
    return this.repeatZState.get();
  }
  set repeatZ(t) {
    this.repeatZState.set(t);
  }
}
class Fm extends Sa {
  constructor() {
    super();
    V(this, "presetState", new Je("industrial0"));
    V(this, "repeatXState", new Je(1));
    V(this, "repeatZState", new Je(1));
    V(this, "repeatYState", new Je(1));
    this.scale = 10, this.createEffect(() => {
      const t = this.presetState.get(), i = this.repeatXState.get(), r = this.repeatZState.get(), s = Math.max(Math.floor(this.repeatYState.get()), 1), o = lr.exports.range(s).map((a) => {
        const l = new Bte(this);
        return l.preset = t, l.repeatX = i, l.repeatZ = r, l.y = a * 100, l;
      });
      return () => {
        for (const a of o)
          a.dispose();
      };
    }, [
      this.presetState.get,
      this.repeatXState.get,
      this.repeatZState.get,
      this.repeatYState.get
    ]);
  }
  get preset() {
    return this.presetState.get();
  }
  set preset(t) {
    this.presetState.set(t);
  }
  get repeatX() {
    return this.repeatXState.get();
  }
  set repeatX(t) {
    this.repeatXState.set(t);
  }
  get repeatZ() {
    return this.repeatZState.get();
  }
  set repeatZ(t) {
    this.repeatZState.set(t);
  }
  get repeatY() {
    return this.repeatYState.get();
  }
  set repeatY(t) {
    this.repeatYState.set(t);
  }
}
V(Fm, "componentName", "building"), V(Fm, "defaults", Fte), V(Fm, "schema", zte);
const Ute = {
  ..._C,
  preset: String
}, Vte = yt([bC], {
  preset: "tree1",
  scale: 4
});
class Bm extends gs {
  constructor() {
    super();
    V(this, "_preset", "");
    this.scale = 4, this.preset = "tree1";
  }
  get preset() {
    return this._preset;
  }
  set preset(t) {
    this.src = RX + t + ".glb";
  }
}
V(Bm, "componentName", "tree"), V(Bm, "defaults", Vte), V(Bm, "schema", Ute);
const Hte = {
  ...dO,
  ...Vf,
  ...Nv,
  innerHTML: String
}, Gte = yt(
  [fO, Dv, Dy],
  { innerHTML: void 0 }
), Wte = /* @__PURE__ */ new WeakMap();
class zu extends jv {
  constructor() {
    super(...arguments);
    V(this, "_innerHTML");
  }
  get innerHTML() {
    return this._innerHTML;
  }
  set innerHTML(t) {
    this._innerHTML = t, this.loaded.done && this.loadedGroup.clear(), this.cancelHandle(
      "src",
      t && (() => SI(
        new Promise((i) => {
          R2(), import("./loadSVG.7b4fad1c.mjs").then(
            ({ loader: r }) => {
              Fd(), i(r.parse(t));
            }
          );
        })
      ).then((i) => {
        const r = this.resolveLoaded(i, t);
        this.loadedGroup.add(r), this.loaded.resolve(r), this.object3d.visible = !!this._boxVisible;
      }))
    );
  }
  async load(t) {
    R2();
    const i = await import("./loadSVG.7b4fad1c.mjs");
    let r;
    try {
      r = await i.default(t);
    } catch {
      throw Fd(), new Error("Failed to load svg, check if src is correct");
    }
    return Fd(), r;
  }
  resolveLoaded(t, i) {
    const r = new ul();
    r.scale.y *= -1;
    const s = Mr(Wte, t, () => {
      const a = [];
      for (const p of t.paths)
        for (const m of p.toShapes(!0))
          a.push(m);
      if (!a.length)
        return [];
      const l = new ul();
      for (const p of a) {
        const m = new Sb(p, {
          depth: 0,
          bevelEnabled: !1
        });
        m.dispose(), l.add(new wi(m));
      }
      const c = gC(l, i), d = [];
      for (const p of a)
        d.push(
          new Sb(p, {
            depth: c.y,
            bevelEnabled: !1
          })
        );
      return d;
    });
    for (const a of s) {
      const l = new wi(a, this.getMaterial().nativeMaterial);
      l.castShadow = !0, l.receiveShadow = !0, r.add(l);
    }
    const o = hO(r, i);
    return !this.widthSet && (this.object3d.scale.x = o.x), !this.heightSet && (this.object3d.scale.y = o.y), !this.depthSet && (this.object3d.scale.z = o.z), r;
  }
  getMaterial() {
    return zv(
      this.nativeObject3d,
      this,
      void 0,
      void 0,
      void 0,
      _5
    )[0];
  }
}
V(zu, "componentName", "svgMesh"), V(zu, "defaults", Gte), V(zu, "schema", Hte);
th(zu, [LE, yl]);
const jte = {
  ...Lc,
  element: Object,
  innerHTML: String,
  cssColor: String,
  sprite: Boolean
};
ya(["element"]);
const qte = yt(
  [Dc],
  {
    element: void 0,
    innerHTML: void 0,
    cssColor: "#ffffff",
    sprite: !1
  }
);
class Yd extends Us {
  constructor(e) {
    super(e), ko.add(this), this.opacity = 0.5, this.castShadow = !1, this.receiveShadow = !1;
  }
}
V(Yd, "componentName", "helper"), V(Yd, "defaults", Bv), V(Yd, "schema", Fv);
class Xte extends Yd {
  constructor() {
    super(iC), this.wireframe = !0, this.emissive = !0, this.opacity = 1;
  }
}
const $te = oo(`
    <div style="position: absolute; visibility: hidden; pointer-events: none;"></div>
`);
class Kd extends Sa {
  constructor() {
    super();
    V(this, "elementState", new Je(void 0));
    V(this, "innerHTMLState", new Je(void 0));
    V(this, "spriteState", new Je(!1));
    V(this, "cssColorState", new Je("#ffffff"));
    this.createEffect(() => {
      let t = this.elementState.get();
      const i = this.innerHTMLState.get();
      if (!t && i && (t = oo(
        i.startsWith("<") ? i : `<div>${i}</div>`
      )), !t) {
        const o = new Xte(), a = ph(o, this);
        return () => {
          o.dispose(), a.cancel();
        };
      }
      const r = $te.cloneNode();
      document.body.appendChild(r), r.appendChild(t);
      const s = new Xn();
      return import("./HTMLMesh.1110f918.mjs").then(({ HTMLMesh: o, HTMLSprite: a }) => {
        if (s.done)
          return;
        const l = this.spriteState.get() ? new a(t) : new o(t);
        this.object3d.add(l), Ds(l, this), s.watch(
          this.cssColorState.get((c) => {
            r.style.color = c, l.update();
          })
        ), s.then(() => {
          this.object3d.remove(l), l.dispose();
        });
      }), () => {
        r.remove(), s.cancel();
      };
    }, [
      this.elementState.get,
      this.spriteState.get,
      this.innerHTMLState.get
    ]);
  }
  get element() {
    return this.elementState.get();
  }
  set element(t) {
    this.elementState.set(t);
  }
  get innerHTML() {
    return this.innerHTMLState.get();
  }
  set innerHTML(t) {
    this.innerHTMLState.set(t);
  }
  get sprite() {
    return this.spriteState.get();
  }
  set sprite(t) {
    this.spriteState.set(t);
  }
  get cssColor() {
    return this.cssColorState.get();
  }
  set cssColor(t) {
    this.cssColorState.set(t);
  }
}
V(Kd, "componentName", "htmlMesh"), V(Kd, "defaults", qte), V(Kd, "schema", jte);
const sb = (n, e) => {
  const t = e.x - n.x, i = e.y - n.y;
  return Math.sqrt(t * t + i * i);
}, Zte = (n, e) => {
  const t = e.x - n.x, i = e.y - n.y;
  return Kte(Math.atan2(i, t));
}, Yte = (n, e, t) => {
  const i = { x: 0, y: 0 };
  return t = TM(t), i.x = n.x - e * Math.cos(t), i.y = n.y - e * Math.sin(t), i;
}, TM = (n) => n * (Math.PI / 180), Kte = (n) => n * (180 / Math.PI), Jte = (n) => isNaN(n.buttons) ? n.pressure !== 0 : n.buttons !== 0, LS = /* @__PURE__ */ new Map(), L4 = (n) => {
  LS.has(n) && clearTimeout(LS.get(n)), LS.set(n, setTimeout(n, 100));
}, Xb = (n, e, t) => {
  const i = e.split(/[ ,]+/g);
  let r;
  for (let s = 0; s < i.length; s += 1)
    r = i[s], n.addEventListener ? n.addEventListener(r, t, !1) : n.attachEvent && n.attachEvent(r, t);
}, D4 = (n, e, t) => {
  const i = e.split(/[ ,]+/g);
  let r;
  for (let s = 0; s < i.length; s += 1)
    r = i[s], n.removeEventListener ? n.removeEventListener(r, t) : n.detachEvent && n.detachEvent(r, t);
}, BO = (n) => (n.preventDefault(), n.type.match(/^touch/) ? n.changedTouches : n), I4 = () => {
  const n = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft, e = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
  return {
    x: n,
    y: e
  };
}, O4 = (n, e) => {
  e.top || e.right || e.bottom || e.left ? (n.style.top = e.top, n.style.right = e.right, n.style.bottom = e.bottom, n.style.left = e.left) : (n.style.left = e.x + "px", n.style.top = e.y + "px");
}, PC = (n, e, t) => {
  const i = UO(n);
  for (let r in i)
    if (i.hasOwnProperty(r))
      if (typeof e == "string")
        i[r] = e + " " + t;
      else {
        let s = "";
        for (let o = 0, a = e.length; o < a; o += 1)
          s += e[o] + " " + t + ", ";
        i[r] = s.slice(0, -2);
      }
  return i;
}, Qte = (n, e) => {
  const t = UO(n);
  for (let i in t)
    t.hasOwnProperty(i) && (t[i] = e);
  return t;
}, UO = (n) => {
  const e = {};
  return e[n] = "", ["webkit", "Moz", "o"].forEach(function(i) {
    e[i + n.charAt(0).toUpperCase() + n.slice(1)] = "";
  }), e;
}, DS = (n, e) => {
  for (let t in e)
    e.hasOwnProperty(t) && (n[t] = e[t]);
  return n;
}, ene = (n, e) => {
  const t = {};
  for (let i in n)
    n.hasOwnProperty(i) && e.hasOwnProperty(i) ? t[i] = e[i] : n.hasOwnProperty(i) && (t[i] = n[i]);
  return t;
}, PM = (n, e) => {
  if (n.length)
    for (let t = 0, i = n.length; t < i; t += 1)
      e(n[t]);
  else
    e(n);
}, tne = (n, e, t) => ({
  x: Math.min(Math.max(n.x, e.x - t), e.x + t),
  y: Math.min(Math.max(n.y, e.y - t), e.y + t)
});
var nne = "ontouchstart" in window, ine = !!window.PointerEvent, rne = !!window.MSPointerEvent, um = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    end: "touchend, touchcancel"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    end: "mouseup"
  },
  pointer: {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup, pointercancel"
  },
  MSPointer: {
    start: "MSPointerDown",
    move: "MSPointerMove",
    end: "MSPointerUp"
  }
}, Od, gv = {};
ine ? Od = um.pointer : rne ? Od = um.MSPointer : nne ? (Od = um.touch, gv = um.mouse) : Od = um.mouse;
function xl() {
}
xl.prototype.on = function(n, e) {
  var t = this, i = n.split(/[ ,]+/g), r;
  t._handlers_ = t._handlers_ || {};
  for (var s = 0; s < i.length; s += 1)
    r = i[s], t._handlers_[r] = t._handlers_[r] || [], t._handlers_[r].push(e);
  return t;
};
xl.prototype.off = function(n, e) {
  var t = this;
  return t._handlers_ = t._handlers_ || {}, n === void 0 ? t._handlers_ = {} : e === void 0 ? t._handlers_[n] = null : t._handlers_[n] && t._handlers_[n].indexOf(e) >= 0 && t._handlers_[n].splice(t._handlers_[n].indexOf(e), 1), t;
};
xl.prototype.trigger = function(n, e) {
  var t = this, i = n.split(/[ ,]+/g), r;
  t._handlers_ = t._handlers_ || {};
  for (var s = 0; s < i.length; s += 1)
    r = i[s], t._handlers_[r] && t._handlers_[r].length && t._handlers_[r].forEach(function(o) {
      o.call(t, {
        type: r,
        target: t
      }, e);
    });
};
xl.prototype.config = function(n) {
  var e = this;
  e.options = e.defaults || {}, n && (e.options = ene(e.options, n));
};
xl.prototype.bindEvt = function(n, e) {
  var t = this;
  return t._domHandlers_ = t._domHandlers_ || {}, t._domHandlers_[e] = function() {
    typeof t["on" + e] == "function" ? t["on" + e].apply(t, arguments) : console.warn('[WARNING] : Missing "on' + e + '" handler.');
  }, Xb(n, Od[e], t._domHandlers_[e]), gv[e] && Xb(n, gv[e], t._domHandlers_[e]), t;
};
xl.prototype.unbindEvt = function(n, e) {
  var t = this;
  return t._domHandlers_ = t._domHandlers_ || {}, D4(n, Od[e], t._domHandlers_[e]), gv[e] && D4(n, gv[e], t._domHandlers_[e]), delete t._domHandlers_[e], this;
};
function Xi(n, e) {
  return this.identifier = e.identifier, this.position = e.position, this.frontPosition = e.frontPosition, this.collection = n, this.defaults = {
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: !1,
    restJoystick: !0,
    restOpacity: 0.5,
    mode: "dynamic",
    zone: document.body,
    lockX: !1,
    lockY: !1,
    shape: "circle"
  }, this.config(e), this.options.mode === "dynamic" && (this.options.restOpacity = 0), this.id = Xi.id, Xi.id += 1, this.buildEl().stylize(), this.instance = {
    el: this.ui.el,
    on: this.on.bind(this),
    off: this.off.bind(this),
    show: this.show.bind(this),
    hide: this.hide.bind(this),
    add: this.addToDom.bind(this),
    remove: this.removeFromDom.bind(this),
    destroy: this.destroy.bind(this),
    setPosition: this.setPosition.bind(this),
    resetDirection: this.resetDirection.bind(this),
    computeDirection: this.computeDirection.bind(this),
    trigger: this.trigger.bind(this),
    position: this.position,
    frontPosition: this.frontPosition,
    ui: this.ui,
    identifier: this.identifier,
    id: this.id,
    options: this.options
  }, this.instance;
}
Xi.prototype = new xl();
Xi.constructor = Xi;
Xi.id = 0;
Xi.prototype.buildEl = function(n) {
  return this.ui = {}, this.options.dataOnly ? this : (this.ui.el = document.createElement("div"), this.ui.back = document.createElement("div"), this.ui.front = document.createElement("div"), this.ui.el.className = "nipple collection_" + this.collection.id, this.ui.back.className = "back", this.ui.front.className = "front", this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id), this.ui.el.appendChild(this.ui.back), this.ui.el.appendChild(this.ui.front), this);
};
Xi.prototype.stylize = function() {
  if (this.options.dataOnly)
    return this;
  var n = this.options.fadeTime + "ms", e = Qte("borderRadius", "50%"), t = PC("transition", "opacity", n), i = {};
  return i.el = {
    position: "absolute",
    opacity: this.options.restOpacity,
    display: "block",
    zIndex: 999
  }, i.back = {
    position: "absolute",
    display: "block",
    width: this.options.size + "px",
    height: this.options.size + "px",
    marginLeft: -this.options.size / 2 + "px",
    marginTop: -this.options.size / 2 + "px",
    background: this.options.color,
    opacity: ".5"
  }, i.front = {
    width: this.options.size / 2 + "px",
    height: this.options.size / 2 + "px",
    position: "absolute",
    display: "block",
    marginLeft: -this.options.size / 4 + "px",
    marginTop: -this.options.size / 4 + "px",
    background: this.options.color,
    opacity: ".5",
    transform: "translate(0px, 0px)"
  }, DS(i.el, t), this.options.shape === "circle" && DS(i.back, e), DS(i.front, e), this.applyStyles(i), this;
};
Xi.prototype.applyStyles = function(n) {
  for (var e in this.ui)
    if (this.ui.hasOwnProperty(e))
      for (var t in n[e])
        this.ui[e].style[t] = n[e][t];
  return this;
};
Xi.prototype.addToDom = function() {
  return this.options.dataOnly || document.body.contains(this.ui.el) ? this : (this.options.zone.appendChild(this.ui.el), this);
};
Xi.prototype.removeFromDom = function() {
  return this.options.dataOnly || !document.body.contains(this.ui.el) ? this : (this.options.zone.removeChild(this.ui.el), this);
};
Xi.prototype.destroy = function() {
  clearTimeout(this.removeTimeout), clearTimeout(this.showTimeout), clearTimeout(this.restTimeout), this.trigger("destroyed", this.instance), this.removeFromDom(), this.off();
};
Xi.prototype.show = function(n) {
  var e = this;
  return e.options.dataOnly || (clearTimeout(e.removeTimeout), clearTimeout(e.showTimeout), clearTimeout(e.restTimeout), e.addToDom(), e.restCallback(), setTimeout(function() {
    e.ui.el.style.opacity = 1;
  }, 0), e.showTimeout = setTimeout(function() {
    e.trigger("shown", e.instance), typeof n == "function" && n.call(this);
  }, e.options.fadeTime)), e;
};
Xi.prototype.hide = function(n) {
  var e = this;
  if (e.options.dataOnly)
    return e;
  if (e.ui.el.style.opacity = e.options.restOpacity, clearTimeout(e.removeTimeout), clearTimeout(e.showTimeout), clearTimeout(e.restTimeout), e.removeTimeout = setTimeout(
    function() {
      var t = e.options.mode === "dynamic" ? "none" : "block";
      e.ui.el.style.display = t, typeof n == "function" && n.call(e), e.trigger("hidden", e.instance);
    },
    e.options.fadeTime
  ), e.options.restJoystick) {
    const t = e.options.restJoystick, i = {};
    i.x = t === !0 || t.x !== !1 ? 0 : e.instance.frontPosition.x, i.y = t === !0 || t.y !== !1 ? 0 : e.instance.frontPosition.y, e.setPosition(n, i);
  }
  return e;
};
Xi.prototype.setPosition = function(n, e) {
  var t = this;
  t.frontPosition = {
    x: e.x,
    y: e.y
  };
  var i = t.options.fadeTime + "ms", r = {};
  r.front = PC(
    "transition",
    ["transform"],
    i
  );
  var s = { front: {} };
  s.front = {
    transform: "translate(" + t.frontPosition.x + "px," + t.frontPosition.y + "px)"
  }, t.applyStyles(r), t.applyStyles(s), t.restTimeout = setTimeout(
    function() {
      typeof n == "function" && n.call(t), t.restCallback();
    },
    t.options.fadeTime
  );
};
Xi.prototype.restCallback = function() {
  var n = this, e = {};
  e.front = PC("transition", "none", ""), n.applyStyles(e), n.trigger("rested", n.instance);
};
Xi.prototype.resetDirection = function() {
  this.direction = {
    x: !1,
    y: !1,
    angle: !1
  };
};
Xi.prototype.computeDirection = function(n) {
  var e = n.angle.radian, t = Math.PI / 4, i = Math.PI / 2, r, s, o;
  if (e > t && e < t * 3 && !n.lockX ? r = "up" : e > -t && e <= t && !n.lockY ? r = "left" : e > -t * 3 && e <= -t && !n.lockX ? r = "down" : n.lockY || (r = "right"), n.lockY || (e > -i && e < i ? s = "left" : s = "right"), n.lockX || (e > 0 ? o = "up" : o = "down"), n.force > this.options.threshold) {
    var a = {}, l;
    for (l in this.direction)
      this.direction.hasOwnProperty(l) && (a[l] = this.direction[l]);
    var c = {};
    this.direction = {
      x: s,
      y: o,
      angle: r
    }, n.direction = this.direction;
    for (l in a)
      a[l] === this.direction[l] && (c[l] = !0);
    if (c.x && c.y && c.angle)
      return n;
    (!c.x || !c.y) && this.trigger("plain", n), c.x || this.trigger("plain:" + s, n), c.y || this.trigger("plain:" + o, n), c.angle || this.trigger("dir dir:" + r, n);
  } else
    this.resetDirection();
  return n;
};
function Ei(n, e) {
  var t = this;
  t.nipples = [], t.idles = [], t.actives = [], t.ids = [], t.pressureIntervals = {}, t.manager = n, t.id = Ei.id, Ei.id += 1, t.defaults = {
    zone: document.body,
    multitouch: !1,
    maxNumberOfNipples: 10,
    mode: "dynamic",
    position: { top: 0, left: 0 },
    catchDistance: 200,
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: !1,
    restJoystick: !0,
    restOpacity: 0.5,
    lockX: !1,
    lockY: !1,
    shape: "circle",
    dynamicPage: !1,
    follow: !1
  }, t.config(e), (t.options.mode === "static" || t.options.mode === "semi") && (t.options.multitouch = !1), t.options.multitouch || (t.options.maxNumberOfNipples = 1);
  const i = getComputedStyle(t.options.zone.parentElement);
  return i && i.display === "flex" && (t.parentIsFlex = !0), t.updateBox(), t.prepareNipples(), t.bindings(), t.begin(), t.nipples;
}
Ei.prototype = new xl();
Ei.constructor = Ei;
Ei.id = 0;
Ei.prototype.prepareNipples = function() {
  var n = this, e = n.nipples;
  e.on = n.on.bind(n), e.off = n.off.bind(n), e.options = n.options, e.destroy = n.destroy.bind(n), e.ids = n.ids, e.id = n.id, e.processOnMove = n.processOnMove.bind(n), e.processOnEnd = n.processOnEnd.bind(n), e.get = function(t) {
    if (t === void 0)
      return e[0];
    for (var i = 0, r = e.length; i < r; i += 1)
      if (e[i].identifier === t)
        return e[i];
    return !1;
  };
};
Ei.prototype.bindings = function() {
  var n = this;
  n.bindEvt(n.options.zone, "start"), n.options.zone.style.touchAction = "none", n.options.zone.style.msTouchAction = "none";
};
Ei.prototype.begin = function() {
  var n = this, e = n.options;
  if (e.mode === "static") {
    var t = n.createNipple(
      e.position,
      n.manager.getIdentifier()
    );
    t.add(), n.idles.push(t);
  }
};
Ei.prototype.createNipple = function(n, e) {
  var t = this, i = t.manager.scroll, r = {}, s = t.options, o = {
    x: t.parentIsFlex ? i.x : i.x + t.box.left,
    y: t.parentIsFlex ? i.y : i.y + t.box.top
  };
  if (n.x && n.y)
    r = {
      x: n.x - o.x,
      y: n.y - o.y
    };
  else if (n.top || n.right || n.bottom || n.left) {
    var a = document.createElement("DIV");
    a.style.display = "hidden", a.style.top = n.top, a.style.right = n.right, a.style.bottom = n.bottom, a.style.left = n.left, a.style.position = "absolute", s.zone.appendChild(a);
    var l = a.getBoundingClientRect();
    s.zone.removeChild(a), r = n, n = {
      x: l.left + i.x,
      y: l.top + i.y
    };
  }
  var c = new Xi(t, {
    color: s.color,
    size: s.size,
    threshold: s.threshold,
    fadeTime: s.fadeTime,
    dataOnly: s.dataOnly,
    restJoystick: s.restJoystick,
    restOpacity: s.restOpacity,
    mode: s.mode,
    identifier: e,
    position: n,
    zone: s.zone,
    frontPosition: {
      x: 0,
      y: 0
    },
    shape: s.shape
  });
  return s.dataOnly || (O4(c.ui.el, r), O4(c.ui.front, c.frontPosition)), t.nipples.push(c), t.trigger("added " + c.identifier + ":added", c), t.manager.trigger("added " + c.identifier + ":added", c), t.bindNipple(c), c;
};
Ei.prototype.updateBox = function() {
  var n = this;
  n.box = n.options.zone.getBoundingClientRect();
};
Ei.prototype.bindNipple = function(n) {
  var e = this, t, i = function(r, s) {
    t = r.type + " " + s.id + ":" + r.type, e.trigger(t, s);
  };
  n.on("destroyed", e.onDestroyed.bind(e)), n.on("shown hidden rested dir plain", i), n.on("dir:up dir:right dir:down dir:left", i), n.on("plain:up plain:right plain:down plain:left", i);
};
Ei.prototype.pressureFn = function(n, e, t) {
  var i = this, r = 0;
  clearInterval(i.pressureIntervals[t]), i.pressureIntervals[t] = setInterval(function() {
    var s = n.force || n.pressure || n.webkitForce || 0;
    s !== r && (e.trigger("pressure", s), i.trigger("pressure " + e.identifier + ":pressure", s), r = s);
  }.bind(i), 100);
};
Ei.prototype.onstart = function(n) {
  var e = this, t = e.options, i = n;
  n = BO(n), e.updateBox();
  var r = function(s) {
    e.actives.length < t.maxNumberOfNipples ? e.processOnStart(s) : i.type.match(/^touch/) && (Object.keys(e.manager.ids).forEach(function(o) {
      if (Object.values(i.touches).findIndex(function(l) {
        return l.identifier === o;
      }) < 0) {
        var a = [n[0]];
        a.identifier = o, e.processOnEnd(a);
      }
    }), e.actives.length < t.maxNumberOfNipples && e.processOnStart(s));
  };
  return PM(n, r), e.manager.bindDocument(), !1;
};
Ei.prototype.processOnStart = function(n) {
  var e = this, t = e.options, i, r = e.manager.getIdentifier(n), s = n.force || n.pressure || n.webkitForce || 0, o = {
    x: n.pageX,
    y: n.pageY
  }, a = e.getOrCreate(r, o);
  a.identifier !== r && e.manager.removeIdentifier(a.identifier), a.identifier = r;
  var l = function(d) {
    d.trigger("start", d), e.trigger("start " + d.id + ":start", d), d.show(), s > 0 && e.pressureFn(n, d, d.identifier), e.processOnMove(n);
  };
  if ((i = e.idles.indexOf(a)) >= 0 && e.idles.splice(i, 1), e.actives.push(a), e.ids.push(a.identifier), t.mode !== "semi")
    l(a);
  else {
    var c = sb(o, a.position);
    if (c <= t.catchDistance)
      l(a);
    else {
      a.destroy(), e.processOnStart(n);
      return;
    }
  }
  return a;
};
Ei.prototype.getOrCreate = function(n, e) {
  var t = this, i = t.options, r;
  return /(semi|static)/.test(i.mode) ? (r = t.idles[0], r ? (t.idles.splice(0, 1), r) : i.mode === "semi" ? t.createNipple(e, n) : (console.warn("Coudln't find the needed nipple."), !1)) : (r = t.createNipple(e, n), r);
};
Ei.prototype.processOnMove = function(n) {
  var e = this, t = e.options, i = e.manager.getIdentifier(n), r = e.nipples.get(i), s = e.manager.scroll;
  if (!Jte(n)) {
    this.processOnEnd(n);
    return;
  }
  if (!r) {
    console.error("Found zombie joystick with ID " + i), e.manager.removeIdentifier(i);
    return;
  }
  if (t.dynamicPage) {
    var o = r.el.getBoundingClientRect();
    r.position = {
      x: s.x + o.left,
      y: s.y + o.top
    };
  }
  r.identifier = i;
  var a = r.options.size / 2, l = {
    x: n.pageX,
    y: n.pageY
  };
  t.lockX && (l.y = r.position.y), t.lockY && (l.x = r.position.x);
  var c = sb(l, r.position), d = Zte(l, r.position), p = TM(d), m = c / a, v = {
    distance: c,
    position: l
  }, b, x;
  if (r.options.shape === "circle" ? (b = Math.min(c, a), x = Yte(r.position, b, d)) : (x = tne(l, r.position, a), b = sb(x, r.position)), t.follow) {
    if (c > a) {
      let M = l.x - x.x, T = l.y - x.y;
      r.position.x += M, r.position.y += T, r.el.style.top = r.position.y - (e.box.top + s.y) + "px", r.el.style.left = r.position.x - (e.box.left + s.x) + "px", c = sb(l, r.position);
    }
  } else
    l = x, c = b;
  var y = l.x - r.position.x, S = l.y - r.position.y;
  r.frontPosition = {
    x: y,
    y: S
  }, t.dataOnly || (r.ui.front.style.transform = "translate(" + y + "px," + S + "px)");
  var C = {
    identifier: r.identifier,
    position: l,
    force: m,
    pressure: n.force || n.pressure || n.webkitForce || 0,
    distance: c,
    angle: {
      radian: p,
      degree: d
    },
    vector: {
      x: y / a,
      y: -S / a
    },
    raw: v,
    instance: r,
    lockX: t.lockX,
    lockY: t.lockY
  };
  C = r.computeDirection(C), C.angle = {
    radian: TM(180 - d),
    degree: 180 - d
  }, r.trigger("move", C), e.trigger("move " + r.id + ":move", C);
};
Ei.prototype.processOnEnd = function(n) {
  var e = this, t = e.options, i = e.manager.getIdentifier(n), r = e.nipples.get(i), s = e.manager.removeIdentifier(r.identifier);
  !r || (t.dataOnly || r.hide(function() {
    t.mode === "dynamic" && (r.trigger("removed", r), e.trigger("removed " + r.id + ":removed", r), e.manager.trigger("removed " + r.id + ":removed", r), r.destroy());
  }), clearInterval(e.pressureIntervals[r.identifier]), r.resetDirection(), r.trigger("end", r), e.trigger("end " + r.id + ":end", r), e.ids.indexOf(r.identifier) >= 0 && e.ids.splice(e.ids.indexOf(r.identifier), 1), e.actives.indexOf(r) >= 0 && e.actives.splice(e.actives.indexOf(r), 1), /(semi|static)/.test(t.mode) ? e.idles.push(r) : e.nipples.indexOf(r) >= 0 && e.nipples.splice(e.nipples.indexOf(r), 1), e.manager.unbindDocument(), /(semi|static)/.test(t.mode) && (e.manager.ids[s.id] = s.identifier));
};
Ei.prototype.onDestroyed = function(n, e) {
  var t = this;
  t.nipples.indexOf(e) >= 0 && t.nipples.splice(t.nipples.indexOf(e), 1), t.actives.indexOf(e) >= 0 && t.actives.splice(t.actives.indexOf(e), 1), t.idles.indexOf(e) >= 0 && t.idles.splice(t.idles.indexOf(e), 1), t.ids.indexOf(e.identifier) >= 0 && t.ids.splice(t.ids.indexOf(e.identifier), 1), t.manager.removeIdentifier(e.identifier), t.manager.unbindDocument();
};
Ei.prototype.destroy = function() {
  var n = this;
  n.unbindEvt(n.options.zone, "start"), n.nipples.forEach(function(t) {
    t.destroy();
  });
  for (var e in n.pressureIntervals)
    n.pressureIntervals.hasOwnProperty(e) && clearInterval(n.pressureIntervals[e]);
  n.trigger("destroyed", n.nipples), n.manager.unbindDocument(), n.off();
};
function fr(n) {
  var e = this;
  e.ids = {}, e.index = 0, e.collections = [], e.scroll = I4(), e.config(n), e.prepareCollections();
  var t = function() {
    var r;
    e.collections.forEach(function(s) {
      s.forEach(function(o) {
        r = o.el.getBoundingClientRect(), o.position = {
          x: e.scroll.x + r.left,
          y: e.scroll.y + r.top
        };
      });
    });
  };
  Xb(window, "resize", function() {
    L4(t);
  });
  var i = function() {
    e.scroll = I4();
  };
  return Xb(window, "scroll", function() {
    L4(i);
  }), e.collections;
}
fr.prototype = new xl();
fr.constructor = fr;
fr.prototype.prepareCollections = function() {
  var n = this;
  n.collections.create = n.create.bind(n), n.collections.on = n.on.bind(n), n.collections.off = n.off.bind(n), n.collections.destroy = n.destroy.bind(n), n.collections.get = function(e) {
    var t;
    return n.collections.every(function(i) {
      return t = i.get(e), !t;
    }), t;
  };
};
fr.prototype.create = function(n) {
  return this.createCollection(n);
};
fr.prototype.createCollection = function(n) {
  var e = this, t = new Ei(e, n);
  return e.bindCollection(t), e.collections.push(t), t;
};
fr.prototype.bindCollection = function(n) {
  var e = this, t, i = function(r, s) {
    t = r.type + " " + s.id + ":" + r.type, e.trigger(t, s);
  };
  n.on("destroyed", e.onDestroyed.bind(e)), n.on("shown hidden rested dir plain", i), n.on("dir:up dir:right dir:down dir:left", i), n.on("plain:up plain:right plain:down plain:left", i);
};
fr.prototype.bindDocument = function() {
  var n = this;
  n.binded || (n.bindEvt(document, "move").bindEvt(document, "end"), n.binded = !0);
};
fr.prototype.unbindDocument = function(n) {
  var e = this;
  (!Object.keys(e.ids).length || n === !0) && (e.unbindEvt(document, "move").unbindEvt(document, "end"), e.binded = !1);
};
fr.prototype.getIdentifier = function(n) {
  var e;
  return n ? (e = n.identifier === void 0 ? n.pointerId : n.identifier, e === void 0 && (e = this.latest || 0)) : e = this.index, this.ids[e] === void 0 && (this.ids[e] = this.index, this.index += 1), this.latest = e, this.ids[e];
};
fr.prototype.removeIdentifier = function(n) {
  var e = {};
  for (var t in this.ids)
    if (this.ids[t] === n) {
      e.id = t, e.identifier = this.ids[t], delete this.ids[t];
      break;
    }
  return e;
};
fr.prototype.onmove = function(n) {
  var e = this;
  return e.onAny("move", n), !1;
};
fr.prototype.onend = function(n) {
  var e = this;
  return e.onAny("end", n), !1;
};
fr.prototype.oncancel = function(n) {
  var e = this;
  return e.onAny("end", n), !1;
};
fr.prototype.onAny = function(n, e) {
  var t = this, i, r = "processOn" + n.charAt(0).toUpperCase() + n.slice(1);
  e = BO(e);
  var s = function(a, l, c) {
    c.ids.indexOf(l) >= 0 && (c[r](a), a._found_ = !0);
  }, o = function(a) {
    i = t.getIdentifier(a), PM(t.collections, s.bind(null, a, i)), a._found_ || t.removeIdentifier(i);
  };
  return PM(e, o), !1;
};
fr.prototype.destroy = function() {
  var n = this;
  n.unbindDocument(!0), n.ids = {}, n.index = 0, n.collections.forEach(function(e) {
    e.destroy();
  }), n.off();
};
fr.prototype.onDestroyed = function(n, e) {
  var t = this;
  if (t.collections.indexOf(e) < 0)
    return !1;
  t.collections.splice(t.collections.indexOf(e), 1);
};
const N4 = new fr(), sne = {
  create: function(n) {
    return N4.create(n);
  },
  factory: N4
}, one = {
  ..._s,
  onMove: Function,
  onMoveStart: Function,
  onMoveEnd: Function,
  onPress: Function
}, ane = yt(
  [bs],
  {
    onMove: void 0,
    onMoveStart: void 0,
    onMoveEnd: void 0,
    onPress: void 0
  }
);
class Jd extends Ii {
  constructor() {
    super();
    V(this, "onMove");
    V(this, "onMoveStart");
    V(this, "onMoveEnd");
    V(this, "onPressState", new Je(void 0));
    let t = new Is(0, 0);
    const [i, r] = Be(!1);
    this.createEffect(() => {
      const s = this.onPressState.get();
      if (!s || !r())
        return;
      const o = Pn(() => {
        s(t);
      });
      return () => o.cancel();
    }, [this.onPressState.get, r]), this.createEffect(() => {
      const s = oo(`
                <div style="width: 150px; height: 150px; transform: scale(3); position: absolute; bottom: 85px; left: 85px;"></div>
            `);
      wa.appendChild(s);
      const o = (l) => {
        l.preventDefault(), l.stopPropagation();
      };
      s.onmousedown = o, s.ontouchstart = o, s.onpointerdown = o;
      const a = new Xn();
      return setTimeout(() => {
        if (a.done)
          return;
        const l = sne.create({
          zone: s,
          mode: "static",
          position: { left: "75px", bottom: "75px" },
          color: "white"
        });
        a.then(() => l.destroy()), l.on("start", () => {
          var c;
          (c = this.onMoveStart) == null || c.call(this, new Is(0, 0)), i(!0);
        }), l.on("move", (c, d) => {
          var p;
          (p = this.onMove) == null || p.call(this, d.vector), t = d.vector;
        }), l.on("end", () => {
          var c;
          (c = this.onMoveEnd) == null || c.call(this, new Is(0, 0)), t = new Is(0, 0), i(!1);
        });
      }), () => {
        a.cancel(), s.remove();
      };
    }, []);
  }
  get onPress() {
    return this.onPressState.get();
  }
  set onPress(t) {
    this.onPressState.set(t);
  }
}
V(Jd, "componentName", "joystick"), V(Jd, "defaults", ane), V(Jd, "schema", one);
const lne = {
  ..._s,
  variant: Number
}, cne = yt(
  [bs],
  { variant: 1 },
  { variant: new Cf({ 1: 1, 2: 2, 3: 3, 4: 4 }) }
);
class Qd extends Ii {
  constructor() {
    super();
    V(this, "variantState", new Je(1));
    this.createEffect(() => {
      const t = this.variantState.get(), i = oo(`
                <img
                  src="${TE}reticle${t}.png"
                  style="position: absolute; left: 50%; top: -1%; transform: translate(-50%, -50%); pointer-events: none; user-select: none; width: 20px;"
                ></img>
            `);
      return wa.appendChild(i), () => {
        i.remove();
      };
    }, [this.variantState.get]);
  }
  get variant() {
    return this.variantState.get();
  }
  set variant(t) {
    this.variantState.set(t);
  }
}
V(Qd, "componentName", "reticle"), V(Qd, "defaults", cne), V(Qd, "schema", lne);
const une = {
  ..._s,
  opacity: Number,
  textCenter: Boolean
}, hne = yt(
  [bs],
  { opacity: 1, textCenter: !1 },
  { opacity: new dt(0, 1) }
);
let z4 = !1;
const dne = () => {
  if (z4)
    return;
  z4 = !0;
  const n = oo(`
        <style>
            .lingo3d-splashscreen {
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                color: white;
                background: black;
            }
        </style>
    `);
  document.head.appendChild(n);
};
class Um extends Ii {
  constructor() {
    super();
    V(this, "splashScreen", oo(
      '<div class="lingo3d-splashscreen" style="opacity: 1"></div>'
    ));
    V(this, "textContainer", document.createElement("div"));
    dne(), wa.appendChild(this.splashScreen), this.splashScreen.appendChild(this.textContainer), this.then(() => this.splashScreen.remove());
  }
  get opacity() {
    return Number(this.splashScreen.style.opacity);
  }
  set opacity(t) {
    this.splashScreen.style.opacity = t + "";
  }
  get textCenter() {
    return this.textContainer.style.textAlign === "center";
  }
  set textCenter(t) {
    this.textContainer.style.textAlign = t ? "center" : "";
  }
  append(t) {
    this._append(t), this.textContainer.appendChild(Sf(t, "el"));
  }
  attach(t) {
    this.append(t);
  }
}
V(Um, "componentName", "splashScreen"), V(Um, "defaults", hne), V(Um, "schema", une);
const fne = {
  ..._s,
  value: String,
  opacity: Number
}, pne = yt(
  [bs],
  { value: "text", opacity: 1 },
  { opacity: new dt(0, 1) }
);
class Vm extends Ii {
  constructor() {
    super();
    V(this, "el", oo('<div style="opacity: 1">text</div>'));
    wa.appendChild(this.el), this.then(() => this.el.remove());
  }
  get opacity() {
    return Number(this.el.style.opacity);
  }
  set opacity(t) {
    this.el.style.opacity = t + "";
  }
  get value() {
    var t;
    return (t = this.el.textContent) != null ? t : "";
  }
  set value(t) {
    this.el.textContent = t;
  }
}
V(Vm, "componentName", "text"), V(Vm, "defaults", pne), V(Vm, "schema", fne);
const mne = {
  ...Lc,
  resolution: Number,
  blur: Number,
  contrast: Number,
  mirror: Number
}, vne = yt(
  [Dc],
  {
    resolution: 256,
    blur: 512,
    contrast: 1.5,
    mirror: 1,
    rotationX: 270
  },
  {
    resolution: new dt(256, 2048, 256),
    blur: new dt(256, 2048, 128)
  }
);
class ef extends Sa {
  constructor() {
    const t = new wi(vC);
    t.castShadow = !0, t.receiveShadow = !0;
    super(t);
    V(this, "resolutionState", new Je(256));
    V(this, "blurState", new Je(512));
    V(this, "contrastState", new Je(1.5));
    V(this, "mirrorState", new Je(1));
    this.rotationX = 270, import("./MeshReflectorMaterial.f333e9d8.mjs").then(
      ({ default: i }) => {
        this.createEffect(() => {
          const r = Ln();
          if (!r || this.done)
            return;
          const s = nt(), o = t.material = new i(
            r,
            s,
            bt,
            this.object3d,
            {
              resolution: this.resolutionState.get(),
              blur: [this.blurState.get(), this.blurState.get()],
              mixBlur: 2.5,
              mixContrast: this.contrastState.get(),
              mirror: this.mirrorState.get(),
              distortionMap: void 0
            }
          ), a = II(() => {
            s.updateWorldMatrix(!0, !1), o.update();
          });
          return () => {
            o.dispose(), a.cancel();
          };
        }, [
          Ln,
          nt,
          this.resolutionState.get,
          this.blurState.get,
          this.contrastState.get,
          this.mirrorState.get
        ]);
      }
    );
  }
  get resolution() {
    return this.resolutionState.get();
  }
  set resolution(t) {
    this.resolutionState.set(t);
  }
  get blur() {
    return this.blurState.get();
  }
  set blur(t) {
    this.blurState.set(t);
  }
  get contrast() {
    return this.contrastState.get();
  }
  set contrast(t) {
    this.contrastState.set(t);
  }
  get mirror() {
    return this.mirrorState.get();
  }
  set mirror(t) {
    this.mirrorState.set(t);
  }
}
V(ef, "componentName", "reflector"), V(ef, "defaults", vne), V(ef, "schema", mne);
const gne = {
  ...Lc,
  shape: String,
  normalMap: String,
  resolution: Number,
  speed: Number
}, _ne = yt(
  [Dc],
  {
    shape: "plane",
    normalMap: JD,
    resolution: 512,
    speed: 1,
    rotationX: 270
  },
  {
    resolution: new dt(256, 2048, 256)
  },
  { normalMap: !0 }
);
class tf extends Sa {
  constructor() {
    super();
    V(this, "shapeState", new Je("plane"));
    V(this, "normalMapState", new Je(JD));
    V(this, "resolutionState", new Je(512));
    V(this, "speedState", new Je(1));
    this.rotationX = 270, import("./Water.6f8e792e.mjs").then(({ Water: t }) => {
      this.createEffect(() => {
        const i = this.normalMapState.get();
        if (!i)
          return;
        const s = this.shapeState.get() === "plane" ? vC : mC, o = this.resolutionState.get(), a = this.speedState.get(), l = new Xn(), c = new t(s, {
          textureWidth: o,
          textureHeight: o,
          waterNormals: Wr(i, () => {
            this.object3d.add(c);
            const d = Pn(() => {
              c.material.uniforms.time.value += Iv[0] * a;
            });
            l.then(() => {
              this.object3d.remove(c), d.cancel();
            });
          }),
          sunColor: 16777215,
          waterColor: 7695,
          distortionScale: 3.7
        });
        return Ds(c, this), () => {
          l.cancel();
        };
      }, [
        this.shapeState.get,
        this.normalMapState.get,
        this.resolutionState.get,
        this.speedState.get
      ]);
    });
  }
  get shape() {
    return this.shapeState.get();
  }
  set shape(t) {
    this.shapeState.set(t);
  }
  get normalMap() {
    return this.normalMapState.get();
  }
  set normalMap(t) {
    this.normalMapState.set(t);
  }
  get resolution() {
    return this.resolutionState.get();
  }
  set resolution(t) {
    this.resolutionState.set(t);
  }
  get speed() {
    return this.speedState.get();
  }
  set speed(t) {
    this.speedState.set(t);
  }
}
V(tf, "componentName", "water"), V(tf, "defaults", _ne), V(tf, "schema", gne);
const F4 = new _D([], void 0, "catmullrom", 0.5), bne = (n, e) => (F4.points = n, F4.getPoint(e)), yne = {
  ..._s,
  points: Array,
  helper: Boolean,
  subdivide: Number
};
ya(["points"]);
const xne = yt(
  [bs],
  {
    points: [],
    helper: !1,
    subdivide: 3
  },
  {
    subdivide: new dt(1, 10, 1)
  }
);
class AC extends Yd {
  constructor() {
    super(mC);
  }
}
const wne = (n, e) => {
  const t = new Set(n), i = V_(() => /* @__PURE__ */ new Set(), []), r = V_(() => /* @__PURE__ */ new Map(), []), s = V_(() => /* @__PURE__ */ new Map(), []);
  for (const o of t)
    if (!i.has(o)) {
      const a = new Xn();
      r.set(o, e(o, a)), s.set(o, a);
    }
  for (const o of i)
    t.has(o) || (s.get(o).cancel(), s.delete(o), r.delete(o));
  fy(() => () => {
    for (const o of s.values())
      o.cancel();
  }, []), i.clear();
  for (const o of n)
    i.add(o);
  return r;
};
class nf extends Ii {
  constructor() {
    super();
    V(this, "refreshState", new Je({}));
    V(this, "helperState", new Je(!1));
    V(this, "_subdivide", 3);
    V(this, "_points", []);
    bt.add(this.outerObject3d), this.createEffect(() => {
      const i = this._points.length * this._subdivide, r = new Vi(new Float32Array(i * 3), 3), s = new qn();
      s.setAttribute("position", r);
      const o = new kc({ color: 16711680 }), a = new xy(s, o);
      if (a.frustumCulled = !0, a.userData.unselectable = !0, this.outerObject3d.add(a), this._points.length < 2)
        for (let l = 0; l < i; ++l)
          r.setXYZ(l, 0, 0, 0);
      else {
        const l = this._points.map(Gy);
        for (let c = 0; c < i; ++c) {
          const d = c / (i - 1), p = bne(l, d);
          r.setXYZ(c, p.x, p.y, p.z);
        }
      }
      return () => {
        s.dispose(), o.dispose(), this.outerObject3d.remove(a);
      };
    }, [this.refreshState.get]);
    let t = !1;
    this.createEffect(() => {
      const i = wne(
        this.helperState.get() && nt() === un ? this._points : [],
        (r, s) => {
          const o = new AC();
          return this.append(o), o.scale = 0.1, Du.add(o.outerObject3d), o.onMove = () => {
            t = !0, Object.assign(r, o.getWorldPosition()), this.refreshState.set({});
          }, s.then(() => {
            o.dispose(), Du.delete(o.outerObject3d);
          }), o;
        }
      );
      if (t) {
        t = !1;
        return;
      }
      for (const [r, s] of i)
        Object.assign(s, r);
    }, [this.helperState.get, this.refreshState.get, nt]);
  }
  get helper() {
    return this.helperState.get();
  }
  set helper(t) {
    this.helperState.set(t);
  }
  get subdivide() {
    return this._subdivide;
  }
  set subdivide(t) {
    this._subdivide = t, this.refreshState.set({});
  }
  get points() {
    return this._points;
  }
  set points(t) {
    this._points = t, this.refreshState.set({});
  }
  addPoint(t) {
    this._points.push(t), this.refreshState.set({});
  }
}
V(nf, "componentName", "curve"), V(nf, "defaults", xne), V(nf, "schema", yne);
const Sne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: nf
}, Symbol.toStringTag, { value: "Module" })), B4 = new so(), L_ = new Z();
class VO extends Uq {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], i = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(i), this.setAttribute("position", new en(e, 3)), this.setAttribute("uv", new en(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, i = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), i.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new E2(t, 6, 1);
    return this.setAttribute("instanceStart", new aa(i, 3, 0)), this.setAttribute("instanceEnd", new aa(i, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const i = new E2(t, 6, 1);
    return this.setAttribute("instanceColorStart", new aa(i, 3, 0)), this.setAttribute("instanceColorEnd", new aa(i, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new yq(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new so());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), B4.setFromBufferAttribute(t), this.boundingBox.union(B4));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new sh()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const i = this.boundingSphere.center;
      this.boundingBox.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        L_.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(L_)), L_.fromBufferAttribute(t, s), r = Math.max(r, i.distanceToSquared(L_));
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
class HO extends VO {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, i = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      i[2 * r] = e[r], i[2 * r + 1] = e[r + 1], i[2 * r + 2] = e[r + 2], i[2 * r + 3] = e[r + 3], i[2 * r + 4] = e[r + 4], i[2 * r + 5] = e[r + 5];
    return super.setPositions(i), this;
  }
  setColors(e) {
    const t = e.length - 3, i = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      i[2 * r] = e[r], i[2 * r + 1] = e[r + 1], i[2 * r + 2] = e[r + 2], i[2 * r + 3] = e[r + 3], i[2 * r + 4] = e[r + 4], i[2 * r + 5] = e[r + 5];
    return super.setColors(i), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
Ke.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new ze(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
};
ms.line = {
  uniforms: gy.merge([
    Ke.common,
    Ke.fog,
    Ke.line
  ]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
class RC extends Yn {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: gy.clone(ms.line.uniforms),
      vertexShader: ms.line.vertexShader,
      fragmentShader: ms.line.fragmentShader,
      clipping: !0
    }), this.isLineMaterial = !0, Object.defineProperties(this, {
      color: {
        enumerable: !0,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(t) {
          this.uniforms.diffuse.value = t;
        }
      },
      worldUnits: {
        enumerable: !0,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(t) {
          t === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
        }
      },
      linewidth: {
        enumerable: !0,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(t) {
          this.uniforms.linewidth.value = t;
        }
      },
      dashed: {
        enumerable: !0,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(t) {
          Boolean(t) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), t === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
        }
      },
      dashScale: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(t) {
          this.uniforms.dashScale.value = t;
        }
      },
      dashSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(t) {
          this.uniforms.dashSize.value = t;
        }
      },
      dashOffset: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(t) {
          this.uniforms.dashOffset.value = t;
        }
      },
      gapSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(t) {
          this.uniforms.gapSize.value = t;
        }
      },
      opacity: {
        enumerable: !0,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(t) {
          this.uniforms.opacity.value = t;
        }
      },
      resolution: {
        enumerable: !0,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(t) {
          this.uniforms.resolution.value.copy(t);
        }
      },
      alphaToCoverage: {
        enumerable: !0,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(t) {
          Boolean(t) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), t === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
        }
      }
    }), this.setValues(e);
  }
}
const U4 = new Z(), V4 = new Z(), vr = new gn(), gr = new gn(), Qo = new gn(), IS = new Z(), OS = new Pt(), Or = new BD(), H4 = new Z(), D_ = new so(), I_ = new sh(), ea = new gn();
let oa, AM, GO, Fu;
function G4(n, e, t) {
  return ea.set(0, 0, -e, 1).applyMatrix4(n.projectionMatrix), ea.multiplyScalar(1 / ea.w), ea.x = Fu / t.width, ea.y = Fu / t.height, ea.applyMatrix4(n.projectionMatrixInverse), ea.multiplyScalar(1 / ea.w), Math.abs(Math.max(ea.x, ea.y));
}
function Mne(n, e) {
  for (let t = 0, i = AM.count; t < i; t++) {
    Or.start.fromBufferAttribute(AM, t), Or.end.fromBufferAttribute(GO, t);
    const r = new Z(), s = new Z();
    oa.distanceSqToSegment(Or.start, Or.end, s, r), s.distanceTo(r) < Fu * 0.5 && e.push({
      point: s,
      pointOnLine: r,
      distance: oa.origin.distanceTo(s),
      object: n,
      face: null,
      faceIndex: t,
      uv: null,
      uv2: null
    });
  }
}
function Ene(n, e, t) {
  const i = e.projectionMatrix, s = n.material.resolution, o = n.matrixWorld, a = n.geometry, l = a.attributes.instanceStart, c = a.attributes.instanceEnd, d = -e.near;
  oa.at(1, Qo), Qo.w = 1, Qo.applyMatrix4(e.matrixWorldInverse), Qo.applyMatrix4(i), Qo.multiplyScalar(1 / Qo.w), Qo.x *= s.x / 2, Qo.y *= s.y / 2, Qo.z = 0, IS.copy(Qo), OS.multiplyMatrices(e.matrixWorldInverse, o);
  for (let p = 0, m = l.count; p < m; p++) {
    if (vr.fromBufferAttribute(l, p), gr.fromBufferAttribute(c, p), vr.w = 1, gr.w = 1, vr.applyMatrix4(OS), gr.applyMatrix4(OS), vr.z > d && gr.z > d)
      continue;
    if (vr.z > d) {
      const C = vr.z - gr.z, M = (vr.z - d) / C;
      vr.lerp(gr, M);
    } else if (gr.z > d) {
      const C = gr.z - vr.z, M = (gr.z - d) / C;
      gr.lerp(vr, M);
    }
    vr.applyMatrix4(i), gr.applyMatrix4(i), vr.multiplyScalar(1 / vr.w), gr.multiplyScalar(1 / gr.w), vr.x *= s.x / 2, vr.y *= s.y / 2, gr.x *= s.x / 2, gr.y *= s.y / 2, Or.start.copy(vr), Or.start.z = 0, Or.end.copy(gr), Or.end.z = 0;
    const b = Or.closestPointToPointParameter(IS, !0);
    Or.at(b, H4);
    const x = Pm.lerp(vr.z, gr.z, b), y = x >= -1 && x <= 1, S = IS.distanceTo(H4) < Fu * 0.5;
    if (y && S) {
      Or.start.fromBufferAttribute(l, p), Or.end.fromBufferAttribute(c, p), Or.start.applyMatrix4(o), Or.end.applyMatrix4(o);
      const C = new Z(), M = new Z();
      oa.distanceSqToSegment(Or.start, Or.end, M, C), t.push({
        point: M,
        pointOnLine: C,
        distance: oa.origin.distanceTo(M),
        object: n,
        face: null,
        faceIndex: p,
        uv: null,
        uv2: null
      });
    }
  }
}
class Cne extends wi {
  constructor(e = new VO(), t = new RC({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, i = e.attributes.instanceEnd, r = new Float32Array(2 * t.count);
    for (let o = 0, a = 0, l = t.count; o < l; o++, a += 2)
      U4.fromBufferAttribute(t, o), V4.fromBufferAttribute(i, o), r[a] = a === 0 ? 0 : r[a - 1], r[a + 1] = r[a] + U4.distanceTo(V4);
    const s = new E2(r, 2, 1);
    return e.setAttribute("instanceDistanceStart", new aa(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new aa(s, 1, 1)), this;
  }
  raycast(e, t) {
    const i = this.material.worldUnits, r = e.camera;
    r === null && !i && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    oa = e.ray;
    const o = this.matrixWorld, a = this.geometry, l = this.material;
    Fu = l.linewidth + s, AM = a.attributes.instanceStart, GO = a.attributes.instanceEnd, a.boundingSphere === null && a.computeBoundingSphere(), I_.copy(a.boundingSphere).applyMatrix4(o);
    let c;
    if (i)
      c = Fu * 0.5;
    else {
      const p = Math.max(r.near, I_.distanceToPoint(oa.origin));
      c = G4(r, p, l.resolution);
    }
    if (I_.radius += c, oa.intersectsSphere(I_) === !1)
      return;
    a.boundingBox === null && a.computeBoundingBox(), D_.copy(a.boundingBox).applyMatrix4(o);
    let d;
    if (i)
      d = Fu * 0.5;
    else {
      const p = Math.max(r.near, D_.distanceToPoint(oa.origin));
      d = G4(r, p, l.resolution);
    }
    D_.expandByScalar(d), oa.intersectsBox(D_) !== !1 && (i ? Mne(this, t) : Ene(this, r, t));
  }
}
class Tne extends Cne {
  constructor(e = new HO(), t = new RC({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class Pne extends Ii {
  constructor() {
    super();
    V(this, "refresh", new Je({}));
    V(this, "_bloom");
    V(this, "_from");
    V(this, "_to");
    V(this, "_thickness", 1);
    this.createEffect(() => {
      const { from: t, to: i, bloom: r } = this;
      if (!t || !i)
        return;
      const s = new HO().setPositions([
        t.x * Ut,
        t.y * Ut,
        t.z * Ut,
        i.x * Ut,
        i.y * Ut,
        i.z * Ut
      ]), o = new RC({
        linewidth: this._thickness * Ut
      }), a = new Tne(s, o);
      return bt.add(a), r && ZE(a), () => {
        bt.remove(a), s.dispose(), o.dispose(), r && YE(a);
      };
    }, [this.refresh.get]);
  }
  get bloom() {
    return this._bloom;
  }
  set bloom(t) {
    this._bloom = t, this.refresh.set({});
  }
  get from() {
    return this._from;
  }
  set from(t) {
    this._from = t, this.refresh.set({});
  }
  get to() {
    return this._to;
  }
  set to(t) {
    this._to = t, this.refresh.set({});
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(t) {
    this._thickness = t, this.refresh.set({});
  }
}
const Ane = {
  ...Fv,
  onEnter: Function,
  onExit: Function,
  target: [String, Array, Object],
  pad: Boolean,
  radius: Number,
  interval: Number,
  helper: Boolean
}, Rne = yt(
  [Bv],
  {
    onEnter: void 0,
    onExit: void 0,
    target: void 0,
    pad: !1,
    radius: 50,
    interval: 300,
    helper: !0
  },
  {
    radius: new dt(0, 1e3),
    interval: new dt(100, 1e3, 100)
  }
);
class WO extends Yd {
  constructor() {
    super(uO);
  }
}
class rf extends Wy {
  constructor() {
    super();
    V(this, "refresh", new Je({}));
    V(this, "onEnter");
    V(this, "onExit");
    V(this, "_pad", !1);
    V(this, "_radius", 50);
    V(this, "_interval", 300);
    V(this, "_helper", !0);
    V(this, "_target");
    let t;
    this.createEffect(() => {
      const { _radius: i, _interval: r, _target: s, _pad: o } = this;
      if (!s)
        return;
      const a = _I(s), l = i * Ut, c = l * 0.2;
      let d = !1;
      const p = Py(r, -1, () => {
        var S, C;
        const { x: m, y: v, z: b } = Dn(this.outerObject3d);
        let x = !1, y;
        for (const M of a)
          for (const T of M) {
            const { x: P, y: D, z: I } = Dn(T.nativeObject3d);
            if (o) {
              const { y: k } = tC(T);
              x = Math.abs(m - P) < l && Math.abs(v - (D - k * 0.5)) < c && Math.abs(b - I) < l;
            } else
              x = Math.abs(m - P) < l && Math.abs(v - D) < l && Math.abs(b - I) < l;
            if (x) {
              y = T;
              break;
            }
          }
        d !== x && (x && y ? ((S = this.onEnter) == null || S.call(this, y), t && (t.color = "blue")) : ((C = this.onExit) == null || C.call(this), t && (t.color = "white"))), d = x;
      });
      return () => {
        p.cancel();
      };
    }, [this.refresh.get]), this.createEffect(() => {
      const { _radius: i, _helper: r, _pad: s } = this;
      if (!r || nt() !== un)
        return;
      t = s ? new WO() : new AC();
      const o = ph(t, this);
      return t.scale = i * Ut * 2, t.height = s ? 10 : 100, () => {
        t.dispose(), t = void 0, o.cancel();
      };
    }, [this.refresh.get, nt]);
  }
  get pad() {
    return this._pad;
  }
  set pad(t) {
    this._pad = t, this.refresh.set({});
  }
  get radius() {
    return this._radius;
  }
  set radius(t) {
    this._radius = t, this.refresh.set({});
  }
  get interval() {
    return this._interval;
  }
  set interval(t) {
    this._interval = t, this.refresh.set({});
  }
  get helper() {
    return this._helper;
  }
  set helper(t) {
    this._helper = t, this.refresh.set({});
  }
  get target() {
    return this._target;
  }
  set target(t) {
    this._target = t, this.refresh.set({});
  }
}
V(rf, "componentName", "trigger"), V(rf, "defaults", Rne), V(rf, "schema", Ane);
const kne = {
  ...Iy,
  helper: Boolean
}, Lne = yt(
  [Oy],
  { helper: !0 }
);
class sf extends mh {
  constructor() {
    super();
    V(this, "helperState", new Je(!0));
    V(this, "isSpawnPoint", !0);
    this.createEffect(() => {
      if (!this.helperState.get() || nt() !== un)
        return;
      const t = new WO(), i = ph(t, this);
      return t.height = 10, () => {
        i.cancel();
      };
    }, [this.helperState.get, nt]);
  }
  get helper() {
    return this.helperState.get();
  }
  set helper(t) {
    this.helperState.set(t);
  }
  append(t) {
    this._append(t), bt.add(t.outerObject3d), t.placeAt(this);
  }
}
V(sf, "componentName", "spawnPoint"), V(sf, "defaults", Lne), V(sf, "schema", kne);
const Dne = {
  ...Fv,
  src: String,
  autoplay: Boolean,
  paused: Boolean,
  stopped: Boolean,
  loop: Boolean,
  volume: Number,
  playbackRate: Number,
  distance: Number,
  distanceModel: String,
  maxDistance: Number,
  rolloffFactor: Number
}, Ine = yt([Bv], {
  src: void 0,
  autoplay: !1,
  paused: !1,
  stopped: !1,
  loop: !1,
  volume: 1,
  playbackRate: 1,
  distance: 1,
  maxDistance: 1e4,
  distanceModel: "inverse",
  rolloffFactor: 1
}), One = /* @__PURE__ */ new Map(), Nne = new Vq(), zne = (n) => Mr(
  One,
  n,
  () => new Promise((e, t) => {
    const i = n.startsWith("https://unpkg.com/");
    i && ky(), Nne.load(
      n,
      (r) => {
        i && Ly(), e(r);
      },
      Ry(n),
      t
    );
  })
), [Fne, $b] = Be(
  void 0
);
ft(() => {
  const n = $b();
  if (!n)
    return;
  const e = nt();
  return e.add(n), () => {
    e.remove(n);
  };
}, [nt, $b]);
class of extends Wy {
  constructor() {
    !$b() && Fne(new Gq());
    const t = new qq($b());
    super(t);
    V(this, "srcState", new Je(void 0));
    V(this, "autoplayState", new Je(!1));
    V(this, "pausedState", new Je(!1));
    V(this, "stoppedState", new Je(!1));
    this.createEffect(() => {
      if (nt() !== un)
        return;
      const s = ph(new qv("audio"), this);
      return () => {
        s.cancel();
      };
    }, [nt]);
    const [i, r] = Be(!1);
    this.createEffect(() => {
      const s = this.srcState.get();
      if (!s)
        return;
      let o = !0;
      return zne(s).then((a) => {
        !o || (t.setBuffer(a), i(!0));
      }), () => {
        o = !1, i(!1);
      };
    }, [this.srcState.get]), this.createEffect(() => {
      if (!(!r() || !this.autoplayState.get() || this.pausedState.get() || this.stoppedState.get()))
        return t.play(), () => {
          this.stoppedState.get() ? t.stop() : t.pause();
        };
    }, [
      r,
      this.autoplayState.get,
      this.pausedState.get,
      this.stoppedState.get
    ]);
  }
  dispose() {
    return this.done ? this : (super.dispose(), this.outerObject3d.buffer && this.outerObject3d.disconnect(), this);
  }
  play() {
    this.autoplay = !0, this.paused = !1, this.stopped = !1;
  }
  pause() {
    this.paused = !0;
  }
  stop() {
    this.stopped = !0;
  }
  get src() {
    return this.srcState.get();
  }
  set src(t) {
    this.srcState.set(t);
  }
  get autoplay() {
    return this.autoplayState.get();
  }
  set autoplay(t) {
    this.autoplayState.set(t);
  }
  get paused() {
    return this.pausedState.get();
  }
  set paused(t) {
    this.pausedState.set(t);
  }
  get stopped() {
    return this.stoppedState.get();
  }
  set stopped(t) {
    this.stoppedState.set(t);
  }
  get loop() {
    return this.outerObject3d.loop;
  }
  set loop(t) {
    this.outerObject3d.loop = t;
  }
  get volume() {
    return this.outerObject3d.getVolume();
  }
  set volume(t) {
    this.outerObject3d.setVolume(t);
  }
  get playbackRate() {
    return this.outerObject3d.playbackRate;
  }
  set playbackRate(t) {
    this.outerObject3d.playbackRate = t;
  }
  get distance() {
    return this.outerObject3d.getRefDistance();
  }
  set distance(t) {
    this.outerObject3d.setRefDistance(t);
  }
  get distanceModel() {
    return this.outerObject3d.getDistanceModel();
  }
  set distanceModel(t) {
    this.outerObject3d.setDistanceModel(t);
  }
  get maxDistance() {
    return this.outerObject3d.getMaxDistance();
  }
  set maxDistance(t) {
    this.outerObject3d.setMaxDistance(t);
  }
  get rolloffFactor() {
    return this.outerObject3d.getRolloffFactor();
  }
  set rolloffFactor(t) {
    this.outerObject3d.setRolloffFactor(t);
  }
}
V(of, "componentName", "audio"), V(of, "defaults", Ine), V(of, "schema", Dne);
const [Bne, Une] = di(), Vne = {
  ...Lc
}, Hne = yt(
  [Dc],
  {}
);
class Bu extends Sa {
  constructor() {
    super(new ul());
  }
}
V(Bu, "componentName", "group"), V(Bu, "defaults", Hne), V(Bu, "schema", Vne);
ft(() => {
  const n = hr();
  if (!n.length)
    return;
  const e = new ul();
  bt.add(e);
  const t = new $f(e);
  ko.add(t), Lv(t);
  const i = [];
  for (const { outerObject3d: o } of n)
    !o.parent || (i.push([o, o.parent]), e.attach(o));
  Ud.setFromObject(e);
  for (const [o, a] of i)
    a.attach(o);
  e.position.copy(Ud.getCenter(Jn));
  for (const [o] of i)
    e.attach(o);
  let r = !1;
  const s = Une(() => {
    if (!n.length || r)
      return;
    r = !0;
    const o = new Bu();
    o.outerObject3d.position.copy(e.position);
    for (const a of n)
      o.attach(a);
    dr(o);
  });
  return () => {
    if (!t.done && !r)
      for (const [o, a] of i)
        a.attach(o);
    t.dispose(), bt.remove(e), s.cancel();
  };
}, [hr]);
const jO = /* @__PURE__ */ new WeakMap();
class Ao extends Ii {
  constructor(t) {
    super();
    V(this, "data", {});
    this.noEffect = t, !t && (gee(this.data), this.then(() => _ee(this.data)), jO.set(this.data, this));
  }
}
V(Ao, "componentName", "setup"), V(Ao, "defaults", Mo), V(Ao, "schema", Jy);
for (const n of Object.keys(Jy))
  Object.defineProperty(Ao.prototype, n, {
    get() {
      return this.data[n];
    },
    set(e) {
      this.data[n] = e, !this.noEffect && aO();
    }
  });
const Gne = {
  ...yI
}, Wne = yt(
  [xI],
  {}
), jne = vn.findNode;
vn.findNode = (n, e) => no.has(e) ? no.get(e) : jne(n, e);
class bc extends ra {
  constructor() {
    super(
      "",
      void 0,
      {},
      new Je(0),
      new Je(void 0),
      void 0,
      !0
    );
  }
}
V(bc, "componentName", "timeline"), V(bc, "defaults", Wne), V(bc, "schema", Gne);
const qne = {
  ..._s
}, Xne = yt([bs], {});
class ob extends Ii {
  constructor() {
    super(), BK(!0);
  }
}
V(ob, "componentName", "sky"), V(ob, "defaults", Xne), V(ob, "schema", qne);
const $ne = {
  ...CI
}, Zne = yt([TI], {});
class af extends Nm {
  constructor() {
    super(new ni(75, 1, uh, Mc));
  }
}
V(af, "componentName", "camera"), V(af, "defaults", Zne), V(af, "schema", $ne);
const [mde, Yne] = di(), qO = {
  ...PI,
  lockTargetRotation: [Boolean, String]
}, XO = yt(
  [AI],
  { lockTargetRotation: !0 }
), Kne = {
  ...qO
}, Jne = yt(
  [XO],
  { innerZ: 300 }
);
class Qne {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++)
        r[s].call(this, e);
      e.target = null;
    }
  }
}
const Lr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
function eie() {
  const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Lr[n & 255] + Lr[n >> 8 & 255] + Lr[n >> 16 & 255] + Lr[n >> 24 & 255] + "-" + Lr[e & 255] + Lr[e >> 8 & 255] + "-" + Lr[e >> 16 & 15 | 64] + Lr[e >> 24 & 255] + "-" + Lr[t & 63 | 128] + Lr[t >> 8 & 255] + "-" + Lr[t >> 16 & 255] + Lr[t >> 24 & 255] + Lr[i & 255] + Lr[i >> 8 & 255] + Lr[i >> 16 & 255] + Lr[i >> 24 & 255]).toLowerCase();
}
function oc(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
class kC {
  constructor() {
    kC.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, i, r, s, o, a, l, c) {
    const d = this.elements;
    return d[0] = e, d[1] = r, d[2] = a, d[3] = t, d[4] = s, d[5] = l, d[6] = i, d[7] = o, d[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[3], l = i[6], c = i[1], d = i[4], p = i[7], m = i[2], v = i[5], b = i[8], x = r[0], y = r[3], S = r[6], C = r[1], M = r[4], T = r[7], P = r[2], D = r[5], I = r[8];
    return s[0] = o * x + a * C + l * P, s[3] = o * y + a * M + l * D, s[6] = o * S + a * T + l * I, s[1] = c * x + d * C + p * P, s[4] = c * y + d * M + p * D, s[7] = c * S + d * T + p * I, s[2] = m * x + v * C + b * P, s[5] = m * y + v * M + b * D, s[8] = m * S + v * T + b * I, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], d = e[8];
    return t * o * d - t * a * c - i * s * d + i * a * l + r * s * c - r * o * l;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], d = e[8], p = d * o - a * c, m = a * l - d * s, v = c * s - o * l, b = t * p + i * m + r * v;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / b;
    return e[0] = p * x, e[1] = (r * c - d * i) * x, e[2] = (a * i - r * o) * x, e[3] = m * x, e[4] = (d * t - r * l) * x, e[5] = (r * s - a * t) * x, e[6] = v * x, e[7] = (i * l - c * t) * x, e[8] = (o * t - i * s) * x, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s), c = Math.sin(s);
    return this.set(
      i * l,
      i * c,
      -i * (l * o + c * a) + o + e,
      -r * c,
      r * l,
      -r * (-c * o + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  scale(e, t) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this;
  }
  rotate(e) {
    const t = Math.cos(e), i = Math.sin(e), r = this.elements, s = r[0], o = r[3], a = r[6], l = r[1], c = r[4], d = r[7];
    return r[0] = t * s + i * l, r[3] = t * o + i * c, r[6] = t * a + i * d, r[1] = -i * s + t * l, r[4] = -i * o + t * c, r[7] = -i * a + t * d, this;
  }
  translate(e, t) {
    const i = this.elements;
    return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
class $v {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r;
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0], c = i[r + 1], d = i[r + 2], p = i[r + 3];
    const m = s[o + 0], v = s[o + 1], b = s[o + 2], x = s[o + 3];
    if (a === 0) {
      e[t + 0] = l, e[t + 1] = c, e[t + 2] = d, e[t + 3] = p;
      return;
    }
    if (a === 1) {
      e[t + 0] = m, e[t + 1] = v, e[t + 2] = b, e[t + 3] = x;
      return;
    }
    if (p !== x || l !== m || c !== v || d !== b) {
      let y = 1 - a;
      const S = l * m + c * v + d * b + p * x, C = S >= 0 ? 1 : -1, M = 1 - S * S;
      if (M > Number.EPSILON) {
        const P = Math.sqrt(M), D = Math.atan2(P, S * C);
        y = Math.sin(y * D) / P, a = Math.sin(a * D) / P;
      }
      const T = a * C;
      if (l = l * y + m * T, c = c * y + v * T, d = d * y + b * T, p = p * y + x * T, y === 1 - a) {
        const P = 1 / Math.sqrt(l * l + c * c + d * d + p * p);
        l *= P, c *= P, d *= P, p *= P;
      }
    }
    e[t] = l, e[t + 1] = c, e[t + 2] = d, e[t + 3] = p;
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r], l = i[r + 1], c = i[r + 2], d = i[r + 3], p = s[o], m = s[o + 1], v = s[o + 2], b = s[o + 3];
    return e[t] = a * b + d * p + l * v - c * m, e[t + 1] = l * b + d * m + c * p - a * v, e[t + 2] = c * b + d * v + a * m - l * p, e[t + 3] = d * b - a * p - l * m - c * v, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, r) {
    return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const i = e._x, r = e._y, s = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(i / 2), d = a(r / 2), p = a(s / 2), m = l(i / 2), v = l(r / 2), b = l(s / 2);
    switch (o) {
      case "XYZ":
        this._x = m * d * p + c * v * b, this._y = c * v * p - m * d * b, this._z = c * d * b + m * v * p, this._w = c * d * p - m * v * b;
        break;
      case "YXZ":
        this._x = m * d * p + c * v * b, this._y = c * v * p - m * d * b, this._z = c * d * b - m * v * p, this._w = c * d * p + m * v * b;
        break;
      case "ZXY":
        this._x = m * d * p - c * v * b, this._y = c * v * p + m * d * b, this._z = c * d * b + m * v * p, this._w = c * d * p - m * v * b;
        break;
      case "ZYX":
        this._x = m * d * p - c * v * b, this._y = c * v * p + m * d * b, this._z = c * d * b - m * v * p, this._w = c * d * p + m * v * b;
        break;
      case "YZX":
        this._x = m * d * p + c * v * b, this._y = c * v * p + m * d * b, this._z = c * d * b - m * v * p, this._w = c * d * p - m * v * b;
        break;
      case "XZY":
        this._x = m * d * p - c * v * b, this._y = c * v * p - m * d * b, this._z = c * d * b + m * v * p, this._w = c * d * p + m * v * b;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, r = Math.sin(i);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], r = t[4], s = t[8], o = t[1], a = t[5], l = t[9], c = t[2], d = t[6], p = t[10], m = i + a + p;
    if (m > 0) {
      const v = 0.5 / Math.sqrt(m + 1);
      this._w = 0.25 / v, this._x = (d - l) * v, this._y = (s - c) * v, this._z = (o - r) * v;
    } else if (i > a && i > p) {
      const v = 2 * Math.sqrt(1 + i - a - p);
      this._w = (d - l) / v, this._x = 0.25 * v, this._y = (r + o) / v, this._z = (s + c) / v;
    } else if (a > p) {
      const v = 2 * Math.sqrt(1 + a - i - p);
      this._w = (s - c) / v, this._x = (r + o) / v, this._y = 0.25 * v, this._z = (l + d) / v;
    } else {
      const v = 2 * Math.sqrt(1 + p - i - a);
      this._w = (o - r) / v, this._x = (s + c) / v, this._y = (l + d) / v, this._z = 0.25 * v;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(oc(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0)
      return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, r = e._y, s = e._z, o = e._w, a = t._x, l = t._y, c = t._z, d = t._w;
    return this._x = i * d + o * a + r * c - s * l, this._y = r * d + o * l + s * a - i * c, this._z = s * d + o * c + i * l - r * a, this._w = o * d - i * a - r * l - s * c, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const i = this._x, r = this._y, s = this._z, o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
      return this._w = o, this._x = i, this._y = r, this._z = s, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const v = 1 - t;
      return this._w = v * o + t * this._w, this._x = v * i + t * this._x, this._y = v * r + t * this._y, this._z = v * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(l), d = Math.atan2(c, a), p = Math.sin((1 - t) * d) / c, m = Math.sin(t * d) / c;
    return this._w = o * p + this._w * m, this._x = i * p + this._x * m, this._y = r * p + this._y * m, this._z = s * p + this._z * m, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class $i {
  constructor(e = 0, t = 0, i = 0) {
    $i.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(W4.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(W4.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, r = this.z, s = e.x, o = e.y, a = e.z, l = e.w, c = l * t + o * r - a * i, d = l * i + a * t - s * r, p = l * r + s * i - o * t, m = -s * t - o * i - a * r;
    return this.x = c * l + m * -s + d * -a - p * -o, this.y = d * l + m * -o + p * -s - c * -a, this.z = p * l + m * -a + c * -o - d * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, r = e.y, s = e.z, o = t.x, a = t.y, l = t.z;
    return this.x = r * l - s * a, this.y = s * o - i * l, this.z = i * a - r * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return NS.copy(this).projectOnVector(e), this.sub(NS);
  }
  reflect(e) {
    return this.sub(NS.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(oc(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2);
    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const NS = /* @__PURE__ */ new $i(), W4 = /* @__PURE__ */ new $v();
class vl {
  constructor() {
    vl.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, i, r, s, o, a, l, c, d, p, m, v, b, x, y) {
    const S = this.elements;
    return S[0] = e, S[4] = t, S[8] = i, S[12] = r, S[1] = s, S[5] = o, S[9] = a, S[13] = l, S[2] = c, S[6] = d, S[10] = p, S[14] = m, S[3] = v, S[7] = b, S[11] = x, S[15] = y, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new vl().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(
      e.x,
      t.x,
      i.x,
      0,
      e.y,
      t.y,
      i.y,
      0,
      e.z,
      t.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, r = 1 / xd.setFromMatrixColumn(e, 0).length(), s = 1 / xd.setFromMatrixColumn(e, 1).length(), o = 1 / xd.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z, o = Math.cos(i), a = Math.sin(i), l = Math.cos(r), c = Math.sin(r), d = Math.cos(s), p = Math.sin(s);
    if (e.order === "XYZ") {
      const m = o * d, v = o * p, b = a * d, x = a * p;
      t[0] = l * d, t[4] = -l * p, t[8] = c, t[1] = v + b * c, t[5] = m - x * c, t[9] = -a * l, t[2] = x - m * c, t[6] = b + v * c, t[10] = o * l;
    } else if (e.order === "YXZ") {
      const m = l * d, v = l * p, b = c * d, x = c * p;
      t[0] = m + x * a, t[4] = b * a - v, t[8] = o * c, t[1] = o * p, t[5] = o * d, t[9] = -a, t[2] = v * a - b, t[6] = x + m * a, t[10] = o * l;
    } else if (e.order === "ZXY") {
      const m = l * d, v = l * p, b = c * d, x = c * p;
      t[0] = m - x * a, t[4] = -o * p, t[8] = b + v * a, t[1] = v + b * a, t[5] = o * d, t[9] = x - m * a, t[2] = -o * c, t[6] = a, t[10] = o * l;
    } else if (e.order === "ZYX") {
      const m = o * d, v = o * p, b = a * d, x = a * p;
      t[0] = l * d, t[4] = b * c - v, t[8] = m * c + x, t[1] = l * p, t[5] = x * c + m, t[9] = v * c - b, t[2] = -c, t[6] = a * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      const m = o * l, v = o * c, b = a * l, x = a * c;
      t[0] = l * d, t[4] = x - m * p, t[8] = b * p + v, t[1] = p, t[5] = o * d, t[9] = -a * d, t[2] = -c * d, t[6] = v * p + b, t[10] = m - x * p;
    } else if (e.order === "XZY") {
      const m = o * l, v = o * c, b = a * l, x = a * c;
      t[0] = l * d, t[4] = -p, t[8] = c * d, t[1] = m * p + x, t[5] = o * d, t[9] = v * p - b, t[2] = b * p - v, t[6] = a * d, t[10] = x * p + m;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(tie, e, nie);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return Ls.subVectors(e, t), Ls.lengthSq() === 0 && (Ls.z = 1), Ls.normalize(), nc.crossVectors(i, Ls), nc.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Ls.x += 1e-4 : Ls.z += 1e-4, Ls.normalize(), nc.crossVectors(i, Ls)), nc.normalize(), O_.crossVectors(Ls, nc), r[0] = nc.x, r[4] = O_.x, r[8] = Ls.x, r[1] = nc.y, r[5] = O_.y, r[9] = Ls.y, r[2] = nc.z, r[6] = O_.z, r[10] = Ls.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[4], l = i[8], c = i[12], d = i[1], p = i[5], m = i[9], v = i[13], b = i[2], x = i[6], y = i[10], S = i[14], C = i[3], M = i[7], T = i[11], P = i[15], D = r[0], I = r[4], k = r[8], O = r[12], B = r[1], Y = r[5], G = r[9], K = r[13], A = r[2], J = r[6], xe = r[10], se = r[14], oe = r[3], Q = r[7], ce = r[11], te = r[15];
    return s[0] = o * D + a * B + l * A + c * oe, s[4] = o * I + a * Y + l * J + c * Q, s[8] = o * k + a * G + l * xe + c * ce, s[12] = o * O + a * K + l * se + c * te, s[1] = d * D + p * B + m * A + v * oe, s[5] = d * I + p * Y + m * J + v * Q, s[9] = d * k + p * G + m * xe + v * ce, s[13] = d * O + p * K + m * se + v * te, s[2] = b * D + x * B + y * A + S * oe, s[6] = b * I + x * Y + y * J + S * Q, s[10] = b * k + x * G + y * xe + S * ce, s[14] = b * O + x * K + y * se + S * te, s[3] = C * D + M * B + T * A + P * oe, s[7] = C * I + M * Y + T * J + P * Q, s[11] = C * k + M * G + T * xe + P * ce, s[15] = C * O + M * K + T * se + P * te, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], o = e[1], a = e[5], l = e[9], c = e[13], d = e[2], p = e[6], m = e[10], v = e[14], b = e[3], x = e[7], y = e[11], S = e[15];
    return b * (+s * l * p - r * c * p - s * a * m + i * c * m + r * a * v - i * l * v) + x * (+t * l * v - t * c * m + s * o * m - r * o * v + r * c * d - s * l * d) + y * (+t * c * p - t * a * v - s * o * p + i * o * v + s * a * d - i * c * d) + S * (-r * a * d - t * l * p + t * a * m + r * o * p - i * o * m + i * l * d);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], c = e[7], d = e[8], p = e[9], m = e[10], v = e[11], b = e[12], x = e[13], y = e[14], S = e[15], C = p * y * c - x * m * c + x * l * v - a * y * v - p * l * S + a * m * S, M = b * m * c - d * y * c - b * l * v + o * y * v + d * l * S - o * m * S, T = d * x * c - b * p * c + b * a * v - o * x * v - d * a * S + o * p * S, P = b * p * l - d * x * l - b * a * m + o * x * m + d * a * y - o * p * y, D = t * C + i * M + r * T + s * P;
    if (D === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const I = 1 / D;
    return e[0] = C * I, e[1] = (x * m * s - p * y * s - x * r * v + i * y * v + p * r * S - i * m * S) * I, e[2] = (a * y * s - x * l * s + x * r * c - i * y * c - a * r * S + i * l * S) * I, e[3] = (p * l * s - a * m * s - p * r * c + i * m * c + a * r * v - i * l * v) * I, e[4] = M * I, e[5] = (d * y * s - b * m * s + b * r * v - t * y * v - d * r * S + t * m * S) * I, e[6] = (b * l * s - o * y * s - b * r * c + t * y * c + o * r * S - t * l * S) * I, e[7] = (o * m * s - d * l * s + d * r * c - t * m * c - o * r * v + t * l * v) * I, e[8] = T * I, e[9] = (b * p * s - d * x * s - b * i * v + t * x * v + d * i * S - t * p * S) * I, e[10] = (o * x * s - b * a * s + b * i * c - t * x * c - o * i * S + t * a * S) * I, e[11] = (d * a * s - o * p * s - d * i * c + t * p * c + o * i * v - t * a * v) * I, e[12] = P * I, e[13] = (d * x * r - b * p * r + b * i * m - t * x * m - d * i * y + t * p * y) * I, e[14] = (b * a * r - o * x * r - b * i * l + t * x * l + o * i * y - t * a * y) * I, e[15] = (o * p * r - d * a * r + d * i * l - t * p * l - o * i * m + t * a * m) * I, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z;
    return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = 1 - i, o = e.x, a = e.y, l = e.z, c = s * o, d = s * a;
    return this.set(
      c * o + i,
      c * a - r * l,
      c * l + r * a,
      0,
      c * a + r * l,
      d * a + i,
      d * l - r * o,
      0,
      c * l - r * a,
      d * l + r * o,
      s * l * l + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(
      1,
      i,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, i) {
    const r = this.elements, s = t._x, o = t._y, a = t._z, l = t._w, c = s + s, d = o + o, p = a + a, m = s * c, v = s * d, b = s * p, x = o * d, y = o * p, S = a * p, C = l * c, M = l * d, T = l * p, P = i.x, D = i.y, I = i.z;
    return r[0] = (1 - (x + S)) * P, r[1] = (v + T) * P, r[2] = (b - M) * P, r[3] = 0, r[4] = (v - T) * D, r[5] = (1 - (m + S)) * D, r[6] = (y + C) * D, r[7] = 0, r[8] = (b + M) * I, r[9] = (y - C) * I, r[10] = (1 - (m + x)) * I, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = xd.set(r[0], r[1], r[2]).length();
    const o = xd.set(r[4], r[5], r[6]).length(), a = xd.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], So.copy(this);
    const c = 1 / s, d = 1 / o, p = 1 / a;
    return So.elements[0] *= c, So.elements[1] *= c, So.elements[2] *= c, So.elements[4] *= d, So.elements[5] *= d, So.elements[6] *= d, So.elements[8] *= p, So.elements[9] *= p, So.elements[10] *= p, t.setFromRotationMatrix(So), i.x = s, i.y = o, i.z = a, this;
  }
  makePerspective(e, t, i, r, s, o) {
    const a = this.elements, l = 2 * s / (t - e), c = 2 * s / (i - r), d = (t + e) / (t - e), p = (i + r) / (i - r), m = -(o + s) / (o - s), v = -2 * o * s / (o - s);
    return a[0] = l, a[4] = 0, a[8] = d, a[12] = 0, a[1] = 0, a[5] = c, a[9] = p, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = m, a[14] = v, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
  }
  makeOrthographic(e, t, i, r, s, o) {
    const a = this.elements, l = 1 / (t - e), c = 1 / (i - r), d = 1 / (o - s), p = (t + e) * l, m = (i + r) * c, v = (o + s) * d;
    return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -p, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -m, a[2] = 0, a[6] = 0, a[10] = -2 * d, a[14] = -v, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const xd = /* @__PURE__ */ new $i(), So = /* @__PURE__ */ new vl(), tie = /* @__PURE__ */ new $i(0, 0, 0), nie = /* @__PURE__ */ new $i(1, 1, 1), nc = /* @__PURE__ */ new $i(), O_ = /* @__PURE__ */ new $i(), Ls = /* @__PURE__ */ new $i(), j4 = /* @__PURE__ */ new vl(), q4 = /* @__PURE__ */ new $v();
class Zv {
  constructor(e = 0, t = 0, i = 0, r = Zv.DefaultOrder) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements, s = r[0], o = r[4], a = r[8], l = r[1], c = r[5], d = r[9], p = r[2], m = r[6], v = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(oc(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-d, v), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(m, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-oc(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(a, v), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-p, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(oc(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-p, v), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;
      case "ZYX":
        this._y = Math.asin(-oc(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(m, v), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
        break;
      case "YZX":
        this._z = Math.asin(oc(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-d, c), this._y = Math.atan2(-p, s)) : (this._x = 0, this._y = Math.atan2(a, v));
        break;
      case "XZY":
        this._z = Math.asin(-oc(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(m, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-d, v), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return j4.makeRotationFromQuaternion(e), this.setFromRotationMatrix(j4, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return q4.setFromEuler(this), this.setFromQuaternion(q4, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
}
Zv.DefaultOrder = "XYZ";
Zv.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class iie {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let rie = 0;
const X4 = /* @__PURE__ */ new $i(), wd = /* @__PURE__ */ new $v(), Qa = /* @__PURE__ */ new vl(), N_ = /* @__PURE__ */ new $i(), hm = /* @__PURE__ */ new $i(), sie = /* @__PURE__ */ new $i(), oie = /* @__PURE__ */ new $v(), $4 = /* @__PURE__ */ new $i(1, 0, 0), Z4 = /* @__PURE__ */ new $i(0, 1, 0), Y4 = /* @__PURE__ */ new $i(0, 0, 1), aie = { type: "added" }, K4 = { type: "removed" };
class yc extends Qne {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: rie++ }), this.uuid = eie(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = yc.DefaultUp.clone();
    const e = new $i(), t = new Zv(), i = new $v(), r = new $i(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s), i._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new vl()
      },
      normalMatrix: {
        value: new kC()
      }
    }), this.matrix = new vl(), this.matrixWorld = new vl(), this.matrixAutoUpdate = yc.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = yc.DefaultMatrixWorldAutoUpdate, this.layers = new iie(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return wd.setFromAxisAngle(e, t), this.quaternion.multiply(wd), this;
  }
  rotateOnWorldAxis(e, t) {
    return wd.setFromAxisAngle(e, t), this.quaternion.premultiply(wd), this;
  }
  rotateX(e) {
    return this.rotateOnAxis($4, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Z4, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Y4, e);
  }
  translateOnAxis(e, t) {
    return X4.copy(e).applyQuaternion(this.quaternion), this.position.add(X4.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis($4, e);
  }
  translateY(e) {
    return this.translateOnAxis(Z4, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Y4, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(Qa.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? N_.copy(e) : N_.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), hm.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Qa.lookAt(hm, N_, this.up) : Qa.lookAt(N_, hm, this.up), this.quaternion.setFromRotationMatrix(Qa), r && (Qa.extractRotation(r.matrixWorld), wd.setFromRotationMatrix(Qa), this.quaternion.premultiply(wd.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(aie)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(K4)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(K4);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Qa.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Qa.multiply(e.parent.matrixWorld)), e.applyMatrix4(Qa), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hm, e, sie), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hm, oie, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, d = l.length; c < d; c++) {
            const p = l[c];
            s(e.shapes, p);
          }
        else
          s(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else
        r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries), l = o(e.materials), c = o(e.textures), d = o(e.images), p = o(e.shapes), m = o(e.skeletons), v = o(e.animations), b = o(e.nodes);
      a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), d.length > 0 && (i.images = d), p.length > 0 && (i.shapes = p), m.length > 0 && (i.skeletons = m), v.length > 0 && (i.animations = v), b.length > 0 && (i.nodes = b);
    }
    return i.object = r, i;
    function o(a) {
      const l = [];
      for (const c in a) {
        const d = a[c];
        delete d.metadata, l.push(d);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
yc.DefaultUp = /* @__PURE__ */ new $i(0, 1, 0);
yc.DefaultMatrixAutoUpdate = !0;
yc.DefaultMatrixWorldAutoUpdate = !0;
const zS = new yc(), $O = (n) => {
  const e = Dn(n.outerObject3d).normalize();
  return zS.lookAt(e), zS.rotateX(xm), n.outerObject3d.quaternion.copy(zS.quaternion);
};
class Zb extends DI {
  constructor() {
    super(new ni(75, 1, uh, Mc));
    V(this, "lockTargetRotation", !0);
    const t = this.midObject3d = new wn();
    this.outerObject3d.add(t), t.add(this.object3d);
    const i = this.camera;
    bt.attach(i), this.then(() => bt.remove(i)), this.createEffect(() => {
      const a = this.foundState.get();
      !a || "frustumCulled" in a && (a.frustumCulled = !1);
    }, [this.foundState.get]);
    const r = (a, l) => {
      ui.setFromQuaternion(a.outerObject3d.quaternion), ui.y += Math.PI, l ? (bu.setFromEuler(ui), t.quaternion.slerp(bu, $u(0.1))) : t.setRotationFromEuler(ui), this.updateAngle();
    }, s = (a, l, c) => {
      if (ui.setFromQuaternion(this.midObject3d.quaternion), ui.x = 0, ui.z = 0, ui.y += Math.PI, c) {
        const p = wK(a);
        bu.copy(a.outerObject3d.quaternion);
        const m = p.rotation.y;
        a.outerObject3d.quaternion.copy(c), p.rotation.y = ui.y, ui.setFromQuaternion(gl(p)), p.rotation.y = m, a.outerObject3d.quaternion.copy(bu);
      }
      const d = iM.has(a);
      if (l && !d) {
        bu.setFromEuler(ui), a.outerObject3d.quaternion.slerp(bu, $u(0.1));
        return;
      }
      a.outerObject3d.setRotationFromEuler(ui), c && d && iM.delete(a);
    };
    let o = !1;
    this.createEffect(() => {
      const a = this.foundState.get();
      if (!a)
        return;
      r(a, !1);
      const l = ml(), c = Pn(() => {
        this.outerObject3d.position.copy(a.outerObject3d.position);
        const d = l ? $O(this) : void 0;
        if (!!this.lockTargetRotation) {
          if (this.lockTargetRotation === "follow" || o) {
            r(a, !1);
            return;
          }
          if (this.lockTargetRotation === "dynamic-lock") {
            Nb(a.outerObject3d) && s(a, !0, d);
            return;
          }
          if (this.lockTargetRotation === "dynamic-follow") {
            Nb(a.outerObject3d) && r(a, !0);
            return;
          }
          s(a, !1, d);
        }
      });
      return () => {
        c.cancel();
      };
    }, [this.foundState.get, ml]), this.createEffect(() => {
      const a = this.foundState.get(), l = Nn(), c = Io(), d = ro();
      if (!!(a && a === l && c && d === "rotate"))
        return o = !0, () => {
          o = !1;
        };
    }, [this.foundState.get, Nn, Io, ro]);
  }
}
V(Zb, "defaults", XO), V(Zb, "schema", qO);
const J4 = (n, e) => {
  "visible" in n && (n.visible = e);
};
let ZO = !1;
ft(() => {
  ZO = !ma() || Fs() && nt() === un;
}, [Fs, Fs, nt]);
class lf extends Zb {
  constructor() {
    super();
    V(this, "enableZoomState", new Je(!0));
    this.innerZ = 300, this.orbitMode = !0;
    const t = this.camera;
    import("./bvhCameraLoop.9b5a0e2a.mjs").then(() => {
      this.createEffect(() => {
        const i = this.foundState.get();
        if (!i) {
          const a = Pn(() => {
            t.position.copy(Dn(this.object3d)), t.quaternion.copy(gl(this.object3d));
          });
          return () => {
            a.cancel();
          };
        }
        let r = !0;
        J4(i, !r);
        let s = !0;
        const o = Yne(() => {
          const a = Dn(this.outerObject3d), l = Dn(this.object3d), c = l.distanceTo(a);
          t.position.lerp(l, s ? 1 : $u(0.1));
          const d = s ? 1 : t.position.distanceTo(a) / c;
          t.quaternion.copy(gl(this.object3d));
          const p = ZO ? !1 : d < 0.35;
          p !== r && J4(i, !p), r = p, s = !1;
        });
        return () => {
          o.cancel();
        };
      }, [this.foundState.get]);
    }), this.createEffect(() => {
      if (Io() || nt() !== t || !this.mouseControlState.get())
        return;
      const i = new Xn();
      if (this.enableZoomState.get()) {
        const r = (s) => {
          s.preventDefault(), this.innerZ < 1900 && this.innerZ > 10 && (this.innerZ += s.deltaY), this.innerZ >= 1900 && (this.innerZ = 1800), this.innerZ <= 80 && (this.innerZ = 90), this.innerZ < 0 && (this.innerZ = 0);
        };
        pn.addEventListener("wheel", r), i.then(() => pn.removeEventListener("wheel", r));
      }
      return () => {
        i.cancel();
      };
    }, [nt, Io, this.enableZoomState.get, this.mouseControlState.get]);
  }
  get enableZoom() {
    return this.enableZoomState.get();
  }
  set enableZoom(t) {
    this.enableZoomState.set(t);
  }
}
V(lf, "componentName", "thirdPersonCamera"), V(lf, "defaults", Jne), V(lf, "schema", Kne);
class ax extends Zb {
  constructor() {
    super();
    V(this, "innerYSetState", new Je(!1));
    this.watch(
      Pn(() => {
        this.camera.position.copy(Dn(this.object3d)), this.camera.quaternion.copy(gl(this.object3d));
      })
    ), this.createEffect(() => {
      const t = this.foundState.get(), i = this.innerYSetState.get();
      if (!(!t || !("height" in t) || i))
        return super.innerY = t.height * 0.4, () => {
          super.innerY = 0;
        };
    }, [this.foundState.get, this.innerYSetState.get]);
  }
  get innerY() {
    return super.innerY;
  }
  set innerY(t) {
    super.innerY = t, this.innerYSetState.set(!0);
  }
}
V(ax, "componentName", "firstPersonCamera");
const ab = (n) => {
  switch (n) {
    case "low":
      return 256;
    case "medium":
      return 512;
    case "high":
      return 1024;
    default:
      hy(n);
  }
};
class Yv extends mh {
  constructor(t, i) {
    super();
    V(this, "lightState", new Je(void 0));
    V(this, "helperState", new Je(!0));
    V(this, "castShadowState", new Je(!1));
    V(this, "shadowResolutionState", new Je(void 0));
    this.createEffect(() => {
      var s;
      const r = new t();
      return this.lightState.set(r), this.object3d.add(r), r.shadow && this.castShadowState.get() && (r.castShadow = !0, r.shadow.bias = Cy, r.shadow.mapSize.setScalar(
        ab(
          (s = this.shadowResolutionState.get()) != null ? s : _c()
        )
      )), () => {
        this.object3d.remove(r), r.dispose();
      };
    }, [
      this.castShadowState.get,
      this.shadowResolutionState.get,
      _c
    ]), this.createEffect(() => {
      const r = this.lightState.get();
      if (nt() !== un || !this.helperState.get() || !r)
        return;
      const s = new qv("light"), o = ph(s, this);
      if (i) {
        const a = new i(r);
        bt.add(a), a.add(s.outerObject3d), "update" in a && o.watch(Pn(() => a.update())), o.then(() => {
          a.dispose(), bt.remove(a);
        });
      }
      return () => {
        o.cancel();
      };
    }, [nt, this.helperState.get, this.lightState.get]);
  }
  get helper() {
    return this.helperState.get();
  }
  set helper(t) {
    this.helperState.set(t);
  }
  get castShadow() {
    return this.castShadowState.get();
  }
  set castShadow(t) {
    this.castShadowState.set(t);
  }
  get shadowResolution() {
    return this.shadowResolutionState.get();
  }
  set shadowResolution(t) {
    this.shadowResolutionState.set(t);
  }
  get color() {
    const t = this.lightState.get();
    return t ? "#" + t.color.getHexString() : "#ffffff";
  }
  set color(t) {
    this.cancelHandle(
      "color",
      () => this.lightState.get((i) => i == null ? void 0 : i.color.set(t))
    );
  }
  get intensity() {
    const t = this.lightState.get();
    return t ? t.intensity : 1;
  }
  set intensity(t) {
    this.cancelHandle(
      "intensity",
      () => this.lightState.get((i) => i && (i.intensity = t))
    );
  }
}
const lie = {
  ...Zf
}, cie = yt(
  [Yf],
  {}
);
class cf extends Yv {
  constructor() {
    super(Fq);
  }
}
V(cf, "componentName", "ambientLight"), V(cf, "defaults", cie), V(cf, "schema", lie);
class uie extends xy {
  constructor(e, t) {
    const i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], r = new qn();
    r.setAttribute("position", new en(i, 3)), r.computeBoundingSphere();
    const s = new kc({ fog: !1 });
    super(r, s), this.light = e, this.color = t, this.type = "RectAreaLightHelper";
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new qn();
    a.setAttribute("position", new en(o, 3)), a.computeBoundingSphere(), this.add(new wi(a, new vy({ side: cr, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const e = this.material.color, t = Math.max(e.r, e.g, e.b);
      t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const hie = {
  ...Zf
}, die = yt(
  [Yf],
  { depth: 0, scaleZ: 0 }
), [vde, YO] = di(), fie = iE(async () => {
  const { RectAreaLightUniformsLib: n } = await import("./RectAreaLightUniformsLib.7038c9a6.mjs");
  n.init();
});
class uf extends mh {
  constructor() {
    super();
    V(this, "light");
    V(this, "shadowResolution");
    V(this, "helperState", new Je(!0));
    V(this, "_color");
    V(this, "_intensity");
    V(this, "_width");
    V(this, "_height");
    V(this, "_scaleX");
    V(this, "_scaleY");
    V(this, "_castShadow");
    fie().then(() => {
      if (this.done)
        return;
      const t = this.light = new Bq(
        this._color,
        this._intensity,
        this.width * this.scaleX * Ut,
        this.height * this.scaleY * Ut
      );
      this.object3d.add(t), this.then(() => t.dispose()), this.createEffect(() => {
        if (ro() !== "scale" || Nn() !== this)
          return;
        const i = YO(() => {
          const { x: r, y: s } = this.outerObject3d.scale;
          this.scaleX = r, this.scaleY = s;
        });
        return () => {
          i.cancel();
        };
      }, [ro, Nn]), this.createEffect(() => {
        if (nt() !== un || !this.helperState.get())
          return;
        const i = new uie(t);
        return bt.add(i), Ub.add(i), Ds(i, this), mc.add(i), av.add(i), () => {
          i.dispose(), bt.remove(i), Ub.delete(i), mc.delete(i), av.delete(i);
        };
      }, [nt, this.helperState.get]);
    });
  }
  get helper() {
    return this.helperState.get();
  }
  set helper(t) {
    this.helperState.set(t);
  }
  get color() {
    var t;
    return (t = this._color) != null ? t : "#ffffff";
  }
  set color(t) {
    var i;
    this._color = t, (i = this.light) == null || i.color.set(t);
  }
  get intensity() {
    var t;
    return (t = this._intensity) != null ? t : 1;
  }
  set intensity(t) {
    this._intensity = t, this.light && (this.light.intensity = t);
  }
  get width() {
    var t;
    return (t = this._width) != null ? t : 100;
  }
  set width(t) {
    this._width = t, this.light && (this.light.width = t * this.scaleX * Ut);
  }
  get height() {
    var t;
    return (t = this._height) != null ? t : 100;
  }
  set height(t) {
    this._height = t, this.light && (this.light.height = t * this.scaleY * Ut);
  }
  get scaleX() {
    var t;
    return (t = this._scaleX) != null ? t : 1;
  }
  set scaleX(t) {
    this._scaleX = t, this.light && (this.light.width = t * this.width * Ut);
  }
  get scaleY() {
    var t;
    return (t = this._scaleY) != null ? t : 1;
  }
  set scaleY(t) {
    this._scaleY = t, this.light && (this.light.height = t * this.height * Ut);
  }
  get depth() {
    return 0;
  }
  set depth(t) {
  }
  get scaleZ() {
    return 0;
  }
  set scaleZ(t) {
  }
  get castShadow() {
    return !!this._castShadow;
  }
  set castShadow(t) {
    this._castShadow = t;
  }
}
V(uf, "componentName", "areaLight"), V(uf, "defaults", die), V(uf, "schema", hie);
const Q4 = (n) => {
  switch (n) {
    case "low":
      return 512;
    case "medium":
      return 1024;
    case "high":
      return 2048;
    default:
      hy(n);
  }
}, ek = (n) => {
  switch (n) {
    case "near":
      return 1e3;
    case "middle":
      return 3e3;
    case "far":
      return 1e4;
    default:
      hy(n);
  }
};
class Uu extends Yv {
  constructor() {
    super(ID);
    V(this, "shadowDistanceState", new Je(
      void 0
    ));
    this.createEffect(() => {
      const t = this.lightState.get();
      if (!!t)
        return bt.add(t.target), () => {
          bt.remove(t.target);
        };
    }, [this.lightState.get]), this.createEffect(() => {
      var o, a;
      const t = this.lightState.get();
      if (!t)
        return;
      const i = Ov(nt()), r = i ? Math.max(
        Z1(
          i.innerZ * (i.fov / 75) * (1 / i.zoom),
          500,
          1e3,
          1,
          1.5
        ),
        1
      ) : 1, s = t.shadow.camera;
      s.zoom = 500 / r / ek(
        (o = this.shadowDistanceState.get()) != null ? o : Mu()
      ), s.updateProjectionMatrix(), t.shadow.mapSize.setScalar(
        Q4(
          (a = this.shadowResolutionState.get()) != null ? a : _c()
        )
      );
    }, [
      this.lightState.get,
      this.shadowDistanceState.get,
      Mu,
      nt
    ]), this.createEffect(() => {
      const t = this.lightState.get();
      if (!t)
        return;
      const i = nt(), r = Pn(() => {
        const s = Dn(i), o = Dn(this.outerObject3d);
        t.position.copy(s).add(o), t.target.position.copy(s).sub(o);
      });
      return () => {
        r.cancel();
      };
    }, [nt, this.lightState.get]), this.createEffect(() => {
      var i, r;
      const t = this.lightState.get();
      !t || (t.shadow.bias = Cy * Z1(
        ek(
          (i = this.shadowDistanceState.get()) != null ? i : Mu()
        ),
        3e3,
        1e4,
        0.05,
        0.15
      ) * Z1(
        Q4(
          (r = this.shadowResolutionState.get()) != null ? r : _c()
        ),
        1024,
        256,
        1,
        4,
        !0
      ));
    }, [
      this.lightState.get,
      this.shadowDistanceState.get,
      Mu,
      this.shadowResolutionState.get,
      _c
    ]);
  }
  getWorldPosition() {
    return Po(Dn(this.outerObject3d));
  }
  get shadowDistance() {
    return this.shadowDistanceState.get();
  }
  set shadowDistance(t) {
    this.shadowDistanceState.set(t);
  }
}
V(Uu, "componentName", "directionalLight"), V(Uu, "defaults", vee), V(Uu, "schema", mee);
const pie = {
  ...Zf,
  shadowDistance: String,
  groundColor: String
}, mie = yt(
  [Yf],
  {
    groundColor: "#ffffff",
    shadowDistance: new Tn("middle")
  },
  {
    shadowDistance: fC
  }
), FS = new Pt();
class lx {
  constructor(e) {
    e = e || {}, this.vertices = {
      near: [
        new Z(),
        new Z(),
        new Z(),
        new Z()
      ],
      far: [
        new Z(),
        new Z(),
        new Z(),
        new Z()
      ]
    }, e.projectionMatrix !== void 0 && this.setFromProjectionMatrix(e.projectionMatrix, e.maxFar || 1e4);
  }
  setFromProjectionMatrix(e, t) {
    const i = e.elements[11] === 0;
    return FS.copy(e).invert(), this.vertices.near[0].set(1, 1, -1), this.vertices.near[1].set(1, -1, -1), this.vertices.near[2].set(-1, -1, -1), this.vertices.near[3].set(-1, 1, -1), this.vertices.near.forEach(function(r) {
      r.applyMatrix4(FS);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function(r) {
      r.applyMatrix4(FS);
      const s = Math.abs(r.z);
      i ? r.z *= Math.min(t / s, 1) : r.multiplyScalar(Math.min(t / s, 1));
    }), this.vertices;
  }
  split(e, t) {
    for (; e.length > t.length; )
      t.push(new lx());
    t.length = e.length;
    for (let i = 0; i < e.length; i++) {
      const r = t[i];
      if (i === 0)
        for (let s = 0; s < 4; s++)
          r.vertices.near[s].copy(this.vertices.near[s]);
      else
        for (let s = 0; s < 4; s++)
          r.vertices.near[s].lerpVectors(this.vertices.near[s], this.vertices.far[s], e[i - 1]);
      if (i === e.length - 1)
        for (let s = 0; s < 4; s++)
          r.vertices.far[s].copy(this.vertices.far[s]);
      else
        for (let s = 0; s < 4; s++)
          r.vertices.far[s].lerpVectors(this.vertices.near[s], this.vertices.far[s], e[i]);
    }
  }
  toSpace(e, t) {
    for (let i = 0; i < 4; i++)
      t.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(e), t.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(e);
  }
}
const tk = {
  lights_fragment_begin: `
GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );

	  	#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
			// NOTE: Depth gets larger away from the camera.
			// cascade.x is closer, cascade.y is further
			cascade = CSM_cascades[ i ];
			cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
			closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
			margin = 0.25 * pow( closestEdge, 2.0 );
			csmx = cascade.x - margin / 2.0;
			csmy = cascade.y + margin / 2.0;
			if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

				float dist = min( linearDepth - csmx, csmy - linearDepth );
				float ratio = clamp( dist / margin, 0.0, 1.0 );

				vec3 prevColor = directLight.color;
				directionalLightShadow = directionalLightShadows[ i ];
				directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
				directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

				ReflectedLight prevLight = reflectedLight;
				RE_Direct( directLight, geometry, material, reflectedLight );

				bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
				float blendRatio = shouldBlend ? ratio : 1.0;

				reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
				reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
				reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
				reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

			}
	  	#endif

	}
	#pragma unroll_loop_end
	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, geometry, directLight );

			#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

			directionalLightShadow = directionalLightShadows[ i ];
			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, geometry, directLight );

			RE_Direct( directLight, geometry, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,
  lights_pars_begin: `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + Nt.lights_pars_begin
}, nk = new Pt(), BS = new lx(), el = new Z(), dm = new so(), US = [], VS = [];
class vie {
  constructor(e) {
    e = e || {}, this.camera = e.camera, this.parent = e.parent, this.cascades = e.cascades || 3, this.maxFar = e.maxFar || 1e5, this.mode = e.mode || "practical", this.shadowMapSize = e.shadowMapSize || 2048, this.shadowBias = e.shadowBias || 1e-6, this.lightDirection = e.lightDirection || new Z(1, -1, 1).normalize(), this.lightIntensity = e.lightIntensity || 1, this.lightNear = e.lightNear || 1, this.lightFar = e.lightFar || 2e3, this.lightMargin = e.lightMargin || 200, this.customSplitsCallback = e.customSplitsCallback, this.fade = !1, this.mainFrustum = new lx(), this.frustums = [], this.breaks = [], this.lights = [], this.shaders = /* @__PURE__ */ new Map(), this.createLights(), this.updateFrustums(), this.injectInclude();
  }
  createLights() {
    for (let e = 0; e < this.cascades; e++) {
      const t = new ID(16777215, this.lightIntensity);
      t.castShadow = !0, t.shadow.mapSize.width = this.shadowMapSize, t.shadow.mapSize.height = this.shadowMapSize, t.shadow.camera.near = this.lightNear, t.shadow.camera.far = this.lightFar, t.shadow.bias = this.shadowBias, this.parent.add(t), this.parent.add(t.target), this.lights.push(t);
    }
  }
  initCascades() {
    const e = this.camera;
    e.updateProjectionMatrix(), this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this.maxFar), this.mainFrustum.split(this.breaks, this.frustums);
  }
  updateShadowBounds() {
    const e = this.frustums;
    for (let t = 0; t < e.length; t++) {
      const r = this.lights[t].shadow.camera, s = this.frustums[t], o = s.vertices.near, a = s.vertices.far, l = a[0];
      let c;
      l.distanceTo(a[2]) > l.distanceTo(o[2]) ? c = a[2] : c = o[2];
      let d = l.distanceTo(c);
      if (this.fade) {
        const p = this.camera, m = Math.max(p.far, this.maxFar), v = s.vertices.far[0].z / (m - p.near), b = 0.25 * Math.pow(v, 2) * (m - p.near);
        d += b;
      }
      r.left = -d / 2, r.right = d / 2, r.top = d / 2, r.bottom = -d / 2, r.updateProjectionMatrix();
    }
  }
  getBreaks() {
    const e = this.camera, t = Math.min(e.far, this.maxFar);
    switch (this.breaks.length = 0, this.mode) {
      case "uniform":
        i(this.cascades, e.near, t, this.breaks);
        break;
      case "logarithmic":
        r(this.cascades, e.near, t, this.breaks);
        break;
      case "practical":
        s(this.cascades, e.near, t, 0.5, this.breaks);
        break;
      case "custom":
        this.customSplitsCallback === void 0 && console.error("CSM: Custom split scheme callback not defined."), this.customSplitsCallback(this.cascades, e.near, t, this.breaks);
        break;
    }
    function i(o, a, l, c) {
      for (let d = 1; d < o; d++)
        c.push((a + (l - a) * d / o) / l);
      c.push(1);
    }
    function r(o, a, l, c) {
      for (let d = 1; d < o; d++)
        c.push(a * (l / a) ** (d / o) / l);
      c.push(1);
    }
    function s(o, a, l, c, d) {
      US.length = 0, VS.length = 0, r(o, a, l, VS), i(o, a, l, US);
      for (let p = 1; p < o; p++)
        d.push(Pm.lerp(US[p - 1], VS[p - 1], c));
      d.push(1);
    }
  }
  update() {
    const e = this.camera, t = this.frustums;
    for (let i = 0; i < t.length; i++) {
      const r = this.lights[i], s = r.shadow.camera, o = (s.right - s.left) / this.shadowMapSize, a = (s.top - s.bottom) / this.shadowMapSize;
      r.shadow.camera.updateMatrixWorld(!0), nk.multiplyMatrices(r.shadow.camera.matrixWorldInverse, e.matrixWorld), t[i].toSpace(nk, BS);
      const l = BS.vertices.near, c = BS.vertices.far;
      dm.makeEmpty();
      for (let d = 0; d < 4; d++)
        dm.expandByPoint(l[d]), dm.expandByPoint(c[d]);
      dm.getCenter(el), el.z = dm.max.z + this.lightMargin, el.x = Math.floor(el.x / o) * o, el.y = Math.floor(el.y / a) * a, el.applyMatrix4(r.shadow.camera.matrixWorld), r.position.copy(el), r.target.position.copy(el), r.target.position.x += this.lightDirection.x, r.target.position.y += this.lightDirection.y, r.target.position.z += this.lightDirection.z;
    }
  }
  injectInclude() {
    Nt.lights_fragment_begin = tk.lights_fragment_begin, Nt.lights_pars_begin = tk.lights_pars_begin;
  }
  setupMaterial(e) {
    e.defines = e.defines || {}, e.defines.USE_CSM = 1, e.defines.CSM_CASCADES = this.cascades, this.fade && (e.defines.CSM_FADE = "");
    const t = [], i = this, r = this.shaders;
    e.onBeforeCompile = function(s) {
      const o = Math.min(i.camera.far, i.maxFar);
      i.getExtendedBreaks(t), s.uniforms.CSM_cascades = { value: t }, s.uniforms.cameraNear = { value: i.camera.near }, s.uniforms.shadowFar = { value: o }, r.set(e, s);
    }, r.set(e, null);
  }
  updateUniforms() {
    const e = Math.min(this.camera.far, this.maxFar);
    this.shaders.forEach(function(i, r) {
      if (i !== null) {
        const s = i.uniforms;
        this.getExtendedBreaks(s.CSM_cascades.value), s.cameraNear.value = this.camera.near, s.shadowFar.value = e;
      }
      !this.fade && "CSM_FADE" in r.defines ? (delete r.defines.CSM_FADE, r.needsUpdate = !0) : this.fade && !("CSM_FADE" in r.defines) && (r.defines.CSM_FADE = "", r.needsUpdate = !0);
    }, this);
  }
  getExtendedBreaks(e) {
    for (; e.length < this.breaks.length; )
      e.push(new ze());
    e.length = this.breaks.length;
    for (let t = 0; t < this.cascades; t++) {
      const i = this.breaks[t], r = this.breaks[t - 1] || 0;
      e[t].x = r, e[t].y = i;
    }
  }
  updateFrustums() {
    this.getBreaks(), this.initCascades(), this.updateShadowBounds(), this.updateUniforms();
  }
  remove() {
    for (let e = 0; e < this.lights.length; e++)
      this.parent.remove(this.lights[e]);
  }
  dispose() {
    const e = this.shaders;
    e.forEach(function(t, i) {
      delete i.onBeforeCompile, delete i.defines.USE_CSM, delete i.defines.CSM_CASCADES, delete i.defines.CSM_FADE, t !== null && (delete t.uniforms.CSM_cascades, delete t.uniforms.cameraNear, delete t.uniforms.shadowFar), i.needsUpdate = !0;
    }), e.clear();
  }
}
const gie = (n, e) => {
  switch (n) {
    case "near":
      return {
        maxFar: 10,
        shadowMapSize: ab(e) * 2,
        shadowBias: -25e-6
      };
    case "middle":
      return {
        maxFar: 30,
        shadowMapSize: ab(e) * 2,
        shadowBias: -55e-6
      };
    case "far":
      return {
        maxFar: 100,
        shadowMapSize: ab(e) * 4,
        shadowBias: -1e-4
      };
    default:
      hy(n);
  }
};
class Vu extends Yv {
  constructor() {
    super(Lq);
    V(this, "shadowDistanceState", new Je(
      void 0
    ));
    this.createEffect(() => {
      var s, o;
      if (!this.castShadowState.get()) {
        const a = new Uu();
        a.intensity = 0.5, this.append(a), ko.add(a);
        const l = this.helperState.get(
          (c) => a.helper = c
        );
        return () => {
          a.dispose(), l.cancel();
        };
      }
      const t = new vie({
        ...gie(
          (s = this.shadowDistanceState.get()) != null ? s : Mu(),
          (o = this.shadowResolutionState.get()) != null ? o : _c()
        ),
        cascades: 1,
        parent: bt,
        camera: nt(),
        lightIntensity: 0.5
      }), i = Pn(() => {
        const a = this.outerObject3d.position.clone().normalize().multiplyScalar(-1);
        t.lightDirection = a, t.update();
      }), r = nt((a) => {
        t.camera = a;
      });
      return () => {
        i.cancel(), r.cancel(), t.dispose();
        for (const a of t.lights)
          a.dispose(), bt.remove(a);
      };
    }, [
      this.castShadowState.get,
      this.shadowDistanceState.get,
      Mu,
      _c
    ]);
  }
  get shadowDistance() {
    return this.shadowDistanceState.get();
  }
  set shadowDistance(t) {
    this.shadowDistanceState.set(t);
  }
  get groundColor() {
    const t = this.lightState.get();
    return t ? "#" + t.groundColor.getHexString() : "#ffffff";
  }
  set groundColor(t) {
    this.cancelHandle(
      "groundColor",
      () => this.lightState.get(
        (i) => i && (i.groundColor = new xt(t))
      )
    );
  }
}
V(Vu, "componentName", "skyLight"), V(Vu, "defaults", mie), V(Vu, "schema", pie);
const _ie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Vu
}, Symbol.toStringTag, { value: "Module" })), bie = {
  ...Zf,
  decay: Number,
  distance: Number
}, yie = yt(
  [Yf],
  { decay: 1, distance: 0 }
);
class hf extends Yv {
  constructor() {
    super(Nq), this.createEffect(() => {
      const e = this.lightState.get();
      !e || (e.shadow.bias = Cy * 0.15);
    }, [this.lightState.get]);
  }
  get decay() {
    const e = this.lightState.get();
    return e ? e.decay : 1;
  }
  set decay(e) {
    this.cancelHandle(
      "decay",
      () => this.lightState.get((t) => t && (t.decay = e))
    );
  }
  get distance() {
    const e = this.lightState.get();
    return e ? e.distance : 0;
  }
  set distance(e) {
    this.cancelHandle(
      "distance",
      () => this.lightState.get((t) => t && (t.distance = e))
    );
  }
}
V(hf, "componentName", "pointLight"), V(hf, "defaults", yie), V(hf, "schema", bie);
const xie = {
  ...Zf,
  angle: Number,
  penumbra: Number,
  decay: Number,
  distance: Number,
  targetX: Number,
  targetY: Number,
  targetZ: Number
}, wie = yt(
  [Yf],
  {
    angle: 1,
    penumbra: 0,
    decay: 1,
    distance: 0,
    targetX: 0,
    targetY: 0,
    targetZ: 0
  }
);
class Hu extends Yv {
  constructor() {
    super(Iq, sX);
    V(this, "targetSprite", new qv("target"));
    this.createEffect(() => {
      const t = this.lightState.get();
      if (!!t)
        return t.shadow.bias = Cy * 1.5, t.position.y = -0.01, this.targetSprite.outerObject3d.add(t.target), () => {
          this.targetSprite.outerObject3d.remove(t.target);
        };
    }, [this.lightState.get]), this.targetSprite.scale = 0.25, this.watch(
      nt(
        (t) => this.targetSprite.visible = t === un
      )
    ), this.then(() => this.targetSprite.dispose());
  }
  get angle() {
    const t = this.lightState.get();
    return t ? t.angle : 1;
  }
  set angle(t) {
    this.cancelHandle(
      "angle",
      () => this.lightState.get((i) => i && (i.angle = t))
    );
  }
  get penumbra() {
    const t = this.lightState.get();
    return t ? t.penumbra : 0;
  }
  set penumbra(t) {
    this.cancelHandle(
      "penumbra",
      () => this.lightState.get((i) => i && (i.penumbra = t))
    );
  }
  get decay() {
    const t = this.lightState.get();
    return t ? t.decay : 1;
  }
  set decay(t) {
    this.cancelHandle(
      "decay",
      () => this.lightState.get((i) => i && (i.decay = t))
    );
  }
  get distance() {
    const t = this.lightState.get();
    return t ? t.distance : 0;
  }
  set distance(t) {
    this.cancelHandle(
      "distance",
      () => this.lightState.get((i) => i && (i.distance = t))
    );
  }
  get targetX() {
    return this.targetSprite.x;
  }
  set targetX(t) {
    this.targetSprite.x = t;
  }
  get targetY() {
    return this.targetSprite.y;
  }
  set targetY(t) {
    this.targetSprite.y = t;
  }
  get targetZ() {
    return this.targetSprite.z;
  }
  set targetZ(t) {
    this.targetSprite.z = t;
  }
}
V(Hu, "componentName", "spotLight"), V(Hu, "defaults", wie), V(Hu, "schema", xie);
const Sie = {
  ..._s,
  onKeyPress: Function,
  onKeyUp: Function,
  onKeyDown: Function
}, Mie = yt(
  [bs],
  {
    onKeyPress: void 0,
    onKeyUp: void 0,
    onKeyDown: void 0
  }
), [Eie, Cie] = di(), [ik, Tie] = di(), [rk, Pie] = di(), jr = /* @__PURE__ */ new Set(), sk = (n) => (n = n.length === 1 ? n.toLocaleLowerCase() : n, n === " " && (n = "Space"), n);
ft(() => {
  if (!ma() || Fs() && nt() === un)
    return;
  const n = Pn(() => jr.size > 0 && rk()), e = (i) => {
    const r = sk(i.key);
    jr.add(r), Eie(r);
  }, t = (i) => {
    const r = sk(i.key);
    jr.delete(r), ik(r), !jr.size && rk();
  };
  return n.watch(
    Xy(() => {
      if (!jr.size)
        return;
      const i = [...jr];
      jr.clear();
      for (const r of i)
        ik(r);
    })
  ), document.addEventListener("keydown", e), document.addEventListener("keyup", t), () => {
    n.cancel(), document.removeEventListener("keydown", e), document.removeEventListener("keyup", t);
  };
}, [ma, Fs, nt]);
class Gu extends Ii {
  constructor() {
    super();
    V(this, "onKeyPress");
    V(this, "onKeyUp");
    V(this, "onKeyDown");
    this.watch(
      Pie(() => {
        if (!!this.onKeyPress) {
          if (!jr.size) {
            this.onKeyPress("", jr);
            return;
          }
          for (const t of jr)
            this.onKeyPress(t, jr);
        }
      })
    ), this.watch(Tie((t) => {
      var i;
      return (i = this.onKeyUp) == null ? void 0 : i.call(this, t, jr);
    })), this.watch(Cie((t) => {
      var i;
      return (i = this.onKeyDown) == null ? void 0 : i.call(this, t, jr);
    }));
  }
}
V(Gu, "componentName", "keyboard"), V(Gu, "defaults", Mie), V(Gu, "schema", Sie);
const KO = new Gu();
Zr.delete(KO);
const Aie = {};
"getGamepads" in navigator && Pn(() => {
  for (const n of navigator.getGamepads())
    if (!!n) {
      for (let e = 0; e < n.buttons.length; e++) {
        const t = n.buttons[e], i = Math.round(t.value * 100) + "%";
        t.pressed && console.log(e, t.value, t.pressed, i);
      }
      for (let e = 0; e < n.axes.length; e++) {
        const t = Number(n.axes[e].toFixed(2));
        t !== 0 && console.log(e, t);
      }
    }
});
const Rie = () => {
  let n;
  const e = {};
  return new Proxy(e, {
    get(t, i) {
      var r;
      return (r = n == null ? void 0 : n[i]) != null ? r : e[i];
    },
    set(t, i, r) {
      if (i === "__target") {
        n = r;
        for (const [s, o] of Object.entries(e))
          r[s] = o;
        return !0;
      }
      return e[i] = r, n && (n[i] = r), !0;
    }
  });
}, JO = /* @__PURE__ */ new Map(), LC = (n) => {
  var e, t;
  return JO.get((t = (e = dy(n)[1]) === null || e === void 0 ? void 0 : e.toLowerCase()) !== null && t !== void 0 ? t : "");
}, Kv = (n, e) => {
  for (const t of e)
    JO.set(t, n);
  return e;
};
Kv("image", [
  "jpg",
  "jpeg",
  "gif",
  "png",
  "svg",
  "tiff",
  "webp",
  "hdr"
]);
Kv("audio", [
  "m4a",
  "mp3",
  "wav",
  "wma",
  "ogg",
  "flax",
  "flac",
  "aac"
]);
Kv("plainText", [
  "ls",
  "js",
  "ts",
  "jsx",
  "tsx",
  "py",
  "txt",
  "md",
  "json",
  "yaml",
  "c",
  "cpp",
  "h",
  "hpp",
  "css",
  "scss",
  "sass",
  "html"
]);
Kv("model", [
  "gltf",
  "glb",
  "fbx"
]);
Kv("scene", [
  "l3d"
]);
const kie = /* @__PURE__ */ new Map(), Lie = (n) => Mr(
  kie,
  n,
  () => new Promise((e) => {
    const t = n.startsWith("https://unpkg.com/");
    t && ky();
    const i = Wr(n, () => {
      t && Ly(), e(i);
    });
  })
), Die = (n) => new Promise(async (e) => {
  const { default: t } = await Promise.resolve().then(() => Fee), i = new t(!0);
  i.src = n, i.onLoad = e;
}), DC = async (n, e, t) => {
  const i = [];
  let r = 0;
  if (typeof e == "number")
    r = e;
  else if (e = e.toLowerCase(), e.endsWith("kb"))
    r = parseFloat(e) * 1024;
  else if (e.endsWith("mb"))
    r = parseFloat(e) * 1024 * 1024;
  else if (e.endsWith("gb"))
    r = parseFloat(e) * 1024 * 1024 * 1024;
  else
    throw new Error("Invalid preload total value: " + e);
  const s = (o) => {
    t == null || t(
      r <= 0 ? 0 : Math.min(o / r * 100, 99)
    );
  };
  GX(s);
  for (const o of n) {
    const a = o.includes("json"), l = LC(o);
    l === "image" ? i.push(Lie(o)) : (l === "model" || a) && i.push(Die(o));
  }
  await Promise.all(i), WX(s), await new Promise((o) => {
    Ty((a, l) => {
      a > 0 || (l.cancel(), o());
    });
  }), t == null || t(100);
}, Iie = {
  toBlob: async () => new Promise((n) => {
    Ec(() => {
      var e;
      (e = Ln()) == null || e.domElement.toBlob(
        (t) => t && n(t)
      );
    }, !0);
  }),
  toDataURL: async (n, e) => new Promise((t) => {
    Ec(() => {
      const i = Ln();
      i && t(i.domElement.toDataURL(n, e));
    }, !0);
  })
}, Oie = (n, e) => {
  if (n === e)
    return "";
  for (var t = 1; t < n.length && n.charCodeAt(t) === 47; ++t)
    ;
  for (var i = n.length, r = i - t, s = 1; s < e.length && e.charCodeAt(s) === 47; ++s)
    ;
  for (var o = e.length, a = o - s, l = r < a ? r : a, c = -1, d = 0; d <= l; ++d) {
    if (d === l) {
      if (a > l) {
        if (e.charCodeAt(s + d) === 47)
          return e.slice(s + d + 1);
        if (d === 0)
          return e.slice(s + d);
      } else
        r > l && (n.charCodeAt(t + d) === 47 ? c = d : d === 0 && (c = 0));
      break;
    }
    var p = n.charCodeAt(t + d), m = e.charCodeAt(s + d);
    if (p !== m)
      break;
    p === 47 && (c = d);
  }
  var v = "";
  for (d = t + c + 1; d <= i; ++d)
    (d === i || n.charCodeAt(d) === 47) && (v.length === 0 ? v += ".." : v += "/..");
  return v.length > 0 ? v + e.slice(s + c) : (s += c, e.charCodeAt(s) === 47 && ++s, e.slice(s));
}, Nie = (n, e) => {
  const t = Oie(pO(n), e);
  return mO(t) ? t : "./" + t;
}, Ad = (n, e) => Number(e.toFixed(2)), ok = (n) => "z" in n ? {
  x: Ad("x", n.x),
  y: Ad("y", n.y),
  z: Ad("z", n.z)
} : {
  x: Ad("x", n.x),
  y: Ad("y", n.y)
}, Hm = (n, e = typeof n) => n && e === "object" && "x" in n && "y" in n, QO = [
  "type",
  "children",
  "scale",
  "rotation",
  "velocity",
  "target",
  "proxy",
  "uiLayer",
  "gridHelper",
  "gridHelperSize",
  "stats",
  "paused"
], RM = async (n, e) => {
  const t = [];
  for (const i of n) {
    if (ko.has(i) || AE.has(i))
      continue;
    const { componentName: r, schema: s, defaults: o } = i.constructor, a = { type: r };
    for (const [l, c] of Object.entries(s)) {
      if (c === Function || Array.isArray(c) && c.includes(Function) || QO.includes(l) || e && l === "uuid")
        continue;
      let d;
      if (l === "animations") {
        if (d = i.serializeAnimations, !d)
          continue;
      } else if (l === "animation") {
        if (d = i.serializeAnimation, !d)
          continue;
      } else
        d = i[l];
      const p = typeof d;
      if (bee(d, o, l) || p === "function")
        continue;
      const m = pv();
      if (p === "string" && d.startsWith("blob:http") && m) {
        const v = xC.get(d);
        d = Nie(
          m.webkitRelativePath,
          v.webkitRelativePath
        );
      } else
        p === "number" ? d = Ad(l, d) : Hm(d, p) ? d = ok(d) : Array.isArray(d) && d.some((v) => Hm(v)) && (d = d.map((v) => Hm(v) ? ok(v) : v));
      a[l] = d;
    }
    if (i.children) {
      const l = await RM(i.children, e);
      l.length && (a.children = l);
    }
    t.push(a);
  }
  return t;
}, Jf = async (n, e = Zr, t) => {
  if (e instanceof Ii)
    return RM([e], t);
  const i = [];
  for (const o of e)
    !(o instanceof Ao) && i.push(o);
  const r = new Ao(!0);
  Object.assign(r, Xr), i.push(r);
  const s = await RM(i, t);
  return n && s.unshift({ type: "lingo3d", version: e5 }), r.dispose(), s;
}, zie = VV({
  group: () => new Bu(),
  model: () => new gs(),
  svgMesh: () => new zu(),
  htmlMesh: () => new Kd(),
  joystick: () => new Jd(),
  reticle: () => new Qd(),
  splashScreen: () => new Um(),
  text: () => new Vm(),
  dummy: () => new Zd(),
  building: () => new Fm(),
  tree: () => new Bm(),
  reflector: () => new ef(),
  water: () => new tf(),
  curve: () => new nf(),
  sprite: () => new gc(),
  trigger: () => new rf(),
  spawnPoint: () => new sf(),
  audio: () => new of(),
  camera: () => new af(),
  thirdPersonCamera: () => new lf(),
  firstPersonCamera: () => new ax(),
  orbitCamera: () => new Iu(),
  ambientLight: () => new cf(),
  areaLight: () => new uf(),
  directionalLight: () => new Uu(),
  skyLight: () => new Vu(),
  pointLight: () => new hf(),
  spotLight: () => new Hu(),
  circle: () => new Xd(),
  cone: () => new tx(),
  cube: () => new qy(),
  cylinder: () => new nx(),
  octahedron: () => new ix(),
  plane: () => new qd(),
  sphere: () => new ex(),
  tetrahedron: () => new sx(),
  torus: () => new ox(),
  skybox: () => new Nu(),
  environment: () => new Ou(),
  setup: () => new Ao(),
  timeline: () => new bc(),
  timelineAudio: () => new vc()
}), e6 = (n) => zie[n](), t6 = (n, e) => {
  var i;
  if (n.type === "lingo3d")
    return;
  const t = e6(n.type);
  return e && t instanceof jv && e.push(t.loaded), Object.assign(t, lr.exports.omit(n, QO)), (i = n.children) == null || i.map((r) => t6(r, e)).forEach((r) => r && t.append(r)), t;
}, IC = (n, e) => n.map((t) => t6(t, e)), n6 = (n, e) => {
  const t = document.createElement("a"), i = t.href = URL.createObjectURL(e);
  t.download = n, document.body.appendChild(t), t.click(), t.remove(), URL.revokeObjectURL(i);
}, cx = (n, e) => {
  const t = new Blob([e], { type: "text/plain" });
  n6(n, t);
}, i6 = async () => {
  const { default: n } = await import("./standalone.f2272d76.mjs").then((i) => i.s), { default: e } = await import("./parser-babel.9831a210.mjs").then((i) => i.p), t = n.format(JSON.stringify(await Jf(!0)), {
    parser: "json",
    plugins: [e]
  });
  cx("scene.json", t);
}, r6 = (n) => {
  let e = "";
  for (const t of n) {
    const i = lr.exports.upperFirst(t.type);
    let r = "";
    for (const [s, o] of Object.entries(t))
      s === "children" || s === "type" || (typeof o == "string" ? r += ` ${s}="${o}"` : o === !0 ? r += ` ${s}` : typeof o == "object" ? r += ` ${s}={${JSON.stringify(o)}}` : r += ` ${s}={${o}}`);
    e += "children" in t && t.children ? `<${i}${r}>${r6(
      t.children
    )}</${i}>` : `<${i}${r} />`;
  }
  return e;
}, s6 = async () => {
  const n = (await import("./standalone.f2272d76.mjs").then((i) => i.s)).default, e = (await import("./parser-babel.9831a210.mjs").then((i) => i.p)).default, t = n.format(
    `const App = () => {
            return (
                <World>
                    ${r6(await Jf())}
                </World>
            )
        }`,
    { parser: "babel", plugins: [e] }
  );
  cx("App.jsx", t);
}, o6 = (n) => {
  let e = "";
  for (const t of n) {
    const i = lr.exports.upperFirst(t.type);
    let r = "";
    for (let [s, o] of Object.entries(t))
      s === "children" || s === "type" || (s = lr.exports.kebabCase(s), typeof o == "string" ? r += ` ${s}='${o}'` : o === !0 ? r += ` ${s}` : typeof o == "object" ? r += ` :${s}='${JSON.stringify(o)}'` : r += ` :${s}='${o}'`);
    e += "children" in t && t.children ? `<${i}${r}>
${o6(
      t.children
    )}</${i}>
` : `<${i}${r} />
`;
  }
  return e;
}, a6 = async () => {
  const n = (await import("./standalone.f2272d76.mjs").then((i) => i.s)).default, e = (await import("./parser-html.e5e56f20.mjs").then((i) => i.p)).default, t = n.format(
    `<template>
            <World>
                ${o6(await Jf())}
            </World>
        </template>`,
    { parser: "vue", plugins: [e] }
  );
  cx("App.vue", t);
}, ux = (() => {
  if (typeof self > "u")
    return !1;
  if ("top" in self && self !== top)
    try {
    } catch {
      return !1;
    }
  else if ("showOpenFilePicker" in self)
    return "showOpenFilePicker";
  return !1;
})(), Fie = ux ? Promise.resolve().then(function() {
  return Wie;
}) : Promise.resolve().then(function() {
  return Xie;
});
async function Bie(...n) {
  return (await Fie).default(...n);
}
const Uie = ux ? Promise.resolve().then(function() {
  return jie;
}) : Promise.resolve().then(function() {
  return $ie;
});
async function l6(...n) {
  return (await Uie).default(...n);
}
const Vie = ux ? Promise.resolve().then(function() {
  return qie;
}) : Promise.resolve().then(function() {
  return Zie;
});
async function Hie(...n) {
  return (await Vie).default(...n);
}
const Gie = async (n) => {
  const e = await n.getFile();
  return e.handle = n, e;
};
var c6 = async (n = [{}]) => {
  Array.isArray(n) || (n = [n]);
  const e = [];
  n.forEach((r, s) => {
    e[s] = { description: r.description || "Files", accept: {} }, r.mimeTypes ? r.mimeTypes.map((o) => {
      e[s].accept[o] = r.extensions || [];
    }) : e[s].accept["*/*"] = r.extensions || [];
  });
  const t = await window.showOpenFilePicker({ id: n[0].id, startIn: n[0].startIn, types: e, multiple: n[0].multiple || !1, excludeAcceptAllOption: n[0].excludeAcceptAllOption || !1 }), i = await Promise.all(t.map(Gie));
  return n[0].multiple ? i : i[0];
}, Wie = { __proto__: null, default: c6 };
function lb(n) {
  function e(t) {
    if (Object(t) !== t)
      return Promise.reject(new TypeError(t + " is not an object."));
    var i = t.done;
    return Promise.resolve(t.value).then(function(r) {
      return { value: r, done: i };
    });
  }
  return lb = function(t) {
    this.s = t, this.n = t.next;
  }, lb.prototype = { s: null, n: null, next: function() {
    return e(this.n.apply(this.s, arguments));
  }, return: function(t) {
    var i = this.s.return;
    return i === void 0 ? Promise.resolve({ value: t, done: !0 }) : e(i.apply(this.s, arguments));
  }, throw: function(t) {
    var i = this.s.return;
    return i === void 0 ? Promise.reject(t) : e(i.apply(this.s, arguments));
  } }, new lb(n);
}
const u6 = async (n, e, t = n.name, i) => {
  const r = [], s = [];
  var o, a = !1, l = !1;
  try {
    for (var c, d = function(p) {
      var m, v, b, x = 2;
      for (typeof Symbol < "u" && (v = Symbol.asyncIterator, b = Symbol.iterator); x--; ) {
        if (v && (m = p[v]) != null)
          return m.call(p);
        if (b && (m = p[b]) != null)
          return new lb(m.call(p));
        v = "@@asyncIterator", b = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }(n.values()); a = !(c = await d.next()).done; a = !1) {
      const p = c.value, m = `${t}/${p.name}`;
      p.kind === "file" ? s.push(p.getFile().then((v) => (v.directoryHandle = n, v.handle = p, Object.defineProperty(v, "webkitRelativePath", { configurable: !0, enumerable: !0, get: () => m })))) : p.kind !== "directory" || !e || i && i(p) || r.push(u6(p, e, m, i));
    }
  } catch (p) {
    l = !0, o = p;
  } finally {
    try {
      a && d.return != null && await d.return();
    } finally {
      if (l)
        throw o;
    }
  }
  return [...(await Promise.all(r)).flat(), ...await Promise.all(s)];
};
var h6 = async (n = {}) => {
  n.recursive = n.recursive || !1, n.mode = n.mode || "read";
  const e = await window.showDirectoryPicker({ id: n.id, startIn: n.startIn, mode: n.mode });
  return u6(e, n.recursive, void 0, n.skipDirectory);
}, jie = { __proto__: null, default: h6 }, d6 = async (n, e = [{}], t = null, i = !1, r = null) => {
  Array.isArray(e) || (e = [e]), e[0].fileName = e[0].fileName || "Untitled";
  const s = [];
  let o = null;
  if (n instanceof Blob && n.type ? o = n.type : n.headers && n.headers.get("content-type") && (o = n.headers.get("content-type")), e.forEach((c, d) => {
    s[d] = { description: c.description || "Files", accept: {} }, c.mimeTypes ? (d === 0 && o && c.mimeTypes.push(o), c.mimeTypes.map((p) => {
      s[d].accept[p] = c.extensions || [];
    })) : o ? s[d].accept[o] = c.extensions || [] : s[d].accept["*/*"] = c.extensions || [];
  }), t)
    try {
      await t.getFile();
    } catch (c) {
      if (t = null, i)
        throw c;
    }
  const a = t || await window.showSaveFilePicker({ suggestedName: e[0].fileName, id: e[0].id, startIn: e[0].startIn, types: s, excludeAcceptAllOption: e[0].excludeAcceptAllOption || !1 });
  !t && r && r(a);
  const l = await a.createWritable();
  return "stream" in n ? (await n.stream().pipeTo(l), a) : "body" in n ? (await n.body.pipeTo(l), a) : (await l.write(await n), await l.close(), a);
}, qie = { __proto__: null, default: d6 }, f6 = async (n = [{}]) => (Array.isArray(n) || (n = [n]), new Promise((e, t) => {
  const i = document.createElement("input");
  i.type = "file";
  const r = [...n.map((l) => l.mimeTypes || []), ...n.map((l) => l.extensions || [])].join();
  i.multiple = n[0].multiple || !1, i.accept = r || "", i.style.display = "none", document.body.append(i);
  const s = (l) => {
    typeof o == "function" && o(), e(l);
  }, o = n[0].legacySetup && n[0].legacySetup(s, () => o(t), i), a = () => {
    window.removeEventListener("focus", a), i.remove();
  };
  i.addEventListener("click", () => {
    window.addEventListener("focus", a);
  }), i.addEventListener("change", () => {
    window.removeEventListener("focus", a), i.remove(), s(i.multiple ? Array.from(i.files) : i.files[0]);
  }), "showPicker" in HTMLInputElement.prototype ? i.showPicker() : i.click();
})), Xie = { __proto__: null, default: f6 }, p6 = async (n = [{}]) => (Array.isArray(n) || (n = [n]), n[0].recursive = n[0].recursive || !1, new Promise((e, t) => {
  const i = document.createElement("input");
  i.type = "file", i.webkitdirectory = !0;
  const r = (o) => {
    typeof s == "function" && s(), e(o);
  }, s = n[0].legacySetup && n[0].legacySetup(r, () => s(t), i);
  i.addEventListener("change", () => {
    let o = Array.from(i.files);
    n[0].recursive ? n[0].recursive && n[0].skipDirectory && (o = o.filter((a) => a.webkitRelativePath.split("/").every((l) => !n[0].skipDirectory({ name: l, kind: "directory" })))) : o = o.filter((a) => a.webkitRelativePath.split("/").length === 2), r(o);
  }), "showPicker" in HTMLInputElement.prototype ? i.showPicker() : i.click();
})), $ie = { __proto__: null, default: p6 }, m6 = async (n, e = {}) => {
  Array.isArray(e) && (e = e[0]);
  const t = document.createElement("a");
  let i = n;
  "body" in n && (i = await async function(o, a) {
    const l = o.getReader(), c = new ReadableStream({ start: (m) => async function v() {
      return l.read().then(({ done: b, value: x }) => {
        if (!b)
          return m.enqueue(x), v();
        m.close();
      });
    }() }), d = new Response(c), p = await d.blob();
    return l.releaseLock(), new Blob([p], { type: a });
  }(n.body, n.headers.get("content-type"))), t.download = e.fileName || "Untitled", t.href = URL.createObjectURL(await i);
  const r = () => {
    typeof s == "function" && s();
  }, s = e.legacySetup && e.legacySetup(r, () => s(), t);
  return t.addEventListener("click", () => {
    setTimeout(() => URL.revokeObjectURL(t.href), 3e4), r();
  }), t.click(), null;
}, Zie = { __proto__: null, default: m6 };
const v6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  directoryOpen: l6,
  directoryOpenLegacy: p6,
  directoryOpenModern: h6,
  fileOpen: Bie,
  fileOpenLegacy: f6,
  fileOpenModern: c6,
  fileSave: Hie,
  fileSaveLegacy: m6,
  fileSaveModern: d6,
  supported: ux
}, Symbol.toStringTag, { value: "Module" })), [g6, Yie] = Be(!1), [Kie, Jie] = di(), OC = async (n) => {
  if (!n.name.toLowerCase().endsWith(".json"))
    return !1;
  try {
    const e = await n.text();
    if (!e.includes('"type": "lingo3d"'))
      return !1;
    for (const t of Zr)
      t.dispose();
    return Ri.x = 0, Ri.y = 0, Ri.z = 0, Ri.rotationX = 0, Ri.rotationY = 0, Ri.rotationZ = 0, vO(n), await new Promise((t) => setTimeout(t)), IC(JSON.parse(e)), Kie(), !0;
  } catch {
    return !1;
  }
}, NC = async () => {
  const n = await l6({
    recursive: !0,
    startIn: "downloads",
    id: "lingo3d",
    skipDirectory: (e) => e.name[0] === "." || e.name === "node_modules"
  });
  Dee(n), g6(!0);
  for (const e of n)
    if (e.webkitRelativePath.split("/").length < 3 && await OC(e))
      return;
}, _6 = async () => {
  const { fileOpen: n } = await Promise.resolve().then(() => v6);
  return OC(await n({ extensions: [".json"], id: "lingo3d" }));
}, zC = async () => {
  const { default: n } = await import("./standalone.f2272d76.mjs").then((a) => a.s), { default: e } = await import("./parser-babel.9831a210.mjs").then((a) => a.p), { fileSave: t } = await Promise.resolve().then(() => v6), i = n.format(JSON.stringify(await Jf(!0)), {
    parser: "json",
    plugins: [e]
  }), r = pv(), s = await t(
    new Blob([i], { type: "text/plain" }),
    {
      fileName: "scene.json",
      extensions: [".json"],
      startIn: "downloads",
      id: "lingo3d"
    },
    r == null ? void 0 : r.handle
  );
  if (r)
    return;
  const o = await (s == null ? void 0 : s.getFile());
  !o || (Bs(o, "handle", s), vO(o));
}, FC = (n, e, t = 500) => {
  const [i, r] = JE(n, e), s = nt();
  Jn.set(i, r, 0.5), Jn.unproject(s);
  const o = Dn(s);
  Jn.sub(o).normalize();
  const a = o.add(Jn.multiplyScalar(t * Ut));
  return Po(a);
}, [Qie, gde] = Be(kX), _de = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Cube: qy,
  Sphere: ex,
  Cone: tx,
  Cylinder: nx,
  Octahedron: ix,
  Tetrahedron: sx,
  Torus: ox,
  Plane: qd,
  Circle: Xd,
  Model: gs,
  Dummy: Zd,
  Building: Fm,
  Tree: Bm,
  SvgMesh: zu,
  HTMLMesh: Kd,
  Joystick: Jd,
  Reticle: Qd,
  SplashScreen: Um,
  Text: Vm,
  Reflector: ef,
  Water: tf,
  Curve: nf,
  Line: Pne,
  Sprite: gc,
  Trigger: rf,
  SpawnPoint: sf,
  Audio: of,
  Group: Bu,
  Skybox: Nu,
  Environment: Ou,
  Setup: Ao,
  Timeline: bc,
  TimelineAudio: vc,
  Sky: ob,
  Camera: af,
  ThirdPersonCamera: lf,
  FirstPersonCamera: ax,
  OrbitCamera: Iu,
  AmbientLight: cf,
  AreaLight: uf,
  DirectionalLight: Uu,
  SkyLight: Vu,
  PointLight: hf,
  SpotLight: Hu,
  Keyboard: Gu,
  keyboard: KO,
  Mouse: Lu,
  mouse: hI,
  gamepad: Aie,
  createProxy: Rie,
  settings: Xr,
  preload: DC,
  screenshot: Iie,
  serialize: Jf,
  deserialize: IC,
  downloadBlob: n6,
  downloadText: cx,
  exportJSON: i6,
  exportReact: s6,
  exportVue: a6,
  openFolder: NC,
  openJSON: _6,
  saveJSON: zC,
  loop: ku,
  timer: Py,
  Object: mh,
  Found: sa,
  onAfterRender: Ec,
  onBeforeRender: Pn,
  Point3d: yf,
  Point: Is,
  clientToWorld: FC,
  setWasmPath: Qie
}, Symbol.toStringTag, { value: "Module" }));
var BC = { exports: {} }, df = typeof Reflect == "object" ? Reflect : null, ak = df && typeof df.apply == "function" ? df.apply : function(e, t, i) {
  return Function.prototype.apply.call(e, t, i);
}, cb;
df && typeof df.ownKeys == "function" ? cb = df.ownKeys : Object.getOwnPropertySymbols ? cb = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : cb = function(e) {
  return Object.getOwnPropertyNames(e);
};
function ere(n) {
  console && console.warn && console.warn(n);
}
var b6 = Number.isNaN || function(e) {
  return e !== e;
};
function Vn() {
  Vn.init.call(this);
}
BC.exports = Vn;
BC.exports.once = rre;
Vn.EventEmitter = Vn;
Vn.prototype._events = void 0;
Vn.prototype._eventsCount = 0;
Vn.prototype._maxListeners = void 0;
var lk = 10;
function hx(n) {
  if (typeof n != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
}
Object.defineProperty(Vn, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return lk;
  },
  set: function(n) {
    if (typeof n != "number" || n < 0 || b6(n))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
    lk = n;
  }
});
Vn.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Vn.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || b6(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function y6(n) {
  return n._maxListeners === void 0 ? Vn.defaultMaxListeners : n._maxListeners;
}
Vn.prototype.getMaxListeners = function() {
  return y6(this);
};
Vn.prototype.emit = function(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t.push(arguments[i]);
  var r = e === "error", s = this._events;
  if (s !== void 0)
    r = r && s.error === void 0;
  else if (!r)
    return !1;
  if (r) {
    var o;
    if (t.length > 0 && (o = t[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var l = s[e];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    ak(l, this, t);
  else
    for (var c = l.length, d = E6(l, c), i = 0; i < c; ++i)
      ak(d[i], this, t);
  return !0;
};
function x6(n, e, t, i) {
  var r, s, o;
  if (hx(t), s = n._events, s === void 0 ? (s = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (s.newListener !== void 0 && (n.emit(
    "newListener",
    e,
    t.listener ? t.listener : t
  ), s = n._events), o = s[e]), o === void 0)
    o = s[e] = t, ++n._eventsCount;
  else if (typeof o == "function" ? o = s[e] = i ? [t, o] : [o, t] : i ? o.unshift(t) : o.push(t), r = y6(n), r > 0 && o.length > r && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = n, a.type = e, a.count = o.length, ere(a);
  }
  return n;
}
Vn.prototype.addListener = function(e, t) {
  return x6(this, e, t, !1);
};
Vn.prototype.on = Vn.prototype.addListener;
Vn.prototype.prependListener = function(e, t) {
  return x6(this, e, t, !0);
};
function tre() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function w6(n, e, t) {
  var i = { fired: !1, wrapFn: void 0, target: n, type: e, listener: t }, r = tre.bind(i);
  return r.listener = t, i.wrapFn = r, r;
}
Vn.prototype.once = function(e, t) {
  return hx(t), this.on(e, w6(this, e, t)), this;
};
Vn.prototype.prependOnceListener = function(e, t) {
  return hx(t), this.prependListener(e, w6(this, e, t)), this;
};
Vn.prototype.removeListener = function(e, t) {
  var i, r, s, o, a;
  if (hx(t), r = this._events, r === void 0)
    return this;
  if (i = r[e], i === void 0)
    return this;
  if (i === t || i.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, i.listener || t));
  else if (typeof i != "function") {
    for (s = -1, o = i.length - 1; o >= 0; o--)
      if (i[o] === t || i[o].listener === t) {
        a = i[o].listener, s = o;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? i.shift() : nre(i, s), i.length === 1 && (r[e] = i[0]), r.removeListener !== void 0 && this.emit("removeListener", e, a || t);
  }
  return this;
};
Vn.prototype.off = Vn.prototype.removeListener;
Vn.prototype.removeAllListeners = function(e) {
  var t, i, r;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[e]), this;
  if (arguments.length === 0) {
    var s = Object.keys(i), o;
    for (r = 0; r < s.length; ++r)
      o = s[r], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = i[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (r = t.length - 1; r >= 0; r--)
      this.removeListener(e, t[r]);
  return this;
};
function S6(n, e, t) {
  var i = n._events;
  if (i === void 0)
    return [];
  var r = i[e];
  return r === void 0 ? [] : typeof r == "function" ? t ? [r.listener || r] : [r] : t ? ire(r) : E6(r, r.length);
}
Vn.prototype.listeners = function(e) {
  return S6(this, e, !0);
};
Vn.prototype.rawListeners = function(e) {
  return S6(this, e, !1);
};
Vn.listenerCount = function(n, e) {
  return typeof n.listenerCount == "function" ? n.listenerCount(e) : M6.call(n, e);
};
Vn.prototype.listenerCount = M6;
function M6(n) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[n];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
Vn.prototype.eventNames = function() {
  return this._eventsCount > 0 ? cb(this._events) : [];
};
function E6(n, e) {
  for (var t = new Array(e), i = 0; i < e; ++i)
    t[i] = n[i];
  return t;
}
function nre(n, e) {
  for (; e + 1 < n.length; e++)
    n[e] = n[e + 1];
  n.pop();
}
function ire(n) {
  for (var e = new Array(n.length), t = 0; t < e.length; ++t)
    e[t] = n[t].listener || n[t];
  return e;
}
function rre(n, e) {
  return new Promise(function(t, i) {
    function r(o) {
      n.removeListener(e, s), i(o);
    }
    function s() {
      typeof n.removeListener == "function" && n.removeListener("error", r), t([].slice.call(arguments));
    }
    C6(n, e, s, { once: !0 }), e !== "error" && sre(n, r, { once: !0 });
  });
}
function sre(n, e, t) {
  typeof n.on == "function" && C6(n, "error", e, t);
}
function C6(n, e, t, i) {
  if (typeof n.on == "function")
    i.once ? n.once(e, t) : n.on(e, t);
  else if (typeof n.addEventListener == "function")
    n.addEventListener(e, function r(s) {
      i.once && n.removeEventListener(e, r), t(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
}
const bde = new BC.exports(), ore = (n) => () => {
  const [e, t] = Yr(() => n());
  return Tv(() => {
    const i = n(t);
    return () => {
      i.cancel();
    };
  }, []), e;
}, are = (n) => {
  const [e, t] = Be(n);
  return [ore(t), e, t];
}, yde = (n, e) => {
  const [t, i] = are(0);
  return DC(n, e, (r) => i(r)).then(() => i(100)), t;
}, dx = document.createElement("div");
Object.assign(dx.style, {
  position: "absolute",
  left: "0px",
  top: "0px",
  width: "100%",
  height: "100%",
  pointerEvents: "none",
  userSelect: "none"
});
const UC = (n, e) => {
  const t = zr({}), i = [], r = [];
  if (e)
    return [i, r];
  const s = t.current;
  for (const [o, a] of Object.entries(n)) {
    if (o === "children")
      continue;
    const l = s[o];
    l !== a && (a && typeof a == "object" ? JSON.stringify(a) !== JSON.stringify(l) && i.push([o, a]) : i.push([o, a]));
  }
  for (const o of Object.keys(s))
    !(o in n) && r.push(o);
  return t.current = n, [i, r];
}, VC = (n) => {
  const e = zr(n);
  return e.current = n, e;
}, lre = console.log;
let kM = [];
const cre = () => kM = [], ure = parseFloat(Gt.version) > 17, HS = /* @__PURE__ */ new WeakSet();
let ck = !1;
const T6 = (n, e, t) => {
  if (ure) {
    const r = KM(n, []), [s] = Yr(() => {
      const o = {};
      return queueMicrotask(() => {
        HS.has(o) || (ck = !0, e == null || e(r));
      }), o;
    });
    return In(() => HS.has(s) ? () => {
      e == null || e(r), t == null || t(r);
    } : (HS.add(s), () => {
      queueMicrotask(() => {
        ck || (e == null || e(r), t == null || t(r));
      });
    }), []), r;
  }
  const [i] = Yr(() => {
    if (lre === console.log) {
      queueMicrotask(cre);
      const r = n();
      return kM.push(r), r;
    }
    return kM.shift();
  });
  return In(() => () => {
    e == null || e(i), t == null || t(i);
  }, []), i;
}, P6 = (n) => {
  const e = zr();
  return Tv(() => {
    e.current = n;
  }), e.current;
};
var A6 = function() {
  if (typeof Map < "u")
    return Map;
  function n(e, t) {
    var i = -1;
    return e.some(function(r, s) {
      return r[0] === t ? (i = s, !0) : !1;
    }), i;
  }
  return function() {
    function e() {
      this.__entries__ = [];
    }
    return Object.defineProperty(e.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.get = function(t) {
      var i = n(this.__entries__, t), r = this.__entries__[i];
      return r && r[1];
    }, e.prototype.set = function(t, i) {
      var r = n(this.__entries__, t);
      ~r ? this.__entries__[r][1] = i : this.__entries__.push([t, i]);
    }, e.prototype.delete = function(t) {
      var i = this.__entries__, r = n(i, t);
      ~r && i.splice(r, 1);
    }, e.prototype.has = function(t) {
      return !!~n(this.__entries__, t);
    }, e.prototype.clear = function() {
      this.__entries__.splice(0);
    }, e.prototype.forEach = function(t, i) {
      i === void 0 && (i = null);
      for (var r = 0, s = this.__entries__; r < s.length; r++) {
        var o = s[r];
        t.call(i, o[1], o[0]);
      }
    }, e;
  }();
}(), LM = typeof window < "u" && typeof document < "u" && window.document === document, Yb = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), hre = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(Yb) : function(n) {
    return setTimeout(function() {
      return n(Date.now());
    }, 1e3 / 60);
  };
}(), dre = 2;
function fre(n, e) {
  var t = !1, i = !1, r = 0;
  function s() {
    t && (t = !1, n()), i && a();
  }
  function o() {
    hre(s);
  }
  function a() {
    var l = Date.now();
    if (t) {
      if (l - r < dre)
        return;
      i = !0;
    } else
      t = !0, i = !1, setTimeout(o, e);
    r = l;
  }
  return a;
}
var pre = 20, mre = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], vre = typeof MutationObserver < "u", gre = function() {
  function n() {
    this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = fre(this.refresh.bind(this), pre);
  }
  return n.prototype.addObserver = function(e) {
    ~this.observers_.indexOf(e) || this.observers_.push(e), this.connected_ || this.connect_();
  }, n.prototype.removeObserver = function(e) {
    var t = this.observers_, i = t.indexOf(e);
    ~i && t.splice(i, 1), !t.length && this.connected_ && this.disconnect_();
  }, n.prototype.refresh = function() {
    var e = this.updateObservers_();
    e && this.refresh();
  }, n.prototype.updateObservers_ = function() {
    var e = this.observers_.filter(function(t) {
      return t.gatherActive(), t.hasActive();
    });
    return e.forEach(function(t) {
      return t.broadcastActive();
    }), e.length > 0;
  }, n.prototype.connect_ = function() {
    !LM || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), vre ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
  }, n.prototype.disconnect_ = function() {
    !LM || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
  }, n.prototype.onTransitionEnd_ = function(e) {
    var t = e.propertyName, i = t === void 0 ? "" : t, r = mre.some(function(s) {
      return !!~i.indexOf(s);
    });
    r && this.refresh();
  }, n.getInstance = function() {
    return this.instance_ || (this.instance_ = new n()), this.instance_;
  }, n.instance_ = null, n;
}(), R6 = function(n, e) {
  for (var t = 0, i = Object.keys(e); t < i.length; t++) {
    var r = i[t];
    Object.defineProperty(n, r, {
      value: e[r],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return n;
}, Rf = function(n) {
  var e = n && n.ownerDocument && n.ownerDocument.defaultView;
  return e || Yb;
}, k6 = fx(0, 0, 0, 0);
function Kb(n) {
  return parseFloat(n) || 0;
}
function uk(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return e.reduce(function(i, r) {
    var s = n["border-" + r + "-width"];
    return i + Kb(s);
  }, 0);
}
function _re(n) {
  for (var e = ["top", "right", "bottom", "left"], t = {}, i = 0, r = e; i < r.length; i++) {
    var s = r[i], o = n["padding-" + s];
    t[s] = Kb(o);
  }
  return t;
}
function bre(n) {
  var e = n.getBBox();
  return fx(0, 0, e.width, e.height);
}
function yre(n) {
  var e = n.clientWidth, t = n.clientHeight;
  if (!e && !t)
    return k6;
  var i = Rf(n).getComputedStyle(n), r = _re(i), s = r.left + r.right, o = r.top + r.bottom, a = Kb(i.width), l = Kb(i.height);
  if (i.boxSizing === "border-box" && (Math.round(a + s) !== e && (a -= uk(i, "left", "right") + s), Math.round(l + o) !== t && (l -= uk(i, "top", "bottom") + o)), !wre(n)) {
    var c = Math.round(a + s) - e, d = Math.round(l + o) - t;
    Math.abs(c) !== 1 && (a -= c), Math.abs(d) !== 1 && (l -= d);
  }
  return fx(r.left, r.top, a, l);
}
var xre = function() {
  return typeof SVGGraphicsElement < "u" ? function(n) {
    return n instanceof Rf(n).SVGGraphicsElement;
  } : function(n) {
    return n instanceof Rf(n).SVGElement && typeof n.getBBox == "function";
  };
}();
function wre(n) {
  return n === Rf(n).document.documentElement;
}
function Sre(n) {
  return LM ? xre(n) ? bre(n) : yre(n) : k6;
}
function Mre(n) {
  var e = n.x, t = n.y, i = n.width, r = n.height, s = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, o = Object.create(s.prototype);
  return R6(o, {
    x: e,
    y: t,
    width: i,
    height: r,
    top: t,
    right: e + i,
    bottom: r + t,
    left: e
  }), o;
}
function fx(n, e, t, i) {
  return { x: n, y: e, width: t, height: i };
}
var Ere = function() {
  function n(e) {
    this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = fx(0, 0, 0, 0), this.target = e;
  }
  return n.prototype.isActive = function() {
    var e = Sre(this.target);
    return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight;
  }, n.prototype.broadcastRect = function() {
    var e = this.contentRect_;
    return this.broadcastWidth = e.width, this.broadcastHeight = e.height, e;
  }, n;
}(), Cre = function() {
  function n(e, t) {
    var i = Mre(t);
    R6(this, { target: e, contentRect: i });
  }
  return n;
}(), Tre = function() {
  function n(e, t, i) {
    if (this.activeObservations_ = [], this.observations_ = new A6(), typeof e != "function")
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    this.callback_ = e, this.controller_ = t, this.callbackCtx_ = i;
  }
  return n.prototype.observe = function(e) {
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    if (!(typeof Element > "u" || !(Element instanceof Object))) {
      if (!(e instanceof Rf(e).Element))
        throw new TypeError('parameter 1 is not of type "Element".');
      var t = this.observations_;
      t.has(e) || (t.set(e, new Ere(e)), this.controller_.addObserver(this), this.controller_.refresh());
    }
  }, n.prototype.unobserve = function(e) {
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    if (!(typeof Element > "u" || !(Element instanceof Object))) {
      if (!(e instanceof Rf(e).Element))
        throw new TypeError('parameter 1 is not of type "Element".');
      var t = this.observations_;
      !t.has(e) || (t.delete(e), t.size || this.controller_.removeObserver(this));
    }
  }, n.prototype.disconnect = function() {
    this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
  }, n.prototype.gatherActive = function() {
    var e = this;
    this.clearActive(), this.observations_.forEach(function(t) {
      t.isActive() && e.activeObservations_.push(t);
    });
  }, n.prototype.broadcastActive = function() {
    if (!!this.hasActive()) {
      var e = this.callbackCtx_, t = this.activeObservations_.map(function(i) {
        return new Cre(i.target, i.broadcastRect());
      });
      this.callback_.call(e, t, e), this.clearActive();
    }
  }, n.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  }, n.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  }, n;
}(), L6 = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new A6(), D6 = function() {
  function n(e) {
    if (!(this instanceof n))
      throw new TypeError("Cannot call a class as a function.");
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    var t = gre.getInstance(), i = new Tre(e, t, this);
    L6.set(this, i);
  }
  return n;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(n) {
  D6.prototype[n] = function() {
    var e;
    return (e = L6.get(this))[n].apply(e, arguments);
  };
});
(function() {
  return typeof Yb.ResizeObserver < "u" ? Yb.ResizeObserver : D6;
})();
(function() {
  if (typeof window != "object")
    return;
  if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
    "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(
      window.IntersectionObserverEntry.prototype,
      "isIntersecting",
      {
        get: function() {
          return this.intersectionRatio > 0;
        }
      }
    );
    return;
  }
  function n(M) {
    try {
      return M.defaultView && M.defaultView.frameElement || null;
    } catch {
      return null;
    }
  }
  var e = function(M) {
    for (var T = M, P = n(T); P; )
      T = P.ownerDocument, P = n(T);
    return T;
  }(window.document), t = [], i = null, r = null;
  function s(M) {
    this.time = M.time, this.target = M.target, this.rootBounds = b(M.rootBounds), this.boundingClientRect = b(M.boundingClientRect), this.intersectionRect = b(M.intersectionRect || v()), this.isIntersecting = !!M.intersectionRect;
    var T = this.boundingClientRect, P = T.width * T.height, D = this.intersectionRect, I = D.width * D.height;
    P ? this.intersectionRatio = Number((I / P).toFixed(4)) : this.intersectionRatio = this.isIntersecting ? 1 : 0;
  }
  function o(M, T) {
    var P = T || {};
    if (typeof M != "function")
      throw new Error("callback must be a function");
    if (P.root && P.root.nodeType != 1 && P.root.nodeType != 9)
      throw new Error("root must be a Document or Element");
    this._checkForIntersections = l(
      this._checkForIntersections.bind(this),
      this.THROTTLE_TIMEOUT
    ), this._callback = M, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(P.rootMargin), this.thresholds = this._initThresholds(P.threshold), this.root = P.root || null, this.rootMargin = this._rootMarginValues.map(function(D) {
      return D.value + D.unit;
    }).join(" "), this._monitoringDocuments = [], this._monitoringUnsubscribes = [];
  }
  o.prototype.THROTTLE_TIMEOUT = 100, o.prototype.POLL_INTERVAL = null, o.prototype.USE_MUTATION_OBSERVER = !0, o._setupCrossOriginUpdater = function() {
    return i || (i = function(M, T) {
      !M || !T ? r = v() : r = x(M, T), t.forEach(function(P) {
        P._checkForIntersections();
      });
    }), i;
  }, o._resetCrossOriginUpdater = function() {
    i = null, r = null;
  }, o.prototype.observe = function(M) {
    var T = this._observationTargets.some(function(P) {
      return P.element == M;
    });
    if (!T) {
      if (!(M && M.nodeType == 1))
        throw new Error("target must be an Element");
      this._registerInstance(), this._observationTargets.push({ element: M, entry: null }), this._monitorIntersections(M.ownerDocument), this._checkForIntersections();
    }
  }, o.prototype.unobserve = function(M) {
    this._observationTargets = this._observationTargets.filter(function(T) {
      return T.element != M;
    }), this._unmonitorIntersections(M.ownerDocument), this._observationTargets.length == 0 && this._unregisterInstance();
  }, o.prototype.disconnect = function() {
    this._observationTargets = [], this._unmonitorAllIntersections(), this._unregisterInstance();
  }, o.prototype.takeRecords = function() {
    var M = this._queuedEntries.slice();
    return this._queuedEntries = [], M;
  }, o.prototype._initThresholds = function(M) {
    var T = M || [0];
    return Array.isArray(T) || (T = [T]), T.sort().filter(function(P, D, I) {
      if (typeof P != "number" || isNaN(P) || P < 0 || P > 1)
        throw new Error("threshold must be a number between 0 and 1 inclusively");
      return P !== I[D - 1];
    });
  }, o.prototype._parseRootMargin = function(M) {
    var T = M || "0px", P = T.split(/\s+/).map(function(D) {
      var I = /^(-?\d*\.?\d+)(px|%)$/.exec(D);
      if (!I)
        throw new Error("rootMargin must be specified in pixels or percent");
      return { value: parseFloat(I[1]), unit: I[2] };
    });
    return P[1] = P[1] || P[0], P[2] = P[2] || P[0], P[3] = P[3] || P[1], P;
  }, o.prototype._monitorIntersections = function(M) {
    var T = M.defaultView;
    if (!!T && this._monitoringDocuments.indexOf(M) == -1) {
      var P = this._checkForIntersections, D = null, I = null;
      this.POLL_INTERVAL ? D = T.setInterval(P, this.POLL_INTERVAL) : (c(T, "resize", P, !0), c(M, "scroll", P, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in T && (I = new T.MutationObserver(P), I.observe(M, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      }))), this._monitoringDocuments.push(M), this._monitoringUnsubscribes.push(function() {
        var B = M.defaultView;
        B && (D && B.clearInterval(D), d(B, "resize", P, !0)), d(M, "scroll", P, !0), I && I.disconnect();
      });
      var k = this.root && (this.root.ownerDocument || this.root) || e;
      if (M != k) {
        var O = n(M);
        O && this._monitorIntersections(O.ownerDocument);
      }
    }
  }, o.prototype._unmonitorIntersections = function(M) {
    var T = this._monitoringDocuments.indexOf(M);
    if (T != -1) {
      var P = this.root && (this.root.ownerDocument || this.root) || e, D = this._observationTargets.some(function(O) {
        var B = O.element.ownerDocument;
        if (B == M)
          return !0;
        for (; B && B != P; ) {
          var Y = n(B);
          if (B = Y && Y.ownerDocument, B == M)
            return !0;
        }
        return !1;
      });
      if (!D) {
        var I = this._monitoringUnsubscribes[T];
        if (this._monitoringDocuments.splice(T, 1), this._monitoringUnsubscribes.splice(T, 1), I(), M != P) {
          var k = n(M);
          k && this._unmonitorIntersections(k.ownerDocument);
        }
      }
    }
  }, o.prototype._unmonitorAllIntersections = function() {
    var M = this._monitoringUnsubscribes.slice(0);
    this._monitoringDocuments.length = 0, this._monitoringUnsubscribes.length = 0;
    for (var T = 0; T < M.length; T++)
      M[T]();
  }, o.prototype._checkForIntersections = function() {
    if (!(!this.root && i && !r)) {
      var M = this._rootIsInDom(), T = M ? this._getRootRect() : v();
      this._observationTargets.forEach(function(P) {
        var D = P.element, I = m(D), k = this._rootContainsTarget(D), O = P.entry, B = M && k && this._computeTargetAndRootIntersection(D, I, T), Y = null;
        this._rootContainsTarget(D) ? (!i || this.root) && (Y = T) : Y = v();
        var G = P.entry = new s({
          time: a(),
          target: D,
          boundingClientRect: I,
          rootBounds: Y,
          intersectionRect: B
        });
        O ? M && k ? this._hasCrossedThreshold(O, G) && this._queuedEntries.push(G) : O && O.isIntersecting && this._queuedEntries.push(G) : this._queuedEntries.push(G);
      }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this);
    }
  }, o.prototype._computeTargetAndRootIntersection = function(M, T, P) {
    if (window.getComputedStyle(M).display != "none") {
      for (var D = T, I = S(M), k = !1; !k && I; ) {
        var O = null, B = I.nodeType == 1 ? window.getComputedStyle(I) : {};
        if (B.display == "none")
          return null;
        if (I == this.root || I.nodeType == 9)
          if (k = !0, I == this.root || I == e)
            i && !this.root ? !r || r.width == 0 && r.height == 0 ? (I = null, O = null, D = null) : O = r : O = P;
          else {
            var Y = S(I), G = Y && m(Y), K = Y && this._computeTargetAndRootIntersection(Y, G, P);
            G && K ? (I = Y, O = x(G, K)) : (I = null, D = null);
          }
        else {
          var A = I.ownerDocument;
          I != A.body && I != A.documentElement && B.overflow != "visible" && (O = m(I));
        }
        if (O && (D = p(O, D)), !D)
          break;
        I = I && S(I);
      }
      return D;
    }
  }, o.prototype._getRootRect = function() {
    var M;
    if (this.root && !C(this.root))
      M = m(this.root);
    else {
      var T = C(this.root) ? this.root : e, P = T.documentElement, D = T.body;
      M = {
        top: 0,
        left: 0,
        right: P.clientWidth || D.clientWidth,
        width: P.clientWidth || D.clientWidth,
        bottom: P.clientHeight || D.clientHeight,
        height: P.clientHeight || D.clientHeight
      };
    }
    return this._expandRectByRootMargin(M);
  }, o.prototype._expandRectByRootMargin = function(M) {
    var T = this._rootMarginValues.map(function(D, I) {
      return D.unit == "px" ? D.value : D.value * (I % 2 ? M.width : M.height) / 100;
    }), P = {
      top: M.top - T[0],
      right: M.right + T[1],
      bottom: M.bottom + T[2],
      left: M.left - T[3]
    };
    return P.width = P.right - P.left, P.height = P.bottom - P.top, P;
  }, o.prototype._hasCrossedThreshold = function(M, T) {
    var P = M && M.isIntersecting ? M.intersectionRatio || 0 : -1, D = T.isIntersecting ? T.intersectionRatio || 0 : -1;
    if (P !== D)
      for (var I = 0; I < this.thresholds.length; I++) {
        var k = this.thresholds[I];
        if (k == P || k == D || k < P != k < D)
          return !0;
      }
  }, o.prototype._rootIsInDom = function() {
    return !this.root || y(e, this.root);
  }, o.prototype._rootContainsTarget = function(M) {
    var T = this.root && (this.root.ownerDocument || this.root) || e;
    return y(T, M) && (!this.root || T == M.ownerDocument);
  }, o.prototype._registerInstance = function() {
    t.indexOf(this) < 0 && t.push(this);
  }, o.prototype._unregisterInstance = function() {
    var M = t.indexOf(this);
    M != -1 && t.splice(M, 1);
  };
  function a() {
    return window.performance && performance.now && performance.now();
  }
  function l(M, T) {
    var P = null;
    return function() {
      P || (P = setTimeout(function() {
        M(), P = null;
      }, T));
    };
  }
  function c(M, T, P, D) {
    typeof M.addEventListener == "function" ? M.addEventListener(T, P, D || !1) : typeof M.attachEvent == "function" && M.attachEvent("on" + T, P);
  }
  function d(M, T, P, D) {
    typeof M.removeEventListener == "function" ? M.removeEventListener(T, P, D || !1) : typeof M.detachEvent == "function" && M.detachEvent("on" + T, P);
  }
  function p(M, T) {
    var P = Math.max(M.top, T.top), D = Math.min(M.bottom, T.bottom), I = Math.max(M.left, T.left), k = Math.min(M.right, T.right), O = k - I, B = D - P;
    return O >= 0 && B >= 0 && {
      top: P,
      bottom: D,
      left: I,
      right: k,
      width: O,
      height: B
    } || null;
  }
  function m(M) {
    var T;
    try {
      T = M.getBoundingClientRect();
    } catch {
    }
    return T ? (T.width && T.height || (T = {
      top: T.top,
      right: T.right,
      bottom: T.bottom,
      left: T.left,
      width: T.right - T.left,
      height: T.bottom - T.top
    }), T) : v();
  }
  function v() {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  function b(M) {
    return !M || "x" in M ? M : {
      top: M.top,
      y: M.top,
      bottom: M.bottom,
      left: M.left,
      x: M.left,
      right: M.right,
      width: M.width,
      height: M.height
    };
  }
  function x(M, T) {
    var P = T.top - M.top, D = T.left - M.left;
    return {
      top: P,
      left: D,
      height: T.height,
      width: T.width,
      bottom: P + T.height,
      right: D + T.width
    };
  }
  function y(M, T) {
    for (var P = T; P; ) {
      if (P == M)
        return !0;
      P = S(P);
    }
    return !1;
  }
  function S(M) {
    var T = M.parentNode;
    return M.nodeType == 9 && M != e ? n(M) : (T && T.assignedSlot && (T = T.assignedSlot.parentNode), T && T.nodeType == 11 && T.host ? T.host : T);
  }
  function C(M) {
    return M && M.nodeType === 9;
  }
  window.IntersectionObserver = o, window.IntersectionObserverEntry = s;
})();
const Pre = /* @__PURE__ */ new WeakMap(), hk = /* @__PURE__ */ new WeakSet(), Are = (n) => hk.has(n) ? n : Mr(Pre, n, () => {
  const e = Object.fromEntries(
    Object.keys(n).map((t) => [t, Qy(n, t)])
  );
  return hk.add(e), e;
}), jt = Gt.createContext(void 0), I6 = /* @__PURE__ */ new WeakMap(), Rre = () => /* @__PURE__ */ new Map(), HC = (n, e, t) => {
  var s, o;
  const i = Mr(I6, n, Rre), r = Are(n.constructor.defaults);
  for (const [a, l] of e) {
    if ((s = i.get(a)) == null || s.cancel(), l instanceof Je) {
      i.set(
        a,
        l.get((d) => n[a] = d)
      );
      continue;
    }
    if (r[a] === il) {
      if (!l)
        continue;
      Array.isArray(l) ? n[a](...l) : n[a](l);
      continue;
    }
    n[a] = l;
  }
  for (const a of t)
    (o = i.get(a)) == null || o.cancel(), n[a] = r[a];
}, GS = /* @__PURE__ */ new WeakSet(), sn = (n, e, t) => {
  const { children: i, ...r } = n, s = cy(jt), o = T6(
    () => {
      const c = new t();
      return s && (s.append(c), GS.add(c)), c;
    },
    (c) => {
      const d = I6.get(c);
      if (d)
        for (const p of d.values())
          p.cancel();
      c.dispose();
    }
  );
  In(() => {
    !s || GS.has(o) || (s.append(o), GS.add(o));
  }, [s]);
  const [a, l] = UC(r);
  return HC(o, a, l), In(() => {
    !e || (typeof e == "function" ? e(o) : e.current = o);
  }, [e]), o;
}, kre = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Ao);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), xde = ({
  style: n,
  className: e,
  position: t,
  children: i,
  ...r
}) => {
  const s = zr(null);
  return In(() => {
    const o = s.current;
    if (!!o)
      return o.appendChild(dx), Xr.autoMount = o, () => {
        Xr.autoMount = !1;
      };
  }, []), /* @__PURE__ */ vt(Ic, {
    children: [/* @__PURE__ */ vt("div", {
      style: {
        width: "100%",
        height: "100%",
        position: t != null ? t : "absolute",
        top: 0,
        left: 0,
        display: "flex",
        ...n
      },
      children: [/* @__PURE__ */ H("div", {
        style: {
          height: "100%"
        },
        children: i
      }), /* @__PURE__ */ H("div", {
        ref: s,
        style: {
          height: "100%",
          flexGrow: 1,
          position: "relative",
          overflow: "hidden"
        }
      })]
    }), /* @__PURE__ */ H(kre, {
      ...r
    })]
  });
}, Lre = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M960 480L768 320v128H512V192h128L480 0 320 192h128v256H192V320L0 480l192 160V512h256v256H320l160 192 160-192H512V512h256v128l192-160z"
  })
}), Dre = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M929 849a30 30 0 01-30-30v-83.137a447.514 447.514 0 01-70.921 92.209C722.935 933.225 578.442 975.008 442 953.482a444.917 444.917 0 01-241.139-120.591 30 30 0 1137.258-47.01l.231-.231A385.175 385.175 0 00442 892.625v-.006c120.855 22.123 250.206-13.519 343.656-106.975a386.646 386.646 0 0070.6-96.653h-87.247a30 30 0 010-60H929a30 30 0 0130 30V819a30 30 0 01-30 30zM512 392a120 120 0 11-120 120 120 120 0 01120-120zm293.005-147.025a29.87 29.87 0 01-19.117-6.882l-.232.231A386.5 386.5 0 00689.478 168h-.011c-145.646-75.182-329.021-51.747-451.117 70.35a386.615 386.615 0 00-70.6 96.65H255a30 30 0 010 60H95a30 30 0 01-30-30V205a30 30 0 0160 0v83.129a447.534 447.534 0 0170.923-92.206C317.981 73.866 493.048 37.2 647 85.836v-.045a444.883 444.883 0 01176.143 105.291 30 30 0 01-18.138 53.893z"
  })
}), Ire = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M609.52 584.92a35.309 35.309 0 0124.98-10.36c9.37 0 18.36 3.73 24.98 10.36l189.29 189.22-.07-114.3.57-6.35c3.25-17.98 19.7-30.5 37.9-28.85 18.2 1.65 32.12 16.92 32.09 35.2v200.23c-.05 1.49-.19 2.97-.42 4.45l-.21 1.13c-.22 1.44-.55 2.85-.99 4.24l-.57 1.62-.56 1.41a34.163 34.163 0 01-7.62 11.36l2.12-2.4-.14.14-.92 1.06-1.06 1.2-.57.57-.56.57a36.378 36.378 0 01-16.23 8.39l-3.53.5-4.02.35h-199.6l-6.35-.63c-16.73-3.06-28.9-17.63-28.93-34.64l.56-6.35c3.07-16.76 17.67-28.93 34.71-28.92l114.29-.14-189.07-189.1-4.09-4.94c-9.71-14.01-8.01-32.95 4.02-45.02zm-162.06 0c12.06 12.05 13.78 30.99 4.09 45.01l-4.09 4.94-189.15 189.08 114.3.14c17.04-.01 31.65 12.17 34.71 28.92l.57 6.35c-.03 17.01-12.19 31.58-28.92 34.64l-6.35.63H173.09l-4.23-.42-3.39-.49a36.38 36.38 0 01-17.36-9.52l-1.06-1.13-.98-1.13.98 1.06-1.97-2.26.85 1.06-.42-.56a35.137 35.137 0 01-3.74-5.64l-1.13-2.68a34.71 34.71 0 01-2.11-7.33l-.28-1.13c-.21-1.47-.33-2.96-.36-4.45V659.78c-.03-18.28 13.89-33.55 32.09-35.2 18.2-1.65 34.65 10.87 37.9 28.85l.57 6.35-.07 114.36 189.29-189.22c13.77-13.77 36.11-13.77 49.88 0h-.09zm-74.71-471.71l6.35.57c16.76 3.06 28.93 17.67 28.92 34.71l-.63 6.35c-3.07 16.76-17.67 28.93-34.71 28.92l-114.3.14 189.15 189.08 4.09 4.94c10.26 15.02 7.42 35.37-6.55 47.01-13.98 11.63-34.51 10.74-47.42-2.07L208.29 233.71l.07 114.3-.57 6.35c-3.25 17.98-19.7 30.5-37.9 28.85-18.2-1.65-32.12-16.92-32.09-35.2V147.78c0-1.55.14-3.03.35-4.51l.21-1.13c.24-1.44.59-2.85 1.06-4.23a34.97 34.97 0 018.68-14.39l-2.12 2.4-.42.57 1.55-1.84-.99 1.06.92-.98 2.26-2.33c3.04-2.73 6.52-4.92 10.3-6.49l2.82-1.06c3.45-1.07 7.04-1.62 10.65-1.62l-3.6.14h.49l1.48-.14h201.31zm512.91 0l1.41.14h.42c2.43.29 4.84.79 7.19 1.48l2.82 1.06 2.61 1.2 3.04 1.76c2.09 1.33 4.03 2.89 5.78 4.66l1.13 1.2.78.98.21.14.49.64 2.33 3.17c2.35 3.83 3.98 8.07 4.8 12.49l.21 1.13c.21 1.48.35 2.96.35 4.44v200.37c-.16 18.13-14.03 33.19-32.08 34.83-18.06 1.64-34.42-10.67-37.83-28.48l-.57-6.35V233.65L659.54 422.87c-12.9 12.95-33.56 13.91-47.59 2.2-14.04-11.71-16.81-32.2-6.38-47.22l4.02-4.86 189.22-189.08-114.29-.14c-17.06.04-31.71-12.14-34.78-28.92l-.63-6.35c-.01-17.04 12.16-31.65 28.93-34.71l6.35-.57h201.27zm0 0"
  })
}), Ore = () => /* @__PURE__ */ vt("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: [/* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M96 892.8V121.6c0-16 12.8-28.8 28.8-28.8h774.4c16 0 28.8 12.8 28.8 28.8v771.2c0 16-12.8 28.8-28.8 28.8H124.8c-16 3.2-28.8-9.6-28.8-28.8zm64-736v704h704v-704H160z"
  }), /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M352 656V358.4c0-6.4 6.4-12.8 9.6-12.8h297.6c6.4 0 9.6 6.4 9.6 12.8V656c0 6.4-6.4 12.8-9.6 12.8H361.6c-3.2 0-9.6-6.4-9.6-12.8zm80-227.2v160h160v-160H432zm240 108.8v-48h192v48H672zm121.6-48H736v48h57.6v-48zm-633.6 48v-48h192v48H160zm124.8-48H224v48h57.6v-48z"
  }), /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M489.6 156.8h48v192h-48v-192zm48 121.6v-57.6h-48v57.6h48zm-48 387.2h48v195.2h-48V665.6zm48 124.8v-57.6h-48v57.6h48z"
  })]
}), Nre = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M185.6 489.6h-48c-3.2 0-9.6 3.2-9.6 9.6v384c0 3.2 3.2 9.6 9.6 9.6h48c3.2 0 9.6-3.2 9.6-9.6v-384c-3.2-6.4-6.4-9.6-9.6-9.6zm217.6 236.8c6.4 0 12.8-3.2 12.8-9.6v-48c0-3.2-6.4-9.6-12.8-9.6H140.8c-6.4 0-12.8 3.2-12.8 9.6v48c0 3.2 6.4 9.6 12.8 9.6h262.4zm512-547.2v-48c0-3.2-3.2-9.6-9.6-9.6h-384c-3.2 0-9.6 3.2-9.6 9.6v48c0 3.2 3.2 9.6 9.6 9.6h384c6.4 0 9.6-6.4 9.6-9.6zM678.4 377.6c0 6.4 3.2 9.6 9.6 9.6h48c3.2 0 9.6-3.2 9.6-9.6V134.4c0-6.4-3.2-9.6-9.6-9.6h-48c-3.2 0-9.6 3.2-9.6 9.6v243.2zm-195.2 89.6v416c0 9.6 6.4 16 16 16h400c9.6 0 16-6.4 16-16v-416c0-9.6-6.4-16-16-16h-400c-9.6 0-16 9.6-16 16zm361.6 57.6v304h-288v-304h288z"
  })
}), fs = ({
  children: n,
  onClick: e,
  active: t,
  disabled: i
}) => /* @__PURE__ */ H("div", {
  className: "lingo3d-flexcenter",
  style: {
    width: 30,
    height: 30,
    margin: 6,
    borderRadius: 4,
    background: t ? "rgba(255, 255, 255, 0.1)" : void 0,
    opacity: i ? 0.25 : t ? 1 : 0.75,
    cursor: "pointer"
  },
  onClick: i || t ? void 0 : e,
  children: n
}), zre = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  style: {
    left: -2
  },
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M279.552 198.879a22.26 22.26 0 0135.217-20.347L933.265 628.47a22.26 22.26 0 01-11.799 40.248l-324.43 19.456a22.26 22.26 0 00-17.23 9.972l-179.11 271.227a22.26 22.26 0 01-40.738-9.929L279.597 198.88z"
  })
}), Fre = () => /* @__PURE__ */ vt("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: [/* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M870.4 342.4c-12.8 0-24-11.2-24-24V153.6c0-12.8 11.2-24 24-24s24 11.2 24 24v164.8c0 12.8-11.2 24-24 24z"
  }), /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M870.4 177.6H705.6c-12.8 0-24-11.2-24-24s11.2-24 24-24h164.8c12.8 0 24 11.2 24 24s-11.2 24-24 24zm-96 716.8H249.6c-65.6 0-120-54.4-120-120V249.6c0-65.6 54.4-120 120-120H512c12.8 0 24 11.2 24 24s-11.2 24-24 24H249.6c-40 0-72 32-72 72v524.8c0 40 32 72 72 72h524.8c40 0 72-32 72-72V512c0-12.8 11.2-24 24-24s24 11.2 24 24v262.4c0 65.6-54.4 120-120 120z"
  }), /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M526.4 521.6c-6.4 0-12.8-1.6-17.6-6.4-9.6-9.6-9.6-24 0-33.6l344-344c9.6-9.6 24-9.6 33.6 0 9.6 9.6 9.6 24 0 33.6l-344 344c-4.8 4.8-11.2 6.4-16 6.4z"
  })]
}), Bre = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M836.8 353.6c-11.2-3.2-20.8-6.4-32-9.6 1.6-8 3.2-14.4 4.8-22.4 24-118.4 8-214.4-46.4-246.4C710.4 44.8 624 76.8 537.6 152c-8 8-17.6 14.4-25.6 22.4-4.8-4.8-11.2-9.6-16-16-91.2-81.6-182.4-115.2-236.8-83.2-52.8 30.4-68.8 120-46.4 233.6 1.6 11.2 4.8 22.4 8 33.6-12.8 3.2-25.6 8-36.8 11.2C76.8 392 0 451.2 0 510.4c0 62.4 81.6 124.8 192 163.2 9.6 3.2 17.6 6.4 27.2 8-3.2 12.8-6.4 24-8 36.8-20.8 110.4-4.8 198.4 48 228.8 54.4 32 145.6 0 233.6-78.4 6.4-6.4 14.4-12.8 20.8-19.2 8 8 17.6 16 27.2 24 84.8 73.6 169.6 104 222.4 73.6 54.4-32 72-126.4 48-241.6-1.6-8-3.2-17.6-6.4-27.2 6.4-1.6 12.8-3.2 19.2-6.4 116.8-35.2 200-97.6 200-161.6 0-59.2-78.4-118.4-187.2-156.8zM566.4 184c75.2-65.6 144-89.6 176-72 33.6 19.2 46.4 97.6 25.6 201.6-1.6 6.4-3.2 12.8-4.8 20.8-44.8-9.6-89.6-17.6-134.4-20.8C603.2 276.8 574.4 240 544 208c6.4-9.6 14.4-16 22.4-24zm-232 430.4c9.6 17.6 20.8 35.2 32 51.2-32-3.2-62.4-8-92.8-14.4 8-28.8 19.2-59.2 32-89.6 9.6 19.2 19.2 36.8 28.8 52.8zm-60.8-240c28.8-6.4 59.2-11.2 91.2-16-11.2 16-20.8 33.6-30.4 51.2-9.6 17.6-19.2 33.6-28.8 52.8-12.8-30.4-22.4-59.2-32-88zM328 512c12.8-27.2 27.2-54.4 43.2-81.6s32-52.8 48-78.4c30.4-1.6 60.8-3.2 91.2-3.2s62.4 1.6 91.2 3.2c17.6 25.6 33.6 51.2 48 76.8s30.4 52.8 43.2 81.6c-12.8 27.2-27.2 54.4-43.2 81.6-16 27.2-32 52.8-48 78.4-30.4 1.6-60.8 3.2-92.8 3.2s-62.4-1.6-91.2-3.2C400 644.8 384 619.2 368 592s-25.6-52.8-40-80zm361.6 102.4l28.8-52.8c12.8 28.8 24 59.2 33.6 88-30.4 6.4-62.4 12.8-94.4 16 11.2-16 22.4-33.6 32-51.2zm28.8-153.6L689.6 408c-9.6-17.6-20.8-33.6-30.4-49.6 32 4.8 62.4 9.6 91.2 16-8 30.4-19.2 59.2-32 86.4zM512 236.8c20.8 22.4 40 46.4 59.2 72-40-1.6-80-1.6-118.4 0 19.2-27.2 40-51.2 59.2-72zM280 113.6c33.6-19.2 108.8 8 187.2 78.4 4.8 4.8 9.6 9.6 16 14.4C452.8 240 424 275.2 396.8 312c-44.8 4.8-89.6 11.2-134.4 20.8-3.2-9.6-4.8-20.8-6.4-30.4-19.2-97.6-6.4-169.6 24-188.8zm-48 528c-8-3.2-16-4.8-25.6-8-43.2-12.8-91.2-35.2-126.4-62.4C59.2 556.8 46.4 536 41.6 512c0-36.8 64-83.2 155.2-115.2 11.2-4.8 22.4-8 35.2-11.2 14.4 43.2 30.4 86.4 49.6 128-19.2 40-36.8 83.2-49.6 128zm232 195.2c-33.6 30.4-72 54.4-113.6 70.4-22.4 11.2-48 11.2-70.4 3.2-32-19.2-44.8-89.6-27.2-184 1.6-11.2 4.8-22.4 8-33.6 44.8 9.6 89.6 16 136 19.2 25.6 36.8 56 73.6 86.4 107.2-6.4 6.4-12.8 12.8-19.2 17.6zm49.6-48c-20.8-22.4-40-46.4-60.8-72 19.2 0 38.4 1.6 59.2 1.6 20.8 0 41.6 0 60.8-1.6-19.2 24-38.4 48-59.2 72zM774.4 848c-1.6 24-14.4 48-33.6 62.4-32 19.2-99.2-4.8-172.8-68.8-8-8-16-14.4-25.6-22.4 30.4-33.6 59.2-68.8 84.8-107.2 46.4-3.2 91.2-11.2 136-20.8l4.8 24c11.2 43.2 12.8 89.6 6.4 132.8zm36.8-214.4c-4.8 1.6-11.2 3.2-17.6 4.8-14.4-43.2-32-86.4-51.2-128 19.2-40 35.2-83.2 49.6-126.4 11.2 3.2 20.8 6.4 30.4 9.6 92.8 32 158.4 80 158.4 116.8 0 40-68.8 89.6-169.6 123.2zM512 603.2c51.2 0 91.2-41.6 91.2-91.2s-41.6-91.2-91.2-91.2-91.2 41.6-91.2 91.2 40 91.2 91.2 91.2z"
  })
}), Ure = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M777.8 128.6H624L512 305.8l-96-177.2H64L512 896l448-767.4H777.8zm-602.4 64H283L512 589l228.8-396.4h107.6L512 769 175.4 192.6z"
  })
}), Vre = () => /* @__PURE__ */ H("div", {
  style: {
    width: "60%",
    height: 2,
    background: "rgba(255, 255, 255, 0.1)",
    margin: 12
  }
}), fm = ({
  children: n
}) => !Array.isArray(n) || !n.length ? null : /* @__PURE__ */ vt(Ic, {
  children: [n, /* @__PURE__ */ H(Vre, {})]
}), [DM, IM] = Be("world"), Hre = () => /* @__PURE__ */ vt("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: [/* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M856.2 47.8H167.8c-66.2 0-120 53.8-120 120v688.6c0 66.2 53.8 120 120 120h688.6c66.2 0 120-53.8 120-120V167.8c-.2-66.2-54-120-120.2-120zm60 808.4c0 33-27 60-60 60H167.8c-33 0-60-27-60-60V167.8c0-33 27-60 60-60h688.6c33 0 60 27 60 60v688.4z"
  }), /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M646.6 466.2l-163.4-94.4c-16.8-9.8-37-9.8-54 0-16.8 9.8-27 27.2-27 46.8v188.8c0 19.6 10 37 27 46.8 8.4 4.8 17.8 7.4 27 7.4s18.6-2.4 27-7.4l163.4-94.4c16.8-9.8 27-27.2 27-46.8-.2-19.6-10.2-37-27-46.8z"
  })]
}), Gre = () => /* @__PURE__ */ vt("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: [/* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M195.1 334.6c-72.2 0-131-58.7-131-131s58.7-131.1 131-131.1c35 0 67.9 13.6 92.6 38.3 24.8 24.7 38.4 57.6 38.4 92.7 0 35-13.6 67.9-38.3 92.7-24.7 24.8-57.6 38.4-92.7 38.4.1 0 .1 0 0 0zm0-215.8c-46.8 0-84.8 38.1-84.8 84.8 0 46.7 38.1 84.8 84.8 84.8 22.7 0 43.9-8.8 60-24.9 16-16 24.8-37.3 24.8-60 0-22.6-8.8-43.9-24.9-59.9-15.9-16-37.2-24.8-59.9-24.8zm632.4 832.3c-35 0-67.9-13.6-92.6-38.3-24.8-24.7-38.4-57.7-38.4-92.7s13.6-67.9 38.3-92.7c24.7-24.8 57.7-38.4 92.7-38.4h.1c72.2 0 131 58.7 131.1 131-.1 72.2-58.9 131-131.2 131.1.1 0 0 0 0 0zm0-215.9c-22.7 0-44 8.8-60 24.9-16 16-24.8 37.3-24.8 60 0 22.7 8.8 43.9 24.9 60 16 16 37.3 24.8 59.9 24.8 46.7 0 84.8-38.1 84.8-84.8 0-46.9-38-84.9-84.8-84.9z"
  }), /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M241.6 843.4c-47.2 0-91.6-18.5-125.2-52-33.6-33.6-52.1-78-52.1-125.2s18.5-91.7 52-125.3c33.6-33.6 78-52.1 125.2-52.1l539.6-.2c34.8 0 67.7-13.7 92.5-38.6 24.8-24.9 38.5-57.7 38.5-92.6 0-72.2-58.8-131-131.1-131h-.1l-474.1.2v-46.3l474.1-.2h.1c47.2 0 91.6 18.5 125.2 52 33.6 33.6 52.1 78 52.1 125.2s-18.5 91.7-52 125.3c-33.6 33.6-78 52.1-125.2 52.1l-539.6.3c-72.3 0-131 58.8-131 131.1 0 72.2 58.8 131 131.1 131h.1l481.8-.2v46.3l-481.9.2z"
  })]
}), Wre = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M96 160h343.968l87.808 160H928v544H96V160zm64 64v576h704V384H489.92l-87.84-160H160z"
  })
}), jre = () => /* @__PURE__ */ vt("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: [/* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M832 928H192c-52.8 0-96-43.2-96-96V192c0-52.8 43.2-96 96-96h576c8 0 16 3.2 22.4 9.6l128 128c6.4 6.4 9.6 14.4 9.6 22.4v576c0 52.8-43.2 96-96 96zM192 160c-17.6 0-32 14.4-32 32v640c0 17.6 14.4 32 32 32h640c17.6 0 32-14.4 32-32V268.8L755.2 160H192z"
  }), /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M736 928H288c-17.6 0-32-14.4-32-32V643.2c0-54.4 44.8-99.2 99.2-99.2h315.2c54.4 0 99.2 44.8 99.2 99.2V896c-1.6 17.6-16 32-33.6 32zm-416-64h384V643.2c0-19.2-16-35.2-35.2-35.2H355.2c-19.2 0-35.2 16-35.2 35.2V864zm315.2-448H388.8c-46.4 0-84.8-38.4-84.8-84.8V128c0-17.6 14.4-32 32-32h352c17.6 0 32 14.4 32 32v203.2c0 46.4-38.4 84.8-84.8 84.8zM368 160v171.2c0 11.2 9.6 20.8 20.8 20.8h246.4c11.2 0 20.8-9.6 20.8-20.8V160H368z"
  }), /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M576 304c-17.6 0-32-14.4-32-32v-32c0-17.6 14.4-32 32-32s32 14.4 32 32v32c0 17.6-14.4 32-32 32z"
  })]
}), qre = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "20",
  height: "20",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M213.333 128h85.334v85.333h-85.334v213.334A85.333 85.333 0 01128 512a85.333 85.333 0 0185.333 85.333v213.334h85.334V896h-85.334C167.68 884.48 128 857.6 128 810.667V640a85.333 85.333 0 00-85.333-85.333H0v-85.334h42.667A85.333 85.333 0 00128 384V213.333A85.333 85.333 0 01213.333 128m597.334 0A85.333 85.333 0 01896 213.333V384a85.333 85.333 0 0085.333 85.333H1024v85.334h-42.667A85.333 85.333 0 00896 640v170.667A85.333 85.333 0 01810.667 896h-85.334v-85.333h85.334V597.333A85.333 85.333 0 01896 512a85.333 85.333 0 01-85.333-85.333V213.333h-85.334V128h85.334M512 640a42.667 42.667 0 0142.667 42.667A42.667 42.667 0 01512 725.333a42.667 42.667 0 01-42.667-42.666A42.667 42.667 0 01512 640m-170.667 0A42.667 42.667 0 01384 682.667a42.667 42.667 0 01-42.667 42.666 42.667 42.667 0 01-42.666-42.666A42.667 42.667 0 01341.333 640m341.334 0a42.667 42.667 0 0142.666 42.667 42.667 42.667 0 01-42.666 42.666A42.667 42.667 0 01640 682.667 42.667 42.667 0 01682.667 640z"
  })
});
let dk = !1;
const wl = () => {
  if (dk)
    return;
  dk = !0;
  const n = oo(`
        <style>
            .lingo3d-ui * {
                overscroll-behavior: none;
                user-select: none;
                -webkit-user-select: none;
                position: relative;
                box-sizing: border-box;
                font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji" !important;
                scrollbar-width: none;
                scrollbar-color: rgba(100,100,100,0.1);
            }
            .lingo3d-ui {
                overscroll-behavior: none;
                position: relative;
                box-sizing: border-box;
                overflow: hidden;
                float: left;
                color: white;
                font-size: 11px;
                max-height: 100%;
            }
            .lingo3d-ui *::-webkit-scrollbar {
                width: 4px;
                height: 4px;
            }
            .lingo3d-ui *::-webkit-scrollbar-thumb {
                background: rgba(100,100,100,0.7);
            }
            .lingo3d-ui *::-webkit-scrollbar-track {
                background: rgba(100,100,100,0.1);
            }
            .lingo3d-ui *::-webkit-scrollbar-corner {
                background: rgba(100,100,100,0.1);
            }

            .lingo3d-bg {
                background: rgb(18, 19, 22);
            }
            .lingo3d-absfull {
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100%;
                height: 100%;
            }
            .lingo3d-flexcenter {
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .tp-lblv_l {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            .tp-rotv {
                box-shadow: none !important;
                background-color: transparent !important;
            }
            .tp-brkv {
                border-left: none !important;
            }
            .tp-fldv_b {
                border-radius: 0px !important;
            }

            .lingo3d-lingoeditor {
                display: grid;
                grid-template:  "toolbar scenegraph editor library tabs"
                                "toolbar scenegraph editor library world"
                                "toolbar panels     panels panels  world";
                grid-template-columns: auto auto auto auto 1fr;
                grid-template-rows: auto 1fr auto;
            }
            .lingo3d-scenegraph { grid-area: scenegraph; }
            .lingo3d-editor { grid-area: editor; }
            .lingo3d-library { grid-area: library; }
            .lingo3d-tabs { grid-area: tabs; }
            .lingo3d-panels { grid-area: panels; }
            .lingo3d-toolbar { grid-area: toolbar; }
            .lingo3d-world { grid-area: world; }

            .lingo3d-sk-cube-grid {
                width: 20px;
                height: 20px;
            }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube {
                width: 33%;
                height: 33%;
                background-color: currentColor;
                float: left;
                -webkit-animation: lingo3d-sk-cubeGridScaleDelay 1.3s infinite ease-in-out;
                        animation: lingo3d-sk-cubeGridScaleDelay 1.3s infinite ease-in-out; 
            }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube1 {
                -webkit-animation-delay: 0.2s;
                        animation-delay: 0.2s; }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube2 {
                -webkit-animation-delay: 0.3s;
                        animation-delay: 0.3s; }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube3 {
                -webkit-animation-delay: 0.4s;
                        animation-delay: 0.4s; }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube4 {
                -webkit-animation-delay: 0.1s;
                        animation-delay: 0.1s; }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube5 {
                -webkit-animation-delay: 0.2s;
                        animation-delay: 0.2s; }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube6 {
                -webkit-animation-delay: 0.3s;
                        animation-delay: 0.3s; }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube7 {
                -webkit-animation-delay: 0s;
                        animation-delay: 0s; }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube8 {
                -webkit-animation-delay: 0.1s;
                        animation-delay: 0.1s; }
            .lingo3d-sk-cube-grid .lingo3d-sk-cube9 {
                -webkit-animation-delay: 0.2s;
                        animation-delay: 0.2s; }
            
            @-webkit-keyframes lingo3d-sk-cubeGridScaleDelay {
                0%, 70%, 100% {
                -webkit-transform: scale3D(1, 1, 1);
                        transform: scale3D(1, 1, 1);
                } 35% {
                -webkit-transform: scale3D(0, 0, 1);
                        transform: scale3D(0, 0, 1); 
                }
            }
            @keyframes lingo3d-sk-cubeGridScaleDelay {
                0%, 70%, 100% {
                -webkit-transform: scale3D(1, 1, 1);
                        transform: scale3D(1, 1, 1);
                } 35% {
                -webkit-transform: scale3D(0, 0, 1);
                        transform: scale3D(0, 0, 1);
                } 
            }
            
            .lingo3d-fadein {
                animation: fadeIn 1s;
            }
            @keyframes fadeIn {
                0% { opacity: 0; }
                100% { opacity: 1; }
            }
            .lingo3d-fadeOut {
                animation: fadeOut 1s;
            }
            @keyframes fadeOut {
                0% { opacity: 1; }
                100% { opacity: 0; }
            }
        </style>
    `);
  document.head.appendChild(n);
}, Jv = () => {
  const n = xa(null);
  return qi(() => {
    const e = n.current;
    if (!e)
      return;
    const t = (i) => i.stopPropagation();
    return e.addEventListener("mousedown", t), e.addEventListener("pointerdown", t), e.addEventListener("touchstart", t), e.addEventListener("keydown", t), () => {
      e.removeEventListener("mousedown", t), e.removeEventListener("pointerdown", t), e.removeEventListener("touchstart", t), e.removeEventListener("keydown", t);
    };
  }, []), n;
}, It = (n) => gY(
  XA((e) => {
    const t = n(e);
    return () => {
      t.cancel();
    };
  }, []),
  XA(() => n(), [])
), [
  fk,
  Xre
] = Be(IM());
ft(() => {
  ro() === "scale" ? fk("local") : fk(IM());
}, [IM, ro]);
const O6 = () => {
  wl();
  const n = Jv(), e = It(ro), t = It(Xre), i = It(Nn), r = i && !Cc(i), s = i && Cc(i) && !(i instanceof $f);
  return /* @__PURE__ */ H("div", {
    ref: n,
    className: "lingo3d-ui lingo3d-bg lingo3d-toolbar",
    style: {
      width: 50,
      height: "100%",
      overflowY: "scroll"
    },
    children: /* @__PURE__ */ vt("div", {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        opacity: 0.75,
        paddingTop: 12
      },
      children: [/* @__PURE__ */ vt(fm, {
        children: [/* @__PURE__ */ H(fs, {
          active: e === "select",
          onClick: () => Co("select"),
          children: /* @__PURE__ */ H(zre, {})
        }), /* @__PURE__ */ H(fs, {
          active: e === "translate",
          onClick: () => Co("translate"),
          disabled: r,
          children: /* @__PURE__ */ H(Lre, {})
        }), /* @__PURE__ */ H(fs, {
          active: e === "rotate",
          disabled: s || r,
          onClick: () => Co("rotate"),
          children: /* @__PURE__ */ H(Dre, {})
        }), /* @__PURE__ */ H(fs, {
          active: e === "scale",
          disabled: s || r,
          onClick: () => Co("scale"),
          children: /* @__PURE__ */ H(Ire, {})
        })]
      }), /* @__PURE__ */ vt(fm, {
        children: [/* @__PURE__ */ H(fs, {
          active: t === "world",
          onClick: () => DM("world"),
          disabled: e !== "translate" && e !== "rotate",
          children: /* @__PURE__ */ H(Ore, {})
        }), /* @__PURE__ */ H(fs, {
          active: t === "local",
          onClick: () => DM("local"),
          disabled: e !== "translate" && e !== "rotate" && e !== "scale",
          children: /* @__PURE__ */ H(Nre, {})
        })]
      }), /* @__PURE__ */ vt(fm, {
        children: [/* @__PURE__ */ H(fs, {
          active: e === "curve",
          onClick: () => Co("curve"),
          children: /* @__PURE__ */ H(Gre, {})
        }), /* @__PURE__ */ H(fs, {
          active: e === "play",
          onClick: () => Co("play"),
          children: /* @__PURE__ */ H(Hre, {})
        })]
      }), /* @__PURE__ */ vt(fm, {
        children: [/* @__PURE__ */ H(fs, {
          onClick: NC,
          children: /* @__PURE__ */ H(Wre, {})
        }), /* @__PURE__ */ H(fs, {
          onClick: _6,
          children: /* @__PURE__ */ H(Fre, {})
        }), /* @__PURE__ */ H(fs, {
          onClick: zC,
          children: /* @__PURE__ */ H(jre, {})
        })]
      }), /* @__PURE__ */ vt(fm, {
        children: [/* @__PURE__ */ H(fs, {
          onClick: i6,
          children: /* @__PURE__ */ H(qre, {})
        }), /* @__PURE__ */ H(fs, {
          onClick: s6,
          children: /* @__PURE__ */ H(Bre, {})
        }), /* @__PURE__ */ H(fs, {
          onClick: a6,
          children: /* @__PURE__ */ H(Ure, {})
        })]
      })]
    })
  });
}, [GC, N6] = Be(void 0);
Nn(() => GC(void 0));
const z6 = ({
  position: n,
  setPosition: e,
  children: t,
  input: i,
  onInput: r
}) => {
  const s = Jv();
  if (!n)
    return null;
  const o = (Array.isArray(t) ? t.length : 1) * n5 + 16;
  return jE(/* @__PURE__ */ vt("div", {
    ref: s,
    className: "lingo3d-ui lingo3d-absfull",
    style: {
      zIndex: 2
    },
    onContextMenu: (a) => a.preventDefault(),
    children: [/* @__PURE__ */ H("div", {
      className: "lingo3d-absfull",
      onMouseDown: () => e(void 0)
    }), /* @__PURE__ */ H("div", {
      className: "lingo3d-bg",
      style: {
        position: "absolute",
        left: n.x,
        top: n.y + o > window.innerHeight ? window.innerHeight - o : n.y,
        padding: 6,
        border: "1px solid rgba(255, 255, 255, 0.2)"
      },
      children: i ? /* @__PURE__ */ H("input", {
        ref: (a) => setTimeout(() => a == null ? void 0 : a.focus()),
        style: {
          all: "unset",
          padding: 6
        },
        placeholder: i,
        onKeyDown: (a) => {
          a.stopPropagation(), !(a.key !== "Enter" && a.key !== "Escape") && (a.key === "Enter" && (r == null || r(a.currentTarget.value)), e(void 0));
        }
      }) : t
    })]
  }), document.body);
}, al = ({
  disabled: n,
  onClick: e,
  children: t
}) => {
  const [i, r] = ji(!1);
  return /* @__PURE__ */ H("div", {
    className: "lingo3d-flexcenter",
    style: {
      padding: 6,
      whiteSpace: "nowrap",
      background: !n && i ? "rgba(255, 255, 255, 0.1)" : void 0,
      opacity: n ? 0.5 : 1,
      cursor: n ? void 0 : "pointer",
      height: n5
    },
    onClick: n ? void 0 : e,
    onMouseEnter: n ? void 0 : () => r(!0),
    onMouseLeave: n ? void 0 : () => r(!1),
    children: t
  });
}, [px, F6] = Be(void 0), OM = new Is(0, 0);
document.addEventListener("mousemove", (n) => {
  OM.x = n.clientX, OM.y = n.clientY;
});
const [$re, Zre] = di(), [B6, _v] = Be([
  /* @__PURE__ */ new Set()
]), Yre = (n) => {
  const [e] = _v();
  e.add(n), B6([e]);
}, pk = (n) => {
  const [e] = _v();
  e.delete(n), B6([e]);
}, [mk, Kre] = Be([]), U6 = [{}];
Promise.resolve().then(() => ise).then(({ getTimelineData: n }) => {
  ft(() => {
    const [e] = n(), [t] = _v();
    if (!e) {
      mk([]);
      return;
    }
    const i = U6[0] = {};
    for (const [r, s] of Object.entries(e)) {
      const o = i[r] = {};
      for (const a of Object.values(s))
        for (const l of Object.keys(a))
          o[l] = !0;
      if (!!t.has(r))
        for (const [a, l] of Object.entries(s)) {
          const c = i[r + " " + a] = {};
          for (const d of Object.keys(l))
            c[d] = !0;
        }
    }
    mk(Object.entries(i));
  }, [_v, n]);
});
const [Jre, NM] = Be(!0), Qre = /* @__PURE__ */ new WeakMap(), V6 = (n) => Mr(Qre, Li(n, "constructor"), () => {
  const e = [];
  for (const [t, i] of Object.entries(
    Li(n.constructor, "schema")
  ))
    (i === Boolean || i === Number && t !== "rotation" && t !== "scale") && e.push(t);
  return e;
}), H6 = /* @__PURE__ */ new WeakMap(), vk = (n) => {
  const e = {};
  for (const t of V6(n))
    e[t] = Li(n, t);
  H6.set(n, e);
}, ese = (n) => {
  const e = [], t = H6.get(n);
  if (!t)
    return e;
  for (const i of V6(n)) {
    const r = Li(n, i);
    t[i] !== r && e.push([i, t[i], r]);
  }
  return e;
}, [Jb, tse] = di(), [nse, G6] = di();
ft(() => {
  if (!Fs())
    return;
  const n = /* @__PURE__ */ new Set(), e = No(() => {
    if (T2[0])
      return;
    n.clear();
    for (const d of hr())
      n.add(d);
    if (n.size)
      return;
    const c = Nn();
    c && n.add(c);
  }), t = Nn(e), i = hr(e), r = () => {
    for (const c of n)
      vk(c);
  }, s = () => gX(
    () => nse(
      [...n].map((c) => [c, ese(c)])
    )
  ), o = YO((c) => {
    c === "start" ? r() : c === "stop" && s();
  }), a = tse((c) => {
    c === "start" ? r() : c === "stop" && s();
  }), l = hr((c) => {
    for (const d of c)
      vk(d);
  });
  return () => {
    t.cancel(), i.cancel(), o.cancel(), a.cancel(), l.cancel();
  };
}, [Fs]);
const [gk, Ju] = Be([
  void 0
]);
ft(() => {
  const n = Zn();
  if (!n)
    return;
  const e = Sf(n, "dataState").get(gk);
  return () => {
    e.cancel(), gk([void 0]);
  };
}, [Zn]);
ft(() => {
  const [n] = Ju(), e = Zn();
  if (!n || !e || !NM())
    return;
  const t = new WeakSet(
    Object.keys(n).map((s) => no.get(s))
  ), i = G6((s) => {
    var c, d, p;
    const o = {}, a = Do(), [l] = U6;
    for (const [m, v] of s) {
      if (!t.has(m))
        continue;
      const { uuid: b } = m, x = n[b], y = Object.keys(l[b]).map(Number);
      for (const [S, C] of v) {
        let M = 0, T = a;
        for (const D of y) {
          if (D > a) {
            T = D;
            break;
          }
          D < a && (M = D);
        }
        const P = (c = x[S]) != null ? c : {};
        lr.exports.merge(o, {
          [b]: {
            [S]: {
              [M]: (d = P[M]) != null ? d : C,
              [T]: (p = P[T]) != null ? p : C,
              [a]: Li(m, S)
            }
          }
        });
      }
    }
    Object.keys(o) && e.mergeData(o);
  }), r = Ay((s) => {
    !t.has(s) || (delete n[s.uuid], e.data = n);
  });
  return () => {
    i.cancel(), r.cancel();
  };
}, [Ju, NM]);
const Qb = (n, e) => {
  const [t] = Ju(), i = Zn();
  if (!t || !i)
    return;
  const r = Ef(), s = Do() + "", o = r.split(" ");
  if (o.length === 1)
    for (const a of Object.keys(t[r]))
      n(t, r, a, s);
  else
    n(t, o[0], o[1], s);
  e || (i.data = t);
};
Zre(
  () => Qb(
    (n, e, t, i) => lr.exports.unset(n, [e, t, i])
  )
);
const ise = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getTimelineData: Ju,
  processKeyframe: Qb
}, Symbol.toStringTag, { value: "Module" })), W6 = (n, e) => {
  var i, r, s;
  e.add(n);
  const t = (s = (r = (i = Ov(n)) == null ? void 0 : i.parent) == null ? void 0 : r.outerObject3d) != null ? s : n.parent;
  t && W6(t, e);
}, rse = (n, e) => {
  const t = n.toLowerCase();
  let i;
  if (e instanceof jv ? e.loadedGroup.traverse((s) => {
    i || s.name.toLowerCase().includes(t) && (i = s);
  }) : e.outerObject3d.traverse((s) => {
    i || s.name.toLowerCase().includes(t) && (i = s);
  }), !i)
    return;
  const r = /* @__PURE__ */ new Set();
  W6(i, r), px(r), GC(i);
}, sse = () => {
  const [n, e] = ji(), t = It(Nn), [i] = It(Tc), [r] = It(Ju), s = It(Zn);
  return qi(() => {
    const o = zy(({
      rightClick: a
    }) => a && e(OM));
    return () => {
      o.cancel();
    };
  }, []), n ? /* @__PURE__ */ vt(z6, {
    position: n,
    setPosition: e,
    input: n.search && "Search child",
    onInput: (o) => t && rse(o, t),
    children: [t && !(t instanceof bc) && /* @__PURE__ */ vt(Ic, {
      children: [/* @__PURE__ */ H(al, {
        onClick: (o) => e({
          x: o.clientX,
          y: o.clientY,
          search: !0
        }),
        children: "Search children"
      }), /* @__PURE__ */ H(al, {
        disabled: !r || t.uuid in r,
        onClick: () => {
          s == null || s.mergeData({
            [t.uuid]: {}
          }), e(void 0);
        },
        children: r && t.uuid in r ? "Already in timeline" : "Add to timeline"
      }), /* @__PURE__ */ H(al, {
        onClick: () => {
          i.has(t) ? sK(t) : rK(t), e(void 0);
        },
        children: i.has(t) ? "Unfreeze selection" : "Freeze selection"
      })]
    }), t instanceof bc && /* @__PURE__ */ H(al, {
      disabled: t === s,
      onClick: () => {
        Fy(t), e(void 0);
      },
      children: t === s ? "Already editing" : "Edit timeline"
    }), /* @__PURE__ */ H(al, {
      disabled: !i.size,
      onClick: () => {
        oK(), e(void 0);
      },
      children: "Unfreeze all"
    })]
  }) : null;
}, [wde, _k] = Be(
  void 0
);
ft(() => {
  const n = _k();
  if (!n)
    return;
  const e = new Xn();
  return e.watch(
    n.loaded.then((t) => {
      t.getObjectByProperty(
        "type",
        "Bone"
      ).traverse((r) => r.name = "mixamorig" + r.name);
    })
  ), () => {
    e.cancel();
  };
}, [_k]);
const j6 = O5({}), q6 = (n, e, t) => {
  const i = UE(j6), { selectedSignal: r, tabs: s } = i;
  return Sr(() => {
    if (!!n)
      return s.push(n), () => {
        r.value === n && (r.value = s[s.indexOf(n) - 1]), TL(s, n);
      };
  }, []), Sr(() => {
    !t || !n || r.value === n && (r.value = s[s.indexOf(n) - 1]);
  }, [t]), Sr(() => {
    e && (r.value = n);
  }, [e]), i;
}, Oc = ({
  className: n,
  style: e,
  children: t,
  selectedSignal: i = Vy(void 0),
  noPadding: r
}) => {
  const s = Di(() => [], []);
  return qi(() => {
    var o;
    (o = i.value) != null || (i.value = s[0]);
  }, []), /* @__PURE__ */ H("div", {
    className: n,
    style: {
      width: "100%",
      height: xf + 8,
      display: "flex",
      alignItems: "center",
      paddingRight: r ? void 0 : 4,
      paddingLeft: r ? void 0 : 4,
      flexShrink: 0,
      background: "rgb(16, 17, 20)",
      ...e
    },
    children: /* @__PURE__ */ H(j6.Provider, {
      value: {
        selectedSignal: i,
        tabs: s
      },
      children: t
    })
  });
}, ose = ({
  title: n,
  children: e
}) => /* @__PURE__ */ vt(Oc, {
  style: {
    paddingLeft: 12,
    background: void 0
  },
  children: [/* @__PURE__ */ H("div", {
    style: {
      marginTop: -2
    },
    children: n
  }), /* @__PURE__ */ H("div", {
    style: {
      flexGrow: 1,
      minWidth: 4
    }
  }), e]
}), ps = ({
  children: n,
  onClick: e,
  disabled: t,
  outline: i,
  fill: r
}) => /* @__PURE__ */ H("div", {
  onClick: t ? void 0 : (s) => {
    s.stopPropagation(), e == null || e();
  },
  className: "lingo3d-flexcenter",
  style: {
    width: xf,
    height: xf - 4,
    marginRight: i ? 8 : 2,
    opacity: t ? 0.1 : 0.5,
    cursor: t ? void 0 : "pointer",
    background: i || r ? `rgba(255, 255, 255, ${r ? 0.2 : 0.1})` : void 0,
    border: i ? "1px solid rgba(255, 255, 255, 0.2)" : void 0
  },
  children: n
}), WC = O5({}), ase = ({
  children: n
}) => /* @__PURE__ */ H(WC.Provider, {
  value: {},
  children: n
}), lse = ({
  onDrop: n
}) => {
  const [e, t] = ji(!1), i = UE(WC);
  return /* @__PURE__ */ H("div", {
    onDragOver: (r) => {
      r.stopPropagation(), r.preventDefault(), i.draggingItem && t(!0);
    },
    onDragEnter: (r) => {
      r.stopPropagation(), r.preventDefault(), i.draggingItem && t(!0);
    },
    onDragLeave: (r) => {
      r.stopPropagation(), t(!1);
    },
    onDrop: (r) => {
      r.stopPropagation(), t(!1), i.draggingItem && (n == null || n(i.draggingItem));
    },
    style: {
      background: e ? "rgba(255, 255, 255, 0.5)" : "none",
      width: "100%",
      height: 18
    }
  });
}, X6 = () => {
  if (Io())
    return;
  const n = Nn(), e = hr();
  n == null || n.dispose();
  for (const t of e)
    t.dispose();
}, cse = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M630.09 151.91V62.16H361.84v89.74H93.6v134.62h89.41v673.11h625.93v-673.1h89.42V151.91H630.09zM361.84 869.89h-89.43V286.53h89.43v583.36zm178.84 0h-89.43V286.53h89.43v583.36zm178.84 0h-89.43V286.53h89.43v583.36z"
  })
}), $6 = () => /* @__PURE__ */ H("path", {
  fill: "#fff",
  d: "M914.5 653.5c-5.5 0-11 1.1-16 3.3l-.2.1h-.2L510.2 822.2 122.2 657h-.2l-.2-.1c-5-2.1-10.3-3.3-16-3.3-23.1 0-41.8 19.3-41.8 43.1 0 18 10.7 33.3 25.8 39.8l403.9 172.1.4.1c10.2 4.4 21.8 4.4 32 0l.2-.1c.1 0 .1-.1.2-.1l403.9-172.1c15.1-6.5 25.8-21.8 25.8-39.8.1-23.8-18.6-43.1-41.7-43.1zm0-186.5c-7.9-.2-16 3.2-16 3.2L510.2 635.6 121.8 470.2s-10.3-3.2-16-3.2C82.7 467 64 486.2 64 510c0 17.9 10.7 33.3 25.8 39.7l403.9 172c.1 0 .1.1.2.1l.1.1c5 2.1 10.3 3.3 16 3.3 5.7 0 11.1-1.2 16-3.3l.2-.1c.1 0 .1 0 .2-.1l403.9-172c15.1-6.4 25.8-21.8 25.9-39.7.1-23.8-18.6-43-41.7-43zM89.8 363.2l403.9 172.1c.1 0 .1 0 .2.1l.1.1c5 2.1 10.3 3.2 16 3.2 5.5 0 10.9-1.1 16-3.2l.2-.1.2-.1 403.9-172c15.1-6.5 25.8-21.8 25.9-39.7 0-18-10.7-33.3-25.8-39.8L526.5 111.6c-.1 0-.1 0-.2-.1l-.2-.1c-10.2-4.4-21.8-4.4-32 0l-.1.1L89.8 283.7C74.7 290.1 64 305.5 64 323.5c0 17.9 10.7 33.2 25.8 39.7z"
}), use = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H($6, {})
}), hse = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "18",
  height: "18",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M640 384h224a32 32 0 0132 32v384h-96v96H416a32 32 0 01-32-32V640H160a32 32 0 01-32-32V224h96v-96h384a32 32 0 0132 32v224zm0 32v192a32 32 0 01-32 32H416v224h352v-96h96V416H640zM96 96h96v96H96V96zm736 0h96v96h-96V96zM96 832h96v96H96v-96zm736 0h96v96h-96v-96z"
  })
}), kf = (n) => Li(n, "name") || lr.exports.upperFirst(Li(n.constructor, "componentName")), dse = ({
  style: n,
  onClick: e
}) => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  style: {
    margin: 2,
    flexShrink: 0,
    ...n
  },
  onMouseDown: (t) => t.stopPropagation(),
  onClick: (t) => (t.stopPropagation(), e == null ? void 0 : e()),
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M752 240H144c-17.7 0-32 14.3-32 32v608c0 17.7 14.3 32 32 32h608c17.7 0 32-14.3 32-32V272c0-17.7-14.3-32-32-32zM596 606c0 4.4-3.6 8-8 8H308c-4.4 0-8-3.6-8-8v-48c0-4.4 3.6-8 8-8h280c4.4 0 8 3.6 8 8v48zm284-494H264c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h576v576c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V144c0-17.7-14.3-32-32-32z"
  })
}), fse = ({
  style: n,
  onClick: e
}) => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  style: {
    margin: 2,
    flexShrink: 0,
    ...n
  },
  onMouseDown: (t) => t.stopPropagation(),
  onClick: (t) => (t.stopPropagation(), e == null ? void 0 : e()),
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M928.1 928.2H98v-830h830.1v830zm-104.8-415c0-24.6-19.9-44.5-44.5-44.5H556.5V246.4c0-24.6-19.9-44.5-44.5-44.5s-44.5 19.9-44.5 44.5v222.3H245.2c-24.6 0-44.5 19.9-44.5 44.5s19.9 44.5 44.5 44.5h222.3V780c0 24.6 19.9 44.5 44.5 44.5s44.5-19.9 44.5-44.5V557.7h222.3c24.6 0 44.5-20 44.5-44.5z"
  })
}), pse = (n) => {
  const e = xa(null);
  return qi(() => {
    const t = e.current;
    if (!t || !n)
      return;
    let i = 0, r = 0, s = 0;
    const o = (c) => {
      c.stopPropagation(), i = Date.now(), r = c.clientX, s = c.clientY;
    }, a = (c) => {
      c.stopPropagation();
      const d = Date.now(), p = d - i, m = Math.abs(c.clientX - r), v = Math.abs(c.clientY - s);
      i = d, r = c.clientX, s = c.clientY, p < 300 && m < 5 && v < 5 && n(c);
    }, l = (c) => {
      c.stopPropagation();
    };
    return t.addEventListener("mousedown", o), t.addEventListener("mouseup", a), t.addEventListener("click", l), () => {
      t.removeEventListener("mousedown", o), t.removeEventListener("mouseup", a), t.removeEventListener("click", l);
    };
  }, []), e;
}, [WS, jS] = Be(void 0);
ft(() => {
  var d;
  const n = jS(), e = qm({ x: 0, y: 0, z: 0 }), t = qm(), i = n instanceof DragEvent, r = V_(() => {
    if (!i)
      return;
    const p = new AC();
    return pI.add(p), p;
  }, [i]);
  if (typeof n == "function") {
    const p = n(t.current);
    if (!p)
      return;
    Object.assign(p, e.current), dr(p);
    return;
  }
  if (!i || !r)
    return;
  const [s, o] = JE(n.clientX, n.clientY), a = dI(s, o, mc);
  t.current = a && Ov(a.object);
  const l = (d = a == null ? void 0 : a.point) != null ? d : Gy(FC(n.clientX, n.clientY)), c = Po(l);
  return Object.assign(r, c), e.current = c, () => {
    !(jS() instanceof DragEvent) && r.dispose();
  };
}, [jS]);
pn.addEventListener("dragenter", (n) => n.preventDefault());
pn.addEventListener("dragover", (n) => n.preventDefault());
pn.addEventListener("dragleave", (n) => n.preventDefault());
pn.addEventListener("drop", (n) => n.preventDefault());
document.addEventListener("drop", (n) => n.preventDefault());
const Z6 = (n) => {
  let e;
  return pn.addEventListener(
    "dragover",
    (t) => e && WS(t)
  ), pn.addEventListener("dragleave", () => WS(void 0)), pn.addEventListener(
    "drop",
    () => e && WS((t) => n(e, t))
  ), (t) => e = t;
}, mx = document.createElement("img");
mx.src = "data:image/basis;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
mx.width = 0;
mx.height = 0;
const jC = (n) => n.dataTransfer.setDragImage(mx, 0, 0), Qv = ({
  label: n,
  children: e,
  selected: t,
  onCollapse: i,
  onExpand: r,
  onClick: s,
  onContextMenu: o,
  onDrop: a,
  myDraggingItem: l,
  draggable: c,
  expanded: d,
  expandable: p = !!e,
  outlined: m,
  IconComponent: v,
  height: b
}) => {
  const x = {
    opacity: p ? 0.5 : 0.05,
    cursor: "pointer"
  }, [y, S] = ji(!!d);
  qi(() => {
    S(!!d);
  }, [d]);
  const C = pse(s), M = xa(null), T = Di(() => {
    if (!t || !C.current || !M.current)
      return;
    const Y = C.current.getBoundingClientRect();
    return M.current.getBoundingClientRect().right - Y.left + 4;
  }, [t, y]), P = () => {
    S(!1), i == null || i();
  }, D = () => {
    S(!0), r == null || r();
  }, I = UE(WC), k = () => c && I.draggingItem && I.draggingItem !== l, [O, B] = ji(!1);
  return /* @__PURE__ */ vt("div", {
    draggable: c,
    onDragStart: (Y) => {
      Y.stopPropagation(), I.draggingItem = l, jC(Y);
    },
    onDragEnd: (Y) => {
      Y.stopPropagation(), I.draggingItem = void 0;
    },
    onDragOver: (Y) => {
      Y.stopPropagation(), Y.preventDefault(), k() && B(!0);
    },
    onDragEnter: (Y) => {
      Y.stopPropagation(), Y.preventDefault(), k() && B(!0);
    },
    onDragLeave: (Y) => {
      Y.stopPropagation(), k() && B(!1);
    },
    onDrop: (Y) => {
      Y.stopPropagation(), k() && (B(!1), I.draggingItem.traverseSome((G) => l === G) || a == null || a(I.draggingItem));
    },
    style: {
      color: "rgba(255, 255, 255, 0.75)",
      marginLeft: 8,
      borderLeft: "1px solid rgba(255, 255, 255, 0.05)",
      background: O ? "rgba(255, 255, 255, 0.5)" : "none"
    },
    children: [/* @__PURE__ */ vt("div", {
      ref: C,
      onDblClick: (Y) => {
        Y.stopPropagation(), y ? P() : D();
      },
      onContextMenu: (Y) => {
        Y.stopPropagation(), Y.preventDefault(), o == null || o();
      },
      style: {
        display: "flex",
        alignItems: "center",
        backgroundColor: t && !m ? "rgba(255, 255, 255, 0.1)" : void 0,
        outline: t && m ? "1px solid rgba(255, 255, 255, 0.5)" : void 0,
        width: T,
        minWidth: "100%",
        height: b
      },
      children: [y ? /* @__PURE__ */ H(dse, {
        style: x,
        onClick: P
      }) : /* @__PURE__ */ H(fse, {
        style: x,
        onClick: D
      }), v && /* @__PURE__ */ H(v, {}), /* @__PURE__ */ H("div", {
        ref: M,
        style: {
          whiteSpace: "nowrap"
        },
        children: n
      })]
    }), y && (typeof e == "function" ? e() : e)]
  });
}, mse = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  style: {
    margin: 2,
    opacity: 0.25,
    flexShrink: 0
  },
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M838.4 325.12L554.24 479.36C528 493.44 512 521.6 512 552.96V851.2c0 32 31.36 53.12 57.6 38.4l284.16-154.24c25.6-14.08 42.24-42.24 42.24-73.6v-297.6c0-32.64-31.36-53.12-57.6-39.04zm-432.64 153.6L121.6 325.12c-26.24-14.08-57.6 6.4-57.6 38.4v299.52c0 31.36 16 59.52 42.24 73.6l284.16 153.6c26.24 14.08 57.6-7.04 57.6-39.04V552.32c0-31.36-16-59.52-42.24-73.6zm406.4-223.36c13.44-7.04 19.84-19.2 18.56-30.72 1.28-12.16-5.12-23.68-18.56-30.72L522.88 42.88c-12.8-7.04-28.16-10.24-43.52-10.24-15.36 0-30.72 3.2-43.52 10.24l-289.28 150.4c-13.44 7.04-19.2 19.2-18.56 30.72-.64 12.16 5.12 24.32 18.56 31.36l289.28 150.4C448.64 412.8 464 416 479.36 416c15.36 0 30.72-3.2 43.52-10.24l289.28-150.4z"
  })
}), vse = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  style: {
    margin: 2,
    opacity: 0.25,
    flexShrink: 0
  },
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M512 42.667C252.793 42.667 42.667 252.793 42.667 512S252.793 981.333 512 981.333 981.333 771.207 981.333 512 771.207 42.667 512 42.667zM708.547 543.16l-266.667 176A37.333 37.333 0 01384 688V336.033a37.333 37.333 0 0157.893-31.16l266.667 176a37.333 37.333 0 010 62.32z"
  })
}), gse = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  style: {
    margin: 2,
    opacity: 0.25,
    flexShrink: 0
  },
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M158.2 158.5h707.6c20.3 0 36.6 16.3 36.6 36.6v288.7c-36.6-28.5-105.7-73.2-158.6-73.2-77.3 0-146.4 178.9-231.8 178.9-65.1-4.1-154.5-77.3-256.2-65.1-40.7 8.1-97.6 73.2-134.2 122V195.1c0-20.4 16.3-36.6 36.6-36.6zM329 451.3c-32.5 0-61-12.2-81.3-32.5s-32.5-52.9-32.5-81.3c0-28.5 12.2-61 32.5-81.3 20.3-20.3 48.8-32.5 81.3-32.5 28.5 0 56.9 12.2 81.3 32.5 20.3 20.3 32.5 52.9 32.5 81.3 0 28.5-12.2 61-32.5 81.3-24.4 20.3-52.8 32.5-81.3 32.5zm557.1-345.7H137.9c-40.7 0-73.2 32.5-73.2 73.2v666.9c0 40.7 32.5 73.2 73.2 73.2h748.3c40.7 0 73.2-32.5 73.2-73.2V178.8c-.1-40.7-32.6-73.2-73.3-73.2zm0 0"
  })
}), Qu = (n, e, t) => {
  ma() && Co("translate"), queueMicrotask(() => {
    Cc(t) && Nn() !== t && dr(t, e, !0), n instanceof wn ? queueMicrotask(() => GC(n)) : dr(n, e, !0);
  });
}, qC = ({
  appendable: n,
  children: e,
  expandable: t
}) => {
  var p;
  const i = Di(() => n.children ? [...n.children].filter((m) => !ko.has(m)) : void 0, [(p = n.children) == null ? void 0 : p.size]), r = It(Nn), s = It(hr), o = r === n || s.includes(n), a = It(F6), l = Di(() => n instanceof ra ? vse : n instanceof Bd ? gse : mse, [n]), [c, d] = ji("");
  return Sr(() => {
    d(kf(n));
    const m = gI((v) => v === n && d(kf(n)));
    return () => {
      m.cancel();
    };
  }, [n]), /* @__PURE__ */ H(Qv, {
    label: c,
    selected: o,
    draggable: !0,
    myDraggingItem: n,
    onDrop: (m) => n.attach(m),
    expanded: a == null ? void 0 : a.has(n.outerObject3d),
    onCollapse: () => px(void 0),
    expandable: t != null ? t : !!(i != null && i.length),
    onClick: () => Qu(n),
    onContextMenu: () => Qu(n, !0),
    IconComponent: l,
    children: () => /* @__PURE__ */ vt(Ic, {
      children: [i == null ? void 0 : i.map((m) => m instanceof gs ? /* @__PURE__ */ H(K6, {
        appendable: m
      }, m.uuid) : /* @__PURE__ */ H(qC, {
        appendable: m
      }, m.uuid)), e]
    })
  });
}, _se = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  style: {
    margin: 2,
    opacity: 0.25,
    flexShrink: 0
  },
  children: /* @__PURE__ */ H($6, {})
}), bse = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  style: {
    margin: 2,
    opacity: 0.25,
    flexShrink: 0
  },
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M699.904 10.496c-25.216-14.976-57.856-5.76-70.912 20.48-30.592 61.44-87.552 153.088-145.92 192.512-11.008 7.424-22.4 14.592-31.488 24.704-52.352 59.008-35.328 147.072 29.184 183.936 23.424 13.44 49.408 17.792 74.112 14.592 25.728-3.456 50.944 11.008 60.928 34.816 9.728 23.04 26.752 43.136 50.176 56.576 64.512 36.864 149.12 6.912 173.312-68.096 3.968-12.16 5.12-24.576 5.504-37.12 2.176-77.312 53.504-163.712 92.288-216.576 17.536-24.064 10.624-57.856-14.976-73.088L699.904 10.496zm-41.344 323.84c.512.256.896.64 1.408.896-.512.256-.896.512-1.408.768.128-.512 0-1.024 0-1.664zm75.008 372.48c9.088-34.176-.512-69.376-25.344-94.464C688 592 663.296 582.4 638.72 581.632c-14.72-.384-27.776-9.6-33.28-23.296-8.192-20.096-22.784-37.632-43.008-49.28-20.864-11.904-44.288-15.488-66.304-11.904-14.592 2.432-28.8-4.864-36.608-17.408-12.032-19.584-30.848-35.456-55.808-43.52-40.576-13.184-86.784 2.176-111.872 36.736-17.408 23.936-15.744 91.904-16.64 99.2-1.28 10.624-1.536 14.208-1.664 21.632-2.176 77.312-54.784 163.712-93.568 216.576-17.536 24.064-10.624 57.856 14.976 73.088l222.336 132.736c25.216 14.976 57.856 5.76 70.912-20.48 30.592-61.44 87.552-153.088 145.92-192.512 10.752-7.168 89.6-59.008 99.456-96.384zM456.96 691.584c.512-.256.896-.512 1.408-.768v1.792a5.683 5.683 0 00-1.408-1.024z"
  })
}), Y6 = ({
  appendable: n,
  object3d: e
}) => {
  const [t, i] = ji(!1), r = It(N6), s = It(F6);
  qi(() => {
    s != null && s.has(e) && i(!0);
  }, [s]);
  const o = r === e, a = Di(() => "isBone" in e ? bse : _se, [e]);
  return /* @__PURE__ */ H(Qv, {
    label: e.name,
    selected: o,
    onCollapse: () => px(void 0),
    onClick: () => Qu(e, !1, n),
    onContextMenu: () => Qu(e, !0, n),
    expanded: t,
    expandable: !!e.children.length,
    outlined: !0,
    IconComponent: a,
    children: () => e.children.map((l) => /* @__PURE__ */ H(Y6, {
      object3d: l,
      appendable: n
    }, l.uuid))
  });
}, K6 = ({
  appendable: n
}) => {
  const [e, t] = ji(), {
    loaded: i
  } = n;
  return qi(() => {
    t(void 0);
    const r = i.then(() => {
      t(n.loadedGroup.children[0]);
    });
    return () => {
      r.cancel();
    };
  }, [i]), /* @__PURE__ */ H(qC, {
    appendable: n,
    expandable: !!e,
    children: e && /* @__PURE__ */ H(Y6, {
      appendable: n,
      object3d: e
    })
  });
}, yse = () => {
  const [n, e] = ji({});
  Sr(() => {
    const a = PE(() => e({}));
    return () => {
      a.cancel();
    };
  }, []);
  const t = Di(() => [...Zr].filter((a) => !ko.has(a)), [n]), i = It(hr), r = It(Nn), s = It(N6);
  return /* @__PURE__ */ H("div", {
    children: /* @__PURE__ */ vt("div", {
      className: "lingo3d-absfull",
      style: {
        display: "flex",
        flexDirection: "column"
      },
      children: [/* @__PURE__ */ vt(ose, {
        title: "scenegraph",
        children: [/* @__PURE__ */ H(ps, {
          disabled: !s,
          onClick: () => {
            (s == null ? void 0 : s.name) && r instanceof mh && setTimeout(() => dr(r.find(s.name)));
          },
          children: /* @__PURE__ */ H(use, {})
        }), /* @__PURE__ */ H(ps, {
          disabled: !i.length,
          onClick: Bne,
          children: /* @__PURE__ */ H(hse, {})
        }), /* @__PURE__ */ H(ps, {
          disabled: !r,
          onClick: X6,
          children: /* @__PURE__ */ H(cse, {})
        })]
      }), /* @__PURE__ */ H("div", {
        style: {
          overflow: "scroll",
          flexGrow: 1
        },
        children: /* @__PURE__ */ vt(ase, {
          children: [t.map((a) => a instanceof gs ? /* @__PURE__ */ H(K6, {
            appendable: a
          }, a.uuid) : /* @__PURE__ */ H(qC, {
            appendable: a
          }, a.uuid)), /* @__PURE__ */ H(lse, {
            onDrop: (a) => {
              var l, c;
              j_(), Zr.add(a), bt.attach(a.outerObject3d), (c = (l = a.parent) == null ? void 0 : l.children) == null || c.delete(a), a.parent = void 0;
            }
          })]
        })
      })]
    })
  });
}, J6 = () => {
  wl();
  const n = Jv();
  return /* @__PURE__ */ vt(Ic, {
    children: [/* @__PURE__ */ H("div", {
      ref: n,
      className: "lingo3d-ui lingo3d-bg lingo3d-scenegraph",
      onClick: () => dr(void 0),
      onContextMenu: (e) => {
        e.preventDefault(), dr(void 0, !0);
      },
      style: {
        width: 200,
        height: "100%",
        display: "grid",
        gridTemplateRows: "1fr auto"
      },
      children: /* @__PURE__ */ H(yse, {})
    }), /* @__PURE__ */ H(sse, {})]
  });
}, ey = [!1], bk = () => {
  ey[0] = !0, Jb("start");
}, yk = () => {
  Jb("stop"), queueMicrotask(() => ey[0] = !1);
};
class xse {
  constructor(e) {
    const [t, i] = e.split("-"), r = t.split(".");
    this.major = parseInt(r[0], 10), this.minor = parseInt(r[1], 10), this.patch = parseInt(r[2], 10), this.prerelease = i != null ? i : null;
  }
  toString() {
    const e = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [e, this.prerelease].join("-") : e;
  }
}
class Sl {
  constructor(e) {
    this.controller_ = e;
  }
  get element() {
    return this.controller_.view.element;
  }
  get disabled() {
    return this.controller_.viewProps.get("disabled");
  }
  set disabled(e) {
    this.controller_.viewProps.set("disabled", e);
  }
  get hidden() {
    return this.controller_.viewProps.get("hidden");
  }
  set hidden(e) {
    this.controller_.viewProps.set("hidden", e);
  }
  dispose() {
    this.controller_.viewProps.set("disposed", !0);
  }
}
class eg {
  constructor(e) {
    this.target = e;
  }
}
class Lf extends eg {
  constructor(e, t, i, r) {
    super(e), this.value = t, this.presetKey = i, this.last = r != null ? r : !0;
  }
}
class Q6 extends eg {
  constructor(e, t, i) {
    super(e), this.value = t, this.presetKey = i;
  }
}
class wse extends eg {
  constructor(e, t) {
    super(e), this.expanded = t;
  }
}
class Sse extends eg {
  constructor(e, t) {
    super(e), this.index = t;
  }
}
function Zi(n) {
  return n == null;
}
function Mse(n, e) {
  if (n.length !== e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
const Ese = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (n) => `Invalid parameters for '${n.name}'`,
  nomatchingcontroller: (n) => `No matching controller for '${n.key}'`,
  nomatchingview: (n) => `No matching view for '${JSON.stringify(n.params)}'`,
  notbindable: () => "Value is not bindable",
  propertynotfound: (n) => `Property '${n.name}' not found`,
  shouldneverhappen: () => "This error should never happen"
};
class xn {
  constructor(e) {
    var t;
    this.message = (t = Ese[e.type](
      e.context
    )) !== null && t !== void 0 ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type;
  }
  static alreadyDisposed() {
    return new xn({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new xn({
      type: "notbindable"
    });
  }
  static propertyNotFound(e) {
    return new xn({
      type: "propertynotfound",
      context: {
        name: e
      }
    });
  }
  static shouldNeverHappen() {
    return new xn({ type: "shouldneverhappen" });
  }
}
class ty {
  constructor(e, t, i) {
    this.obj_ = e, this.key_ = t, this.presetKey_ = i != null ? i : t;
  }
  static isBindable(e) {
    return !(e === null || typeof e != "object");
  }
  get key() {
    return this.key_;
  }
  get presetKey() {
    return this.presetKey_;
  }
  read() {
    return this.obj_[this.key_];
  }
  write(e) {
    this.obj_[this.key_] = e;
  }
  writeProperty(e, t) {
    const i = this.read();
    if (!ty.isBindable(i))
      throw xn.notBindable();
    if (!(e in i))
      throw xn.propertyNotFound(e);
    i[e] = t;
  }
}
class Cse extends Sl {
  get label() {
    return this.controller_.props.get("label");
  }
  set label(e) {
    this.controller_.props.set("label", e);
  }
  get title() {
    var e;
    return (e = this.controller_.valueController.props.get("title")) !== null && e !== void 0 ? e : "";
  }
  set title(e) {
    this.controller_.valueController.props.set("title", e);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.controller_.valueController.emitter.on(e, () => {
      i(new eg(this));
    }), this;
  }
}
class Oi {
  constructor() {
    this.observers_ = {};
  }
  on(e, t) {
    let i = this.observers_[e];
    return i || (i = this.observers_[e] = []), i.push({
      handler: t
    }), this;
  }
  off(e, t) {
    const i = this.observers_[e];
    return i && (this.observers_[e] = i.filter((r) => r.handler !== t)), this;
  }
  emit(e, t) {
    const i = this.observers_[e];
    !i || i.forEach((r) => {
      r.handler(t);
    });
  }
}
const Tse = "tp";
function _n(n) {
  return (t, i) => [
    Tse,
    "-",
    n,
    "v",
    t ? `_${t}` : "",
    i ? `-${i}` : ""
  ].join("");
}
function Pse(n, e) {
  return (t) => e(n(t));
}
function Ase(n) {
  return n.rawValue;
}
function Qf(n, e) {
  n.emitter.on("change", Pse(Ase, e)), e(n.rawValue);
}
function Ns(n, e, t) {
  Qf(n.value(e), t);
}
function Rse(n, e, t) {
  t ? n.classList.add(e) : n.classList.remove(e);
}
function ep(n, e) {
  return (t) => {
    Rse(n, e, t);
  };
}
function XC(n, e) {
  Qf(n, (t) => {
    e.textContent = t != null ? t : "";
  });
}
const qS = _n("btn");
class kse {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(qS()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("button");
    i.classList.add(qS("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
    const r = e.createElement("div");
    r.classList.add(qS("t")), XC(t.props.value("title"), r), this.buttonElement.appendChild(r);
  }
}
class xk {
  constructor(e, t) {
    this.emitter = new Oi(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new kse(e, {
      props: this.props,
      viewProps: this.viewProps
    }), this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this
    });
  }
}
class Lse {
  constructor(e, t) {
    var i;
    this.constraint_ = t == null ? void 0 : t.constraint, this.equals_ = (i = t == null ? void 0 : t.equals) !== null && i !== void 0 ? i : (r, s) => r === s, this.emitter = new Oi(), this.rawValue_ = e;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(e) {
    this.setRawValue(e, {
      forceEmit: !1,
      last: !0
    });
  }
  setRawValue(e, t) {
    const i = t != null ? t : {
      forceEmit: !1,
      last: !0
    }, r = this.constraint_ ? this.constraint_.constrain(e) : e;
    !!this.equals_(this.rawValue_, r) && !i.forceEmit || (this.emitter.emit("beforechange", {
      sender: this
    }), this.rawValue_ = r, this.emitter.emit("change", {
      options: i,
      rawValue: r,
      sender: this
    }));
  }
}
class Dse {
  constructor(e) {
    this.emitter = new Oi(), this.value_ = e;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(e) {
    this.setRawValue(e, {
      forceEmit: !1,
      last: !0
    });
  }
  setRawValue(e, t) {
    const i = t != null ? t : {
      forceEmit: !1,
      last: !0
    };
    this.value_ === e && !i.forceEmit || (this.emitter.emit("beforechange", {
      sender: this
    }), this.value_ = e, this.emitter.emit("change", {
      options: i,
      rawValue: this.value_,
      sender: this
    }));
  }
}
function Fr(n, e) {
  const t = e == null ? void 0 : e.constraint, i = e == null ? void 0 : e.equals;
  return !t && !i ? new Dse(n) : new Lse(n, e);
}
class Qt {
  constructor(e) {
    this.emitter = new Oi(), this.valMap_ = e;
    for (const t in this.valMap_)
      this.valMap_[t].emitter.on("change", () => {
        this.emitter.emit("change", {
          key: t,
          sender: this
        });
      });
  }
  static createCore(e) {
    return Object.keys(e).reduce((i, r) => Object.assign(i, {
      [r]: Fr(e[r])
    }), {});
  }
  static fromObject(e) {
    const t = this.createCore(e);
    return new Qt(t);
  }
  get(e) {
    return this.valMap_[e].rawValue;
  }
  set(e, t) {
    this.valMap_[e].rawValue = t;
  }
  value(e) {
    return this.valMap_[e];
  }
}
function Ise(n, e) {
  const i = Object.keys(e).reduce((r, s) => {
    if (r === void 0)
      return;
    const o = e[s], a = o(n[s]);
    return a.succeeded ? Object.assign(Object.assign({}, r), { [s]: a.value }) : void 0;
  }, {});
  return i;
}
function Ose(n, e) {
  return n.reduce((t, i) => {
    if (t === void 0)
      return;
    const r = e(i);
    if (!(!r.succeeded || r.value === void 0))
      return [...t, r.value];
  }, []);
}
function Nse(n) {
  return n === null ? !1 : typeof n == "object";
}
function tl(n) {
  return (e) => (t) => {
    if (!e && t === void 0)
      return {
        succeeded: !1,
        value: void 0
      };
    if (e && t === void 0)
      return {
        succeeded: !0,
        value: void 0
      };
    const i = n(t);
    return i !== void 0 ? {
      succeeded: !0,
      value: i
    } : {
      succeeded: !1,
      value: void 0
    };
  };
}
function wk(n) {
  return {
    custom: (e) => tl(e)(n),
    boolean: tl(
      (e) => typeof e == "boolean" ? e : void 0
    )(n),
    number: tl(
      (e) => typeof e == "number" ? e : void 0
    )(n),
    string: tl(
      (e) => typeof e == "string" ? e : void 0
    )(n),
    function: tl(
      (e) => typeof e == "function" ? e : void 0
    )(n),
    constant: (e) => tl((t) => t === e ? e : void 0)(
      n
    ),
    raw: tl((e) => e)(n),
    object: (e) => tl((t) => {
      if (!!Nse(t))
        return Ise(t, e);
    })(n),
    array: (e) => tl((t) => {
      if (!!Array.isArray(t))
        return Ose(t, e);
    })(n)
  };
}
const si = {
  optional: wk(!0),
  required: wk(!1)
};
function Tr(n, e) {
  const t = si.required.object(e)(n);
  return t.succeeded ? t.value : void 0;
}
function zse(n) {
  return n && n.parentElement && n.parentElement.removeChild(n), null;
}
function Fse() {
  return ["veryfirst", "first", "last", "verylast"];
}
const Sk = _n(""), Mk = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst"
};
class tg {
  constructor(e) {
    this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
    const t = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      Fse().forEach((i) => {
        t.classList.remove(
          Sk(void 0, Mk[i])
        );
      }), this.blade.get("positions").forEach((i) => {
        t.classList.add(
          Sk(void 0, Mk[i])
        );
      });
    }), this.viewProps.handleDispose(() => {
      zse(t);
    });
  }
  get parent() {
    return this.parent_;
  }
}
const ca = "http://www.w3.org/2000/svg";
function ny(n) {
  n.offsetHeight;
}
function Bse(n, e) {
  const t = n.style.transition;
  n.style.transition = "none", e(), n.style.transition = t;
}
function $C(n) {
  return n.ontouchstart !== void 0;
}
function Use() {
  return new Function("return this")();
}
function Vse() {
  return Use().document;
}
function Hse(n) {
  const e = n.ownerDocument.defaultView;
  return e && "document" in e ? n.getContext("2d") : null;
}
const Gse = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
};
function vx(n, e) {
  const t = n.createElementNS(ca, "svg");
  return t.innerHTML = Gse[e], t;
}
function eN(n, e, t) {
  n.insertBefore(e, n.children[t]);
}
function tN(n) {
  n.parentElement && n.parentElement.removeChild(n);
}
function nN(n) {
  for (; n.children.length > 0; )
    n.removeChild(n.children[0]);
}
function Wse(n) {
  for (; n.childNodes.length > 0; )
    n.removeChild(n.childNodes[0]);
}
function iN(n) {
  return n.relatedTarget ? n.relatedTarget : "explicitOriginalTarget" in n ? n.explicitOriginalTarget : null;
}
const pm = _n("lbl");
function jse(n, e) {
  const t = n.createDocumentFragment();
  return e.split(`
`).map((r) => n.createTextNode(r)).forEach((r, s) => {
    s > 0 && t.appendChild(n.createElement("br")), t.appendChild(r);
  }), t;
}
class rN {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(pm()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(pm("l")), Ns(t.props, "label", (s) => {
      Zi(s) ? this.element.classList.add(pm(void 0, "nol")) : (this.element.classList.remove(pm(void 0, "nol")), Wse(i), i.appendChild(jse(e, s)));
    }), this.element.appendChild(i), this.labelElement = i;
    const r = e.createElement("div");
    r.classList.add(pm("v")), this.element.appendChild(r), this.valueElement = r;
  }
}
class iy extends tg {
  constructor(e, t) {
    const i = t.valueController.viewProps;
    super(
      Object.assign(Object.assign({}, t), {
        view: new rN(e, {
          props: t.props,
          viewProps: i
        }),
        viewProps: i
      })
    ), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
  }
}
const qse = {
  id: "button",
  type: "blade",
  accept(n) {
    const e = si, t = Tr(n, {
      title: e.required.string,
      view: e.required.constant("button"),
      label: e.optional.string
    });
    return t ? { params: t } : null;
  },
  controller(n) {
    return new iy(n.document, {
      blade: n.blade,
      props: Qt.fromObject({
        label: n.params.label
      }),
      valueController: new xk(n.document, {
        props: Qt.fromObject({
          title: n.params.title
        }),
        viewProps: n.viewProps
      })
    });
  },
  api(n) {
    return !(n.controller instanceof iy) || !(n.controller.valueController instanceof xk) ? null : new Cse(n.controller);
  }
};
class ff extends tg {
  constructor(e) {
    super(e), this.value = e.value;
  }
}
function ng() {
  return new Qt({
    positions: Fr([], {
      equals: Mse
    })
  });
}
class ig extends Qt {
  constructor(e) {
    super(e);
  }
  static create(e) {
    const t = {
      completed: !0,
      expanded: e,
      expandedHeight: null,
      shouldFixHeight: !1,
      temporaryExpanded: null
    }, i = Qt.createCore(t);
    return new ig(i);
  }
  get styleExpanded() {
    var e;
    return (e = this.get("temporaryExpanded")) !== null && e !== void 0 ? e : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded)
      return "0";
    const e = this.get("expandedHeight");
    return this.get("shouldFixHeight") && !Zi(e) ? `${e}px` : "auto";
  }
  bindExpandedClass(e, t) {
    const i = () => {
      this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
    };
    Ns(this, "expanded", i), Ns(this, "temporaryExpanded", i);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0);
  }
}
function Xse(n, e) {
  let t = 0;
  return Bse(e, () => {
    n.set("expandedHeight", null), n.set("temporaryExpanded", !0), ny(e), t = e.clientHeight, n.set("temporaryExpanded", null), ny(e);
  }), t;
}
function Ek(n, e) {
  e.style.height = n.styleHeight;
}
function ZC(n, e) {
  n.value("expanded").emitter.on("beforechange", () => {
    n.set("completed", !1), Zi(n.get("expandedHeight")) && n.set(
      "expandedHeight",
      Xse(n, e)
    ), n.set("shouldFixHeight", !0), ny(e);
  }), n.emitter.on("change", () => {
    Ek(n, e);
  }), Ek(n, e), e.addEventListener("transitionend", (t) => {
    t.propertyName === "height" && n.cleanUpTransition();
  });
}
class YC extends Sl {
  constructor(e, t) {
    super(e), this.rackApi_ = t;
  }
}
function $se(n, e) {
  return n.addBlade(
    Object.assign(Object.assign({}, e), { view: "button" })
  );
}
function Zse(n, e) {
  return n.addBlade(
    Object.assign(Object.assign({}, e), { view: "folder" })
  );
}
function Yse(n, e) {
  const t = e != null ? e : {};
  return n.addBlade(
    Object.assign(Object.assign({}, t), { view: "separator" })
  );
}
function Kse(n, e) {
  return n.addBlade(
    Object.assign(Object.assign({}, e), { view: "tab" })
  );
}
class KC {
  constructor(e) {
    this.emitter = new Oi(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(e) {
    for (const t of this.allItems())
      if (e(t))
        return t;
    return null;
  }
  includes(e) {
    return this.cache_.has(e);
  }
  add(e, t) {
    if (this.includes(e))
      throw xn.shouldNeverHappen();
    const i = t !== void 0 ? t : this.items_.length;
    this.items_.splice(i, 0, e), this.cache_.add(e);
    const r = this.extract_(e);
    r && (r.emitter.on("add", this.onSubListAdd_), r.emitter.on("remove", this.onSubListRemove_), r.allItems().forEach((s) => {
      this.cache_.add(s);
    })), this.emitter.emit("add", {
      index: i,
      item: e,
      root: this,
      target: this
    });
  }
  remove(e) {
    const t = this.items_.indexOf(e);
    if (t < 0)
      return;
    this.items_.splice(t, 1), this.cache_.delete(e);
    const i = this.extract_(e);
    i && (i.emitter.off("add", this.onSubListAdd_), i.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
      index: t,
      item: e,
      root: this,
      target: this
    });
  }
  onSubListAdd_(e) {
    this.cache_.add(e.item), this.emitter.emit("add", {
      index: e.index,
      item: e.item,
      root: this,
      target: e.target
    });
  }
  onSubListRemove_(e) {
    this.cache_.delete(e.item), this.emitter.emit("remove", {
      index: e.index,
      item: e.item,
      root: this,
      target: e.target
    });
  }
}
class sN extends Sl {
  constructor(e) {
    super(e), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new Oi(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
  }
  get label() {
    return this.controller_.props.get("label");
  }
  set label(e) {
    this.controller_.props.set("label", e);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (r) => {
      i(r.event);
    }), this;
  }
  refresh() {
    this.controller_.binding.read();
  }
  onBindingChange_(e) {
    const t = e.sender.target.read();
    this.emitter_.emit("change", {
      event: new Lf(
        this,
        t,
        this.controller_.binding.target.presetKey,
        e.options.last
      )
    });
  }
}
class da extends iy {
  constructor(e, t) {
    super(e, t), this.binding = t.binding;
  }
}
class oN extends Sl {
  constructor(e) {
    super(e), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new Oi(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
  }
  get label() {
    return this.controller_.props.get("label");
  }
  set label(e) {
    this.controller_.props.set("label", e);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (r) => {
      i(r.event);
    }), this;
  }
  refresh() {
    this.controller_.binding.read();
  }
  onBindingUpdate_(e) {
    const t = e.sender.target.read();
    this.emitter_.emit("update", {
      event: new Q6(
        this,
        t,
        this.controller_.binding.target.presetKey
      )
    });
  }
}
class xc extends iy {
  constructor(e, t) {
    super(e, t), this.binding = t.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
      this.binding.dispose();
    });
  }
}
function Jse(n) {
  return n instanceof gx ? n.apiSet_ : n instanceof YC ? n.rackApi_.apiSet_ : null;
}
function mm(n, e) {
  const t = n.find((i) => i.controller_ === e);
  if (!t)
    throw xn.shouldNeverHappen();
  return t;
}
function Ck(n, e, t) {
  if (!ty.isBindable(n))
    throw xn.notBindable();
  return new ty(n, e, t);
}
class gx extends Sl {
  constructor(e, t) {
    super(e), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new Oi(), this.apiSet_ = new KC(Jse), this.pool_ = t;
    const i = this.controller_.rack;
    i.emitter.on("add", this.onRackAdd_), i.emitter.on("remove", this.onRackRemove_), i.emitter.on("inputchange", this.onRackInputChange_), i.emitter.on("monitorupdate", this.onRackMonitorUpdate_), i.children.forEach((r) => {
      this.setUpApi_(r);
    });
  }
  get children() {
    return this.controller_.rack.children.map(
      (e) => mm(this.apiSet_, e)
    );
  }
  addInput(e, t, i) {
    const r = i != null ? i : {}, s = this.controller_.view.element.ownerDocument, o = this.pool_.createInput(
      s,
      Ck(e, t, r.presetKey),
      r
    ), a = new sN(o);
    return this.add(a, r.index);
  }
  addMonitor(e, t, i) {
    const r = i != null ? i : {}, s = this.controller_.view.element.ownerDocument, o = this.pool_.createMonitor(
      s,
      Ck(e, t),
      r
    ), a = new oN(o);
    return this.add(a, r.index);
  }
  addFolder(e) {
    return Zse(this, e);
  }
  addButton(e) {
    return $se(this, e);
  }
  addSeparator(e) {
    return Yse(this, e);
  }
  addTab(e) {
    return Kse(this, e);
  }
  add(e, t) {
    this.controller_.rack.add(e.controller_, t);
    const i = this.apiSet_.find((r) => r.controller_ === e.controller_);
    return i && this.apiSet_.remove(i), this.apiSet_.add(e), e;
  }
  remove(e) {
    this.controller_.rack.remove(e.controller_);
  }
  addBlade(e) {
    const t = this.controller_.view.element.ownerDocument, i = this.pool_.createBlade(t, e), r = this.pool_.createBladeApi(i);
    return this.add(r, e.index);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (r) => {
      i(r.event);
    }), this;
  }
  setUpApi_(e) {
    this.apiSet_.find((i) => i.controller_ === e) || this.apiSet_.add(this.pool_.createBladeApi(e));
  }
  onRackAdd_(e) {
    this.setUpApi_(e.bladeController);
  }
  onRackRemove_(e) {
    if (e.isRoot) {
      const t = mm(this.apiSet_, e.bladeController);
      this.apiSet_.remove(t);
    }
  }
  onRackInputChange_(e) {
    const t = e.bladeController;
    if (t instanceof da) {
      const i = mm(this.apiSet_, t), r = t.binding;
      this.emitter_.emit("change", {
        event: new Lf(
          i,
          r.target.read(),
          r.target.presetKey,
          e.options.last
        )
      });
    } else if (t instanceof ff) {
      const i = mm(this.apiSet_, t);
      this.emitter_.emit("change", {
        event: new Lf(
          i,
          t.value.rawValue,
          void 0,
          e.options.last
        )
      });
    }
  }
  onRackMonitorUpdate_(e) {
    if (!(e.bladeController instanceof xc))
      throw xn.shouldNeverHappen();
    const t = mm(this.apiSet_, e.bladeController), i = e.bladeController.binding;
    this.emitter_.emit("update", {
      event: new Q6(
        t,
        i.target.read(),
        i.target.presetKey
      )
    });
  }
}
class aN extends YC {
  constructor(e, t) {
    super(e, new gx(e.rackController, t)), this.emitter_ = new Oi(), this.controller_.foldable.value("expanded").emitter.on("change", (i) => {
      this.emitter_.emit("fold", {
        event: new wse(this, i.sender.rawValue)
      });
    }), this.rackApi_.on("change", (i) => {
      this.emitter_.emit("change", {
        event: i
      });
    }), this.rackApi_.on("update", (i) => {
      this.emitter_.emit("update", {
        event: i
      });
    });
  }
  get expanded() {
    return this.controller_.foldable.get("expanded");
  }
  set expanded(e) {
    this.controller_.foldable.set("expanded", e);
  }
  get title() {
    return this.controller_.props.get("title");
  }
  set title(e) {
    this.controller_.props.set("title", e);
  }
  get children() {
    return this.rackApi_.children;
  }
  addInput(e, t, i) {
    return this.rackApi_.addInput(e, t, i);
  }
  addMonitor(e, t, i) {
    return this.rackApi_.addMonitor(e, t, i);
  }
  addFolder(e) {
    return this.rackApi_.addFolder(e);
  }
  addButton(e) {
    return this.rackApi_.addButton(e);
  }
  addSeparator(e) {
    return this.rackApi_.addSeparator(e);
  }
  addTab(e) {
    return this.rackApi_.addTab(e);
  }
  add(e, t) {
    return this.rackApi_.add(e, t);
  }
  remove(e) {
    this.rackApi_.remove(e);
  }
  addBlade(e) {
    return this.rackApi_.addBlade(e);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (r) => {
      i(r.event);
    }), this;
  }
}
class JC extends tg {
  constructor(e) {
    super({
      blade: e.blade,
      view: e.view,
      viewProps: e.rackController.viewProps
    }), this.rackController = e.rackController;
  }
}
class Qse {
  constructor(e, t) {
    const i = _n(t.viewName);
    this.element = e.createElement("div"), this.element.classList.add(i()), t.viewProps.bindClassModifiers(this.element);
  }
}
function eoe(n, e) {
  for (let t = 0; t < n.length; t++) {
    const i = n[t];
    if (i instanceof da && i.binding === e)
      return i;
  }
  return null;
}
function toe(n, e) {
  for (let t = 0; t < n.length; t++) {
    const i = n[t];
    if (i instanceof xc && i.binding === e)
      return i;
  }
  return null;
}
function noe(n, e) {
  for (let t = 0; t < n.length; t++) {
    const i = n[t];
    if (i instanceof ff && i.value === e)
      return i;
  }
  return null;
}
function zM(n) {
  return n instanceof rg ? n.rack : n instanceof JC ? n.rackController.rack : null;
}
function ioe(n) {
  const e = zM(n);
  return e ? e.bcSet_ : null;
}
class roe {
  constructor(e) {
    var t;
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new Oi(), this.blade_ = e != null ? e : null, (t = this.blade_) === null || t === void 0 || t.value("positions").emitter.on("change", this.onBladePositionsChange_), this.bcSet_ = new KC(ioe), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(e, t) {
    e.parent && e.parent.remove(e), e.parent_ = this, this.bcSet_.add(e, t);
  }
  remove(e) {
    e.parent_ = null, this.bcSet_.remove(e);
  }
  find(e) {
    return this.bcSet_.allItems().filter((t) => t instanceof e);
  }
  onSetAdd_(e) {
    this.updatePositions_();
    const t = e.target === e.root;
    if (this.emitter.emit("add", {
      bladeController: e.item,
      index: e.index,
      isRoot: t,
      sender: this
    }), !t)
      return;
    const i = e.item;
    if (i.viewProps.emitter.on("change", this.onChildViewPropsChange_), i.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), i.viewProps.handleDispose(this.onChildDispose_), i instanceof da)
      i.binding.emitter.on("change", this.onChildInputChange_);
    else if (i instanceof xc)
      i.binding.emitter.on("update", this.onChildMonitorUpdate_);
    else if (i instanceof ff)
      i.value.emitter.on("change", this.onChildValueChange_);
    else {
      const r = zM(i);
      if (r) {
        const s = r.emitter;
        s.on("layout", this.onDescendantLayout_), s.on("inputchange", this.onDescendantInputChange_), s.on("monitorupdate", this.onDescendantMonitorUpdate_);
      }
    }
  }
  onSetRemove_(e) {
    this.updatePositions_();
    const t = e.target === e.root;
    if (this.emitter.emit("remove", {
      bladeController: e.item,
      isRoot: t,
      sender: this
    }), !t)
      return;
    const i = e.item;
    if (i instanceof da)
      i.binding.emitter.off("change", this.onChildInputChange_);
    else if (i instanceof xc)
      i.binding.emitter.off("update", this.onChildMonitorUpdate_);
    else if (i instanceof ff)
      i.value.emitter.off("change", this.onChildValueChange_);
    else {
      const r = zM(i);
      if (r) {
        const s = r.emitter;
        s.off("layout", this.onDescendantLayout_), s.off("inputchange", this.onDescendantInputChange_), s.off("monitorupdate", this.onDescendantMonitorUpdate_);
      }
    }
  }
  updatePositions_() {
    const e = this.bcSet_.items.filter(
      (r) => !r.viewProps.get("hidden")
    ), t = e[0], i = e[e.length - 1];
    this.bcSet_.items.forEach((r) => {
      const s = [];
      r === t && (s.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && s.push("veryfirst")), r === i && (s.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && s.push("verylast")), r.blade.set("positions", s);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_(), this.emitter.emit("layout", {
      sender: this
    });
  }
  onChildViewPropsChange_(e) {
    this.updatePositions_(), this.emitter.emit("layout", {
      sender: this
    });
  }
  onChildDispose_() {
    this.bcSet_.items.filter((t) => t.viewProps.get("disposed")).forEach((t) => {
      this.bcSet_.remove(t);
    });
  }
  onChildInputChange_(e) {
    const t = eoe(
      this.find(da),
      e.sender
    );
    if (!t)
      throw xn.shouldNeverHappen();
    this.emitter.emit("inputchange", {
      bladeController: t,
      options: e.options,
      sender: this
    });
  }
  onChildMonitorUpdate_(e) {
    const t = toe(
      this.find(xc),
      e.sender
    );
    if (!t)
      throw xn.shouldNeverHappen();
    this.emitter.emit("monitorupdate", {
      bladeController: t,
      sender: this
    });
  }
  onChildValueChange_(e) {
    const t = noe(
      this.find(ff),
      e.sender
    );
    if (!t)
      throw xn.shouldNeverHappen();
    this.emitter.emit("inputchange", {
      bladeController: t,
      options: e.options,
      sender: this
    });
  }
  onDescendantLayout_(e) {
    this.updatePositions_(), this.emitter.emit("layout", {
      sender: this
    });
  }
  onDescendantInputChange_(e) {
    this.emitter.emit("inputchange", {
      bladeController: e.bladeController,
      options: e.options,
      sender: this
    });
  }
  onDescendantMonitorUpdate_(e) {
    this.emitter.emit("monitorupdate", {
      bladeController: e.bladeController,
      sender: this
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
}
class rg extends tg {
  constructor(e, t) {
    super(
      Object.assign(Object.assign({}, t), {
        view: new Qse(e, {
          viewName: "brk",
          viewProps: t.viewProps
        })
      })
    ), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
    const i = new roe(t.root ? void 0 : t.blade);
    i.emitter.on("add", this.onRackAdd_), i.emitter.on("remove", this.onRackRemove_), this.rack = i, this.viewProps.handleDispose(() => {
      for (let r = this.rack.children.length - 1; r >= 0; r--)
        this.rack.children[r].viewProps.set("disposed", !0);
    });
  }
  onRackAdd_(e) {
    !e.isRoot || eN(
      this.view.element,
      e.bladeController.view.element,
      e.index
    );
  }
  onRackRemove_(e) {
    !e.isRoot || tN(e.bladeController.view.element);
  }
}
const lN = _n("cnt");
class soe {
  constructor(e, t) {
    var i;
    this.className_ = _n(
      (i = t.viewName) !== null && i !== void 0 ? i : "fld"
    ), this.element = e.createElement("div"), this.element.classList.add(this.className_(), lN()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(
      this.element,
      this.className_(void 0, "expanded")
    ), Ns(
      this.foldable_,
      "completed",
      ep(this.element, this.className_(void 0, "cpl"))
    );
    const r = e.createElement("button");
    r.classList.add(this.className_("b")), Ns(t.props, "title", (l) => {
      Zi(l) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
    }), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r;
    const s = e.createElement("div");
    s.classList.add(this.className_("t")), XC(t.props.value("title"), s), this.buttonElement.appendChild(s), this.titleElement = s;
    const o = e.createElement("div");
    o.classList.add(this.className_("m")), this.buttonElement.appendChild(o);
    const a = t.containerElement;
    a.classList.add(this.className_("c")), this.element.appendChild(a), this.containerElement = a;
  }
}
class FM extends JC {
  constructor(e, t) {
    var i;
    const r = ig.create(
      (i = t.expanded) !== null && i !== void 0 ? i : !0
    ), s = new rg(e, {
      blade: t.blade,
      root: t.root,
      viewProps: t.viewProps
    });
    super(
      Object.assign(Object.assign({}, t), {
        rackController: s,
        view: new soe(e, {
          containerElement: s.view.element,
          foldable: r,
          props: t.props,
          viewName: t.root ? "rot" : void 0,
          viewProps: t.viewProps
        })
      })
    ), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = r, ZC(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    }), this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
}
const ooe = {
  id: "folder",
  type: "blade",
  accept(n) {
    const e = si, t = Tr(n, {
      title: e.required.string,
      view: e.required.constant("folder"),
      expanded: e.optional.boolean
    });
    return t ? { params: t } : null;
  },
  controller(n) {
    return new FM(n.document, {
      blade: n.blade,
      expanded: n.params.expanded,
      props: Qt.fromObject({
        title: n.params.title
      }),
      viewProps: n.viewProps
    });
  },
  api(n) {
    return n.controller instanceof FM ? new aN(n.controller, n.pool) : null;
  }
};
class Df extends ff {
  constructor(e, t) {
    const i = t.valueController.viewProps;
    super(
      Object.assign(Object.assign({}, t), {
        value: t.valueController.value,
        view: new rN(e, {
          props: t.props,
          viewProps: i
        }),
        viewProps: i
      })
    ), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
  }
}
class aoe extends Sl {
}
const Tk = _n("spr");
class loe {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Tk()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("hr");
    i.classList.add(Tk("r")), this.element.appendChild(i);
  }
}
class Pk extends tg {
  constructor(e, t) {
    super(
      Object.assign(Object.assign({}, t), {
        view: new loe(e, {
          viewProps: t.viewProps
        })
      })
    );
  }
}
const coe = {
  id: "separator",
  type: "blade",
  accept(n) {
    const t = Tr(n, {
      view: si.required.constant("separator")
    });
    return t ? { params: t } : null;
  },
  controller(n) {
    return new Pk(n.document, {
      blade: n.blade,
      viewProps: n.viewProps
    });
  },
  api(n) {
    return n.controller instanceof Pk ? new aoe(n.controller) : null;
  }
}, uoe = _n("");
function Ak(n, e) {
  return ep(n, uoe(void 0, e));
}
class Ac extends Qt {
  constructor(e) {
    super(e);
  }
  static create(e) {
    var t, i;
    const r = e != null ? e : {}, s = {
      disabled: (t = r.disabled) !== null && t !== void 0 ? t : !1,
      disposed: !1,
      hidden: (i = r.hidden) !== null && i !== void 0 ? i : !1
    }, o = Qt.createCore(s);
    return new Ac(o);
  }
  bindClassModifiers(e) {
    Ns(this, "disabled", Ak(e, "disabled")), Ns(this, "hidden", Ak(e, "hidden"));
  }
  bindDisabled(e) {
    Ns(this, "disabled", (t) => {
      e.disabled = t;
    });
  }
  bindTabIndex(e) {
    Ns(this, "disabled", (t) => {
      e.tabIndex = t ? -1 : 0;
    });
  }
  handleDispose(e) {
    this.value("disposed").emitter.on("change", (t) => {
      t && e();
    });
  }
}
const vm = _n("tbi");
class hoe {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(vm()), t.viewProps.bindClassModifiers(this.element), Ns(t.props, "selected", (s) => {
      s ? this.element.classList.add(vm(void 0, "sel")) : this.element.classList.remove(vm(void 0, "sel"));
    });
    const i = e.createElement("button");
    i.classList.add(vm("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
    const r = e.createElement("div");
    r.classList.add(vm("t")), XC(t.props.value("title"), r), this.buttonElement.appendChild(r), this.titleElement = r;
  }
}
class doe {
  constructor(e, t) {
    this.emitter = new Oi(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new hoe(e, {
      props: t.props,
      viewProps: t.viewProps
    }), this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this
    });
  }
}
class cN {
  constructor(e, t) {
    this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new doe(e, {
      props: t.itemProps,
      viewProps: Ac.create()
    }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new rg(e, {
      blade: ng(),
      viewProps: Ac.create()
    }), this.props = t.props, Ns(this.props, "selected", (i) => {
      this.itemController.props.set("selected", i), this.contentController.viewProps.set("hidden", !i);
    });
  }
  get itemController() {
    return this.ic_;
  }
  get contentController() {
    return this.cc_;
  }
  onItemClick_() {
    this.props.set("selected", !0);
  }
}
class foe {
  constructor(e, t) {
    this.controller_ = e, this.rackApi_ = t;
  }
  get title() {
    var e;
    return (e = this.controller_.itemController.props.get("title")) !== null && e !== void 0 ? e : "";
  }
  set title(e) {
    this.controller_.itemController.props.set("title", e);
  }
  get selected() {
    return this.controller_.props.get("selected");
  }
  set selected(e) {
    this.controller_.props.set("selected", e);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(e) {
    return this.rackApi_.addButton(e);
  }
  addFolder(e) {
    return this.rackApi_.addFolder(e);
  }
  addSeparator(e) {
    return this.rackApi_.addSeparator(e);
  }
  addTab(e) {
    return this.rackApi_.addTab(e);
  }
  add(e, t) {
    this.rackApi_.add(e, t);
  }
  remove(e) {
    this.rackApi_.remove(e);
  }
  addInput(e, t, i) {
    return this.rackApi_.addInput(e, t, i);
  }
  addMonitor(e, t, i) {
    return this.rackApi_.addMonitor(e, t, i);
  }
  addBlade(e) {
    return this.rackApi_.addBlade(e);
  }
}
class poe extends YC {
  constructor(e, t) {
    super(e, new gx(e.rackController, t)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new Oi(), this.pageApiMap_ = /* @__PURE__ */ new Map(), this.rackApi_.on("change", (i) => {
      this.emitter_.emit("change", {
        event: i
      });
    }), this.rackApi_.on("update", (i) => {
      this.emitter_.emit("update", {
        event: i
      });
    }), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((i) => {
      this.setUpPageApi_(i);
    });
  }
  get pages() {
    return this.controller_.pageSet.items.map((e) => {
      const t = this.pageApiMap_.get(e);
      if (!t)
        throw xn.shouldNeverHappen();
      return t;
    });
  }
  addPage(e) {
    const t = this.controller_.view.element.ownerDocument, i = new cN(t, {
      itemProps: Qt.fromObject({
        selected: !1,
        title: e.title
      }),
      props: Qt.fromObject({
        selected: !1
      })
    });
    this.controller_.add(i, e.index);
    const r = this.pageApiMap_.get(i);
    if (!r)
      throw xn.shouldNeverHappen();
    return r;
  }
  removePage(e) {
    this.controller_.remove(e);
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (r) => {
      i(r.event);
    }), this;
  }
  setUpPageApi_(e) {
    const t = this.rackApi_.apiSet_.find(
      (r) => r.controller_ === e.contentController
    );
    if (!t)
      throw xn.shouldNeverHappen();
    const i = new foe(e, t);
    this.pageApiMap_.set(e, i);
  }
  onPageAdd_(e) {
    this.setUpPageApi_(e.item);
  }
  onPageRemove_(e) {
    if (!this.pageApiMap_.get(e.item))
      throw xn.shouldNeverHappen();
    this.pageApiMap_.delete(e.item);
  }
  onSelect_(e) {
    this.emitter_.emit("select", {
      event: new Sse(this, e.rawValue)
    });
  }
}
const Rk = -1;
class moe {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = Fr(!0), this.selectedIndex = Fr(Rk), this.items_ = [];
  }
  add(e, t) {
    const i = t != null ? t : this.items_.length;
    this.items_.splice(i, 0, e), e.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
  }
  remove(e) {
    const t = this.items_.indexOf(e);
    t < 0 || (this.items_.splice(t, 1), e.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = Rk, this.empty.rawValue = !0;
      return;
    }
    const e = this.items_.findIndex((t) => t.rawValue);
    e < 0 ? (this.items_.forEach((t, i) => {
      t.rawValue = i === 0;
    }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((t, i) => {
      t.rawValue = i === e;
    }), this.selectedIndex.rawValue = e), this.empty.rawValue = !1;
  }
  onItemSelectedChange_(e) {
    if (e.rawValue) {
      const t = this.items_.findIndex((i) => i === e.sender);
      this.items_.forEach((i, r) => {
        i.rawValue = r === t;
      }), this.selectedIndex.rawValue = t;
    } else
      this.keepSelection_();
  }
}
const z_ = _n("tab");
class voe {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(z_(), lN()), t.viewProps.bindClassModifiers(this.element), Qf(
      t.empty,
      ep(this.element, z_(void 0, "nop"))
    );
    const i = e.createElement("div");
    i.classList.add(z_("i")), this.element.appendChild(i), this.itemsElement = i;
    const r = t.contentsElement;
    r.classList.add(z_("c")), this.element.appendChild(r), this.contentsElement = r;
  }
}
class kk extends JC {
  constructor(e, t) {
    const i = new rg(e, {
      blade: t.blade,
      viewProps: t.viewProps
    }), r = new moe();
    super({
      blade: t.blade,
      rackController: i,
      view: new voe(e, {
        contentsElement: i.view.element,
        empty: r.empty,
        viewProps: t.viewProps
      })
    }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new KC(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = r;
  }
  get pageSet() {
    return this.pageSet_;
  }
  add(e, t) {
    this.pageSet_.add(e, t);
  }
  remove(e) {
    this.pageSet_.remove(this.pageSet_.items[e]);
  }
  onPageAdd_(e) {
    const t = e.item;
    eN(
      this.view.itemsElement,
      t.itemController.view.element,
      e.index
    ), this.rackController.rack.add(t.contentController, e.index), this.tab.add(t.props.value("selected"));
  }
  onPageRemove_(e) {
    const t = e.item;
    tN(t.itemController.view.element), this.rackController.rack.remove(t.contentController), this.tab.remove(t.props.value("selected"));
  }
}
const uN = {
  id: "tab",
  type: "blade",
  accept(n) {
    const e = si, t = Tr(n, {
      pages: e.required.array(
        e.required.object({ title: e.required.string })
      ),
      view: e.required.constant("tab")
    });
    return !t || t.pages.length === 0 ? null : { params: t };
  },
  controller(n) {
    const e = new kk(n.document, {
      blade: n.blade,
      viewProps: n.viewProps
    });
    return n.params.pages.forEach((t) => {
      const i = new cN(n.document, {
        itemProps: Qt.fromObject({
          selected: !1,
          title: t.title
        }),
        props: Qt.fromObject({
          selected: !1
        })
      });
      e.add(i);
    }), e;
  },
  api(n) {
    return n.controller instanceof kk ? new poe(n.controller, n.pool) : null;
  }
};
function goe(n, e) {
  const t = n.accept(e.params);
  if (!t)
    return null;
  const i = si.optional.boolean(
    e.params.disabled
  ).value, r = si.optional.boolean(e.params.hidden).value;
  return n.controller({
    blade: ng(),
    document: e.document,
    params: Object.assign(Object.assign({}, t.params), {
      disabled: i,
      hidden: r
    }),
    viewProps: Ac.create({
      disabled: i,
      hidden: r
    })
  });
}
class _oe {
  constructor() {
    this.disabled = !1, this.emitter = new Oi();
  }
  dispose() {
  }
  tick() {
    this.disabled || this.emitter.emit("tick", {
      sender: this
    });
  }
}
class boe {
  constructor(e, t) {
    this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new Oi(), this.interval_ = t, this.setTimer_();
  }
  get disabled() {
    return this.disabled_;
  }
  set disabled(e) {
    this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_();
  }
  dispose() {
    this.clearTimer_();
  }
  clearTimer_() {
    if (this.timerId_ === null)
      return;
    const e = this.doc_.defaultView;
    e && e.clearInterval(this.timerId_), this.timerId_ = null;
  }
  setTimer_() {
    if (this.clearTimer_(), this.interval_ <= 0)
      return;
    const e = this.doc_.defaultView;
    e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_));
  }
  onTick_() {
    this.disabled_ || this.emitter.emit("tick", {
      sender: this
    });
  }
}
class sg {
  constructor(e) {
    this.constraints = e;
  }
  constrain(e) {
    return this.constraints.reduce((t, i) => i.constrain(t), e);
  }
}
function va(n, e) {
  if (n instanceof e)
    return n;
  if (n instanceof sg) {
    const t = n.constraints.reduce((i, r) => i || (r instanceof e ? r : null), null);
    if (t)
      return t;
  }
  return null;
}
class og {
  constructor(e) {
    this.options = e;
  }
  constrain(e) {
    const t = this.options;
    return t.length === 0 || t.filter((r) => r.value === e).length > 0 ? e : t[0].value;
  }
}
class tp {
  constructor(e) {
    this.maxValue = e.max, this.minValue = e.min;
  }
  constrain(e) {
    return e;
  }
}
class _x {
  constructor(e, t = 0) {
    this.step = e, this.origin = t;
  }
  constrain(e) {
    const t = this.origin % this.step, i = Math.round((e - t) / this.step);
    return t + i * this.step;
  }
}
const XS = _n("lst");
class yoe {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(XS()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("select");
    i.classList.add(XS("s")), Ns(this.props_, "options", (s) => {
      nN(i), s.forEach((o, a) => {
        const l = e.createElement("option");
        l.dataset.index = String(a), l.textContent = o.text, l.value = String(o.value), i.appendChild(l);
      });
    }), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.selectElement = i;
    const r = e.createElement("div");
    r.classList.add(XS("m")), r.appendChild(vx(e, "dropdown")), this.element.appendChild(r), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, this.update_();
  }
  update_() {
    this.selectElement.value = String(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
}
class bv {
  constructor(e, t) {
    this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new yoe(e, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const i = e.currentTarget.selectedOptions.item(0);
    if (!i)
      return;
    const r = Number(i.dataset.index);
    this.value.rawValue = this.props.get("options")[r].value;
  }
}
const Lk = _n("pop");
class xoe {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Lk()), t.viewProps.bindClassModifiers(this.element), Qf(
      t.shows,
      ep(this.element, Lk(void 0, "v"))
    );
  }
}
class hN {
  constructor(e, t) {
    this.shows = Fr(!1), this.viewProps = t.viewProps, this.view = new xoe(e, {
      shows: this.shows,
      viewProps: this.viewProps
    });
  }
}
const Dk = _n("txt");
class woe {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(Dk()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
    const i = e.createElement("input");
    i.classList.add(Dk("i")), i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh();
  }
  refresh() {
    const e = this.props_.get("formatter");
    this.inputElement.value = e(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
}
class ry {
  constructor(e, t) {
    this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new woe(e, {
      props: t.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const i = e.currentTarget.value, r = this.parser_(i);
    Zi(r) || (this.value.rawValue = r), this.view.refresh();
  }
}
function Soe(n) {
  return String(n);
}
function dN(n) {
  return n === "false" ? !1 : !!n;
}
function Ik(n) {
  return Soe(n);
}
class Moe {
  constructor(e) {
    this.text = e;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
}
const Eoe = {
  "**": (n, e) => Math.pow(n, e),
  "*": (n, e) => n * e,
  "/": (n, e) => n / e,
  "%": (n, e) => n % e,
  "+": (n, e) => n + e,
  "-": (n, e) => n - e,
  "<<": (n, e) => n << e,
  ">>": (n, e) => n >> e,
  ">>>": (n, e) => n >>> e,
  "&": (n, e) => n & e,
  "^": (n, e) => n ^ e,
  "|": (n, e) => n | e
};
class Coe {
  constructor(e, t, i) {
    this.left = t, this.operator = e, this.right = i;
  }
  evaluate() {
    const e = Eoe[this.operator];
    if (!e)
      throw new Error(`unexpected binary operator: '${this.operator}`);
    return e(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")"
    ].join(" ");
  }
}
const Toe = {
  "+": (n) => n,
  "-": (n) => -n,
  "~": (n) => ~n
};
class Poe {
  constructor(e, t) {
    this.operator = e, this.expression = t;
  }
  evaluate() {
    const e = Toe[this.operator];
    if (!e)
      throw new Error(`unexpected unary operator: '${this.operator}`);
    return e(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
}
function QC(n) {
  return (e, t) => {
    for (let i = 0; i < n.length; i++) {
      const r = n[i](e, t);
      if (r !== "")
        return r;
    }
    return "";
  };
}
function yv(n, e) {
  var t;
  const i = n.substr(e).match(/^\s+/);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Aoe(n, e) {
  const t = n.substr(e, 1);
  return t.match(/^[1-9]$/) ? t : "";
}
function xv(n, e) {
  var t;
  const i = n.substr(e).match(/^[0-9]+/);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Roe(n, e) {
  const t = xv(n, e);
  if (t !== "")
    return t;
  const i = n.substr(e, 1);
  if (e += 1, i !== "-" && i !== "+")
    return "";
  const r = xv(n, e);
  return r === "" ? "" : i + r;
}
function e3(n, e) {
  const t = n.substr(e, 1);
  if (e += 1, t.toLowerCase() !== "e")
    return "";
  const i = Roe(n, e);
  return i === "" ? "" : t + i;
}
function fN(n, e) {
  const t = n.substr(e, 1);
  if (t === "0")
    return t;
  const i = Aoe(n, e);
  return e += i.length, i === "" ? "" : i + xv(n, e);
}
function koe(n, e) {
  const t = fN(n, e);
  if (e += t.length, t === "")
    return "";
  const i = n.substr(e, 1);
  if (e += i.length, i !== ".")
    return "";
  const r = xv(n, e);
  return e += r.length, t + i + r + e3(n, e);
}
function Loe(n, e) {
  const t = n.substr(e, 1);
  if (e += t.length, t !== ".")
    return "";
  const i = xv(n, e);
  return e += i.length, i === "" ? "" : t + i + e3(n, e);
}
function Doe(n, e) {
  const t = fN(n, e);
  return e += t.length, t === "" ? "" : t + e3(n, e);
}
const Ioe = QC([
  koe,
  Loe,
  Doe
]);
function Ooe(n, e) {
  var t;
  const i = n.substr(e).match(/^[01]+/);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Noe(n, e) {
  const t = n.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0b")
    return "";
  const i = Ooe(n, e);
  return i === "" ? "" : t + i;
}
function zoe(n, e) {
  var t;
  const i = n.substr(e).match(/^[0-7]+/);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Foe(n, e) {
  const t = n.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0o")
    return "";
  const i = zoe(n, e);
  return i === "" ? "" : t + i;
}
function Boe(n, e) {
  var t;
  const i = n.substr(e).match(/^[0-9a-f]+/i);
  return (t = i && i[0]) !== null && t !== void 0 ? t : "";
}
function Uoe(n, e) {
  const t = n.substr(e, 2);
  if (e += t.length, t.toLowerCase() !== "0x")
    return "";
  const i = Boe(n, e);
  return i === "" ? "" : t + i;
}
const Voe = QC([
  Noe,
  Foe,
  Uoe
]), Hoe = QC([
  Voe,
  Ioe
]);
function Goe(n, e) {
  const t = Hoe(n, e);
  return e += t.length, t === "" ? null : {
    evaluable: new Moe(t),
    cursor: e
  };
}
function Woe(n, e) {
  const t = n.substr(e, 1);
  if (e += t.length, t !== "(")
    return null;
  const i = mN(n, e);
  if (!i)
    return null;
  e = i.cursor, e += yv(n, e).length;
  const r = n.substr(e, 1);
  return e += r.length, r !== ")" ? null : {
    evaluable: i.evaluable,
    cursor: e
  };
}
function joe(n, e) {
  var t;
  return (t = Goe(n, e)) !== null && t !== void 0 ? t : Woe(n, e);
}
function pN(n, e) {
  const t = joe(n, e);
  if (t)
    return t;
  const i = n.substr(e, 1);
  if (e += i.length, i !== "+" && i !== "-" && i !== "~")
    return null;
  const r = pN(n, e);
  return r ? (e = r.cursor, {
    cursor: e,
    evaluable: new Poe(i, r.evaluable)
  }) : null;
}
function qoe(n, e, t) {
  t += yv(e, t).length;
  const i = n.filter((r) => e.startsWith(r, t))[0];
  return i ? (t += i.length, t += yv(e, t).length, {
    cursor: t,
    operator: i
  }) : null;
}
function Xoe(n, e) {
  return (t, i) => {
    const r = n(t, i);
    if (!r)
      return null;
    i = r.cursor;
    let s = r.evaluable;
    for (; ; ) {
      const o = qoe(e, t, i);
      if (!o)
        break;
      i = o.cursor;
      const a = n(t, i);
      if (!a)
        return null;
      i = a.cursor, s = new Coe(
        o.operator,
        s,
        a.evaluable
      );
    }
    return s ? {
      cursor: i,
      evaluable: s
    } : null;
  };
}
const $oe = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"]
].reduce((n, e) => Xoe(n, e), pN);
function mN(n, e) {
  return e += yv(n, e).length, $oe(n, e);
}
function Zoe(n) {
  const e = mN(n, 0);
  return !e || e.cursor + yv(n, e.cursor).length !== n.length ? null : e.evaluable;
}
function _l(n) {
  var e;
  const t = Zoe(n);
  return (e = t == null ? void 0 : t.evaluate()) !== null && e !== void 0 ? e : null;
}
function vN(n) {
  if (typeof n == "number")
    return n;
  if (typeof n == "string") {
    const e = _l(n);
    if (!Zi(e))
      return e;
  }
  return 0;
}
function Yoe(n) {
  return String(n);
}
function Er(n) {
  return (e) => e.toFixed(Math.max(Math.min(n, 20), 0));
}
const Koe = Er(0);
function sy(n) {
  return Koe(n) + "%";
}
function gN(n) {
  return String(n);
}
function BM(n) {
  return n;
}
function _N(n, e) {
  for (; n.length < e; )
    n.push(void 0);
}
function Joe(n) {
  const e = [];
  return _N(e, n), Fr(e);
}
function Qoe(n) {
  const e = n.indexOf(void 0);
  return e < 0 ? n : n.slice(0, e);
}
function eae(n, e) {
  const t = [...Qoe(n), e];
  return t.length > n.length ? t.splice(0, t.length - n.length) : _N(t, n.length), t;
}
function ag({ primary: n, secondary: e, forward: t, backward: i }) {
  let r = !1;
  function s(o) {
    r || (r = !0, o(), r = !1);
  }
  n.emitter.on("change", (o) => {
    s(() => {
      e.setRawValue(t(n, e), o.options);
    });
  }), e.emitter.on("change", (o) => {
    s(() => {
      n.setRawValue(i(n, e), o.options);
    }), s(() => {
      e.setRawValue(t(n, e), o.options);
    });
  }), s(() => {
    e.setRawValue(t(n, e), {
      forceEmit: !1,
      last: !0
    });
  });
}
function vs(n, e) {
  const t = n * (e.altKey ? 0.1 : 1) * (e.shiftKey ? 10 : 1);
  return e.upKey ? +t : e.downKey ? -t : 0;
}
function wv(n) {
  return {
    altKey: n.altKey,
    downKey: n.key === "ArrowDown",
    shiftKey: n.shiftKey,
    upKey: n.key === "ArrowUp"
  };
}
function bl(n) {
  return {
    altKey: n.altKey,
    downKey: n.key === "ArrowLeft",
    shiftKey: n.shiftKey,
    upKey: n.key === "ArrowRight"
  };
}
function tae(n) {
  return n === "ArrowUp" || n === "ArrowDown";
}
function bN(n) {
  return tae(n) || n === "ArrowLeft" || n === "ArrowRight";
}
function $S(n, e) {
  var t, i;
  const r = e.ownerDocument.defaultView, s = e.getBoundingClientRect();
  return {
    x: n.pageX - (((t = r && r.scrollX) !== null && t !== void 0 ? t : 0) + s.left),
    y: n.pageY - (((i = r && r.scrollY) !== null && i !== void 0 ? i : 0) + s.top)
  };
}
class _h {
  constructor(e) {
    this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new Oi(), e.addEventListener("touchstart", this.onTouchStart_, {
      passive: !1
    }), e.addEventListener("touchmove", this.onTouchMove_, {
      passive: !0
    }), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(e) {
    const t = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: t.width,
        height: t.height
      },
      point: e ? {
        x: e.x,
        y: e.y
      } : null
    };
  }
  onMouseDown_(e) {
    var t;
    e.preventDefault(), (t = e.currentTarget) === null || t === void 0 || t.focus();
    const i = this.elem_.ownerDocument;
    i.addEventListener("mousemove", this.onDocumentMouseMove_), i.addEventListener("mouseup", this.onDocumentMouseUp_), bk(), this.emitter.emit("down", {
      altKey: e.altKey,
      data: this.computePosition_($S(e, this.elem_)),
      sender: this,
      shiftKey: e.shiftKey
    });
  }
  onDocumentMouseMove_(e) {
    this.emitter.emit("move", {
      altKey: e.altKey,
      data: this.computePosition_($S(e, this.elem_)),
      sender: this,
      shiftKey: e.shiftKey
    });
  }
  onDocumentMouseUp_(e) {
    const t = this.elem_.ownerDocument;
    t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), yk(), this.emitter.emit("up", {
      altKey: e.altKey,
      data: this.computePosition_($S(e, this.elem_)),
      sender: this,
      shiftKey: e.shiftKey
    });
  }
  onTouchStart_(e) {
    e.preventDefault();
    const t = e.targetTouches.item(0), i = this.elem_.getBoundingClientRect();
    bk(), this.emitter.emit("down", {
      altKey: e.altKey,
      data: this.computePosition_(
        t ? {
          x: t.clientX - i.left,
          y: t.clientY - i.top
        } : void 0
      ),
      sender: this,
      shiftKey: e.shiftKey
    }), this.lastTouch_ = t;
  }
  onTouchMove_(e) {
    const t = e.targetTouches.item(0), i = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: e.altKey,
      data: this.computePosition_(
        t ? {
          x: t.clientX - i.left,
          y: t.clientY - i.top
        } : void 0
      ),
      sender: this,
      shiftKey: e.shiftKey
    }), this.lastTouch_ = t;
  }
  onTouchEnd_(e) {
    var t;
    const i = (t = e.targetTouches.item(0)) !== null && t !== void 0 ? t : this.lastTouch_, r = this.elem_.getBoundingClientRect();
    yk(), this.emitter.emit("up", {
      altKey: e.altKey,
      data: this.computePosition_(
        i ? {
          x: i.clientX - r.left,
          y: i.clientY - r.top
        } : void 0
      ),
      sender: this,
      shiftKey: e.shiftKey
    });
  }
}
function ri(n, e, t, i, r) {
  const s = (n - e) / (t - e);
  return i + s * (r - i);
}
function Ok(n) {
  return String(n.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
}
function Hi(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
function yN(n, e) {
  return (n % e + e) % e;
}
const Ks = _n("txt");
class nae {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Ks(), Ks(void 0, "num")), t.arrayPosition && this.element.classList.add(
      Ks(void 0, t.arrayPosition)
    ), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("input");
    i.classList.add(Ks("i")), i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Ks()), this.inputElement.classList.add(Ks("i"));
    const r = e.createElement("div");
    r.classList.add(Ks("k")), this.element.appendChild(r), this.knobElement = r;
    const s = e.createElementNS(ca, "svg");
    s.classList.add(Ks("g")), this.knobElement.appendChild(s);
    const o = e.createElementNS(ca, "path");
    o.classList.add(Ks("gb")), s.appendChild(o), this.guideBodyElem_ = o;
    const a = e.createElementNS(ca, "path");
    a.classList.add(Ks("gh")), s.appendChild(a), this.guideHeadElem_ = a;
    const l = e.createElement("div");
    l.classList.add(_n("tt")()), this.knobElement.appendChild(l), this.tooltipElem_ = l, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh();
  }
  onDraggingChange_(e) {
    if (e.rawValue === null) {
      this.element.classList.remove(Ks(void 0, "drg"));
      return;
    }
    this.element.classList.add(Ks(void 0, "drg"));
    const t = e.rawValue / this.props_.get("draggingScale"), i = t + (t > 0 ? -1 : t < 0 ? 1 : 0), r = Hi(-i, -4, 4);
    this.guideHeadElem_.setAttributeNS(
      null,
      "d",
      [
        `M ${i + r},0 L${i},4 L${i + r},8`,
        `M ${t},-1 L${t},9`
      ].join(" ")
    ), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
    const s = this.props_.get("formatter");
    this.tooltipElem_.textContent = s(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`;
  }
  refresh() {
    const e = this.props_.get("formatter");
    this.inputElement.value = e(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
}
class lg {
  constructor(e, t) {
    var i;
    this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.parser_ = t.parser, this.props = t.props, this.sliderProps_ = (i = t.sliderProps) !== null && i !== void 0 ? i : null, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = Fr(null), this.view = new nae(e, {
      arrayPosition: t.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const r = new _h(this.view.knobElement);
    r.emitter.on("down", this.onPointerDown_), r.emitter.on("move", this.onPointerMove_), r.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(e) {
    return e;
  }
  onInputChange_(e) {
    const i = e.currentTarget.value, r = this.parser_(i);
    Zi(r) || (this.value.rawValue = this.constrainValue_(r)), this.view.refresh();
  }
  onInputKeyDown_(e) {
    const t = vs(this.baseStep_, wv(e));
    t !== 0 && this.value.setRawValue(
      this.constrainValue_(this.value.rawValue + t),
      {
        forceEmit: !1,
        last: !1
      }
    );
  }
  onInputKeyUp_(e) {
    vs(this.baseStep_, wv(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(e) {
    if (!e.point)
      return null;
    const t = e.point.x - e.bounds.width / 2;
    return this.constrainValue_(
      this.originRawValue_ + t * this.props.get("draggingScale")
    );
  }
  onPointerMove_(e) {
    const t = this.computeDraggingValue_(e.data);
    t !== null && (this.value.setRawValue(t, {
      forceEmit: !1,
      last: !1
    }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
  }
  onPointerUp_(e) {
    const t = this.computeDraggingValue_(e.data);
    t !== null && (this.value.setRawValue(t, {
      forceEmit: !0,
      last: !0
    }), this.dragging_.rawValue = null);
  }
}
const ZS = _n("sld");
class iae {
  constructor(e, t) {
    this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(ZS()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(ZS("t")), t.viewProps.bindTabIndex(i), this.element.appendChild(i), this.trackElement = i;
    const r = e.createElement("div");
    r.classList.add(ZS("k")), this.trackElement.appendChild(r), this.knobElement = r, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_();
  }
  update_() {
    const e = Hi(
      ri(
        this.value.rawValue,
        this.props_.get("minValue"),
        this.props_.get("maxValue"),
        0,
        100
      ),
      0,
      100
    );
    this.knobElement.style.width = `${e}%`;
  }
  onChange_() {
    this.update_();
  }
}
class rae {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new iae(e, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new _h(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    !e.point || this.value.setRawValue(
      ri(
        Hi(e.point.x, 0, e.bounds.width),
        0,
        e.bounds.width,
        this.props.get("minValue"),
        this.props.get("maxValue")
      ),
      t
    );
  }
  onPointerDownOrMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onKeyDown_(e) {
    const t = vs(this.baseStep_, bl(e));
    t !== 0 && this.value.setRawValue(this.value.rawValue + t, {
      forceEmit: !1,
      last: !1
    });
  }
  onKeyUp_(e) {
    vs(this.baseStep_, bl(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
const YS = _n("sldtxt");
class sae {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(YS());
    const i = e.createElement("div");
    i.classList.add(YS("s")), this.sliderView_ = t.sliderView, i.appendChild(this.sliderView_.element), this.element.appendChild(i);
    const r = e.createElement("div");
    r.classList.add(YS("t")), this.textView_ = t.textView, r.appendChild(this.textView_.element), this.element.appendChild(r);
  }
}
class UM {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new rae(e, {
      baseStep: t.baseStep,
      props: t.sliderProps,
      value: t.value,
      viewProps: this.viewProps
    }), this.textC_ = new lg(e, {
      baseStep: t.baseStep,
      parser: t.parser,
      props: t.textProps,
      sliderProps: t.sliderProps,
      value: t.value,
      viewProps: t.viewProps
    }), this.view = new sae(e, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
}
function cg(n, e) {
  n.write(e);
}
function bx(n) {
  const e = si;
  if (Array.isArray(n))
    return e.required.array(
      e.required.object({
        text: e.required.string,
        value: e.required.raw
      })
    )(n).value;
  if (typeof n == "object")
    return e.required.raw(n).value;
}
function xN(n) {
  if (n === "inline" || n === "popup")
    return n;
}
function hc(n) {
  const e = si;
  return e.required.object({
    max: e.optional.number,
    min: e.optional.number,
    step: e.optional.number
  })(n).value;
}
function wN(n) {
  if (Array.isArray(n))
    return n;
  const e = [];
  return Object.keys(n).forEach((t) => {
    e.push({ text: t, value: n[t] });
  }), e;
}
function t3(n) {
  return Zi(n) ? null : new og(wN(n));
}
function n3(n) {
  const e = n ? va(n, og) : null;
  return e ? e.options : null;
}
function oae(n) {
  const e = n ? va(n, _x) : null;
  return e ? e.step : null;
}
function yx(n, e) {
  const t = n && va(n, _x);
  return t ? Ok(t.step) : Math.max(Ok(e), 2);
}
function If(n) {
  const e = oae(n);
  return e != null ? e : 1;
}
function Of(n, e) {
  var t;
  const i = n && va(n, _x), r = Math.abs(
    (t = i == null ? void 0 : i.step) !== null && t !== void 0 ? t : e
  );
  return r === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(r)) - 1);
}
const F_ = _n("ckb");
class aae {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(F_()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("label");
    i.classList.add(F_("l")), this.element.appendChild(i);
    const r = e.createElement("input");
    r.classList.add(F_("i")), r.type = "checkbox", i.appendChild(r), this.inputElement = r, t.viewProps.bindDisabled(this.inputElement);
    const s = e.createElement("div");
    s.classList.add(F_("w")), i.appendChild(s);
    const o = vx(e, "check");
    s.appendChild(o), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
}
class lae {
  constructor(e, t) {
    this.onInputChange_ = this.onInputChange_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new aae(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const t = e.currentTarget;
    this.value.rawValue = t.checked;
  }
}
function cae(n) {
  const e = [], t = t3(n.options);
  return t && e.push(t), new sg(e);
}
const uae = {
  id: "input-bool",
  type: "input",
  accept: (n, e) => {
    if (typeof n != "boolean")
      return null;
    const i = Tr(e, {
      options: si.optional.custom(bx)
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    reader: (n) => dN,
    constraint: (n) => cae(n.params),
    writer: (n) => cg
  },
  controller: (n) => {
    var e;
    const t = n.document, i = n.value, r = n.constraint;
    return r && va(r, og) ? new bv(t, {
      props: Qt.fromObject({
        options: (e = n3(r)) !== null && e !== void 0 ? e : []
      }),
      value: i,
      viewProps: n.viewProps
    }) : new lae(t, {
      value: i,
      viewProps: n.viewProps
    });
  }
}, vu = _n("col");
class hae {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(vu()), t.foldable.bindExpandedClass(
      this.element,
      vu(void 0, "expanded")
    ), Ns(
      t.foldable,
      "completed",
      ep(this.element, vu(void 0, "cpl"))
    );
    const i = e.createElement("div");
    i.classList.add(vu("h")), this.element.appendChild(i);
    const r = e.createElement("div");
    r.classList.add(vu("s")), i.appendChild(r), this.swatchElement = r;
    const s = e.createElement("div");
    if (s.classList.add(vu("t")), i.appendChild(s), this.textElement = s, t.pickerLayout === "inline") {
      const o = e.createElement("div");
      o.classList.add(vu("p")), this.element.appendChild(o), this.pickerElement = o;
    } else
      this.pickerElement = null;
  }
}
function dae(n, e, t) {
  const i = Hi(n / 255, 0, 1), r = Hi(e / 255, 0, 1), s = Hi(t / 255, 0, 1), o = Math.max(i, r, s), a = Math.min(i, r, s), l = o - a;
  let c = 0, d = 0;
  const p = (a + o) / 2;
  return l !== 0 && (d = l / (1 - Math.abs(o + a - 1)), i === o ? c = (r - s) / l : r === o ? c = 2 + (s - i) / l : c = 4 + (i - r) / l, c = c / 6 + (c < 0 ? 1 : 0)), [c * 360, d * 100, p * 100];
}
function fae(n, e, t) {
  const i = (n % 360 + 360) % 360, r = Hi(e / 100, 0, 1), s = Hi(t / 100, 0, 1), o = (1 - Math.abs(2 * s - 1)) * r, a = o * (1 - Math.abs(i / 60 % 2 - 1)), l = s - o / 2;
  let c, d, p;
  return i >= 0 && i < 60 ? [c, d, p] = [o, a, 0] : i >= 60 && i < 120 ? [c, d, p] = [a, o, 0] : i >= 120 && i < 180 ? [c, d, p] = [0, o, a] : i >= 180 && i < 240 ? [c, d, p] = [0, a, o] : i >= 240 && i < 300 ? [c, d, p] = [a, 0, o] : [c, d, p] = [o, 0, a], [(c + l) * 255, (d + l) * 255, (p + l) * 255];
}
function pae(n, e, t) {
  const i = Hi(n / 255, 0, 1), r = Hi(e / 255, 0, 1), s = Hi(t / 255, 0, 1), o = Math.max(i, r, s), a = Math.min(i, r, s), l = o - a;
  let c;
  l === 0 ? c = 0 : o === i ? c = 60 * (((r - s) / l % 6 + 6) % 6) : o === r ? c = 60 * ((s - i) / l + 2) : c = 60 * ((i - r) / l + 4);
  const d = o === 0 ? 0 : l / o, p = o;
  return [c, d * 100, p * 100];
}
function SN(n, e, t) {
  const i = yN(n, 360), r = Hi(e / 100, 0, 1), s = Hi(t / 100, 0, 1), o = s * r, a = o * (1 - Math.abs(i / 60 % 2 - 1)), l = s - o;
  let c, d, p;
  return i >= 0 && i < 60 ? [c, d, p] = [o, a, 0] : i >= 60 && i < 120 ? [c, d, p] = [a, o, 0] : i >= 120 && i < 180 ? [c, d, p] = [0, o, a] : i >= 180 && i < 240 ? [c, d, p] = [0, a, o] : i >= 240 && i < 300 ? [c, d, p] = [a, 0, o] : [c, d, p] = [o, 0, a], [(c + l) * 255, (d + l) * 255, (p + l) * 255];
}
function mae(n, e, t) {
  const i = t + e * (100 - Math.abs(2 * t - 100)) / 200;
  return [
    n,
    i !== 0 ? e * (100 - Math.abs(2 * t - 100)) / i : 0,
    t + e * (100 - Math.abs(2 * t - 100)) / (2 * 100)
  ];
}
function vae(n, e, t) {
  const i = 100 - Math.abs(t * (200 - e) / 100 - 100);
  return [n, i !== 0 ? e * t / i : 0, t * (200 - e) / (2 * 100)];
}
function bh(n) {
  return [n[0], n[1], n[2]];
}
function MN(n, e) {
  return [n[0], n[1], n[2], e];
}
const gae = {
  hsl: {
    hsl: (n, e, t) => [n, e, t],
    hsv: mae,
    rgb: fae
  },
  hsv: {
    hsl: vae,
    hsv: (n, e, t) => [n, e, t],
    rgb: SN
  },
  rgb: {
    hsl: dae,
    hsv: pae,
    rgb: (n, e, t) => [n, e, t]
  }
};
function oy(n, e) {
  return [
    e === "float" ? 1 : n === "rgb" ? 255 : 360,
    e === "float" ? 1 : n === "rgb" ? 255 : 100,
    e === "float" ? 1 : n === "rgb" ? 255 : 100
  ];
}
function _ae(n, e, t) {
  var i;
  const r = oy(e, t);
  return [
    e === "rgb" ? Hi(n[0], 0, r[0]) : yN(n[0], r[0]),
    Hi(n[1], 0, r[1]),
    Hi(n[2], 0, r[2]),
    Hi(
      (i = n[3]) !== null && i !== void 0 ? i : 1,
      0,
      1
    )
  ];
}
function Nk(n, e, t, i) {
  const r = oy(e, t), s = oy(e, i);
  return n.map((o, a) => o / r[a] * s[a]);
}
function bae(n, e, t) {
  const i = Nk(n, e.mode, e.type, "int"), r = gae[e.mode][t.mode](...i);
  return Nk(r, t.mode, "int", t.type);
}
function B_(n, e) {
  return typeof n != "object" || Zi(n) ? !1 : e in n && typeof n[e] == "number";
}
class rn {
  constructor(e, t, i = "int") {
    this.mode = t, this.type = i, this.comps_ = _ae(e, t, i);
  }
  static black(e = "int") {
    return new rn([0, 0, 0], "rgb", e);
  }
  static fromObject(e, t = "int") {
    const i = "a" in e ? [e.r, e.g, e.b, e.a] : [e.r, e.g, e.b];
    return new rn(i, "rgb", t);
  }
  static toRgbaObject(e, t = "int") {
    return e.toRgbaObject(t);
  }
  static isRgbColorObject(e) {
    return B_(e, "r") && B_(e, "g") && B_(e, "b");
  }
  static isRgbaColorObject(e) {
    return this.isRgbColorObject(e) && B_(e, "a");
  }
  static isColorObject(e) {
    return this.isRgbColorObject(e);
  }
  static equals(e, t) {
    if (e.mode !== t.mode)
      return !1;
    const i = e.comps_, r = t.comps_;
    for (let s = 0; s < i.length; s++)
      if (i[s] !== r[s])
        return !1;
    return !0;
  }
  getComponents(e, t = "int") {
    return MN(
      bae(
        bh(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: e != null ? e : this.mode,
          type: t
        }
      ),
      this.comps_[3]
    );
  }
  toRgbaObject(e = "int") {
    const t = this.getComponents("rgb", e);
    return {
      r: t[0],
      g: t[1],
      b: t[2],
      a: t[3]
    };
  }
}
const ic = _n("colp");
class yae {
  constructor(e, t) {
    this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(ic());
    const i = e.createElement("div");
    i.classList.add(ic("hsv"));
    const r = e.createElement("div");
    r.classList.add(ic("sv")), this.svPaletteView_ = t.svPaletteView, r.appendChild(this.svPaletteView_.element), i.appendChild(r);
    const s = e.createElement("div");
    s.classList.add(ic("h")), this.hPaletteView_ = t.hPaletteView, s.appendChild(this.hPaletteView_.element), i.appendChild(s), this.element.appendChild(i);
    const o = e.createElement("div");
    if (o.classList.add(ic("rgb")), this.textView_ = t.textView, o.appendChild(this.textView_.element), this.element.appendChild(o), t.alphaViews) {
      this.alphaViews_ = {
        palette: t.alphaViews.palette,
        text: t.alphaViews.text
      };
      const a = e.createElement("div");
      a.classList.add(ic("a"));
      const l = e.createElement("div");
      l.classList.add(ic("ap")), l.appendChild(this.alphaViews_.palette.element), a.appendChild(l);
      const c = e.createElement("div");
      c.classList.add(ic("at")), c.appendChild(this.alphaViews_.text.element), a.appendChild(c), this.element.appendChild(a);
    }
  }
  get allFocusableElements() {
    const e = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textView_.modeSelectElement,
      ...this.textView_.textViews.map((t) => t.inputElement)
    ];
    return this.alphaViews_ && e.push(
      this.alphaViews_.palette.element,
      this.alphaViews_.text.inputElement
    ), e;
  }
}
function xae(n) {
  return n === "int" ? "int" : n === "float" ? "float" : void 0;
}
function i3(n) {
  const e = si;
  return Tr(n, {
    alpha: e.optional.boolean,
    color: e.optional.object({
      alpha: e.optional.boolean,
      type: e.optional.custom(xae)
    }),
    expanded: e.optional.boolean,
    picker: e.optional.custom(xN)
  });
}
function eh(n) {
  return n ? 0.1 : 1;
}
function Eu(n) {
  var e;
  return (e = n.color) === null || e === void 0 ? void 0 : e.type;
}
function wae(n, e) {
  return n.alpha === e.alpha && n.mode === e.mode && n.notation === e.notation && n.type === e.type;
}
function eo(n, e) {
  const t = n.match(/^(.+)%$/);
  return Math.min(t ? parseFloat(t[1]) * 0.01 * e : parseFloat(n), e);
}
const Sae = {
  deg: (n) => n,
  grad: (n) => n * 360 / 400,
  rad: (n) => n * 360 / (2 * Math.PI),
  turn: (n) => n * 360
};
function EN(n) {
  const e = n.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!e)
    return parseFloat(n);
  const t = parseFloat(e[1]), i = e[2];
  return Sae[i](t);
}
function CN(n) {
  const e = n.match(
    /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
  );
  if (!e)
    return null;
  const t = [
    eo(e[1], 255),
    eo(e[2], 255),
    eo(e[3], 255)
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function zk(n) {
  return (e) => {
    const t = CN(e);
    return t ? new rn(t, "rgb", n) : null;
  };
}
function TN(n) {
  const e = n.match(
    /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
  );
  if (!e)
    return null;
  const t = [
    eo(e[1], 255),
    eo(e[2], 255),
    eo(e[3], 255),
    eo(e[4], 1)
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function Fk(n) {
  return (e) => {
    const t = TN(e);
    return t ? new rn(t, "rgb", n) : null;
  };
}
function PN(n) {
  const e = n.match(
    /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
  );
  if (!e)
    return null;
  const t = [
    EN(e[1]),
    eo(e[2], 100),
    eo(e[3], 100)
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function Bk(n) {
  return (e) => {
    const t = PN(e);
    return t ? new rn(t, "hsl", n) : null;
  };
}
function AN(n) {
  const e = n.match(
    /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
  );
  if (!e)
    return null;
  const t = [
    EN(e[1]),
    eo(e[2], 100),
    eo(e[3], 100),
    eo(e[4], 1)
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function Uk(n) {
  return (e) => {
    const t = AN(e);
    return t ? new rn(t, "hsl", n) : null;
  };
}
function RN(n) {
  const e = n.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (e)
    return [
      parseInt(e[1] + e[1], 16),
      parseInt(e[2] + e[2], 16),
      parseInt(e[3] + e[3], 16)
    ];
  const t = n.match(
    /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
  );
  return t ? [
    parseInt(t[1], 16),
    parseInt(t[2], 16),
    parseInt(t[3], 16)
  ] : null;
}
function Mae(n) {
  const e = RN(n);
  return e ? new rn(e, "rgb", "int") : null;
}
function kN(n) {
  const e = n.match(
    /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/
  );
  if (e)
    return [
      parseInt(e[1] + e[1], 16),
      parseInt(e[2] + e[2], 16),
      parseInt(e[3] + e[3], 16),
      ri(parseInt(e[4] + e[4], 16), 0, 255, 0, 1)
    ];
  const t = n.match(
    /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
  );
  return t ? [
    parseInt(t[1], 16),
    parseInt(t[2], 16),
    parseInt(t[3], 16),
    ri(parseInt(t[4], 16), 0, 255, 0, 1)
  ] : null;
}
function Eae(n) {
  const e = kN(n);
  return e ? new rn(e, "rgb", "int") : null;
}
function LN(n) {
  const e = n.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
  );
  if (!e)
    return null;
  const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function Vk(n) {
  return (e) => {
    const t = LN(e);
    return t ? new rn(t, "rgb", n) : null;
  };
}
function DN(n) {
  const e = n.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
  );
  if (!e)
    return null;
  const t = [
    parseFloat(e[1]),
    parseFloat(e[2]),
    parseFloat(e[3]),
    parseFloat(e[4])
  ];
  return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function Hk(n) {
  return (e) => {
    const t = DN(e);
    return t ? new rn(t, "rgb", n) : null;
  };
}
const Cae = [
  {
    parser: RN,
    result: {
      alpha: !1,
      mode: "rgb",
      notation: "hex"
    }
  },
  {
    parser: kN,
    result: {
      alpha: !0,
      mode: "rgb",
      notation: "hex"
    }
  },
  {
    parser: CN,
    result: {
      alpha: !1,
      mode: "rgb",
      notation: "func"
    }
  },
  {
    parser: TN,
    result: {
      alpha: !0,
      mode: "rgb",
      notation: "func"
    }
  },
  {
    parser: PN,
    result: {
      alpha: !1,
      mode: "hsl",
      notation: "func"
    }
  },
  {
    parser: AN,
    result: {
      alpha: !0,
      mode: "hsl",
      notation: "func"
    }
  },
  {
    parser: LN,
    result: {
      alpha: !1,
      mode: "rgb",
      notation: "object"
    }
  },
  {
    parser: DN,
    result: {
      alpha: !0,
      mode: "rgb",
      notation: "object"
    }
  }
];
function Tae(n) {
  return Cae.reduce((e, { parser: t, result: i }) => e || (t(n) ? i : null), null);
}
function KS(n, e = "int") {
  const t = Tae(n);
  return t ? t.notation === "hex" && e !== "float" ? Object.assign(Object.assign({}, t), { type: "int" }) : t.notation === "func" ? Object.assign(Object.assign({}, t), { type: e }) : null : null;
}
const IN = {
  int: [
    Mae,
    Eae,
    zk("int"),
    Fk("int"),
    Bk("int"),
    Uk("int"),
    Vk("int"),
    Hk("int")
  ],
  float: [
    zk("float"),
    Fk("float"),
    Bk("float"),
    Uk("float"),
    Vk("float"),
    Hk("float")
  ]
};
function Pae(n) {
  const e = IN[n];
  return (t) => {
    if (typeof t != "string")
      return rn.black(n);
    const i = e.reduce((r, s) => r || s(t), null);
    return i != null ? i : rn.black(n);
  };
}
function r3(n) {
  const e = IN[n];
  return (t) => e.reduce((i, r) => i || r(t), null);
}
function ON(n) {
  const e = Hi(Math.floor(n), 0, 255).toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function NN(n, e = "#") {
  const t = bh(n.getComponents("rgb")).map(ON).join("");
  return `${e}${t}`;
}
function s3(n, e = "#") {
  const t = n.getComponents("rgb"), i = [t[0], t[1], t[2], t[3] * 255].map(ON).join("");
  return `${e}${i}`;
}
function zN(n, e) {
  const t = Er(e === "float" ? 2 : 0);
  return `rgb(${bh(
    n.getComponents("rgb", e)
  ).map((r) => t(r)).join(", ")})`;
}
function Aae(n) {
  return (e) => zN(e, n);
}
function ub(n, e) {
  const t = Er(2), i = Er(e === "float" ? 2 : 0);
  return `rgba(${n.getComponents("rgb", e).map((s, o) => (o === 3 ? t : i)(s)).join(", ")})`;
}
function Rae(n) {
  return (e) => ub(e, n);
}
function kae(n) {
  const e = [
    Er(0),
    sy,
    sy
  ];
  return `hsl(${bh(n.getComponents("hsl")).map(
    (i, r) => e[r](i)
  ).join(", ")})`;
}
function Lae(n) {
  const e = [
    Er(0),
    sy,
    sy,
    Er(2)
  ];
  return `hsla(${n.getComponents("hsl").map((i, r) => e[r](i)).join(", ")})`;
}
function FN(n, e) {
  const t = Er(e === "float" ? 2 : 0), i = ["r", "g", "b"];
  return `{${bh(n.getComponents("rgb", e)).map(
    (s, o) => `${i[o]}: ${t(s)}`
  ).join(", ")}}`;
}
function Dae(n) {
  return (e) => FN(e, n);
}
function BN(n, e) {
  const t = Er(2), i = Er(e === "float" ? 2 : 0), r = ["r", "g", "b", "a"];
  return `{${n.getComponents("rgb", e).map((o, a) => {
    const l = a === 3 ? t : i;
    return `${r[a]}: ${l(o)}`;
  }).join(", ")}}`;
}
function Iae(n) {
  return (e) => BN(e, n);
}
const Oae = [
  {
    format: {
      alpha: !1,
      mode: "rgb",
      notation: "hex",
      type: "int"
    },
    stringifier: NN
  },
  {
    format: {
      alpha: !0,
      mode: "rgb",
      notation: "hex",
      type: "int"
    },
    stringifier: s3
  },
  {
    format: {
      alpha: !1,
      mode: "hsl",
      notation: "func",
      type: "int"
    },
    stringifier: kae
  },
  {
    format: {
      alpha: !0,
      mode: "hsl",
      notation: "func",
      type: "int"
    },
    stringifier: Lae
  },
  ...["int", "float"].reduce((n, e) => [
    ...n,
    {
      format: {
        alpha: !1,
        mode: "rgb",
        notation: "func",
        type: e
      },
      stringifier: Aae(e)
    },
    {
      format: {
        alpha: !0,
        mode: "rgb",
        notation: "func",
        type: e
      },
      stringifier: Rae(e)
    },
    {
      format: {
        alpha: !1,
        mode: "rgb",
        notation: "object",
        type: e
      },
      stringifier: Dae(e)
    },
    {
      format: {
        alpha: !0,
        mode: "rgb",
        notation: "object",
        type: e
      },
      stringifier: Iae(e)
    }
  ], [])
];
function VM(n) {
  return Oae.reduce((e, t) => e || (wae(t.format, n) ? t.stringifier : null), null);
}
const gm = _n("apl");
class Nae {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(gm()), t.viewProps.bindTabIndex(this.element);
    const i = e.createElement("div");
    i.classList.add(gm("b")), this.element.appendChild(i);
    const r = e.createElement("div");
    r.classList.add(gm("c")), i.appendChild(r), this.colorElem_ = r;
    const s = e.createElement("div");
    s.classList.add(gm("m")), this.element.appendChild(s), this.markerElem_ = s;
    const o = e.createElement("div");
    o.classList.add(gm("p")), this.markerElem_.appendChild(o), this.previewElem_ = o, this.update_();
  }
  update_() {
    const e = this.value.rawValue, t = e.getComponents("rgb"), i = new rn(
      [t[0], t[1], t[2], 0],
      "rgb"
    ), r = new rn(
      [t[0], t[1], t[2], 255],
      "rgb"
    ), s = [
      "to right",
      ub(i),
      ub(r)
    ];
    this.colorElem_.style.background = `linear-gradient(${s.join(
      ","
    )})`, this.previewElem_.style.backgroundColor = ub(e);
    const o = ri(t[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${o}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class zae {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Nae(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new _h(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point)
      return;
    const i = e.point.x / e.bounds.width, r = this.value.rawValue, [s, o, a] = r.getComponents("hsv");
    this.value.setRawValue(new rn([s, o, a, i], "hsv"), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onKeyDown_(e) {
    const t = vs(
      eh(!0),
      bl(e)
    );
    if (t === 0)
      return;
    const i = this.value.rawValue, [r, s, o, a] = i.getComponents("hsv");
    this.value.setRawValue(new rn([r, s, o, a + t], "hsv"), {
      forceEmit: !1,
      last: !1
    });
  }
  onKeyUp_(e) {
    vs(
      eh(!0),
      bl(e)
    ) !== 0 && this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
const Sd = _n("coltxt");
function Fae(n) {
  const e = n.createElement("select"), t = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" }
  ];
  return e.appendChild(
    t.reduce((i, r) => {
      const s = n.createElement("option");
      return s.textContent = r.text, s.value = r.value, i.appendChild(s), i;
    }, n.createDocumentFragment())
  ), e;
}
class Bae {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Sd());
    const i = e.createElement("div");
    i.classList.add(Sd("m")), this.modeElem_ = Fae(e), this.modeElem_.classList.add(Sd("ms")), i.appendChild(this.modeSelectElement);
    const r = e.createElement("div");
    r.classList.add(Sd("mm")), r.appendChild(vx(e, "dropdown")), i.appendChild(r), this.element.appendChild(i);
    const s = e.createElement("div");
    s.classList.add(Sd("w")), this.element.appendChild(s), this.textsElem_ = s, this.textViews_ = t.textViews, this.applyTextViews_(), Qf(t.colorMode, (o) => {
      this.modeElem_.value = o;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get textViews() {
    return this.textViews_;
  }
  set textViews(e) {
    this.textViews_ = e, this.applyTextViews_();
  }
  applyTextViews_() {
    nN(this.textsElem_);
    const e = this.element.ownerDocument;
    this.textViews_.forEach((t) => {
      const i = e.createElement("div");
      i.classList.add(Sd("c")), i.appendChild(t.element), this.textsElem_.appendChild(i);
    });
  }
}
function Uae(n) {
  return Er(n === "float" ? 2 : 0);
}
function Vae(n, e, t) {
  const i = oy(n, e)[t];
  return new tp({
    min: 0,
    max: i
  });
}
function JS(n, e, t) {
  return new lg(n, {
    arrayPosition: t === 0 ? "fst" : t === 3 - 1 ? "lst" : "mid",
    baseStep: eh(!1),
    parser: e.parser,
    props: Qt.fromObject({
      draggingScale: e.colorType === "float" ? 0.01 : 1,
      formatter: Uae(e.colorType)
    }),
    value: Fr(0, {
      constraint: Vae(
        e.colorMode,
        e.colorType,
        t
      )
    }),
    viewProps: e.viewProps
  });
}
class Hae {
  constructor(e, t) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = t.colorType, this.parser_ = t.parser, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = Fr(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new Bae(e, {
      colorMode: this.colorMode,
      textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
    }), this.view.modeSelectElement.addEventListener(
      "change",
      this.onModeSelectChange_
    );
  }
  createComponentControllers_(e) {
    const t = {
      colorMode: this.colorMode.rawValue,
      colorType: this.colorType_,
      parser: this.parser_,
      viewProps: this.viewProps
    }, i = [
      JS(e, t, 0),
      JS(e, t, 1),
      JS(e, t, 2)
    ];
    return i.forEach((r, s) => {
      ag({
        primary: this.value,
        secondary: r.value,
        forward: (o) => o.rawValue.getComponents(
          this.colorMode.rawValue,
          this.colorType_
        )[s],
        backward: (o, a) => {
          const l = this.colorMode.rawValue, c = o.rawValue.getComponents(
            l,
            this.colorType_
          );
          return c[s] = a.rawValue, new rn(
            MN(
              bh(c),
              c[3]
            ),
            l,
            this.colorType_
          );
        }
      });
    }), i;
  }
  onModeSelectChange_(e) {
    const t = e.currentTarget;
    this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(
      this.view.element.ownerDocument
    ), this.view.textViews = [
      this.ccs_[0].view,
      this.ccs_[1].view,
      this.ccs_[2].view
    ];
  }
}
const QS = _n("hpl");
class Gae {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(QS()), t.viewProps.bindTabIndex(this.element);
    const i = e.createElement("div");
    i.classList.add(QS("c")), this.element.appendChild(i);
    const r = e.createElement("div");
    r.classList.add(QS("m")), this.element.appendChild(r), this.markerElem_ = r, this.update_();
  }
  update_() {
    const e = this.value.rawValue, [t] = e.getComponents("hsv");
    this.markerElem_.style.backgroundColor = zN(
      new rn([t, 100, 100], "hsv")
    );
    const i = ri(t, 0, 360, 0, 100);
    this.markerElem_.style.left = `${i}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class Wae {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Gae(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new _h(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point)
      return;
    const i = ri(
      Hi(e.point.x, 0, e.bounds.width),
      0,
      e.bounds.width,
      0,
      359
    ), r = this.value.rawValue, [, s, o, a] = r.getComponents("hsv");
    this.value.setRawValue(new rn([i, s, o, a], "hsv"), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onKeyDown_(e) {
    const t = vs(
      eh(!1),
      bl(e)
    );
    if (t === 0)
      return;
    const i = this.value.rawValue, [r, s, o, a] = i.getComponents("hsv");
    this.value.setRawValue(new rn([r + t, s, o, a], "hsv"), {
      forceEmit: !1,
      last: !1
    });
  }
  onKeyUp_(e) {
    vs(
      eh(!1),
      bl(e)
    ) !== 0 && this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
const e2 = _n("svp"), Gk = 64;
class jae {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(e2()), t.viewProps.bindTabIndex(this.element);
    const i = e.createElement("canvas");
    i.height = Gk, i.width = Gk, i.classList.add(e2("c")), this.element.appendChild(i), this.canvasElement = i;
    const r = e.createElement("div");
    r.classList.add(e2("m")), this.element.appendChild(r), this.markerElem_ = r, this.update_();
  }
  update_() {
    const e = Hse(this.canvasElement);
    if (!e)
      return;
    const i = this.value.rawValue.getComponents("hsv"), r = this.canvasElement.width, s = this.canvasElement.height, o = e.getImageData(0, 0, r, s), a = o.data;
    for (let d = 0; d < s; d++)
      for (let p = 0; p < r; p++) {
        const m = ri(p, 0, r, 0, 100), v = ri(d, 0, s, 100, 0), b = SN(i[0], m, v), x = (d * r + p) * 4;
        a[x] = b[0], a[x + 1] = b[1], a[x + 2] = b[2], a[x + 3] = 255;
      }
    e.putImageData(o, 0, 0);
    const l = ri(i[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${l}%`;
    const c = ri(i[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${c}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class qae {
  constructor(e, t) {
    this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new jae(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new _h(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point)
      return;
    const i = ri(e.point.x, 0, e.bounds.width, 0, 100), r = ri(e.point.y, 0, e.bounds.height, 100, 0), [s, , , o] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(
      new rn([s, i, r, o], "hsv"),
      t
    );
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onKeyDown_(e) {
    bN(e.key) && e.preventDefault();
    const [t, i, r, s] = this.value.rawValue.getComponents("hsv"), o = eh(!1), a = vs(o, bl(e)), l = vs(o, wv(e));
    a === 0 && l === 0 || this.value.setRawValue(new rn([t, i + a, r + l, s], "hsv"), {
      forceEmit: !1,
      last: !1
    });
  }
  onKeyUp_(e) {
    const t = eh(!1), i = vs(t, bl(e)), r = vs(t, wv(e));
    i === 0 && r === 0 || this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
class Xae {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new Wae(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.svPaletteC_ = new qae(e, {
      value: this.value,
      viewProps: this.viewProps
    }), this.alphaIcs_ = t.supportsAlpha ? {
      palette: new zae(e, {
        value: this.value,
        viewProps: this.viewProps
      }),
      text: new lg(e, {
        parser: _l,
        baseStep: 0.1,
        props: Qt.fromObject({
          draggingScale: 0.01,
          formatter: Er(2)
        }),
        value: Fr(0, {
          constraint: new tp({
            min: 0,
            max: 1
          })
        }),
        viewProps: this.viewProps
      })
    } : null, this.alphaIcs_ && ag({
      primary: this.value,
      secondary: this.alphaIcs_.text.value,
      forward: (i) => i.rawValue.getComponents()[3],
      backward: (i, r) => {
        const s = i.rawValue.getComponents();
        return s[3] = r.rawValue, new rn(s, i.rawValue.mode);
      }
    }), this.textC_ = new Hae(e, {
      colorType: t.colorType,
      parser: _l,
      value: this.value,
      viewProps: this.viewProps
    }), this.view = new yae(e, {
      alphaViews: this.alphaIcs_ ? {
        palette: this.alphaIcs_.palette.view,
        text: this.alphaIcs_.text.view
      } : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: t.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textView: this.textC_.view
    });
  }
  get textController() {
    return this.textC_;
  }
}
const t2 = _n("colsw");
class $ae {
  constructor(e, t) {
    this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(t2()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("div");
    i.classList.add(t2("sw")), this.element.appendChild(i), this.swatchElem_ = i;
    const r = e.createElement("button");
    r.classList.add(t2("b")), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r, this.update_();
  }
  update_() {
    const e = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = s3(e);
  }
  onValueChange_() {
    this.update_();
  }
}
class Zae {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new $ae(e, {
      value: this.value,
      viewProps: this.viewProps
    });
  }
}
class o3 {
  constructor(e, t) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = ig.create(t.expanded), this.swatchC_ = new Zae(e, {
      value: this.value,
      viewProps: this.viewProps
    });
    const i = this.swatchC_.view.buttonElement;
    i.addEventListener("blur", this.onButtonBlur_), i.addEventListener("click", this.onButtonClick_), this.textC_ = new ry(e, {
      parser: t.parser,
      props: Qt.fromObject({
        formatter: t.formatter
      }),
      value: this.value,
      viewProps: this.viewProps
    }), this.view = new hae(e, {
      foldable: this.foldable_,
      pickerLayout: t.pickerLayout
    }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = t.pickerLayout === "popup" ? new hN(e, {
      viewProps: this.viewProps
    }) : null;
    const r = new Xae(e, {
      colorType: t.colorType,
      supportsAlpha: t.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps
    });
    r.view.allFocusableElements.forEach((s) => {
      s.addEventListener("blur", this.onPopupChildBlur_), s.addEventListener("keydown", this.onPopupChildKeydown_);
    }), this.pickerC_ = r, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(r.view.element), ag({
      primary: this.foldable_.value("expanded"),
      secondary: this.popC_.shows,
      forward: (s) => s.rawValue,
      backward: (s, o) => o.rawValue
    })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), ZC(this.foldable_, this.view.pickerElement));
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_)
      return;
    const t = this.view.element, i = e.relatedTarget;
    (!i || !t.contains(i)) && (this.popC_.shows.rawValue = !1);
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
  }
  onPopupChildBlur_(e) {
    if (!this.popC_)
      return;
    const t = this.popC_.view.element, i = iN(e);
    i && t.contains(i) || i && i === this.swatchC_.view.buttonElement && !$C(t.ownerDocument) || (this.popC_.shows.rawValue = !1);
  }
  onPopupChildKeydown_(e) {
    this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && e.key === "Escape" && this.swatchC_.view.buttonElement.focus();
  }
}
function Yae(n, e) {
  return rn.isColorObject(n) ? rn.fromObject(n, e) : rn.black(e);
}
function Kae(n) {
  return bh(n.getComponents("rgb")).reduce(
    (e, t) => e << 8 | Math.floor(t) & 255,
    0
  );
}
function Jae(n) {
  return n.getComponents("rgb").reduce((e, t, i) => {
    const r = Math.floor(i === 3 ? t * 255 : t) & 255;
    return e << 8 | r;
  }, 0) >>> 0;
}
function Qae(n) {
  return new rn([n >> 16 & 255, n >> 8 & 255, n & 255], "rgb");
}
function ele(n) {
  return new rn(
    [
      n >> 24 & 255,
      n >> 16 & 255,
      n >> 8 & 255,
      ri(n & 255, 0, 255, 0, 1)
    ],
    "rgb"
  );
}
function tle(n) {
  return typeof n != "number" ? rn.black() : Qae(n);
}
function nle(n) {
  return typeof n != "number" ? rn.black() : ele(n);
}
function ile(n) {
  const e = VM(n);
  return e ? (t, i) => {
    cg(t, e(i));
  } : null;
}
function rle(n) {
  const e = n ? Jae : Kae;
  return (t, i) => {
    cg(t, e(i));
  };
}
function sle(n, e, t) {
  const i = e.toRgbaObject(t);
  n.writeProperty("r", i.r), n.writeProperty("g", i.g), n.writeProperty("b", i.b), n.writeProperty("a", i.a);
}
function ole(n, e, t) {
  const i = e.toRgbaObject(t);
  n.writeProperty("r", i.r), n.writeProperty("g", i.g), n.writeProperty("b", i.b);
}
function ale(n, e) {
  return (t, i) => {
    n ? sle(t, i, e) : ole(t, i, e);
  };
}
function n2(n) {
  var e;
  return !!((n == null ? void 0 : n.alpha) || ((e = n == null ? void 0 : n.color) === null || e === void 0 ? void 0 : e.alpha));
}
function lle(n) {
  return n ? (e) => s3(e, "0x") : (e) => NN(e, "0x");
}
function cle(n) {
  return "color" in n || "view" in n && n.view === "color";
}
const ule = {
  id: "input-color-number",
  type: "input",
  accept: (n, e) => {
    if (typeof n != "number" || !cle(e))
      return null;
    const t = i3(e);
    return t ? {
      initialValue: n,
      params: t
    } : null;
  },
  binding: {
    reader: (n) => n2(n.params) ? nle : tle,
    equals: rn.equals,
    writer: (n) => rle(n2(n.params))
  },
  controller: (n) => {
    const e = n2(n.params), t = "expanded" in n.params ? n.params.expanded : void 0, i = "picker" in n.params ? n.params.picker : void 0;
    return new o3(n.document, {
      colorType: "int",
      expanded: t != null ? t : !1,
      formatter: lle(e),
      parser: r3("int"),
      pickerLayout: i != null ? i : "popup",
      supportsAlpha: e,
      value: n.value,
      viewProps: n.viewProps
    });
  }
};
function hle(n) {
  return rn.isRgbaColorObject(n);
}
function dle(n) {
  return (e) => Yae(e, n);
}
function fle(n, e) {
  return (t) => n ? BN(t, e) : FN(t, e);
}
const ple = {
  id: "input-color-object",
  type: "input",
  accept: (n, e) => {
    if (!rn.isColorObject(n))
      return null;
    const t = i3(e);
    return t ? {
      initialValue: n,
      params: t
    } : null;
  },
  binding: {
    reader: (n) => dle(Eu(n.params)),
    equals: rn.equals,
    writer: (n) => ale(
      hle(n.initialValue),
      Eu(n.params)
    )
  },
  controller: (n) => {
    var e;
    const t = rn.isRgbaColorObject(n.initialValue), i = "expanded" in n.params ? n.params.expanded : void 0, r = "picker" in n.params ? n.params.picker : void 0, s = (e = Eu(n.params)) !== null && e !== void 0 ? e : "int";
    return new o3(n.document, {
      colorType: s,
      expanded: i != null ? i : !1,
      formatter: fle(t, s),
      parser: r3(s),
      pickerLayout: r != null ? r : "popup",
      supportsAlpha: t,
      value: n.value,
      viewProps: n.viewProps
    });
  }
}, mle = {
  id: "input-color-string",
  type: "input",
  accept: (n, e) => {
    if (typeof n != "string" || "view" in e && e.view === "text")
      return null;
    const t = KS(n, Eu(e));
    if (!t || !VM(t))
      return null;
    const r = i3(e);
    return r ? {
      initialValue: n,
      params: r
    } : null;
  },
  binding: {
    reader: (n) => {
      var e;
      return Pae(
        (e = Eu(n.params)) !== null && e !== void 0 ? e : "int"
      );
    },
    equals: rn.equals,
    writer: (n) => {
      const e = KS(
        n.initialValue,
        Eu(n.params)
      );
      if (!e)
        throw xn.shouldNeverHappen();
      const t = ile(e);
      if (!t)
        throw xn.notBindable();
      return t;
    }
  },
  controller: (n) => {
    const e = KS(
      n.initialValue,
      Eu(n.params)
    );
    if (!e)
      throw xn.shouldNeverHappen();
    const t = VM(e);
    if (!t)
      throw xn.shouldNeverHappen();
    const i = "expanded" in n.params ? n.params.expanded : void 0, r = "picker" in n.params ? n.params.picker : void 0;
    return new o3(n.document, {
      colorType: e.type,
      expanded: i != null ? i : !1,
      formatter: t,
      parser: r3(e.type),
      pickerLayout: r != null ? r : "popup",
      supportsAlpha: e.alpha,
      value: n.value,
      viewProps: n.viewProps
    });
  }
};
class Rc {
  constructor(e) {
    this.components = e.components, this.asm_ = e.assembly;
  }
  constrain(e) {
    const t = this.asm_.toComponents(e).map((i, r) => {
      var s, o;
      return (o = (s = this.components[r]) === null || s === void 0 ? void 0 : s.constrain(i)) !== null && o !== void 0 ? o : i;
    });
    return this.asm_.fromComponents(t);
  }
}
const Wk = _n("pndtxt");
class vle {
  constructor(e, t) {
    this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(Wk()), this.textViews.forEach((i) => {
      const r = e.createElement("div");
      r.classList.add(Wk("a")), r.appendChild(i.element), this.element.appendChild(r);
    });
  }
}
function gle(n, e, t) {
  return new lg(n, {
    arrayPosition: t === 0 ? "fst" : t === e.axes.length - 1 ? "lst" : "mid",
    baseStep: e.axes[t].baseStep,
    parser: e.parser,
    props: e.axes[t].textProps,
    value: Fr(0, {
      constraint: e.axes[t].constraint
    }),
    viewProps: e.viewProps
  });
}
class a3 {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map(
      (i, r) => gle(e, t, r)
    ), this.acs_.forEach((i, r) => {
      ag({
        primary: this.value,
        secondary: i.value,
        forward: (s) => t.assembly.toComponents(s.rawValue)[r],
        backward: (s, o) => {
          const a = t.assembly.toComponents(s.rawValue);
          return a[r] = o.rawValue, t.assembly.fromComponents(a);
        }
      });
    }), this.view = new vle(e, {
      textViews: this.acs_.map((i) => i.view)
    });
  }
}
function UN(n, e) {
  return "step" in n && !Zi(n.step) ? new _x(n.step, e) : null;
}
function VN(n) {
  return "max" in n && !Zi(n.max) || "min" in n && !Zi(n.min) ? new tp({
    max: n.max,
    min: n.min
  }) : null;
}
function _le(n, e) {
  const t = [], i = UN(n, e);
  i && t.push(i);
  const r = VN(n);
  r && t.push(r);
  const s = t3(n.options);
  return s && t.push(s), new sg(t);
}
function ble(n) {
  const e = n ? va(n, tp) : null;
  return e ? [e.minValue, e.maxValue] : [void 0, void 0];
}
function yle(n) {
  const [e, t] = ble(n);
  return [
    e != null ? e : 0,
    t != null ? t : 100
  ];
}
const xle = {
  id: "input-number",
  type: "input",
  accept: (n, e) => {
    if (typeof n != "number")
      return null;
    const t = si, i = Tr(e, {
      format: t.optional.function,
      max: t.optional.number,
      min: t.optional.number,
      options: t.optional.custom(bx),
      step: t.optional.number
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    reader: (n) => vN,
    constraint: (n) => _le(n.params, n.initialValue),
    writer: (n) => cg
  },
  controller: (n) => {
    var e, t;
    const i = n.value, r = n.constraint;
    if (r && va(r, og))
      return new bv(n.document, {
        props: Qt.fromObject({
          options: (e = n3(r)) !== null && e !== void 0 ? e : []
        }),
        value: i,
        viewProps: n.viewProps
      });
    const s = (t = "format" in n.params ? n.params.format : void 0) !== null && t !== void 0 ? t : Er(
      yx(r, i.rawValue)
    );
    if (r && va(r, tp)) {
      const [o, a] = yle(r);
      return new UM(n.document, {
        baseStep: If(r),
        parser: _l,
        sliderProps: Qt.fromObject({
          maxValue: a,
          minValue: o
        }),
        textProps: Qt.fromObject({
          draggingScale: Of(r, i.rawValue),
          formatter: s
        }),
        value: i,
        viewProps: n.viewProps
      });
    }
    return new lg(n.document, {
      baseStep: If(r),
      parser: _l,
      props: Qt.fromObject({
        draggingScale: Of(r, i.rawValue),
        formatter: s
      }),
      value: i,
      viewProps: n.viewProps
    });
  }
};
class wc {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(e) {
    if (Zi(e))
      return !1;
    const t = e.x, i = e.y;
    return !(typeof t != "number" || typeof i != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y
    };
  }
}
const HN = {
  toComponents: (n) => n.getComponents(),
  fromComponents: (n) => new wc(...n)
}, Md = _n("p2d");
class wle {
  constructor(e, t) {
    this.element = e.createElement("div"), this.element.classList.add(Md()), t.viewProps.bindClassModifiers(this.element), Qf(
      t.expanded,
      ep(this.element, Md(void 0, "expanded"))
    );
    const i = e.createElement("div");
    i.classList.add(Md("h")), this.element.appendChild(i);
    const r = e.createElement("button");
    r.classList.add(Md("b")), r.appendChild(vx(e, "p2dpad")), t.viewProps.bindDisabled(r), i.appendChild(r), this.buttonElement = r;
    const s = e.createElement("div");
    if (s.classList.add(Md("t")), i.appendChild(s), this.textElement = s, t.pickerLayout === "inline") {
      const o = e.createElement("div");
      o.classList.add(Md("p")), this.element.appendChild(o), this.pickerElement = o;
    } else
      this.pickerElement = null;
  }
}
const rc = _n("p2dp");
class Sle {
  constructor(e, t) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = t.invertsY, this.maxValue_ = t.maxValue, this.element = e.createElement("div"), this.element.classList.add(rc()), t.layout === "popup" && this.element.classList.add(rc(void 0, "p"));
    const i = e.createElement("div");
    i.classList.add(rc("p")), t.viewProps.bindTabIndex(i), this.element.appendChild(i), this.padElement = i;
    const r = e.createElementNS(ca, "svg");
    r.classList.add(rc("g")), this.padElement.appendChild(r), this.svgElem_ = r;
    const s = e.createElementNS(ca, "line");
    s.classList.add(rc("ax")), s.setAttributeNS(null, "x1", "0"), s.setAttributeNS(null, "y1", "50%"), s.setAttributeNS(null, "x2", "100%"), s.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(s);
    const o = e.createElementNS(ca, "line");
    o.classList.add(rc("ax")), o.setAttributeNS(null, "x1", "50%"), o.setAttributeNS(null, "y1", "0"), o.setAttributeNS(null, "x2", "50%"), o.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(o);
    const a = e.createElementNS(ca, "line");
    a.classList.add(rc("l")), a.setAttributeNS(null, "x1", "50%"), a.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(a), this.lineElem_ = a;
    const l = e.createElement("div");
    l.classList.add(rc("m")), this.padElement.appendChild(l), this.markerElem_ = l, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [e, t] = this.value.rawValue.getComponents(), i = this.maxValue_, r = ri(e, -i, +i, 0, 100), s = ri(t, -i, +i, 0, 100), o = this.invertsY_ ? 100 - s : s;
    this.lineElem_.setAttributeNS(null, "x2", `${r}%`), this.lineElem_.setAttributeNS(null, "y2", `${o}%`), this.markerElem_.style.left = `${r}%`, this.markerElem_.style.top = `${o}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
}
function jk(n, e, t) {
  return [
    vs(e[0], bl(n)),
    vs(e[1], wv(n)) * (t ? 1 : -1)
  ];
}
class Mle {
  constructor(e, t) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.baseSteps_ = t.baseSteps, this.maxValue_ = t.maxValue, this.invertsY_ = t.invertsY, this.view = new Sle(e, {
      invertsY: this.invertsY_,
      layout: t.layout,
      maxValue: this.maxValue_,
      value: this.value,
      viewProps: this.viewProps
    }), this.ptHandler_ = new _h(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(e, t) {
    if (!e.point)
      return;
    const i = this.maxValue_, r = ri(e.point.x, 0, e.bounds.width, -i, +i), s = ri(
      this.invertsY_ ? e.bounds.height - e.point.y : e.point.y,
      0,
      e.bounds.height,
      -i,
      +i
    );
    this.value.setRawValue(new wc(r, s), t);
  }
  onPointerDown_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerMove_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !1,
      last: !1
    });
  }
  onPointerUp_(e) {
    this.handlePointerEvent_(e.data, {
      forceEmit: !0,
      last: !0
    });
  }
  onPadKeyDown_(e) {
    bN(e.key) && e.preventDefault();
    const [t, i] = jk(e, this.baseSteps_, this.invertsY_);
    t === 0 && i === 0 || this.value.setRawValue(
      new wc(this.value.rawValue.x + t, this.value.rawValue.y + i),
      {
        forceEmit: !1,
        last: !1
      }
    );
  }
  onPadKeyUp_(e) {
    const [t, i] = jk(e, this.baseSteps_, this.invertsY_);
    t === 0 && i === 0 || this.value.setRawValue(this.value.rawValue, {
      forceEmit: !0,
      last: !0
    });
  }
}
class Ele {
  constructor(e, t) {
    var i, r;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = ig.create(t.expanded), this.popC_ = t.pickerLayout === "popup" ? new hN(e, {
      viewProps: this.viewProps
    }) : null;
    const s = new Mle(e, {
      baseSteps: [t.axes[0].baseStep, t.axes[1].baseStep],
      invertsY: t.invertsY,
      layout: t.pickerLayout,
      maxValue: t.maxValue,
      value: this.value,
      viewProps: this.viewProps
    });
    s.view.allFocusableElements.forEach((o) => {
      o.addEventListener("blur", this.onPopupChildBlur_), o.addEventListener("keydown", this.onPopupChildKeydown_);
    }), this.pickerC_ = s, this.textC_ = new a3(e, {
      assembly: HN,
      axes: t.axes,
      parser: t.parser,
      value: this.value,
      viewProps: this.viewProps
    }), this.view = new wle(e, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: t.pickerLayout,
      viewProps: this.viewProps
    }), this.view.textElement.appendChild(this.textC_.view.element), (i = this.view.buttonElement) === null || i === void 0 || i.addEventListener("blur", this.onPadButtonBlur_), (r = this.view.buttonElement) === null || r === void 0 || r.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), ag({
      primary: this.foldable_.value("expanded"),
      secondary: this.popC_.shows,
      forward: (o) => o.rawValue,
      backward: (o, a) => a.rawValue
    })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), ZC(this.foldable_, this.view.pickerElement));
  }
  onPadButtonBlur_(e) {
    if (!this.popC_)
      return;
    const t = this.view.element, i = e.relatedTarget;
    (!i || !t.contains(i)) && (this.popC_.shows.rawValue = !1);
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
  }
  onPopupChildBlur_(e) {
    if (!this.popC_)
      return;
    const t = this.popC_.view.element, i = iN(e);
    i && t.contains(i) || i && i === this.view.buttonElement && !$C(t.ownerDocument) || (this.popC_.shows.rawValue = !1);
  }
  onPopupChildKeydown_(e) {
    this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && e.key === "Escape" && this.view.buttonElement.focus();
  }
}
function Cle(n) {
  return wc.isObject(n) ? new wc(n.x, n.y) : new wc();
}
function Tle(n, e) {
  n.writeProperty("x", e.x), n.writeProperty("y", e.y);
}
function hl(n, e) {
  if (!n)
    return;
  const t = [], i = UN(n, e);
  i && t.push(i);
  const r = VN(n);
  return r && t.push(r), new sg(t);
}
function Ple(n, e) {
  return new Rc({
    assembly: HN,
    components: [
      hl(
        "x" in n ? n.x : void 0,
        e.x
      ),
      hl(
        "y" in n ? n.y : void 0,
        e.y
      )
    ]
  });
}
function qk(n, e) {
  var t, i;
  const r = n && va(n, tp);
  if (r)
    return Math.max(
      Math.abs((t = r.minValue) !== null && t !== void 0 ? t : 0),
      Math.abs((i = r.maxValue) !== null && i !== void 0 ? i : 0)
    );
  const s = If(n);
  return Math.max(Math.abs(s) * 10, Math.abs(e) * 10);
}
function Ale(n, e) {
  const t = e instanceof Rc ? e.components[0] : void 0, i = e instanceof Rc ? e.components[1] : void 0, r = qk(t, n.x), s = qk(i, n.y);
  return Math.max(r, s);
}
function Xk(n, e) {
  return {
    baseStep: If(e),
    constraint: e,
    textProps: Qt.fromObject({
      draggingScale: Of(e, n),
      formatter: Er(
        yx(e, n)
      )
    })
  };
}
function Rle(n) {
  if (!("y" in n))
    return !1;
  const e = n.y;
  return e && "inverted" in e ? !!e.inverted : !1;
}
const kle = {
  id: "input-point2d",
  type: "input",
  accept: (n, e) => {
    if (!wc.isObject(n))
      return null;
    const t = si, i = Tr(e, {
      expanded: t.optional.boolean,
      picker: t.optional.custom(xN),
      x: t.optional.custom(hc),
      y: t.optional.object({
        inverted: t.optional.boolean,
        max: t.optional.number,
        min: t.optional.number,
        step: t.optional.number
      })
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    reader: (n) => Cle,
    constraint: (n) => Ple(n.params, n.initialValue),
    equals: wc.equals,
    writer: (n) => Tle
  },
  controller: (n) => {
    const e = n.document, t = n.value, i = n.constraint;
    if (!(i instanceof Rc))
      throw xn.shouldNeverHappen();
    const r = "expanded" in n.params ? n.params.expanded : void 0, s = "picker" in n.params ? n.params.picker : void 0;
    return new Ele(e, {
      axes: [
        Xk(t.rawValue.x, i.components[0]),
        Xk(t.rawValue.y, i.components[1])
      ],
      expanded: r != null ? r : !1,
      invertsY: Rle(n.params),
      maxValue: Ale(t.rawValue, i),
      parser: _l,
      pickerLayout: s != null ? s : "popup",
      value: t,
      viewProps: n.viewProps
    });
  }
};
class pf {
  constructor(e = 0, t = 0, i = 0) {
    this.x = e, this.y = t, this.z = i;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(e) {
    if (Zi(e))
      return !1;
    const t = e.x, i = e.y, r = e.z;
    return !(typeof t != "number" || typeof i != "number" || typeof r != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y && e.z === t.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
}
const GN = {
  toComponents: (n) => n.getComponents(),
  fromComponents: (n) => new pf(...n)
};
function Lle(n) {
  return pf.isObject(n) ? new pf(n.x, n.y, n.z) : new pf();
}
function Dle(n, e) {
  n.writeProperty("x", e.x), n.writeProperty("y", e.y), n.writeProperty("z", e.z);
}
function Ile(n, e) {
  return new Rc({
    assembly: GN,
    components: [
      hl(
        "x" in n ? n.x : void 0,
        e.x
      ),
      hl(
        "y" in n ? n.y : void 0,
        e.y
      ),
      hl(
        "z" in n ? n.z : void 0,
        e.z
      )
    ]
  });
}
function i2(n, e) {
  return {
    baseStep: If(e),
    constraint: e,
    textProps: Qt.fromObject({
      draggingScale: Of(e, n),
      formatter: Er(
        yx(e, n)
      )
    })
  };
}
const Ole = {
  id: "input-point3d",
  type: "input",
  accept: (n, e) => {
    if (!pf.isObject(n))
      return null;
    const t = si, i = Tr(e, {
      x: t.optional.custom(hc),
      y: t.optional.custom(hc),
      z: t.optional.custom(hc)
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    reader: (n) => Lle,
    constraint: (n) => Ile(n.params, n.initialValue),
    equals: pf.equals,
    writer: (n) => Dle
  },
  controller: (n) => {
    const e = n.value, t = n.constraint;
    if (!(t instanceof Rc))
      throw xn.shouldNeverHappen();
    return new a3(n.document, {
      assembly: GN,
      axes: [
        i2(e.rawValue.x, t.components[0]),
        i2(e.rawValue.y, t.components[1]),
        i2(e.rawValue.z, t.components[2])
      ],
      parser: _l,
      value: e,
      viewProps: n.viewProps
    });
  }
};
class mf {
  constructor(e = 0, t = 0, i = 0, r = 0) {
    this.x = e, this.y = t, this.z = i, this.w = r;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(e) {
    if (Zi(e))
      return !1;
    const t = e.x, i = e.y, r = e.z, s = e.w;
    return !(typeof t != "number" || typeof i != "number" || typeof r != "number" || typeof s != "number");
  }
  static equals(e, t) {
    return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
}
const WN = {
  toComponents: (n) => n.getComponents(),
  fromComponents: (n) => new mf(...n)
};
function Nle(n) {
  return mf.isObject(n) ? new mf(n.x, n.y, n.z, n.w) : new mf();
}
function zle(n, e) {
  n.writeProperty("x", e.x), n.writeProperty("y", e.y), n.writeProperty("z", e.z), n.writeProperty("w", e.w);
}
function Fle(n, e) {
  return new Rc({
    assembly: WN,
    components: [
      hl(
        "x" in n ? n.x : void 0,
        e.x
      ),
      hl(
        "y" in n ? n.y : void 0,
        e.y
      ),
      hl(
        "z" in n ? n.z : void 0,
        e.z
      ),
      hl(
        "w" in n ? n.w : void 0,
        e.w
      )
    ]
  });
}
function Ble(n, e) {
  return {
    baseStep: If(e),
    constraint: e,
    textProps: Qt.fromObject({
      draggingScale: Of(e, n),
      formatter: Er(
        yx(e, n)
      )
    })
  };
}
const Ule = {
  id: "input-point4d",
  type: "input",
  accept: (n, e) => {
    if (!mf.isObject(n))
      return null;
    const t = si, i = Tr(e, {
      x: t.optional.custom(hc),
      y: t.optional.custom(hc),
      z: t.optional.custom(hc),
      w: t.optional.custom(hc)
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    reader: (n) => Nle,
    constraint: (n) => Fle(n.params, n.initialValue),
    equals: mf.equals,
    writer: (n) => zle
  },
  controller: (n) => {
    const e = n.value, t = n.constraint;
    if (!(t instanceof Rc))
      throw xn.shouldNeverHappen();
    return new a3(n.document, {
      assembly: WN,
      axes: e.rawValue.getComponents().map((i, r) => Ble(i, t.components[r])),
      parser: _l,
      value: e,
      viewProps: n.viewProps
    });
  }
};
function Vle(n) {
  const e = [], t = t3(n.options);
  return t && e.push(t), new sg(e);
}
const Hle = {
  id: "input-string",
  type: "input",
  accept: (n, e) => {
    if (typeof n != "string")
      return null;
    const i = Tr(e, {
      options: si.optional.custom(bx)
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    reader: (n) => gN,
    constraint: (n) => Vle(n.params),
    writer: (n) => cg
  },
  controller: (n) => {
    var e;
    const t = n.document, i = n.value, r = n.constraint;
    return r && va(r, og) ? new bv(t, {
      props: Qt.fromObject({
        options: (e = n3(r)) !== null && e !== void 0 ? e : []
      }),
      value: i,
      viewProps: n.viewProps
    }) : new ry(t, {
      parser: (s) => s,
      props: Qt.fromObject({
        formatter: BM
      }),
      value: i,
      viewProps: n.viewProps
    });
  }
}, ug = {
  monitor: {
    defaultInterval: 200,
    defaultLineCount: 3
  }
}, $k = _n("mll");
class Gle {
  constructor(e, t) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add($k()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("textarea");
    i.classList.add($k("i")), i.style.height = `calc(var(--bld-us) * ${t.lineCount})`, i.readOnly = !0, t.viewProps.bindDisabled(i), this.element.appendChild(i), this.textareaElem_ = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  update_() {
    const e = this.textareaElem_, t = e.scrollTop === e.scrollHeight - e.clientHeight, i = [];
    this.value.rawValue.forEach((r) => {
      r !== void 0 && i.push(this.formatter_(r));
    }), e.textContent = i.join(`
`), t && (e.scrollTop = e.scrollHeight);
  }
  onValueUpdate_() {
    this.update_();
  }
}
class l3 {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new Gle(e, {
      formatter: t.formatter,
      lineCount: t.lineCount,
      value: this.value,
      viewProps: this.viewProps
    });
  }
}
const Zk = _n("sgl");
class Wle {
  constructor(e, t) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(Zk()), t.viewProps.bindClassModifiers(this.element);
    const i = e.createElement("input");
    i.classList.add(Zk("i")), i.readOnly = !0, i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  update_() {
    const e = this.value.rawValue, t = e[e.length - 1];
    this.inputElement.value = t !== void 0 ? this.formatter_(t) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
}
class c3 {
  constructor(e, t) {
    this.value = t.value, this.viewProps = t.viewProps, this.view = new Wle(e, {
      formatter: t.formatter,
      value: this.value,
      viewProps: this.viewProps
    });
  }
}
const jle = {
  id: "monitor-bool",
  type: "monitor",
  accept: (n, e) => {
    if (typeof n != "boolean")
      return null;
    const i = Tr(e, {
      lineCount: si.optional.number
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    reader: (n) => dN
  },
  controller: (n) => {
    var e;
    return n.value.rawValue.length === 1 ? new c3(n.document, {
      formatter: Ik,
      value: n.value,
      viewProps: n.viewProps
    }) : new l3(n.document, {
      formatter: Ik,
      lineCount: (e = n.params.lineCount) !== null && e !== void 0 ? e : ug.monitor.defaultLineCount,
      value: n.value,
      viewProps: n.viewProps
    });
  }
}, sc = _n("grl");
class qle {
  constructor(e, t) {
    this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(sc()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.props_ = t.props, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
    const i = e.createElementNS(ca, "svg");
    i.classList.add(sc("g")), i.style.height = `calc(var(--bld-us) * ${t.lineCount})`, this.element.appendChild(i), this.svgElem_ = i;
    const r = e.createElementNS(ca, "polyline");
    this.svgElem_.appendChild(r), this.lineElem_ = r;
    const s = e.createElement("div");
    s.classList.add(sc("t"), _n("tt")()), this.element.appendChild(s), this.tooltipElem_ = s, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const e = this.svgElem_.getBoundingClientRect(), t = this.value.rawValue.length - 1, i = this.props_.get("minValue"), r = this.props_.get("maxValue"), s = [];
    this.value.rawValue.forEach((d, p) => {
      if (d === void 0)
        return;
      const m = ri(p, 0, t, 0, e.width), v = ri(d, i, r, e.height, 0);
      s.push([m, v].join(","));
    }), this.lineElem_.setAttributeNS(null, "points", s.join(" "));
    const o = this.tooltipElem_, a = this.value.rawValue[this.cursor_.rawValue];
    if (a === void 0) {
      o.classList.remove(sc("t", "a"));
      return;
    }
    const l = ri(this.cursor_.rawValue, 0, t, 0, e.width), c = ri(a, i, r, e.height, 0);
    o.style.left = `${l}px`, o.style.top = `${c}px`, o.textContent = `${this.formatter_(a)}`, o.classList.contains(sc("t", "a")) || (o.classList.add(sc("t", "a"), sc("t", "in")), ny(o), o.classList.remove(sc("t", "in")));
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
}
class Xle {
  constructor(e, t) {
    if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = t.props, this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = Fr(-1), this.view = new qle(e, {
      cursor: this.cursor_,
      formatter: t.formatter,
      lineCount: t.lineCount,
      props: this.props_,
      value: this.value,
      viewProps: this.viewProps
    }), !$C(e))
      this.view.element.addEventListener(
        "mousemove",
        this.onGraphMouseMove_
      ), this.view.element.addEventListener(
        "mouseleave",
        this.onGraphMouseLeave_
      );
    else {
      const i = new _h(this.view.element);
      i.emitter.on("down", this.onGraphPointerDown_), i.emitter.on("move", this.onGraphPointerMove_), i.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(e) {
    const t = this.view.element.getBoundingClientRect();
    this.cursor_.rawValue = Math.floor(
      ri(e.offsetX, 0, t.width, 0, this.value.rawValue.length)
    );
  }
  onGraphPointerDown_(e) {
    this.onGraphPointerMove_(e);
  }
  onGraphPointerMove_(e) {
    if (!e.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(
      ri(
        e.data.point.x,
        0,
        e.data.bounds.width,
        0,
        this.value.rawValue.length
      )
    );
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
}
function HM(n) {
  return "format" in n && !Zi(n.format) ? n.format : Er(2);
}
function $le(n) {
  var e;
  return n.value.rawValue.length === 1 ? new c3(n.document, {
    formatter: HM(n.params),
    value: n.value,
    viewProps: n.viewProps
  }) : new l3(n.document, {
    formatter: HM(n.params),
    lineCount: (e = n.params.lineCount) !== null && e !== void 0 ? e : ug.monitor.defaultLineCount,
    value: n.value,
    viewProps: n.viewProps
  });
}
function Zle(n) {
  var e, t, i;
  return new Xle(n.document, {
    formatter: HM(n.params),
    lineCount: (e = n.params.lineCount) !== null && e !== void 0 ? e : ug.monitor.defaultLineCount,
    props: Qt.fromObject({
      maxValue: (t = "max" in n.params ? n.params.max : null) !== null && t !== void 0 ? t : 100,
      minValue: (i = "min" in n.params ? n.params.min : null) !== null && i !== void 0 ? i : 0
    }),
    value: n.value,
    viewProps: n.viewProps
  });
}
function Yk(n) {
  return "view" in n && n.view === "graph";
}
const Yle = {
  id: "monitor-number",
  type: "monitor",
  accept: (n, e) => {
    if (typeof n != "number")
      return null;
    const t = si, i = Tr(e, {
      format: t.optional.function,
      lineCount: t.optional.number,
      max: t.optional.number,
      min: t.optional.number,
      view: t.optional.string
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    defaultBufferSize: (n) => Yk(n) ? 64 : 1,
    reader: (n) => vN
  },
  controller: (n) => Yk(n.params) ? Zle(n) : $le(n)
}, Kle = {
  id: "monitor-string",
  type: "monitor",
  accept: (n, e) => {
    if (typeof n != "string")
      return null;
    const t = si, i = Tr(e, {
      lineCount: t.optional.number,
      multiline: t.optional.boolean
    });
    return i ? {
      initialValue: n,
      params: i
    } : null;
  },
  binding: {
    reader: (n) => gN
  },
  controller: (n) => {
    var e;
    const t = n.value;
    return t.rawValue.length > 1 || "multiline" in n.params && n.params.multiline ? new l3(n.document, {
      formatter: BM,
      lineCount: (e = n.params.lineCount) !== null && e !== void 0 ? e : ug.monitor.defaultLineCount,
      value: t,
      viewProps: n.viewProps
    }) : new c3(n.document, {
      formatter: BM,
      value: t,
      viewProps: n.viewProps
    });
  }
};
class Jle {
  constructor(e) {
    this.onValueChange_ = this.onValueChange_.bind(this), this.reader = e.reader, this.writer = e.writer, this.emitter = new Oi(), this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.target = e.target, this.read();
  }
  read() {
    const e = this.target.read();
    e !== void 0 && (this.value.rawValue = this.reader(e));
  }
  write_(e) {
    this.writer(this.target, e);
  }
  onValueChange_(e) {
    this.write_(e.rawValue), this.emitter.emit("change", {
      options: e.options,
      rawValue: e.rawValue,
      sender: this
    });
  }
}
function Qle(n, e) {
  const t = n.accept(e.target.read(), e.params);
  if (Zi(t))
    return null;
  const i = si, r = {
    target: e.target,
    initialValue: t.initialValue,
    params: t.params
  }, s = n.binding.reader(r), o = n.binding.constraint ? n.binding.constraint(r) : void 0, a = Fr(s(t.initialValue), {
    constraint: o,
    equals: n.binding.equals
  }), l = new Jle({
    reader: s,
    target: e.target,
    value: a,
    writer: n.binding.writer(r)
  }), c = i.optional.boolean(e.params.disabled).value, d = i.optional.boolean(e.params.hidden).value, p = n.controller({
    constraint: o,
    document: e.document,
    initialValue: t.initialValue,
    params: t.params,
    value: l.value,
    viewProps: Ac.create({
      disabled: c,
      hidden: d
    })
  }), m = i.optional.string(e.params.label).value;
  return new da(e.document, {
    binding: l,
    blade: ng(),
    props: Qt.fromObject({
      label: m != null ? m : e.target.key
    }),
    valueController: p
  });
}
class ece {
  constructor(e) {
    this.onTick_ = this.onTick_.bind(this), this.reader_ = e.reader, this.target = e.target, this.emitter = new Oi(), this.value = e.value, this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
  }
  dispose() {
    this.ticker.dispose();
  }
  read() {
    const e = this.target.read();
    if (e === void 0)
      return;
    const t = this.value.rawValue, i = this.reader_(e);
    this.value.rawValue = eae(t, i), this.emitter.emit("update", {
      rawValue: i,
      sender: this
    });
  }
  onTick_(e) {
    this.read();
  }
}
function tce(n, e) {
  return e === 0 ? new _oe() : new boe(
    n,
    e != null ? e : ug.monitor.defaultInterval
  );
}
function nce(n, e) {
  var t, i, r;
  const s = si, o = n.accept(e.target.read(), e.params);
  if (Zi(o))
    return null;
  const a = {
    target: e.target,
    initialValue: o.initialValue,
    params: o.params
  }, l = n.binding.reader(a), c = (i = (t = s.optional.number(e.params.bufferSize).value) !== null && t !== void 0 ? t : n.binding.defaultBufferSize && n.binding.defaultBufferSize(o.params)) !== null && i !== void 0 ? i : 1, d = s.optional.number(e.params.interval).value, p = new ece({
    reader: l,
    target: e.target,
    ticker: tce(e.document, d),
    value: Joe(c)
  }), m = s.optional.boolean(e.params.disabled).value, v = s.optional.boolean(e.params.hidden).value, b = n.controller({
    document: e.document,
    params: o.params,
    value: p.value,
    viewProps: Ac.create({
      disabled: m,
      hidden: v
    })
  }), x = (r = s.optional.string(e.params.label).value) !== null && r !== void 0 ? r : e.target.key;
  return new xc(e.document, {
    binding: p,
    blade: ng(),
    props: Qt.fromObject({
      label: x
    }),
    valueController: b
  });
}
class ice {
  constructor() {
    this.pluginsMap_ = {
      blades: [],
      inputs: [],
      monitors: []
    };
  }
  getAll() {
    return [
      ...this.pluginsMap_.blades,
      ...this.pluginsMap_.inputs,
      ...this.pluginsMap_.monitors
    ];
  }
  register(e) {
    e.type === "blade" ? this.pluginsMap_.blades.unshift(e) : e.type === "input" ? this.pluginsMap_.inputs.unshift(e) : e.type === "monitor" && this.pluginsMap_.monitors.unshift(e);
  }
  createInput(e, t, i) {
    const r = t.read();
    if (Zi(r))
      throw new xn({
        context: {
          key: t.key
        },
        type: "nomatchingcontroller"
      });
    const s = this.pluginsMap_.inputs.reduce(
      (o, a) => o != null ? o : Qle(a, {
        document: e,
        target: t,
        params: i
      }),
      null
    );
    if (s)
      return s;
    throw new xn({
      context: {
        key: t.key
      },
      type: "nomatchingcontroller"
    });
  }
  createMonitor(e, t, i) {
    const r = this.pluginsMap_.monitors.reduce(
      (s, o) => s != null ? s : nce(o, {
        document: e,
        params: i,
        target: t
      }),
      null
    );
    if (r)
      return r;
    throw new xn({
      context: {
        key: t.key
      },
      type: "nomatchingcontroller"
    });
  }
  createBlade(e, t) {
    const i = this.pluginsMap_.blades.reduce(
      (r, s) => r != null ? r : goe(s, {
        document: e,
        params: t
      }),
      null
    );
    if (!i)
      throw new xn({
        type: "nomatchingview",
        context: {
          params: t
        }
      });
    return i;
  }
  createBladeApi(e) {
    if (e instanceof da)
      return new sN(e);
    if (e instanceof xc)
      return new oN(e);
    if (e instanceof rg)
      return new gx(e, this);
    const t = this.pluginsMap_.blades.reduce(
      (i, r) => i != null ? i : r.api({
        controller: e,
        pool: this
      }),
      null
    );
    if (!t)
      throw xn.shouldNeverHappen();
    return t;
  }
}
function rce() {
  const n = new ice();
  return [
    kle,
    Ole,
    Ule,
    Hle,
    xle,
    mle,
    ple,
    ule,
    uae,
    jle,
    Kle,
    Yle,
    qse,
    ooe,
    coe,
    uN
  ].forEach((e) => {
    n.register(e);
  }), n;
}
class sce extends Sl {
  constructor(e) {
    super(e), this.emitter_ = new Oi(), this.controller_.valueController.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", {
        event: new Lf(this, t.rawValue)
      });
    });
  }
  get label() {
    return this.controller_.props.get("label");
  }
  set label(e) {
    this.controller_.props.set("label", e);
  }
  get options() {
    return this.controller_.valueController.props.get("options");
  }
  set options(e) {
    this.controller_.valueController.props.set("options", e);
  }
  get value() {
    return this.controller_.valueController.value.rawValue;
  }
  set value(e) {
    this.controller_.valueController.value.rawValue = e;
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (r) => {
      i(r.event);
    }), this;
  }
}
class oce extends Sl {
  constructor(e) {
    super(e), this.emitter_ = new Oi(), this.controller_.valueController.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", {
        event: new Lf(this, t.rawValue)
      });
    });
  }
  get label() {
    return this.controller_.props.get("label");
  }
  set label(e) {
    this.controller_.props.set("label", e);
  }
  get maxValue() {
    return this.controller_.valueController.sliderController.props.get(
      "maxValue"
    );
  }
  set maxValue(e) {
    this.controller_.valueController.sliderController.props.set(
      "maxValue",
      e
    );
  }
  get minValue() {
    return this.controller_.valueController.sliderController.props.get(
      "minValue"
    );
  }
  set minValue(e) {
    this.controller_.valueController.sliderController.props.set(
      "minValue",
      e
    );
  }
  get value() {
    return this.controller_.valueController.value.rawValue;
  }
  set value(e) {
    this.controller_.valueController.value.rawValue = e;
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (r) => {
      i(r.event);
    }), this;
  }
}
class ace extends Sl {
  constructor(e) {
    super(e), this.emitter_ = new Oi(), this.controller_.valueController.value.emitter.on("change", (t) => {
      this.emitter_.emit("change", {
        event: new Lf(this, t.rawValue)
      });
    });
  }
  get label() {
    return this.controller_.props.get("label");
  }
  set label(e) {
    this.controller_.props.set("label", e);
  }
  get formatter() {
    return this.controller_.valueController.props.get("formatter");
  }
  set formatter(e) {
    this.controller_.valueController.props.set("formatter", e);
  }
  get value() {
    return this.controller_.valueController.value.rawValue;
  }
  set value(e) {
    this.controller_.valueController.value.rawValue = e;
  }
  on(e, t) {
    const i = t.bind(this);
    return this.emitter_.on(e, (r) => {
      i(r.event);
    }), this;
  }
}
const lce = function() {
  return {
    id: "list",
    type: "blade",
    accept(n) {
      const e = si, t = Tr(n, {
        options: e.required.custom(bx),
        value: e.required.raw,
        view: e.required.constant("list"),
        label: e.optional.string
      });
      return t ? { params: t } : null;
    },
    controller(n) {
      const e = new bv(n.document, {
        props: Qt.fromObject({
          options: wN(n.params.options)
        }),
        value: Fr(n.params.value),
        viewProps: n.viewProps
      });
      return new Df(n.document, {
        blade: n.blade,
        props: Qt.fromObject({
          label: n.params.label
        }),
        valueController: e
      });
    },
    api(n) {
      return !(n.controller instanceof Df) || !(n.controller.valueController instanceof bv) ? null : new sce(n.controller);
    }
  };
}();
function cce(n) {
  return n.reduce((e, t) => Object.assign(e, {
    [t.presetKey]: t.read()
  }), {});
}
function uce(n, e) {
  n.forEach((t) => {
    const i = e[t.presetKey];
    i !== void 0 && t.write(i);
  });
}
class hce extends aN {
  constructor(e, t) {
    super(e, t);
  }
  get element() {
    return this.controller_.view.element;
  }
  importPreset(e) {
    const t = this.controller_.rackController.rack.find(da).map((i) => i.binding.target);
    uce(t, e), this.refresh();
  }
  exportPreset() {
    const e = this.controller_.rackController.rack.find(da).map((t) => t.binding.target);
    return cce(e);
  }
  refresh() {
    this.controller_.rackController.rack.find(da).forEach((e) => {
      e.binding.read();
    }), this.controller_.rackController.rack.find(xc).forEach((e) => {
      e.binding.read();
    });
  }
}
class dce extends FM {
  constructor(e, t) {
    super(e, {
      expanded: t.expanded,
      blade: t.blade,
      props: t.props,
      root: !0,
      viewProps: t.viewProps
    });
  }
}
const fce = {
  id: "slider",
  type: "blade",
  accept(n) {
    const e = si, t = Tr(n, {
      max: e.required.number,
      min: e.required.number,
      view: e.required.constant("slider"),
      format: e.optional.function,
      label: e.optional.string,
      value: e.optional.number
    });
    return t ? { params: t } : null;
  },
  controller(n) {
    var e, t;
    const i = (e = n.params.value) !== null && e !== void 0 ? e : 0, r = new UM(n.document, {
      baseStep: 1,
      parser: _l,
      sliderProps: Qt.fromObject({
        maxValue: n.params.max,
        minValue: n.params.min
      }),
      textProps: Qt.fromObject({
        draggingScale: Of(void 0, i),
        formatter: (t = n.params.format) !== null && t !== void 0 ? t : Yoe
      }),
      value: Fr(i),
      viewProps: n.viewProps
    });
    return new Df(n.document, {
      blade: n.blade,
      props: Qt.fromObject({
        label: n.params.label
      }),
      valueController: r
    });
  },
  api(n) {
    return !(n.controller instanceof Df) || !(n.controller.valueController instanceof UM) ? null : new oce(n.controller);
  }
}, pce = function() {
  return {
    id: "text",
    type: "blade",
    accept(n) {
      const e = si, t = Tr(n, {
        parse: e.required.function,
        value: e.required.raw,
        view: e.required.constant("text"),
        format: e.optional.function,
        label: e.optional.string
      });
      return t ? { params: t } : null;
    },
    controller(n) {
      var e;
      const t = new ry(n.document, {
        parser: n.params.parse,
        props: Qt.fromObject({
          formatter: (e = n.params.format) !== null && e !== void 0 ? e : (i) => String(i)
        }),
        value: Fr(n.params.value),
        viewProps: n.viewProps
      });
      return new Df(n.document, {
        blade: n.blade,
        props: Qt.fromObject({
          label: n.params.label
        }),
        valueController: t
      });
    },
    api(n) {
      return !(n.controller instanceof Df) || !(n.controller.valueController instanceof ry) ? null : new ace(n.controller);
    }
  };
}();
function mce(n) {
  const e = n.createElement("div");
  return e.classList.add(_n("dfw")()), n.body && n.body.appendChild(e), e;
}
function Kk(n, e, t) {
  if (n.querySelector(`style[data-tp-style=${e}]`))
    return;
  const i = n.createElement("style");
  i.dataset.tpStyle = e, i.textContent = t, n.head.appendChild(i);
}
class vce extends hce {
  constructor(e) {
    var t, i;
    const r = e != null ? e : {}, s = (t = r.document) !== null && t !== void 0 ? t : Vse(), o = rce(), a = new dce(s, {
      expanded: r.expanded,
      blade: ng(),
      props: Qt.fromObject({
        title: r.title
      }),
      viewProps: Ac.create()
    });
    super(a, o), this.pool_ = o, this.containerElem_ = (i = r.container) !== null && i !== void 0 ? i : mce(s), this.containerElem_.appendChild(this.element), this.doc_ = s, this.usesDefaultWrapper_ = !r.container, this.setUpDefaultPlugins_();
  }
  get document() {
    if (!this.doc_)
      throw xn.alreadyDisposed();
    return this.doc_;
  }
  dispose() {
    const e = this.containerElem_;
    if (!e)
      throw xn.alreadyDisposed();
    if (this.usesDefaultWrapper_) {
      const t = e.parentElement;
      t && t.removeChild(e);
    }
    this.containerElem_ = null, this.doc_ = null, super.dispose();
  }
  registerPlugin(e) {
    ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach((i) => {
      this.pool_.register(i), this.embedPluginStyle_(i);
    });
  }
  embedPluginStyle_(e) {
    e.css && Kk(this.document, `plugin-${e.id}`, e.css);
  }
  setUpDefaultPlugins_() {
    Kk(
      this.document,
      "default",
      '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);strokeWidth:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);strokeLinejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;strokeWidth:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'
    ), this.pool_.getAll().forEach((e) => {
      this.embedPluginStyle_(e);
    }), this.registerPlugin({
      plugins: [
        fce,
        lce,
        uN,
        pce
      ]
    });
  }
}
new xse("3.1.0");
const gce = oo(`
    <div>
        <svg t="1656447640895" class="icon" viewBox="0 0 1084 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1297" width="10" height="10"><path d="M788.804292 977.500541a503.543363 503.543363 0 0 0 162.507176-119.862595 509.687074 509.687074 0 0 0 103.780528-174.312738 515.047762 515.047762 0 0 0 28.550186-194.068985 514.385205 514.385205 0 0 0-45.53574-190.816432 508.663122 508.663122 0 0 0-118.657945-164.193685A501.676156 501.676156 0 0 0 554.921651 0.530046 503.904757 503.904757 0 0 0 203.585714 166.530704a509.807538 509.807538 0 0 0-94.564962 150.159522L0 290.187944l45.174345 154.014399 45.234577 154.0144 109.382147-116.610042L309.173215 365.056891l-103.057738-24.936238a411.387699 411.387699 0 0 1 69.990118-106.611453 405.846313 405.846313 0 0 1 576.906499-25.960191c166.181356 153.592772 177.625524 415.001647 25.659027 582.869512a406.087243 406.087243 0 0 1-577.026963 25.899958l-66.315938 73.302904a502.097784 502.097784 0 0 0 364.707543 133.836525 499.387323 499.387323 0 0 0 188.768529-45.957367z" p-id="1298" fill="#ffffff"></path></svg>
    </div>
`);
let jN = !1, r2 = !0;
const Jk = nE(
  () => {
    jN = r2, r2 = !r2;
  },
  0,
  "both"
), Qk = (n) => n === !0 || n === "true", eL = (n) => n === !1 || n === "false", tL = (n, e) => Hm(n) && Hm(e) ? n.x === e.x && n.y === e.y && n.z === e.z : Qk(n) && Qk(e) || eL(n) && eL(e) ? !0 : n === e, ar = async (n, e, t, i, r, s, o) => {
  o || await Promise.resolve();
  const a = Object.keys(s);
  if (!a.length)
    return {};
  const l = { ...s }, c = {};
  for (const b of a)
    s[b] = c[b] = Qy(r, b, !0);
  const d = e.addFolder({ title: t }), p = Eb.get(r), m = Object.fromEntries(
    Object.keys(s).map((b) => {
      const x = d.addInput(s, b, p == null ? void 0 : p[b]), y = gce.cloneNode(!0);
      x.element.prepend(y), y.style.opacity = "0.1";
      const S = No(() => {
        const C = tL(s[b], c[b]);
        y.style.opacity = C ? "0.1" : "0.5", y.style.cursor = C ? "auto" : "pointer";
      }, SA);
      return S(), y.onclick = () => {
        s[b] = JSON.parse(JSON.stringify(c[b])), x.refresh();
      }, x.on("change", ({ value: C }) => {
        S(), !jN && (!ey[0] && Jb("start"), i[b] = C, !ey[0] && Jb("stop"));
      }), [b, x];
    })
  );
  Object.assign(s, l), Jk(), e.refresh();
  const v = setInterval(() => {
    var x;
    let b = !1;
    for (const y of a)
      tL((x = i[y]) != null ? x : c[y], s[y]) || (s[y] = i[y], b = !0);
    b && (Jk(), e.refresh());
  }, SA);
  return n.then(() => clearInterval(v)), m;
}, qN = (n, e, t) => {
  const i = {};
  for (const [r, s] of Object.entries(n)) {
    if (s5.has(r))
      continue;
    let o = t[r];
    s === Function || Array.isArray(s) && s.includes(Function) || typeof o == "function" || (s === Object || typeof o == "object" && !Array.isArray(o)) && (!o || typeof o.x != "number" || typeof o.y != "number") || (o != null || (o = Qy(e, r, !0)), Array.isArray(o) && (o = JSON.stringify(o)), i[r] = o);
  }
  return i;
}, Nr = (n, e) => {
  let t = {};
  for (const s of e)
    s in n && (t[s] = n[s]);
  const i = new Set(e), r = {};
  for (const [s, o] of Object.entries(n))
    i.has(s) || (r[s] = o);
  return [t, r];
};
let To = 0;
const dc = [];
let Sv = [];
const XN = /* @__PURE__ */ new WeakMap();
ft(() => {
  if (!Fs())
    return;
  let n = 0;
  const e = Zn((i) => {
    i ? n = To : To = n, dc.length = To, Sv = [];
  }), t = G6((i) => {
    var r;
    Sv = [], XN.set(
      i,
      structuredClone((r = Zn()) == null ? void 0 : r.data)
    ), dc.length = To, dc.push(i), To = dc.length;
  });
  return () => {
    e.cancel(), t.cancel();
  };
}, [Fs]);
const _ce = () => {
  if (--To < 0) {
    To = 0;
    return;
  }
  const n = Zn();
  Sv.push(structuredClone(n == null ? void 0 : n.data));
  const e = dc[To];
  n && (n.data = XN.get(e));
  for (const [t, i] of e)
    for (const [r, s] of i)
      Bs(t, r, s);
}, nL = () => {
  if (++To > dc.length) {
    To = dc.length;
    return;
  }
  const n = Zn();
  n && Sv.length && (n.data = Sv.pop());
  for (const [e, t] of dc[To - 1])
    for (const [i, , r] of t)
      Bs(e, i, r);
}, bce = () => {
  qi(() => {
    const n = async (i) => {
      if ((i.key === "Shift" || i.key === "Meta" || i.key === "Control") && cS(!0), i.key === "Backspace" || i.key === "Delete") {
        i.preventDefault(), !eM() && X6();
        return;
      }
      const r = i.key.toLocaleLowerCase();
      if (r === "g") {
        Xr.gridHelper = !Xr.gridHelper;
        return;
      }
      if (r === "1") {
        Zu() || Vd(
          X_() === un ? void 0 : un
        ), D2(!1);
        return;
      }
      if (r === "2") {
        D2(!0), Vd(void 0);
        return;
      }
      if (r === "3") {
        Xr.uiLayer = !Xr.uiLayer;
        return;
      }
      const s = Nn();
      if (i.metaKey || i.ctrlKey) {
        if (r === "z" && (i.preventDefault(), i.shiftKey ? nL() : _ce()), r === "y" && (i.preventDefault(), nL()), r === "s")
          i.preventDefault(), zC();
        else if (r === "o")
          i.preventDefault(), NC();
        else if (s)
          if (r === "c") {
            if (i.preventDefault(), !hr().length) {
              const [a] = IC(
                await Jf(!1, s, !0)
              );
              s.parent && a && (s.parent.attach(a), dr(a));
            }
          } else
            i.key === "ArrowUp" && ml() && (i.preventDefault(), $O(s), DM("local"));
      } else
        r === "c" ? (Vd(un), Xr.uiLayer = !1, Cc(s) && DK(s)) : r === "escape" && s && dr(void 0);
    }, e = (i) => {
      (i.key === "Shift" || i.key === "Meta" || i.key === "Control") && cS(!1);
    };
    document.addEventListener("keydown", n), document.addEventListener("keyup", e);
    const t = Xy(() => cS(!1));
    return () => {
      document.removeEventListener("keydown", n), document.removeEventListener("keyup", e), t.cancel();
    };
  }, []);
}, yce = (n, e, t) => {
  const [i, r] = Nr(
    qN(Jy, Mo, t),
    ["gridHelper", "gridHelperSize", "stats"]
  );
  ar(n, e, "editor", t, Mo, i);
  const [s, o] = Nr(r, [
    "antiAlias",
    "pixelRatio",
    "fps",
    "logarithmicDepth",
    "uiLayer",
    "pbr"
  ]);
  ar(
    n,
    e,
    "renderer",
    t,
    Mo,
    s
  );
  const [a, l] = Nr(o, [
    "exposure",
    "defaultLight",
    "environment",
    "skybox",
    "texture",
    "color",
    "defaultShadow",
    "shadowResolution",
    "shadowDistance"
  ]);
  ar(
    n,
    e,
    "lighting & environment",
    t,
    Mo,
    a
  );
  const [c, d] = Nr(l, [
    "bloom",
    "bloomIntensity",
    "bloomThreshold",
    "bloomRadius",
    "ssr",
    "ssrIntensity",
    "ssao",
    "ssaoIntensity",
    "bokeh",
    "bokehScale",
    "vignette"
  ]);
  ar(
    n,
    e,
    "effects",
    t,
    Mo,
    c
  );
  const [p, m] = Nr(d, [
    "outlineColor",
    "outlineHiddenColor",
    "outlinePattern",
    "outlinePulse",
    "outlineStrength"
  ]);
  ar(
    n,
    e,
    "outline effect",
    t,
    Mo,
    p
  );
  const [v, b] = Nr(m, [
    "gravity",
    "repulsion",
    "centripetal"
  ]);
  ar(
    n,
    e,
    "physics",
    t,
    Mo,
    v
  ), Object.keys(b).length && ar(
    n,
    e,
    "settings",
    t,
    Mo,
    b
  );
}, xce = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "10",
  height: "10",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M546.942 511.819L874.4 185.689c9.617-9.577 9.648-25.135.07-34.75-9.577-9.618-25.137-9.648-34.75-.072l-327.6 326.27-327.598-326.269c-9.617-9.577-25.177-9.545-34.752.071-9.578 9.616-9.546 25.174.07 34.752l327.458 326.128L149.84 837.948c-9.616 9.577-9.647 25.135-.07 34.751a24.496 24.496 0 0017.411 7.232 24.5 24.5 0 0017.34-7.162l327.6-326.27 327.6 326.27a24.492 24.492 0 0017.34 7.162 24.503 24.503 0 0017.41-7.232c9.578-9.617 9.546-25.175-.07-34.751l-327.458-326.13z"
  })
}), Mv = ({
  onClose: n,
  children: e,
  selected: t,
  disabled: i,
  id: r = e
}) => {
  const {
    selectedSignal: s
  } = q6(r, t, i);
  return /* @__PURE__ */ vt("div", {
    className: "lingo3d-bg lingo3d-flexcenter",
    style: {
      opacity: i ? 0.1 : 1,
      pointerEvents: i ? "none" : "auto",
      marginLeft: 4,
      marginRight: 4,
      height: 20,
      paddingLeft: 12,
      background: s.value === r ? "rgba(255, 255, 255, 0.1)" : void 0
    },
    onClick: i ? void 0 : () => s.value = r,
    children: [/* @__PURE__ */ H("div", {
      style: {
        marginTop: -2,
        minWidth: 30,
        maxWidth: 100,
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden"
      },
      children: e
    }), /* @__PURE__ */ H("div", {
      style: {
        width: 4
      }
    }), /* @__PURE__ */ H(ps, {
      disabled: !n,
      onClick: () => n == null ? void 0 : n(s.value === r),
      children: /* @__PURE__ */ H(xce, {})
    })]
  });
}, wce = (n, e) => {
  const t = It(rv), i = It(rC), r = It(Zu);
  Sr(() => {
    if (!n || !e)
      return;
    const s = {
      get camera() {
        return i.indexOf(t);
      },
      set camera(d) {
        Vd(i[d]);
      },
      get split() {
        return r;
      },
      set split(d) {
        D2(d);
      }
    }, o = {};
    let a = 0;
    for (const d of i)
      o[kf(Ov(d))] = a++;
    const l = e.add(
      n.addInput(s, "camera", { options: o })
    ), c = e.add(
      n.addInput(s, "split")
    );
    return () => {
      l.dispose(), c.dispose();
    };
  }, [n, e, i, t, r]);
};
Object.assign(FO, {
  stride: {
    x: 0,
    y: 0
  }
});
const $N = () => {
  var p;
  wl(), bce();
  const n = Jv();
  Sr(() => {
    window.onbeforeunload = m;
    function m() {
      return "Are you sure you want to close the current page?";
    }
    Vd(un), RR(!0), wR(!0), Xr.gridHelper = !0;
    const v = Jie(() => Xr.gridHelper = !1);
    return () => {
      Vd(void 0), RR(!1), Xr.gridHelper = !1, wR(!1), v.cancel();
    };
  }, []);
  const [e, t] = ji(), [i, r] = ji(), o = It(Tf).at(-1), a = (p = o && jO.get(o)) != null ? p : Xr, l = It(Nn), c = It(hr), d = Vy(void 0);
  return wce(e, i), Sr(() => {
    var x;
    const m = n.current;
    if (!m)
      return;
    const v = new vce({
      container: m
    });
    t(v), r(v.addFolder({
      title: "camera"
    }));
    const b = new Xn();
    if (d.value === "World" || !l || l instanceof Ao)
      return yce(b, v, l instanceof Ao ? l : a), () => {
        r(void 0), b.cancel(), v.dispose();
      };
    if (!c.length) {
      const {
        schema: y,
        defaults: S,
        componentName: C
      } = Li(l, "constructor"), [M, T] = Nr(qN(y, S, l), Object.keys((x = Cb.get(S)) != null ? x : {})), [P, D] = Nr(T, ["name", "id", "physics", "gravity"]);
      P && ar(b, v, "general", l, S, P, !0);
      const [I, k] = Nr(D, ["x", "y", "z", "rotationX", "rotationY", "rotationZ", "scale", "scaleX", "scaleY", "scaleZ", "innerX", "innerY", "innerZ", "innerRotationX", "innerRotationY", "innerRotationZ", "width", "height", "depth"]);
      if (I) {
        const [te, ee] = Nr(I, ["innerX", "innerY", "innerZ", "innerRotationX", "innerRotationY", "innerRotationZ", "width", "height", "depth"]);
        ar(b, v, "transform", l, S, ee), te && ar(b, v, "inner transform", l, S, te);
      }
      const [O, B] = Nr(k, ["animation", "animationPaused", "animationRepeat"]);
      O && ar(b, v, "animation", l, S, O);
      const [Y, G] = Nr(B, ["visible", "innerVisible", "frustumCulled", "castShadow", "receiveShadow"]);
      Y && ar(b, v, "display", l, S, Y);
      const [K, A] = Nr(G, ["bloom", "outline"]);
      K && ar(b, v, "effects", l, S, K);
      const [J, xe] = Nr(A, ["metalnessFactor", "roughnessFactor", "opacityFactor", "envFactor", "reflection"]);
      J && ar(b, v, "adjust material", l, S, J);
      const [se, oe] = Nr(xe, ["opacity", "color", "texture", "textureRepeat", "textureFlipY", "textureRotation", "videoTexture", "wireframe"]);
      se && ar(b, v, "material", l, S, se);
      const [Q, ce] = Nr(oe, ["metalnessMap", "metalness", "roughnessMap", "roughness", "normalMap", "normalScale", "bumpMap", "bumpScale", "displacementMap", "displacementScale", "displacementBias", "aoMap", "aoMapIntensity", "lightMap", "lightMapIntensity", "emissive", "emissiveIntensity", "envMap", "envMapIntensity", "alphaMap"]);
      Q && ar(b, v, "pbr material", l, S, Q), Object.assign(ce, M), C === "dummy" ? (ce.stride = {
        x: Li(l, "strideRight"),
        y: -Li(l, "strideForward")
      }, ar(b, v, C, l, S, ce, !0).then((te) => te.stride.on("change", ({
        value: ee
      }) => {
        Object.assign(ce, {
          strideForward: -ee.y,
          strideRight: ee.x
        }), v.refresh();
      }))) : Object.keys(ce).length && ar(b, v, C, l, S, ce, !0);
    }
    return () => {
      r(void 0), b.cancel(), v.dispose();
    };
  }, [l, c, a, d.value]), /* @__PURE__ */ vt("div", {
    className: "lingo3d-ui lingo3d-bg lingo3d-editor",
    style: {
      width: 300,
      height: "100%",
      display: "flex",
      flexDirection: "column"
    },
    children: [/* @__PURE__ */ vt(Oc, {
      selectedSignal: d,
      children: [/* @__PURE__ */ H(Mv, {
        children: "World"
      }), l && /* @__PURE__ */ H(Mv, {
        selected: !0,
        onClose: () => dr(void 0),
        children: kf(l)
      }, l.uuid)]
    }), /* @__PURE__ */ H("div", {
      style: {
        flexGrow: 1,
        overflowY: "scroll",
        overflowX: "hidden",
        paddingLeft: 8,
        paddingRight: 8
      },
      ref: n
    })]
  });
}, ZN = ({
  color: n,
  size: e
}) => /* @__PURE__ */ vt("div", {
  className: "lingo3d-sk-cube-grid",
  style: {
    color: n,
    width: e,
    height: e
  },
  children: [/* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube1"
  }), /* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube2"
  }), /* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube3"
  }), /* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube4"
  }), /* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube5"
  }), /* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube6"
  }), /* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube7"
  }), /* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube8"
  }), /* @__PURE__ */ H("div", {
    className: "lingo3d-sk-cube lingo3d-sk-cube9"
  })]
}), Sce = ({
  iconName: n
}) => {
  const [e, t] = ji(!1), i = Di(() => `${QD}${n}.png`, [n]);
  return qi(() => {
    const r = new Image();
    r.src = i, r.onload = () => t(!0);
  }, []), /* @__PURE__ */ vt("div", {
    style: {
      width: 50,
      height: 50
    },
    children: [!e && /* @__PURE__ */ H("div", {
      className: "lingo3d-flexcenter",
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ H(ZN, {
        color: "rgba(255, 255, 255, 0.1)"
      })
    }), e && /* @__PURE__ */ H("div", {
      className: "lingo3d-fadein",
      style: {
        width: "100%",
        height: "100%",
        backgroundImage: `url(${i})`,
        backgroundSize: "contain",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat"
      }
    })]
  });
}, iL = Z6((n) => {
  const e = e6(n);
  return e instanceof Hu && queueMicrotask(() => {
    e.targetX = e.x, e.targetY = e.y - 100, e.targetZ = e.z;
  }), e;
}), rL = ({
  name: n,
  iconName: e = n
}) => /* @__PURE__ */ vt("div", {
  draggable: !0,
  onDragStart: (t) => {
    iL(n), jC(t);
  },
  onDragEnd: () => iL(void 0),
  style: {
    width: "50%",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    paddingTop: 20,
    paddingBottom: 20
  },
  children: [/* @__PURE__ */ H(Sce, {
    iconName: e
  }), /* @__PURE__ */ H("div", {
    style: {
      marginTop: 6,
      opacity: 0.75,
      overflow: "hidden",
      textOverflow: "ellipsis",
      maxWidth: "100%"
    },
    children: lr.exports.upperFirst(n)
  })]
}), sL = (n) => typeof n == "string" ? n.endsWith("Camera") ? "camera" : n.endsWith("Light") ? "light" : n : Object.values(n)[0], oL = (n) => typeof n == "string" ? n : Object.keys(n)[0], Mce = ({
  names: n
}) => {
  const e = [];
  let t = [], i = 0;
  for (const r of n)
    i === 0 && e.push(t = []), t.push(r), ++i === 2 && (i = 0);
  return /* @__PURE__ */ H(Ic, {
    children: e.map(([r, s], o) => /* @__PURE__ */ vt("div", {
      style: {
        display: "flex"
      },
      children: [/* @__PURE__ */ H(rL, {
        name: oL(r),
        iconName: sL(r)
      }), s && /* @__PURE__ */ H(rL, {
        name: oL(s),
        iconName: sL(s)
      })]
    }, o))
  });
}, aL = ({
  children: n,
  selected: e,
  disabled: t,
  half: i,
  id: r = n
}) => {
  const {
    selectedSignal: s
  } = q6(r, e, t);
  return /* @__PURE__ */ H("div", {
    className: "lingo3d-bg lingo3d-flexcenter",
    style: {
      width: i ? "50%" : void 0,
      opacity: t ? 0.1 : 1,
      height: 20,
      padding: i ? void 0 : 12,
      background: s.value === r ? "rgba(255, 255, 255, 0.1)" : void 0
    },
    onClick: t ? void 0 : () => s.value = r,
    children: /* @__PURE__ */ H("div", {
      style: {
        marginTop: -2
      },
      children: n
    })
  });
}, YN = () => {
  wl();
  const n = Jv();
  return /* @__PURE__ */ vt("div", {
    ref: n,
    className: "lingo3d-ui lingo3d-bg lingo3d-library",
    style: {
      width: 200,
      height: "100%",
      display: "flex",
      flexDirection: "column"
    },
    children: [/* @__PURE__ */ vt(Oc, {
      children: [/* @__PURE__ */ H(aL, {
        half: !0,
        children: "components"
      }), /* @__PURE__ */ H(aL, {
        half: !0,
        disabled: !0,
        children: "materials"
      })]
    }), /* @__PURE__ */ H("div", {
      style: {
        padding: 10,
        overflowY: "scroll",
        flexGrow: 1
      },
      children: /* @__PURE__ */ H(Mce, {
        names: [
          "model",
          "dummy",
          "svgMesh",
          "htmlMesh",
          {
            joystick: "htmlMesh"
          },
          {
            splashScreen: "htmlMesh"
          },
          {
            text: "htmlMesh"
          },
          "trigger",
          "spawnPoint",
          "audio",
          "group",
          "reflector",
          "water",
          {
            sprite: "plane"
          },
          "cube",
          "sphere",
          "cone",
          "cylinder",
          "octahedron",
          "tetrahedron",
          "torus",
          "plane",
          "circle",
          "areaLight",
          "ambientLight",
          "skyLight",
          "directionalLight",
          "pointLight",
          "spotLight",
          {
            environment: "light"
          },
          "camera",
          "thirdPersonCamera",
          "firstPersonCamera",
          "orbitCamera"
        ]
      })
    })]
  });
}, Dr = ({
  hotkey: n,
  description: e
}) => /* @__PURE__ */ vt("div", {
  style: {
    display: "flex",
    alignItems: "center",
    marginTop: 4,
    whiteSpace: "nowrap"
  },
  children: [/* @__PURE__ */ H("div", {
    style: {
      border: "1px solid white",
      borderRadius: "4px",
      padding: "2px 4px 2px 4px"
    },
    children: /* @__PURE__ */ H("div", {
      className: "lingo3d-flexcenter",
      style: {
        minWidth: 10
      },
      children: n
    })
  }), n && e && /* @__PURE__ */ H("div", {
    style: {
      padding: "0 1px 0 1px"
    },
    children: "\xA0-\xA0"
  }), /* @__PURE__ */ H("div", {
    style: {
      padding: "2px 0px 2px 0px"
    },
    children: e
  })]
}), Ece = ({
  children: n,
  mounted: e,
  delay: t = 1e3
}) => {
  const [i, r] = ji(e), [s, o] = ji(!0);
  return qi(() => {
    if (e) {
      r(!0);
      return;
    }
    const a = setTimeout(() => r(!1), t);
    return () => {
      clearTimeout(a);
    };
  }, [e, t]), qi(() => {
    if (!i) {
      o(!0);
      return;
    }
    const a = setTimeout(() => o(!1), 100);
    return () => {
      clearTimeout(a);
    };
  }, [i]), i ? n == null ? void 0 : n(s) : null;
}, lL = ({
  mounted: n,
  style: e,
  children: t,
  fadeIn: i
}) => /* @__PURE__ */ H(Ece, {
  mounted: n,
  children: (r) => /* @__PURE__ */ H("div", {
    className: "lingo3d-absfull lingo3d-flexcenter",
    style: {
      flexDirection: "column",
      transition: "opacity 1s",
      opacity: i && r ? 0 : n ? 1 : 0,
      ...e
    },
    children: /* @__PURE__ */ H("div", {
      className: "lingo3d-flexcenter",
      style: {
        gap: 10,
        background: "rgba(0, 0, 0, 0.5)",
        padding: 2
      },
      children: t
    })
  })
}), Cce = () => {
  wl();
  const n = It(nt), e = It(kE), t = It(RI);
  return jE(/* @__PURE__ */ vt("div", {
    className: "lingo3d-ui lingo3d-absfull",
    style: {
      pointerEvents: "none",
      padding: 10
    },
    children: [/* @__PURE__ */ vt(lL, {
      mounted: !!e,
      children: [/* @__PURE__ */ H(ZN, {
        size: 14
      }), "loading data from unpkg"]
    }), /* @__PURE__ */ H(lL, {
      mounted: t,
      style: {
        background: "rgba(18, 19, 22, 0.75)"
      },
      fadeIn: !0,
      children: "paused"
    }), n === un && /* @__PURE__ */ vt("div", {
      style: {
        opacity: 0.5
      },
      children: [/* @__PURE__ */ H(Dr, {
        hotkey: "\u21E7",
        description: "accelerate"
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "W",
        description: "move forward"
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "S",
        description: "move backwards"
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "A",
        description: "move left"
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "D",
        description: "move right"
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "\u2191",
        description: "move up"
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "\u2193",
        description: "move down"
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "C",
        description: "center selected"
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "\u232B",
        description: "delete selected"
      }), /* @__PURE__ */ vt("div", {
        style: {
          display: "flex",
          gap: 4
        },
        children: [/* @__PURE__ */ H(Dr, {
          hotkey: "\u2318"
        }), /* @__PURE__ */ H(Dr, {
          hotkey: "C",
          description: "copy selected"
        })]
      }), /* @__PURE__ */ vt("div", {
        style: {
          display: "flex",
          gap: 4
        },
        children: [/* @__PURE__ */ H(Dr, {
          hotkey: "\u2318"
        }), /* @__PURE__ */ H(Dr, {
          hotkey: "O",
          description: "open folder"
        })]
      }), /* @__PURE__ */ vt("div", {
        style: {
          display: "flex",
          gap: 4
        },
        children: [/* @__PURE__ */ H(Dr, {
          hotkey: "\u2318"
        }), /* @__PURE__ */ H(Dr, {
          hotkey: "S",
          description: "save scene"
        })]
      }), /* @__PURE__ */ H(Dr, {
        hotkey: "G",
        description: "toggle grid"
      })]
    })]
  }), wa);
};
var KN = { exports: {} };
(function(n, e) {
  (function(t, i) {
    n.exports = i();
  })(sl, function() {
    var t = function() {
      function i(v) {
        return o.appendChild(v.dom), v;
      }
      function r(v) {
        for (var b = 0; b < o.children.length; b++)
          o.children[b].style.display = b === v ? "block" : "none";
        s = v;
      }
      var s = 0, o = document.createElement("div");
      o.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", o.addEventListener("click", function(v) {
        v.preventDefault(), r(++s % o.children.length);
      }, !1);
      var a = (performance || Date).now(), l = a, c = 0, d = i(new t.Panel("FPS", "#0ff", "#002")), p = i(new t.Panel("MS", "#0f0", "#020"));
      if (self.performance && self.performance.memory)
        var m = i(new t.Panel("MB", "#f08", "#201"));
      return r(0), { REVISION: 16, dom: o, addPanel: i, showPanel: r, begin: function() {
        a = (performance || Date).now();
      }, end: function() {
        c++;
        var v = (performance || Date).now();
        if (p.update(v - a, 200), v > l + 1e3 && (d.update(1e3 * c / (v - l), 100), l = v, c = 0, m)) {
          var b = performance.memory;
          m.update(b.usedJSHeapSize / 1048576, b.jsHeapSizeLimit / 1048576);
        }
        return v;
      }, update: function() {
        a = this.end();
      }, domElement: o, setMode: r };
    };
    return t.Panel = function(i, r, s) {
      var o = 1 / 0, a = 0, l = Math.round, c = l(window.devicePixelRatio || 1), d = 80 * c, p = 48 * c, m = 3 * c, v = 2 * c, b = 3 * c, x = 15 * c, y = 74 * c, S = 30 * c, C = document.createElement("canvas");
      C.width = d, C.height = p, C.style.cssText = "width:80px;height:48px";
      var M = C.getContext("2d");
      return M.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", M.textBaseline = "top", M.fillStyle = s, M.fillRect(0, 0, d, p), M.fillStyle = r, M.fillText(i, m, v), M.fillRect(b, x, y, S), M.fillStyle = s, M.globalAlpha = 0.9, M.fillRect(b, x, y, S), { dom: C, update: function(T, P) {
        o = Math.min(o, T), a = Math.max(a, T), M.fillStyle = s, M.globalAlpha = 1, M.fillRect(0, 0, d, x), M.fillStyle = r, M.fillText(l(T) + " " + i + " (" + l(o) + "-" + l(a) + ")", m, v), M.drawImage(C, b + c, x, y - c, S, b, x, y - c, S), M.fillRect(b + y - c, x, c, S), M.fillStyle = s, M.globalAlpha = 0.9, M.fillRect(b + y - c, x, c, l((1 - T / P) * S));
      } };
    }, t;
  });
})(KN);
const Tce = KN.exports, Pce = ({
  mode: n = "fps"
}) => {
  const e = xa(null);
  return Sr(() => {
    const t = e.current;
    if (!t)
      return;
    const i = new Tce();
    i.showPanel(n === "fps" ? 0 : n === "time" ? 1 : 2), t.appendChild(i.dom), Object.assign(i.dom.style, {
      position: "absolute",
      right: "0px",
      left: "auto"
    });
    const r = Pn(() => i.begin()), s = Ec(() => i.end());
    return () => {
      r.cancel(), s.cancel();
    };
  }, []), jE(/* @__PURE__ */ H("div", {
    ref: e
  }), wa);
}, JN = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M891.161 512L141.169 962V62l749.992 450z"
  })
}), QN = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M209.417 62h150.008v900H209.417V62zM659.417 62h149.985v900H659.417V62z"
  })
}), Ace = () => {
  const n = It(ro);
  return /* @__PURE__ */ H("div", {
    style: {
      display: "flex",
      gap: 10
    },
    children: /* @__PURE__ */ vt("div", {
      style: {
        display: "flex"
      },
      children: [/* @__PURE__ */ H(ps, {
        fill: !0,
        disabled: n === "play",
        onClick: () => Co("play"),
        children: /* @__PURE__ */ H(JN, {})
      }), /* @__PURE__ */ H(ps, {
        fill: !0,
        disabled: n !== "play",
        onClick: () => Co("translate"),
        children: /* @__PURE__ */ H(QN, {})
      })]
    })
  });
}, Rce = () => {
  var t;
  wl();
  const n = It(pv), e = (t = n == null ? void 0 : n.name) != null ? t : "untitled";
  return /* @__PURE__ */ H("div", {
    className: "lingo3d-ui lingo3d-bg lingo3d-tabs",
    style: {
      width: "100%"
    },
    children: /* @__PURE__ */ vt(Oc, {
      children: [/* @__PURE__ */ H(Mv, {
        selected: !0,
        children: e
      }, e), /* @__PURE__ */ H("div", {
        style: {
          flexGrow: 1,
          minWidth: 4
        }
      }), /* @__PURE__ */ H(Ace, {})]
    })
  });
}, [ez, kce] = Be(
  void 0
), Lce = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "40",
  height: "40",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M888.495 313.883l-198.02-198.02c-7.992-7.992-20.957-7.992-28.95 0s-7.992 20.947 0 28.939L824.61 307.886H608.815v-265.2c0-11.307-9.159-20.466-20.466-20.466H180.254c-11.307 0-20.466 9.159-20.466 20.466v938.628c0 11.297 9.159 20.466 20.466 20.466h693.761c11.308 0 20.466-9.169 20.466-20.466V328.352a20.463 20.463 0 00-5.986-14.47zm-34.946 646.965H200.72V63.152h367.163v265.2c0 11.308 9.169 20.466 20.466 20.466h265.2v612.03z"
  })
}), cL = Z6((n, e) => {
  const t = LC(n.name), [i, r] = dy(n.name), s = () => gO(n, r == null ? void 0 : r.toLowerCase());
  if (t === "model") {
    const o = new gs();
    return o.src = s(), o;
  } else if (t === "image" && e && "texture" in e) {
    const o = i.toLowerCase();
    "roughness" in e ? o.includes("rough") ? e.roughnessMap = s() : o.includes("metal") ? e.metalnessMap = s() : o.includes("normal") ? e.normalMap = s() : o.includes("disp") ? e.displacementMap = s() : e.texture = s() : e.texture = s();
  }
}), Dce = ({
  file: n
}) => {
  const e = It(kce);
  return /* @__PURE__ */ vt("div", {
    style: {
      width: 70,
      height: 90,
      background: e === n ? "rgba(255, 255, 255, 0.1)" : void 0
    },
    draggable: !0,
    onDragStart: (t) => {
      cL(n), jC(t);
    },
    onDragEnd: () => cL(void 0),
    onMouseDown: (t) => (t.stopPropagation(), ez(n)),
    onDblClick: () => OC(n),
    children: [/* @__PURE__ */ H("div", {
      className: "lingo3d-flexcenter",
      style: {
        width: "100%",
        paddingTop: 10,
        paddingBottom: 4
      },
      children: /* @__PURE__ */ H(Lce, {})
    }), /* @__PURE__ */ H("div", {
      className: "lingo3d-flexcenter",
      style: {
        width: "100%",
        paddingLeft: 10,
        paddingRight: 10
      },
      children: /* @__PURE__ */ H("div", {
        style: {
          wordBreak: "break-word",
          overflow: "hidden",
          textOverflow: "ellipsis",
          display: "-webkit-box",
          lineClamp: 2,
          webkitLineClamp: 2,
          webkitBoxOrient: "vertical"
        },
        children: n.name
      })
    })]
  });
}, [tz, nz] = Be(""), Ice = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  style: {
    margin: 2,
    opacity: 0.25,
    flexShrink: 0
  },
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M880 298.4H521L403.7 186.2c-1.5-1.4-3.5-2.2-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32z"
  })
}), hb = /* @__PURE__ */ new WeakMap(), iz = ({
  fileStructure: n,
  firstFolderName: e,
  folderName: t,
  myPath: i
}) => {
  const r = Object.entries(n), s = It(nz), o = () => r.map(([a, l]) => l instanceof File ? null : /* @__PURE__ */ H(iz, {
    fileStructure: l,
    firstFolderName: e,
    folderName: a,
    myPath: e + hb.get(l)
  }, a));
  return i ? /* @__PURE__ */ H(Qv, {
    label: t,
    expanded: !0,
    selected: i === s,
    onClick: () => tz(i),
    IconComponent: Ice,
    children: o
  }) : /* @__PURE__ */ H(Ic, {
    children: o()
  });
}, Oce = () => {
  wl();
  const n = It(gM), e = It(nz), [t, i] = Di(() => {
    const s = {};
    let o = "";
    if (n) {
      for (const a of n)
        U_(s, a.webkitRelativePath.split("/"), a);
      o = Object.keys(s)[0], mb(s, (a, l, c) => {
        let d = "";
        hb.has(c) && (d = hb.get(c) + "/" + a), typeof l == "object" && hb.set(l, d);
      });
    }
    return tz(o), [s, o];
  }, [n]), r = Di(() => {
    const s = lr.exports.get(t, e.split("/"));
    return s && Object.values(s).filter((a) => a instanceof File && a.name[0] !== ".");
  }, [t, e]);
  return /* @__PURE__ */ vt("div", {
    className: "lingo3d-ui lingo3d-bg lingo3d-panels",
    style: {
      height: Pb - xf,
      width: "100%",
      display: "flex"
    },
    children: [/* @__PURE__ */ H("div", {
      style: {
        overflow: "scroll",
        width: 200
      },
      children: /* @__PURE__ */ H(iz, {
        fileStructure: t,
        firstFolderName: i
      })
    }), /* @__PURE__ */ H("div", {
      style: {
        flexGrow: 1
      },
      children: /* @__PURE__ */ H("div", {
        className: "lingo3d-absfull",
        style: {
          overflow: "scroll",
          display: "flex",
          flexWrap: "wrap"
        },
        onMouseDown: () => ez(void 0),
        children: r == null ? void 0 : r.map((s) => /* @__PURE__ */ H(Dce, {
          file: s
        }, s.name))
      })
    })]
  });
}, rz = () => {
  const n = xa(null), [e, t] = ji({
    width: 0,
    height: 0
  });
  return Sr(() => {
    const i = n.current;
    if (!i)
      return;
    const r = new ResizeObserver(
      () => t({ width: i.clientWidth, height: i.clientHeight })
    );
    return r.observe(i), () => {
      r.disconnect();
    };
  }, []), [n, e];
}, ay = hh(0), Nce = () => {
  const n = xa(null);
  return qi(() => {
    const e = n.current;
    if (!e)
      return;
    const [t, i] = Be(ay.value), r = ay.subscribe(t), s = ft(() => {
      const o = Do(), a = i();
      e.style.left = `${-a + o * ki}px`;
    }, [Do, i]);
    return () => {
      s.cancel(), r();
    };
  }, []), /* @__PURE__ */ H("div", {
    className: "lingo3d-absfull",
    style: {
      height: Pb,
      zIndex: 1,
      overflow: "hidden",
      pointerEvents: "none"
    },
    children: /* @__PURE__ */ H("div", {
      ref: n,
      style: {
        position: "absolute",
        top: 0,
        width: ki,
        height: xf,
        background: "white",
        opacity: 0.3
      },
      children: /* @__PURE__ */ H("div", {
        style: {
          width: 1,
          height: Pb,
          background: "white",
          position: "absolute",
          left: ki * 0.5
        }
      })
    })
  });
}, zce = ({
  data: n,
  itemNum: e = ((l) => (l = n == null ? void 0 : n.length) != null ? l : 0)(),
  itemWidth: t,
  containerWidth: i,
  containerHeight: r,
  RenderComponent: s,
  scrollSignal: o = hh(0),
  style: a
}) => {
  const c = xa(null);
  Sr(() => {
    const b = c.current;
    if (b)
      return o.subscribe((x) => b.scrollLeft = x);
  }, []);
  const d = e * t, p = Math.floor(o.value / t), m = Math.min(e - 1, Math.floor((o.value + i) / t)), v = [];
  for (let b = p; b <= m; ++b)
    v.push(/* @__PURE__ */ H(s, {
      index: b,
      style: {
        position: "absolute",
        left: b * t
      },
      data: n == null ? void 0 : n[b]
    }, b));
  return /* @__PURE__ */ H("div", {
    ref: c,
    style: {
      overflowX: "scroll",
      overflowY: "hidden",
      width: i,
      height: r + 4,
      ...a
    },
    onScroll: (b) => o.value = b.currentTarget.scrollLeft,
    children: /* @__PURE__ */ H("div", {
      style: {
        position: "relative",
        width: d
      },
      children: v
    })
  });
}, Fce = (n) => Math.round((n + Number.EPSILON) * 100) / 100, Bce = ({
  index: n,
  style: e
}) => {
  const t = Fce(n * 5 * tv), i = t * 100 % 5 === 0;
  return /* @__PURE__ */ H("div", {
    style: e,
    children: /* @__PURE__ */ vt("div", {
      style: {
        opacity: i ? 0.75 : 0.65,
        marginLeft: ki * 0.5
      },
      children: [/* @__PURE__ */ vt("div", {
        style: {
          display: "flex",
          fontSize: 10
        },
        children: [/* @__PURE__ */ H("div", {
          style: {
            width: 1,
            marginRight: 2,
            height: i ? 16 : 12,
            background: "white"
          }
        }), n * 5]
      }), i && /* @__PURE__ */ vt("div", {
        style: {
          fontSize: 9,
          opacity: 0.5
        },
        children: [t, "s"]
      })]
    })
  });
}, Uce = fh(Bce, () => !0), xx = (n, e, t = { style: !0 }) => {
  for (const [i, r] of Object.entries(n))
    if (!t[i] && r !== e[i])
      return !1;
  return !0;
}, sz = [1 / 0], oz = [0], az = [0], GM = {}, uL = () => {
  const n = Object.keys(GM);
  sz[0] = Number(n.at(-1)), oz[0] = Number(n[0]);
}, Vce = ({
  width: n
}) => {
  az[0] = Math.floor(n / 5) * 5;
  const e = Di(() => fh(({
    index: t,
    style: i
  }) => (qi(() => {
    const r = t * 5;
    return GM[r] = !0, uL(), () => {
      delete GM[r], uL();
    };
  }, []), /* @__PURE__ */ H(Uce, {
    index: t,
    style: i
  }, t)), xx), []);
  return /* @__PURE__ */ H(zce, {
    scrollSignal: ay,
    itemNum: t5 / 5 + 3,
    itemWidth: ki * 5,
    containerWidth: n,
    containerHeight: xf,
    style: {
      overflowX: "hidden"
    },
    RenderComponent: e
  });
}, Hce = () => {
  const [n, {
    width: e
  }] = rz(), t = It(Zn);
  return /* @__PURE__ */ H(Oc, {
    children: /* @__PURE__ */ vt("div", {
      ref: n,
      className: "lingo3d-absfull",
      style: {
        opacity: t ? 1 : 0.2
      },
      children: [/* @__PURE__ */ H(Vce, {
        width: e
      }), /* @__PURE__ */ H(Nce, {})]
    })
  });
}, [ll, Gce] = Be(void 0), lz = hh(0), Wce = () => /* @__PURE__ */ vt("svg", {
  className: "lingo3d-absfull",
  width: "100%",
  height: "100%",
  xmlns: "http://www.w3.org/2000/svg",
  children: [/* @__PURE__ */ H("defs", {
    children: /* @__PURE__ */ H("pattern", {
      id: "smallGrid",
      width: ki,
      height: Os,
      patternUnits: "userSpaceOnUse",
      children: /* @__PURE__ */ H("path", {
        d: `M ${ki} 0 L 0 0 0 ${Os}`,
        fill: "none",
        stroke: "rgba(255, 255, 255, 0.2)",
        strokeWidth: "0.5"
      })
    })
  }), /* @__PURE__ */ H("rect", {
    width: "100%",
    height: "100%",
    fill: "url(#smallGrid)"
  })]
}), jce = fh(Wce, () => !0), [qce, cz] = Be(!1), Xce = ({
  instance: n,
  frames: e
}) => {
  const t = It(Sf(n, "srcState").get), i = It(Sf(n, "durationState").get), r = Di(() => Object.keys(e), [e]), [s, o] = Di(() => {
    var b;
    const v = Number((b = r[0]) != null ? b : 0);
    return [v, r.length < 2 ? v + Math.ceil(i * pc) : Number(r.at(-1))];
  }, [r, i]), a = o * ki, l = xa(null), [c, d] = ji(), p = It(pa), m = It(Zn);
  return Sr(() => {
    !i || r.length >= 2 || !m || m.mergeData({
      [n.uuid]: {
        frames: {
          0: 0,
          [o]: 0
        }
      }
    });
  }, [i, r, m, o]), Sr(() => {
    if (!c || !m)
      return;
    if (!p) {
      const b = Do((C, M) => {
        C < s || (c.play((C - s) * tv), M.cancel());
      });
      let x = 1;
      m.await += x;
      const y = c.backend.getAudioContext(), S = setTimeout(() => {
        m.await -= x, x = 0;
      }, (y.baseLatency + y.outputLatency) * 1e3);
      return () => {
        clearTimeout(S), c.pause(), m.await -= x, b.cancel();
      };
    }
    const v = Do((b) => {
      c.setCurrentTime(Math.max(b - s, 0) * tv);
    });
    return () => {
      v.cancel();
    };
  }, [c, p, m]), Sr(() => {
    const v = l.current;
    if (!v || !t || !a)
      return;
    const b = new Xn();
    return import("./wavesurfer.29ba2d47.mjs").then((x) => x.w).then(({
      default: x
    }) => {
      if (b.done)
        return;
      const y = x.create({
        container: v,
        waveColor: "magenta",
        progressColor: "magenta",
        height: Os
      });
      b.then(() => y.destroy()), y.load(t), d(y), b.watch(cz((S) => y.setMute(S)));
    }), () => {
      b.cancel(), d(void 0);
    };
  }, [t, a]), /* @__PURE__ */ H("div", {
    ref: l,
    style: {
      width: a,
      left: s * ki
    }
  });
}, $ce = fh(Xce, xx), hL = ["#D50000", "#C51162", "#AA00FF", "#6200EA", "#304FFE", "#2962FF", "#0091EA", "#00B8D4", "#00BFA5", "#00C853", "#64DD17", "#AEEA00", "#FFD600", "#FFAB00", "#FF6D00", "#DD2C00"];
let s2 = 0;
const Zce = ({
  frameNum: n,
  frameNums: e,
  index: t
}) => {
  var r;
  const i = Di(() => (++s2 === hL.length && (s2 = 0), hL[s2]), []);
  return /* @__PURE__ */ vt("div", {
    className: "lingo3d-flexcenter",
    style: {
      width: Math.max(((r = e[t + 1]) != null ? r : n) - n, 1) * ki,
      height: Os,
      position: "absolute",
      left: n * ki,
      opacity: 0.5
    },
    children: [/* @__PURE__ */ H("div", {
      style: {
        width: "100%",
        height: 4,
        background: i
      }
    }), /* @__PURE__ */ H("div", {
      className: "lingo3d-flexcenter",
      style: {
        position: "absolute",
        width: ki,
        height: Os,
        left: 0,
        top: 0
      },
      onContextMenu: (s) => {
        s.preventDefault(), s.stopPropagation(), ll({
          x: s.clientX,
          y: s.clientY,
          keyframe: !0
        });
      },
      children: /* @__PURE__ */ H("div", {
        style: {
          width: 8,
          height: 8,
          border: "1px solid rgba(255, 255, 255, 1)",
          background: i,
          borderRadius: 8
        }
      })
    })]
  });
}, Yce = fh(Zce, xx), Kce = ({
  frames: n,
  uuid: e
}) => {
  const t = Di(() => Object.keys(n).map(Number), [n]), i = Di(() => no.get(e.split(" ")[0]), [e]);
  return i ? i instanceof vc ? /* @__PURE__ */ H($ce, {
    instance: i,
    frames: n
  }) : /* @__PURE__ */ H("div", {
    style: {
      height: Os
    },
    children: t.map((r, s) => /* @__PURE__ */ H(Yce, {
      frameNum: r,
      frameNums: t,
      index: s
    }, r))
  }) : null;
}, Jce = fh(Kce, xx), dL = hh(0), uz = () => {
  const n = xa(null);
  return qi(() => {
    const e = n.current;
    if (!e)
      return;
    const t = () => dL.value = e.scrollTop;
    e.addEventListener("scroll", t);
    const i = dL.subscribe(
      (r) => e.scrollTop = r
    );
    return () => {
      e.removeEventListener("scroll", t), i();
    };
  }, []), n;
}, Qce = () => {
  const n = uz(), e = It(Kre);
  return qi(() => {
    const t = n.current;
    if (!t)
      return;
    const i = () => {
      const o = Do() / 5, a = Math.ceil(o) * 5, l = Math.floor(o) * 5;
      a > sz[0] ? t.scrollLeft = l * ki : l < oz[0] && (t.scrollLeft = a * ki - az[0]);
    }, r = ft(() => {
      if (pa())
        return;
      const o = Do(i);
      return () => {
        o.cancel();
      };
    }, [pa]), s = SY(i);
    return () => {
      r.cancel(), s.cancel();
    };
  }, []), /* @__PURE__ */ H("div", {
    className: "lingo3d-absfull",
    style: {
      overflow: "scroll"
    },
    ref: n,
    onScroll: (t) => ay.value = t.currentTarget.scrollLeft,
    onMouseDown: (t) => {
      const i = n.current, [r] = Ju(), [s] = _v(), o = Zn();
      if (!i || !r || !o)
        return;
      const a = i.getBoundingClientRect(), l = t.clientX - a.x + i.scrollLeft, c = t.clientY - a.y + i.scrollTop, d = (v, b) => {
        const x = v * Os, y = x + Os;
        return x > c || y < c ? !1 : (Gd(b), Qu(no.get(b.split(" ")[0])), !0);
      };
      let p = 0;
      e:
        for (const [v, b] of Object.entries(r)) {
          if (d(p++, v))
            break;
          if (!!s.has(v)) {
            for (const x of Object.keys(b))
              if (d(p++, v + " " + x))
                break e;
          }
        }
      const m = Math.floor(l / ki);
      Xf(m), Wd({
        x: m * ki,
        y: Math.floor(c / Os) * Os
      });
    },
    onContextMenu: (t) => {
      t.preventDefault(), ll({
        x: t.clientX,
        y: t.clientY
      });
    },
    children: /* @__PURE__ */ vt("div", {
      style: {
        width: t5 * ki,
        height: lz.value
      },
      children: [/* @__PURE__ */ H(jce, {}), e.map(([t, i]) => /* @__PURE__ */ H(Jce, {
        uuid: t,
        frames: i
      }, t)), /* @__PURE__ */ H(xY, {})]
    })
  });
}, fL = ({
  children: n,
  disabled: e,
  onClick: t
}) => /* @__PURE__ */ H("div", {
  className: "lingo3d-bg lingo3d-flexcenter",
  style: {
    opacity: e ? 0.1 : 1,
    marginLeft: 4,
    marginRight: 14,
    height: 20,
    display: "flex",
    gap: 4,
    cursor: e ? void 0 : "pointer"
  },
  onClick: e ? void 0 : t,
  children: n
}), pL = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M509.728 92.854c-231.476 0-419.148 187.672-419.148 419.148 0 231.47 187.672 419.143 419.148 419.143 231.499 0 419.143-187.672 419.143-419.143 0-231.476-187.644-419.148-419.143-419.148zm236.12 445.342H535.922v209.926c0 14.278-11.736 25.846-26.194 25.846-14.474 0-26.198-11.568-26.198-25.846V538.196H273.603c-14.278 0-25.841-11.737-25.841-26.194 0-14.475 11.592-26.199 25.841-26.199H483.53V275.85c0-14.251 11.724-25.814 26.198-25.814 14.458 0 26.194 11.563 26.194 25.814v209.953h209.926c14.306 0 25.847 11.724 25.847 26.199 0 14.457-11.541 26.194-25.847 26.194zm0 0"
  })
}), eue = () => {
  const n = It(Zn);
  return /* @__PURE__ */ vt(Oc, {
    children: [/* @__PURE__ */ vt(fL, {
      onClick: (e) => ll({
        x: e.clientX,
        y: e.clientY,
        create: "timeline"
      }),
      children: [/* @__PURE__ */ H(pL, {}), "New timeline"]
    }), /* @__PURE__ */ vt(fL, {
      disabled: !n,
      onClick: (e) => ll({
        x: e.clientX,
        y: e.clientY,
        create: "audio"
      }),
      children: [/* @__PURE__ */ H(pL, {}), "Audio"]
    })]
  });
}, tue = () => {
  const n = It(Gce), [e, t] = ji(), i = It(Zn);
  return /* @__PURE__ */ vt(z6, {
    position: n,
    setPosition: ll,
    input: (n == null ? void 0 : n.create) && (n.create === "audio" ? "Audio name" : "Timeline name"),
    onInput: (r) => {
      if ((n == null ? void 0 : n.create) === "audio") {
        const o = Zn();
        if (!o)
          return;
        const a = new vc();
        a.name = r, LC(r) === "audio" && (a.src = r), o.mergeData({
          [a.uuid]: {}
        }), o.append(a), px(/* @__PURE__ */ new Set([o.outerObject3d])), dr(a);
        return;
      }
      const s = new bc();
      s.name = r, s.data = {}, Fy(s), dr(s);
    },
    children: [/* @__PURE__ */ H(al, {
      disabled: (n == null ? void 0 : n.keyframe) || !i,
      onClick: () => {
        Qb((r, s, o, a) => U_(r, [s, o, a], Li(no.get(s), o))), ll(void 0);
      },
      children: "Add keyframe"
    }), /* @__PURE__ */ H(al, {
      disabled: !(n != null && n.keyframe),
      onClick: () => {
        const r = {};
        Qb((s, o, a, l) => U_(r, [o, a, "0"], lr.exports.get(s, [o, a, l])), !0), t(r), ll(void 0);
      },
      children: "Copy keyframe"
    }), /* @__PURE__ */ H(al, {
      disabled: !e,
      onClick: e ? () => {
        var o;
        const r = {}, s = Do() + "";
        for (const [a, l] of Object.entries(e))
          for (const [c, d] of Object.entries(l))
            for (const p of Object.values(d))
              U_(r, [a, c, s], p);
        (o = Zn()) == null || o.mergeData(r), ll(void 0);
      } : void 0,
      children: "Paste keyframe"
    }), /* @__PURE__ */ H(al, {
      disabled: !(n != null && n.keyframe),
      onClick: () => {
        $re(), ll(void 0);
      },
      children: "Clear keyframe"
    })]
  });
}, nue = ({
  children: n,
  uuid: e
}) => {
  const t = It(Ef), [i, r] = ji(""), s = Di(() => no.get(e), [e]), o = t === e;
  return Sr(() => () => {
    pk(e);
  }, []), Sr(() => {
    if (!s)
      return;
    r(kf(s));
    const a = gI((l) => l === s && r(kf(s)));
    return () => {
      a.cancel();
    };
  }, [s]), /* @__PURE__ */ H(Qv, {
    height: Os,
    label: i,
    onExpand: () => Yre(e),
    onCollapse: () => pk(e),
    selected: o,
    onClick: () => {
      Gd(e), Qu(s);
    },
    children: n
  });
}, iue = ({
  property: n,
  uuid: e
}) => {
  const t = It(Ef), i = e + " " + n;
  return /* @__PURE__ */ H(Qv, {
    height: Os,
    label: n,
    selected: t === i,
    onClick: () => {
      Gd(i), Qu(no.get(e));
    }
  });
}, rue = () => {
  const [n] = It(Ju), e = uz(), [t, {
    height: i
  }] = rz();
  return lz.value = i, /* @__PURE__ */ H("div", {
    className: "lingo3d-absfull",
    style: {
      overflow: "scroll"
    },
    ref: e,
    children: /* @__PURE__ */ H("div", {
      ref: t,
      children: n && Object.entries(n).map(([r, s]) => /* @__PURE__ */ H(nue, {
        uuid: r,
        children: Object.keys(s).map((o) => /* @__PURE__ */ H(iue, {
          property: o,
          uuid: r
        }, r + " " + o))
      }, r))
    })
  });
}, sue = () => (wl(), /* @__PURE__ */ vt(Ic, {
  children: [/* @__PURE__ */ vt("div", {
    className: "lingo3d-ui lingo3d-bg lingo3d-panels",
    style: {
      height: "100%",
      width: "100%",
      display: "flex"
    },
    children: [/* @__PURE__ */ vt("div", {
      style: {
        width: 200,
        display: "flex",
        flexDirection: "column"
      },
      children: [/* @__PURE__ */ H(eue, {}), /* @__PURE__ */ H("div", {
        style: {
          flexGrow: 1
        },
        children: /* @__PURE__ */ H(rue, {})
      })]
    }), /* @__PURE__ */ vt("div", {
      style: {
        flexGrow: 1,
        display: "flex",
        flexDirection: "column"
      },
      children: [/* @__PURE__ */ H(Hce, {}), /* @__PURE__ */ H("div", {
        style: {
          flexGrow: 1
        },
        children: /* @__PURE__ */ H(Qce, {})
      })]
    })]
  }), /* @__PURE__ */ H(tue, {})]
})), oue = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M384 512l512 320V192L384 512zM128 128h128v704H128z"
  })
}), aue = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M128 832l512-320-512-320v640zm640-704h128v704H768z"
  })
}), lue = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M342.52 120.49v783.02L960 512 342.52 120.49zm-278.52 0v783.02h168.16V120.49H64z"
  })
}), cue = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "14",
  height: "14",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M681.48 120.49V903.5L64 512l617.48-391.51zm278.52 0V903.5H791.84V120.49H960z"
  })
}), uue = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16",
  viewBox: "0 0 1024 1024",
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M588.78 3.1c-8.53-5.687-19.905-2.843-28.437 2.844L219.096 244.817H51.316c-14.22 0-25.594 11.375-25.594 22.75V756.69c0 14.219 11.375 22.75 25.593 22.75h167.78l344.092 238.874c5.688 2.843 8.531 5.687 14.219 5.687 2.844 0 8.531 0 11.375-2.844 8.531-2.843 14.218-11.375 14.218-19.906V23.006c0-8.53-5.687-17.062-14.218-19.906zm307.124 224.655c-14.219-14.219-34.125-14.219-48.344 0s-14.218 36.969 0 54.031c48.344 54.03 79.625 130.812 79.625 218.967s-31.281 162.093-79.625 218.968c-14.218 14.218-14.218 36.968 0 54.03 14.219 14.22 34.125 14.22 48.344 0 62.562-68.249 102.374-164.936 102.374-272.998s-39.812-204.748-102.374-272.998zM787.842 335.817c-14.219-14.219-34.125-14.219-48.343 0s-14.22 36.968 0 54.03c25.593 25.594 42.656 65.407 42.656 108.063s-14.22 79.624-42.656 108.061c-14.22 14.22-14.22 36.969 0 54.031 14.218 14.219 34.124 14.219 48.343 0 39.812-42.656 62.562-99.53 62.562-162.092s-22.75-125.125-62.562-162.093z"
  })
}), hue = () => /* @__PURE__ */ H("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16",
  viewBox: "0 0 1024 1024",
  style: {
    opacity: 0.25
  },
  children: /* @__PURE__ */ H("path", {
    fill: "#fff",
    d: "M890.216 514.972l88.156 88.156c14.219 14.218 14.219 39.812 0 54.03s-39.812 14.22-54.03 0l-88.157-88.155-88.155 88.156c-14.219 14.218-39.812 14.218-54.031 0s-14.219-39.813 0-54.031l88.156-88.156-91-88.156c-14.219-14.218-14.219-39.812 0-54.03s39.812-14.22 54.031 0l88.156 88.155 88.155-88.156c14.22-14.218 39.813-14.218 54.031 0s14.219 39.813 0 54.031l-85.312 88.156zM577.406 3.1C568.875-2.587 557.5.257 548.969 5.944L207.72 244.817H39.94c-14.22 0-25.594 11.375-25.594 22.75V756.69c0 14.219 11.375 22.75 25.593 22.75h167.78l344.092 238.874c5.688 2.843 8.531 5.687 14.219 5.687 2.844 0 8.531 0 11.375-2.844 8.531-2.843 14.218-11.375 14.218-19.906V23.006c0-8.53-5.687-17.062-14.218-19.906z"
  })
}), due = () => {
  const n = It(Zn), e = It(pa), t = It(NM), i = It(cz);
  return /* @__PURE__ */ vt(Oc, {
    noPadding: !0,
    children: [e ? /* @__PURE__ */ H(ps, {
      outline: !0,
      disabled: !n,
      onClick: n ? () => {
        n.frame >= n.totalFrames && (n.frame = 0), Wd(), n.paused = !1;
      } : void 0,
      children: /* @__PURE__ */ H(JN, {})
    }) : /* @__PURE__ */ H(ps, {
      outline: !0,
      disabled: !n,
      onClick: n ? () => {
        Wd(), n.paused = !0;
      } : void 0,
      children: /* @__PURE__ */ H(QN, {})
    }), /* @__PURE__ */ H(ps, {
      outline: !0,
      disabled: !n,
      onClick: EY,
      children: /* @__PURE__ */ H(cue, {})
    }), /* @__PURE__ */ H(ps, {
      outline: !0,
      disabled: !n,
      onClick: MY,
      children: /* @__PURE__ */ H(lue, {})
    }), /* @__PURE__ */ H(ps, {
      outline: !0,
      disabled: !n,
      onClick: CY,
      children: /* @__PURE__ */ H(oue, {})
    }), /* @__PURE__ */ H(ps, {
      outline: !0,
      disabled: !n,
      onClick: TY,
      children: /* @__PURE__ */ H(aue, {})
    }), /* @__PURE__ */ H(ps, {
      outline: !0,
      disabled: !n,
      onClick: n ? () => {
        Jre(!t), Wd(), n.paused = !0;
      } : void 0,
      children: /* @__PURE__ */ H("div", {
        style: {
          width: 10,
          height: 10,
          borderRadius: 10,
          background: t ? "red" : "white"
        }
      })
    }), /* @__PURE__ */ H(ps, {
      outline: !0,
      disabled: !n,
      onClick: () => qce(!i),
      children: i ? /* @__PURE__ */ H(hue, {}) : /* @__PURE__ */ H(uue, {})
    })]
  });
}, fue = () => {
  wl();
  const n = It(Yie), e = It(Zn), t = Vy(void 0);
  return qi(() => {
    n && (t.value = "files");
  }, [n]), qi(() => {
    e && (t.value = "timeline");
  }, [e]), /* @__PURE__ */ vt("div", {
    className: "lingo3d-ui lingo3d-bg lingo3d-panels",
    style: {
      height: Pb,
      width: "100%",
      display: "flex",
      flexDirection: "column"
    },
    children: [/* @__PURE__ */ vt("div", {
      style: {
        display: "flex"
      },
      children: [/* @__PURE__ */ vt(Oc, {
        selectedSignal: t,
        style: {
          width: 200
        },
        children: [/* @__PURE__ */ H(Mv, {
          onClose: e ? () => Fy(void 0) : void 0,
          children: "timeline"
        }), /* @__PURE__ */ H(Mv, {
          disabled: !n,
          onClose: () => g6(!1),
          children: "files"
        })]
      }), /* @__PURE__ */ H("div", {
        style: {
          flexGrow: 1
        },
        children: t.value !== "files" && /* @__PURE__ */ H(due, {})
      })]
    }), /* @__PURE__ */ H("div", {
      style: {
        flexGrow: 1
      },
      children: t.value === "files" ? /* @__PURE__ */ H(Oce, {}) : /* @__PURE__ */ H(sue, {})
    })]
  });
}, pue = () => {
  const n = xa(null);
  qi(() => {
    const t = n.current;
    t && (Xr.autoMount = t);
  }, []);
  const e = It(sO);
  return /* @__PURE__ */ vt("div", {
    className: "lingo3d-ui lingo3d-lingoeditor lingo3d-absfull",
    onContextMenu: (t) => t.preventDefault(),
    children: [/* @__PURE__ */ H(O6, {}), /* @__PURE__ */ H(J6, {}), /* @__PURE__ */ H($N, {}), /* @__PURE__ */ H(YN, {}), /* @__PURE__ */ H(fue, {}), /* @__PURE__ */ H(Rce, {}), /* @__PURE__ */ H("div", {
      className: "lingo3d-world",
      ref: n,
      style: {
        height: "100%",
        flexGrow: 1,
        position: "relative"
      }
    }), e && /* @__PURE__ */ H(Pce, {}), /* @__PURE__ */ H(Cce, {})]
  });
}, hg = (n, e, t) => {
  const i = KM(
    () => t ? document.createElement("div") : null,
    []
  ), r = zr(i);
  return In(() => {
    const s = r.current;
    !s || Db(Yu(n, e, s), s);
  }, [e]), In(() => {
    const s = r.current;
    if (!!s)
      return () => {
        Db(void 0, s);
      };
  }, []), r;
}, Sde = () => {
  const n = hg(pue, {
    embedded: !0
  });
  return /* @__PURE__ */ H("div", {
    ref: n,
    style: {
      height: "100%"
    }
  });
}, Mde = () => {
  const n = hg($N);
  return /* @__PURE__ */ H("div", {
    ref: n,
    className: "lingo3d-ui",
    style: {
      height: "100%"
    }
  });
}, Ede = () => {
  const n = hg(J6);
  return /* @__PURE__ */ H("div", {
    ref: n,
    className: "lingo3d-ui",
    style: {
      height: "100%"
    }
  });
}, Cde = () => {
  const n = hg(O6);
  return /* @__PURE__ */ H("div", {
    ref: n,
    className: "lingo3d-ui",
    style: {
      height: "100%"
    }
  });
}, Tde = () => {
  const n = hg(YN);
  return /* @__PURE__ */ H("div", {
    ref: n,
    className: "lingo3d-ui",
    style: {
      height: "100%"
    }
  });
};
var WM = { exports: {} };
/*! Tweakpane 3.1.7 (c) 2016 cocopon, licensed under the MIT license. */
(function(n, e) {
  (function(t, i) {
    i(e);
  })(sl, function(t) {
    class i {
      constructor(h) {
        const [g, E] = h.split("-"), N = g.split(".");
        this.major = parseInt(N[0], 10), this.minor = parseInt(N[1], 10), this.patch = parseInt(N[2], 10), this.prerelease = E != null ? E : null;
      }
      toString() {
        const h = [this.major, this.minor, this.patch].join(".");
        return this.prerelease !== null ? [h, this.prerelease].join("-") : h;
      }
    }
    class r {
      constructor(h) {
        this.controller_ = h;
      }
      get element() {
        return this.controller_.view.element;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(h) {
        this.controller_.viewProps.set("disabled", h);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(h) {
        this.controller_.viewProps.set("hidden", h);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", !0);
      }
    }
    class s {
      constructor(h) {
        this.target = h;
      }
    }
    class o extends s {
      constructor(h, g, E, N) {
        super(h), this.value = g, this.presetKey = E, this.last = N != null ? N : !0;
      }
    }
    class a extends s {
      constructor(h, g, E) {
        super(h), this.value = g, this.presetKey = E;
      }
    }
    class l extends s {
      constructor(h, g) {
        super(h), this.expanded = g;
      }
    }
    class c extends s {
      constructor(h, g) {
        super(h), this.index = g;
      }
    }
    function d(_) {
      return _;
    }
    function p(_) {
      return _ == null;
    }
    function m(_, h) {
      if (_.length !== h.length)
        return !1;
      for (let g = 0; g < _.length; g++)
        if (_[g] !== h[g])
          return !1;
      return !0;
    }
    function v(_, h) {
      let g = _;
      do {
        const E = Object.getOwnPropertyDescriptor(g, h);
        if (E && (E.set !== void 0 || E.writable === !0))
          return !0;
        g = Object.getPrototypeOf(g);
      } while (g !== null);
      return !1;
    }
    const b = {
      alreadydisposed: () => "View has been already disposed",
      invalidparams: (_) => `Invalid parameters for '${_.name}'`,
      nomatchingcontroller: (_) => `No matching controller for '${_.key}'`,
      nomatchingview: (_) => `No matching view for '${JSON.stringify(_.params)}'`,
      notbindable: () => "Value is not bindable",
      propertynotfound: (_) => `Property '${_.name}' not found`,
      shouldneverhappen: () => "This error should never happen"
    };
    class x {
      static alreadyDisposed() {
        return new x({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new x({
          type: "notbindable"
        });
      }
      static propertyNotFound(h) {
        return new x({
          type: "propertynotfound",
          context: {
            name: h
          }
        });
      }
      static shouldNeverHappen() {
        return new x({ type: "shouldneverhappen" });
      }
      constructor(h) {
        var g;
        this.message = (g = b[h.type](h.context)) !== null && g !== void 0 ? g : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = h.type;
      }
    }
    class y {
      constructor(h, g, E) {
        this.obj_ = h, this.key_ = g, this.presetKey_ = E != null ? E : g;
      }
      static isBindable(h) {
        return !(h === null || typeof h != "object");
      }
      get key() {
        return this.key_;
      }
      get presetKey() {
        return this.presetKey_;
      }
      read() {
        return this.obj_[this.key_];
      }
      write(h) {
        this.obj_[this.key_] = h;
      }
      writeProperty(h, g) {
        const E = this.read();
        if (!y.isBindable(E))
          throw x.notBindable();
        if (!(h in E))
          throw x.propertyNotFound(h);
        E[h] = g;
      }
    }
    class S extends r {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(h) {
        this.controller_.props.set("label", h);
      }
      get title() {
        var h;
        return (h = this.controller_.valueController.props.get("title")) !== null && h !== void 0 ? h : "";
      }
      set title(h) {
        this.controller_.valueController.props.set("title", h);
      }
      on(h, g) {
        const E = g.bind(this);
        return this.controller_.valueController.emitter.on(h, () => {
          E(new s(this));
        }), this;
      }
    }
    class C {
      constructor() {
        this.observers_ = {};
      }
      on(h, g) {
        let E = this.observers_[h];
        return E || (E = this.observers_[h] = []), E.push({
          handler: g
        }), this;
      }
      off(h, g) {
        const E = this.observers_[h];
        return E && (this.observers_[h] = E.filter((N) => N.handler !== g)), this;
      }
      emit(h, g) {
        const E = this.observers_[h];
        !E || E.forEach((N) => {
          N.handler(g);
        });
      }
    }
    const M = "tp";
    function T(_) {
      return (g, E) => [
        M,
        "-",
        _,
        "v",
        g ? `_${g}` : "",
        E ? `-${E}` : ""
      ].join("");
    }
    function P(_, h) {
      return (g) => h(_(g));
    }
    function D(_) {
      return _.rawValue;
    }
    function I(_, h) {
      _.emitter.on("change", P(D, h)), h(_.rawValue);
    }
    function k(_, h, g) {
      I(_.value(h), g);
    }
    function O(_, h, g) {
      g ? _.classList.add(h) : _.classList.remove(h);
    }
    function B(_, h) {
      return (g) => {
        O(_, h, g);
      };
    }
    function Y(_, h) {
      I(_, (g) => {
        h.textContent = g != null ? g : "";
      });
    }
    const G = T("btn");
    class K {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(G()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("button");
        E.classList.add(G("b")), g.viewProps.bindDisabled(E), this.element.appendChild(E), this.buttonElement = E;
        const N = h.createElement("div");
        N.classList.add(G("t")), Y(g.props.value("title"), N), this.buttonElement.appendChild(N);
      }
    }
    class A {
      constructor(h, g) {
        this.emitter = new C(), this.onClick_ = this.onClick_.bind(this), this.props = g.props, this.viewProps = g.viewProps, this.view = new K(h, {
          props: this.props,
          viewProps: this.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class J {
      constructor(h, g) {
        var E;
        this.constraint_ = g == null ? void 0 : g.constraint, this.equals_ = (E = g == null ? void 0 : g.equals) !== null && E !== void 0 ? E : (N, ne) => N === ne, this.emitter = new C(), this.rawValue_ = h;
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(h) {
        this.setRawValue(h, {
          forceEmit: !1,
          last: !0
        });
      }
      setRawValue(h, g) {
        const E = g != null ? g : {
          forceEmit: !1,
          last: !0
        }, N = this.constraint_ ? this.constraint_.constrain(h) : h, ne = this.rawValue_;
        !!this.equals_(ne, N) && !E.forceEmit || (this.emitter.emit("beforechange", {
          sender: this
        }), this.rawValue_ = N, this.emitter.emit("change", {
          options: E,
          previousRawValue: ne,
          rawValue: N,
          sender: this
        }));
      }
    }
    class xe {
      constructor(h) {
        this.emitter = new C(), this.value_ = h;
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(h) {
        this.setRawValue(h, {
          forceEmit: !1,
          last: !0
        });
      }
      setRawValue(h, g) {
        const E = g != null ? g : {
          forceEmit: !1,
          last: !0
        }, N = this.value_;
        N === h && !E.forceEmit || (this.emitter.emit("beforechange", {
          sender: this
        }), this.value_ = h, this.emitter.emit("change", {
          options: E,
          previousRawValue: N,
          rawValue: this.value_,
          sender: this
        }));
      }
    }
    function se(_, h) {
      const g = h == null ? void 0 : h.constraint, E = h == null ? void 0 : h.equals;
      return !g && !E ? new xe(_) : new J(_, h);
    }
    class oe {
      constructor(h) {
        this.emitter = new C(), this.valMap_ = h;
        for (const g in this.valMap_)
          this.valMap_[g].emitter.on("change", () => {
            this.emitter.emit("change", {
              key: g,
              sender: this
            });
          });
      }
      static createCore(h) {
        return Object.keys(h).reduce((E, N) => Object.assign(E, {
          [N]: se(h[N])
        }), {});
      }
      static fromObject(h) {
        const g = this.createCore(h);
        return new oe(g);
      }
      get(h) {
        return this.valMap_[h].rawValue;
      }
      set(h, g) {
        this.valMap_[h].rawValue = g;
      }
      value(h) {
        return this.valMap_[h];
      }
    }
    function Q(_, h) {
      const E = Object.keys(h).reduce((N, ne) => {
        if (N === void 0)
          return;
        const be = h[ne], He = be(_[ne]);
        return He.succeeded ? Object.assign(Object.assign({}, N), { [ne]: He.value }) : void 0;
      }, {});
      return E;
    }
    function ce(_, h) {
      return _.reduce((g, E) => {
        if (g === void 0)
          return;
        const N = h(E);
        if (!(!N.succeeded || N.value === void 0))
          return [...g, N.value];
      }, []);
    }
    function te(_) {
      return _ === null ? !1 : typeof _ == "object";
    }
    function ee(_) {
      return (h) => (g) => {
        if (!h && g === void 0)
          return {
            succeeded: !1,
            value: void 0
          };
        if (h && g === void 0)
          return {
            succeeded: !0,
            value: void 0
          };
        const E = _(g);
        return E !== void 0 ? {
          succeeded: !0,
          value: E
        } : {
          succeeded: !1,
          value: void 0
        };
      };
    }
    function Re(_) {
      return {
        custom: (h) => ee(h)(_),
        boolean: ee((h) => typeof h == "boolean" ? h : void 0)(_),
        number: ee((h) => typeof h == "number" ? h : void 0)(_),
        string: ee((h) => typeof h == "string" ? h : void 0)(_),
        function: ee((h) => typeof h == "function" ? h : void 0)(_),
        constant: (h) => ee((g) => g === h ? h : void 0)(_),
        raw: ee((h) => h)(_),
        object: (h) => ee((g) => {
          if (!!te(g))
            return Q(g, h);
        })(_),
        array: (h) => ee((g) => {
          if (!!Array.isArray(g))
            return ce(g, h);
        })(_)
      };
    }
    const ye = {
      optional: Re(!0),
      required: Re(!1)
    };
    function Se(_, h) {
      const g = ye.required.object(h)(_);
      return g.succeeded ? g.value : void 0;
    }
    function Ee(_) {
      console.warn([
        `Missing '${_.key}' of ${_.target} in ${_.place}.`,
        "Please rebuild plugins with the latest core package."
      ].join(" "));
    }
    function gt(_) {
      return _ && _.parentElement && _.parentElement.removeChild(_), null;
    }
    class qe {
      constructor(h) {
        this.value_ = h;
      }
      static create(h) {
        return [
          new qe(h),
          (g, E) => {
            h.setRawValue(g, E);
          }
        ];
      }
      get emitter() {
        return this.value_.emitter;
      }
      get rawValue() {
        return this.value_.rawValue;
      }
    }
    const Ze = T("");
    function je(_, h) {
      return B(_, Ze(void 0, h));
    }
    class st extends oe {
      constructor(h) {
        var g;
        super(h), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = qe.create(se(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (g = this.get("parent")) === null || g === void 0 || g.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
      }
      static create(h) {
        var g, E, N;
        const ne = h != null ? h : {};
        return new st(oe.createCore({
          disabled: (g = ne.disabled) !== null && g !== void 0 ? g : !1,
          disposed: !1,
          hidden: (E = ne.hidden) !== null && E !== void 0 ? E : !1,
          parent: (N = ne.parent) !== null && N !== void 0 ? N : null
        }));
      }
      get globalDisabled() {
        return this.globalDisabled_;
      }
      bindClassModifiers(h) {
        I(this.globalDisabled_, je(h, "disabled")), k(this, "hidden", je(h, "hidden"));
      }
      bindDisabled(h) {
        I(this.globalDisabled_, (g) => {
          h.disabled = g;
        });
      }
      bindTabIndex(h) {
        I(this.globalDisabled_, (g) => {
          h.tabIndex = g ? -1 : 0;
        });
      }
      handleDispose(h) {
        this.value("disposed").emitter.on("change", (g) => {
          g && h();
        });
      }
      getGlobalDisabled_() {
        const h = this.get("parent");
        return (h ? h.globalDisabled.rawValue : !1) || this.get("disabled");
      }
      updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_());
      }
      onDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_();
      }
      onParentChange_(h) {
        var g;
        const E = h.previousRawValue;
        E == null || E.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (g = this.get("parent")) === null || g === void 0 || g.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_();
      }
    }
    function Ie() {
      return ["veryfirst", "first", "last", "verylast"];
    }
    const Le = T(""), L = {
      veryfirst: "vfst",
      first: "fst",
      last: "lst",
      verylast: "vlst"
    };
    class fe {
      constructor(h) {
        this.parent_ = null, this.blade = h.blade, this.view = h.view, this.viewProps = h.viewProps;
        const g = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          Ie().forEach((E) => {
            g.classList.remove(Le(void 0, L[E]));
          }), this.blade.get("positions").forEach((E) => {
            g.classList.add(Le(void 0, L[E]));
          });
        }), this.viewProps.handleDispose(() => {
          gt(g);
        });
      }
      get parent() {
        return this.parent_;
      }
      set parent(h) {
        if (this.parent_ = h, !("parent" in this.viewProps.valMap_)) {
          Ee({
            key: "parent",
            target: st.name,
            place: "BladeController.parent"
          });
          return;
        }
        this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
      }
    }
    const ae = "http://www.w3.org/2000/svg";
    function $(_) {
      _.offsetHeight;
    }
    function j(_, h) {
      const g = _.style.transition;
      _.style.transition = "none", h(), _.style.transition = g;
    }
    function re(_) {
      return _.ontouchstart !== void 0;
    }
    function Te() {
      return globalThis;
    }
    function Ce() {
      return Te().document;
    }
    function F(_) {
      const h = _.ownerDocument.defaultView;
      return h && "document" in h ? _.getContext("2d", {
        willReadFrequently: !0
      }) : null;
    }
    const U = {
      check: '<path d="M2 8l4 4l8 -8"/>',
      dropdown: '<path d="M5 7h6l-3 3 z"/>',
      p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
    };
    function he(_, h) {
      const g = _.createElementNS(ae, "svg");
      return g.innerHTML = U[h], g;
    }
    function me(_, h, g) {
      _.insertBefore(h, _.children[g]);
    }
    function Ae(_) {
      _.parentElement && _.parentElement.removeChild(_);
    }
    function Ve(_) {
      for (; _.children.length > 0; )
        _.removeChild(_.children[0]);
    }
    function $e(_) {
      for (; _.childNodes.length > 0; )
        _.removeChild(_.childNodes[0]);
    }
    function Me(_) {
      return _.relatedTarget ? _.relatedTarget : "explicitOriginalTarget" in _ ? _.explicitOriginalTarget : null;
    }
    const lt = T("lbl");
    function Ye(_, h) {
      const g = _.createDocumentFragment();
      return h.split(`
`).map((N) => _.createTextNode(N)).forEach((N, ne) => {
        ne > 0 && g.appendChild(_.createElement("br")), g.appendChild(N);
      }), g;
    }
    class ht {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(lt()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("div");
        E.classList.add(lt("l")), k(g.props, "label", (ne) => {
          p(ne) ? this.element.classList.add(lt(void 0, "nol")) : (this.element.classList.remove(lt(void 0, "nol")), $e(E), E.appendChild(Ye(h, ne)));
        }), this.element.appendChild(E), this.labelElement = E;
        const N = h.createElement("div");
        N.classList.add(lt("v")), this.element.appendChild(N), this.valueElement = N;
      }
    }
    class Xe extends fe {
      constructor(h, g) {
        const E = g.valueController.viewProps;
        super(Object.assign(Object.assign({}, g), { view: new ht(h, {
          props: g.props,
          viewProps: E
        }), viewProps: E })), this.props = g.props, this.valueController = g.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    const Mt = {
      id: "button",
      type: "blade",
      accept(_) {
        const h = ye, g = Se(_, {
          title: h.required.string,
          view: h.required.constant("button"),
          label: h.optional.string
        });
        return g ? { params: g } : null;
      },
      controller(_) {
        return new Xe(_.document, {
          blade: _.blade,
          props: oe.fromObject({
            label: _.params.label
          }),
          valueController: new A(_.document, {
            props: oe.fromObject({
              title: _.params.title
            }),
            viewProps: _.viewProps
          })
        });
      },
      api(_) {
        return !(_.controller instanceof Xe) || !(_.controller.valueController instanceof A) ? null : new S(_.controller);
      }
    };
    class At extends fe {
      constructor(h) {
        super(h), this.value = h.value;
      }
    }
    function Bt() {
      return new oe({
        positions: se([], {
          equals: m
        })
      });
    }
    class pe extends oe {
      constructor(h) {
        super(h);
      }
      static create(h) {
        const g = {
          completed: !0,
          expanded: h,
          expandedHeight: null,
          shouldFixHeight: !1,
          temporaryExpanded: null
        }, E = oe.createCore(g);
        return new pe(E);
      }
      get styleExpanded() {
        var h;
        return (h = this.get("temporaryExpanded")) !== null && h !== void 0 ? h : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded)
          return "0";
        const h = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !p(h) ? `${h}px` : "auto";
      }
      bindExpandedClass(h, g) {
        const E = () => {
          this.styleExpanded ? h.classList.add(g) : h.classList.remove(g);
        };
        k(this, "expanded", E), k(this, "temporaryExpanded", E);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0);
      }
    }
    function ot(_, h) {
      let g = 0;
      return j(h, () => {
        _.set("expandedHeight", null), _.set("temporaryExpanded", !0), $(h), g = h.clientHeight, _.set("temporaryExpanded", null), $(h);
      }), g;
    }
    function De(_, h) {
      h.style.height = _.styleHeight;
    }
    function tt(_, h) {
      _.value("expanded").emitter.on("beforechange", () => {
        if (_.set("completed", !1), p(_.get("expandedHeight"))) {
          const g = ot(_, h);
          g > 0 && _.set("expandedHeight", g);
        }
        _.set("shouldFixHeight", !0), $(h);
      }), _.emitter.on("change", () => {
        De(_, h);
      }), De(_, h), h.addEventListener("transitionend", (g) => {
        g.propertyName === "height" && _.cleanUpTransition();
      });
    }
    class Qe extends r {
      constructor(h, g) {
        super(h), this.rackApi_ = g;
      }
    }
    function Ft(_, h) {
      return _.addBlade(Object.assign(Object.assign({}, h), { view: "button" }));
    }
    function An(_, h) {
      return _.addBlade(Object.assign(Object.assign({}, h), { view: "folder" }));
    }
    function Hn(_, h) {
      const g = h != null ? h : {};
      return _.addBlade(Object.assign(Object.assign({}, g), { view: "separator" }));
    }
    function es(_, h) {
      return _.addBlade(Object.assign(Object.assign({}, h), { view: "tab" }));
    }
    class Sn {
      constructor(h) {
        this.emitter = new C(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = h;
      }
      get items() {
        return this.items_;
      }
      allItems() {
        return Array.from(this.cache_);
      }
      find(h) {
        for (const g of this.allItems())
          if (h(g))
            return g;
        return null;
      }
      includes(h) {
        return this.cache_.has(h);
      }
      add(h, g) {
        if (this.includes(h))
          throw x.shouldNeverHappen();
        const E = g !== void 0 ? g : this.items_.length;
        this.items_.splice(E, 0, h), this.cache_.add(h);
        const N = this.extract_(h);
        N && (N.emitter.on("add", this.onSubListAdd_), N.emitter.on("remove", this.onSubListRemove_), N.allItems().forEach((ne) => {
          this.cache_.add(ne);
        })), this.emitter.emit("add", {
          index: E,
          item: h,
          root: this,
          target: this
        });
      }
      remove(h) {
        const g = this.items_.indexOf(h);
        if (g < 0)
          return;
        this.items_.splice(g, 1), this.cache_.delete(h);
        const E = this.extract_(h);
        E && (E.emitter.off("add", this.onSubListAdd_), E.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
          index: g,
          item: h,
          root: this,
          target: this
        });
      }
      onSubListAdd_(h) {
        this.cache_.add(h.item), this.emitter.emit("add", {
          index: h.index,
          item: h.item,
          root: this,
          target: h.target
        });
      }
      onSubListRemove_(h) {
        this.cache_.delete(h.item), this.emitter.emit("remove", {
          index: h.index,
          item: h.item,
          root: this,
          target: h.target
        });
      }
    }
    class Yi extends r {
      constructor(h) {
        super(h), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new C(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(h) {
        this.controller_.props.set("label", h);
      }
      on(h, g) {
        const E = g.bind(this);
        return this.emitter_.on(h, (N) => {
          E(N.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingChange_(h) {
        const g = h.sender.target.read();
        this.emitter_.emit("change", {
          event: new o(this, g, this.controller_.binding.target.presetKey, h.options.last)
        });
      }
    }
    class Gn extends Xe {
      constructor(h, g) {
        super(h, g), this.binding = g.binding;
      }
    }
    class Ma extends r {
      constructor(h) {
        super(h), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new C(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(h) {
        this.controller_.props.set("label", h);
      }
      on(h, g) {
        const E = g.bind(this);
        return this.emitter_.on(h, (N) => {
          E(N.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingUpdate_(h) {
        const g = h.sender.target.read();
        this.emitter_.emit("update", {
          event: new a(this, g, this.controller_.binding.target.presetKey)
        });
      }
    }
    class pr extends Xe {
      constructor(h, g) {
        super(h, g), this.binding = g.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
          this.binding.dispose();
        });
      }
    }
    function le(_) {
      return _ instanceof wt ? _.apiSet_ : _ instanceof Qe ? _.rackApi_.apiSet_ : null;
    }
    function We(_, h) {
      const g = _.find((E) => E.controller_ === h);
      if (!g)
        throw x.shouldNeverHappen();
      return g;
    }
    function et(_, h, g) {
      if (!y.isBindable(_))
        throw x.notBindable();
      return new y(_, h, g);
    }
    class wt extends r {
      constructor(h, g) {
        super(h), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new C(), this.apiSet_ = new Sn(le), this.pool_ = g;
        const E = this.controller_.rack;
        E.emitter.on("add", this.onRackAdd_), E.emitter.on("remove", this.onRackRemove_), E.emitter.on("inputchange", this.onRackInputChange_), E.emitter.on("monitorupdate", this.onRackMonitorUpdate_), E.children.forEach((N) => {
          this.setUpApi_(N);
        });
      }
      get children() {
        return this.controller_.rack.children.map((h) => We(this.apiSet_, h));
      }
      addInput(h, g, E) {
        const N = E != null ? E : {}, ne = this.controller_.view.element.ownerDocument, be = this.pool_.createInput(ne, et(h, g, N.presetKey), N), He = new Yi(be);
        return this.add(He, N.index);
      }
      addMonitor(h, g, E) {
        const N = E != null ? E : {}, ne = this.controller_.view.element.ownerDocument, be = this.pool_.createMonitor(ne, et(h, g), N), He = new Ma(be);
        return this.add(He, N.index);
      }
      addFolder(h) {
        return An(this, h);
      }
      addButton(h) {
        return Ft(this, h);
      }
      addSeparator(h) {
        return Hn(this, h);
      }
      addTab(h) {
        return es(this, h);
      }
      add(h, g) {
        this.controller_.rack.add(h.controller_, g);
        const E = this.apiSet_.find((N) => N.controller_ === h.controller_);
        return E && this.apiSet_.remove(E), this.apiSet_.add(h), h;
      }
      remove(h) {
        this.controller_.rack.remove(h.controller_);
      }
      addBlade(h) {
        const g = this.controller_.view.element.ownerDocument, E = this.pool_.createBlade(g, h), N = this.pool_.createBladeApi(E);
        return this.add(N, h.index);
      }
      on(h, g) {
        const E = g.bind(this);
        return this.emitter_.on(h, (N) => {
          E(N.event);
        }), this;
      }
      setUpApi_(h) {
        this.apiSet_.find((E) => E.controller_ === h) || this.apiSet_.add(this.pool_.createBladeApi(h));
      }
      onRackAdd_(h) {
        this.setUpApi_(h.bladeController);
      }
      onRackRemove_(h) {
        if (h.isRoot) {
          const g = We(this.apiSet_, h.bladeController);
          this.apiSet_.remove(g);
        }
      }
      onRackInputChange_(h) {
        const g = h.bladeController;
        if (g instanceof Gn) {
          const E = We(this.apiSet_, g), N = g.binding;
          this.emitter_.emit("change", {
            event: new o(E, N.target.read(), N.target.presetKey, h.options.last)
          });
        } else if (g instanceof At) {
          const E = We(this.apiSet_, g);
          this.emitter_.emit("change", {
            event: new o(E, g.value.rawValue, void 0, h.options.last)
          });
        }
      }
      onRackMonitorUpdate_(h) {
        if (!(h.bladeController instanceof pr))
          throw x.shouldNeverHappen();
        const g = We(this.apiSet_, h.bladeController), E = h.bladeController.binding;
        this.emitter_.emit("update", {
          event: new a(g, E.target.read(), E.target.presetKey)
        });
      }
    }
    class X extends Qe {
      constructor(h, g) {
        super(h, new wt(h.rackController, g)), this.emitter_ = new C(), this.controller_.foldable.value("expanded").emitter.on("change", (E) => {
          this.emitter_.emit("fold", {
            event: new l(this, E.sender.rawValue)
          });
        }), this.rackApi_.on("change", (E) => {
          this.emitter_.emit("change", {
            event: E
          });
        }), this.rackApi_.on("update", (E) => {
          this.emitter_.emit("update", {
            event: E
          });
        });
      }
      get expanded() {
        return this.controller_.foldable.get("expanded");
      }
      set expanded(h) {
        this.controller_.foldable.set("expanded", h);
      }
      get title() {
        return this.controller_.props.get("title");
      }
      set title(h) {
        this.controller_.props.set("title", h);
      }
      get children() {
        return this.rackApi_.children;
      }
      addInput(h, g, E) {
        return this.rackApi_.addInput(h, g, E);
      }
      addMonitor(h, g, E) {
        return this.rackApi_.addMonitor(h, g, E);
      }
      addFolder(h) {
        return this.rackApi_.addFolder(h);
      }
      addButton(h) {
        return this.rackApi_.addButton(h);
      }
      addSeparator(h) {
        return this.rackApi_.addSeparator(h);
      }
      addTab(h) {
        return this.rackApi_.addTab(h);
      }
      add(h, g) {
        return this.rackApi_.add(h, g);
      }
      remove(h) {
        this.rackApi_.remove(h);
      }
      addBlade(h) {
        return this.rackApi_.addBlade(h);
      }
      on(h, g) {
        const E = g.bind(this);
        return this.emitter_.on(h, (N) => {
          E(N.event);
        }), this;
      }
    }
    class ge extends fe {
      constructor(h) {
        super({
          blade: h.blade,
          view: h.view,
          viewProps: h.rackController.viewProps
        }), this.rackController = h.rackController;
      }
    }
    class we {
      constructor(h, g) {
        const E = T(g.viewName);
        this.element = h.createElement("div"), this.element.classList.add(E()), g.viewProps.bindClassModifiers(this.element);
      }
    }
    function de(_, h) {
      for (let g = 0; g < _.length; g++) {
        const E = _[g];
        if (E instanceof Gn && E.binding === h)
          return E;
      }
      return null;
    }
    function ke(_, h) {
      for (let g = 0; g < _.length; g++) {
        const E = _[g];
        if (E instanceof pr && E.binding === h)
          return E;
      }
      return null;
    }
    function it(_, h) {
      for (let g = 0; g < _.length; g++) {
        const E = _[g];
        if (E instanceof At && E.value === h)
          return E;
      }
      return null;
    }
    function ct(_) {
      return _ instanceof Yt ? _.rack : _ instanceof ge ? _.rackController.rack : null;
    }
    function Et(_) {
      const h = ct(_);
      return h ? h.bcSet_ : null;
    }
    class Ct {
      constructor(h) {
        var g, E;
        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new C(), this.blade_ = (g = h.blade) !== null && g !== void 0 ? g : null, (E = this.blade_) === null || E === void 0 || E.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = h.viewProps, this.bcSet_ = new Sn(Et), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
      }
      get children() {
        return this.bcSet_.items;
      }
      add(h, g) {
        var E;
        (E = h.parent) === null || E === void 0 || E.remove(h), v(h, "parent") ? h.parent = this : (h.parent_ = this, Ee({
          key: "parent",
          target: "BladeController",
          place: "BladeRack.add"
        })), this.bcSet_.add(h, g);
      }
      remove(h) {
        v(h, "parent") ? h.parent = null : (h.parent_ = null, Ee({
          key: "parent",
          target: "BladeController",
          place: "BladeRack.remove"
        })), this.bcSet_.remove(h);
      }
      find(h) {
        return this.bcSet_.allItems().filter((g) => g instanceof h);
      }
      onSetAdd_(h) {
        this.updatePositions_();
        const g = h.target === h.root;
        if (this.emitter.emit("add", {
          bladeController: h.item,
          index: h.index,
          isRoot: g,
          sender: this
        }), !g)
          return;
        const E = h.item;
        if (E.viewProps.emitter.on("change", this.onChildViewPropsChange_), E.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), E.viewProps.handleDispose(this.onChildDispose_), E instanceof Gn)
          E.binding.emitter.on("change", this.onChildInputChange_);
        else if (E instanceof pr)
          E.binding.emitter.on("update", this.onChildMonitorUpdate_);
        else if (E instanceof At)
          E.value.emitter.on("change", this.onChildValueChange_);
        else {
          const N = ct(E);
          if (N) {
            const ne = N.emitter;
            ne.on("layout", this.onDescendantLayout_), ne.on("inputchange", this.onDescendantInputChange_), ne.on("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      onSetRemove_(h) {
        this.updatePositions_();
        const g = h.target === h.root;
        if (this.emitter.emit("remove", {
          bladeController: h.item,
          isRoot: g,
          sender: this
        }), !g)
          return;
        const E = h.item;
        if (E instanceof Gn)
          E.binding.emitter.off("change", this.onChildInputChange_);
        else if (E instanceof pr)
          E.binding.emitter.off("update", this.onChildMonitorUpdate_);
        else if (E instanceof At)
          E.value.emitter.off("change", this.onChildValueChange_);
        else {
          const N = ct(E);
          if (N) {
            const ne = N.emitter;
            ne.off("layout", this.onDescendantLayout_), ne.off("inputchange", this.onDescendantInputChange_), ne.off("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      updatePositions_() {
        const h = this.bcSet_.items.filter((N) => !N.viewProps.get("hidden")), g = h[0], E = h[h.length - 1];
        this.bcSet_.items.forEach((N) => {
          const ne = [];
          N === g && (ne.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && ne.push("veryfirst")), N === E && (ne.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && ne.push("verylast")), N.blade.set("positions", ne);
        });
      }
      onChildPositionsChange_() {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onChildViewPropsChange_(h) {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onChildDispose_() {
        this.bcSet_.items.filter((g) => g.viewProps.get("disposed")).forEach((g) => {
          this.bcSet_.remove(g);
        });
      }
      onChildInputChange_(h) {
        const g = de(this.find(Gn), h.sender);
        if (!g)
          throw x.alreadyDisposed();
        this.emitter.emit("inputchange", {
          bladeController: g,
          options: h.options,
          sender: this
        });
      }
      onChildMonitorUpdate_(h) {
        const g = ke(this.find(pr), h.sender);
        if (!g)
          throw x.alreadyDisposed();
        this.emitter.emit("monitorupdate", {
          bladeController: g,
          sender: this
        });
      }
      onChildValueChange_(h) {
        const g = it(this.find(At), h.sender);
        if (!g)
          throw x.alreadyDisposed();
        this.emitter.emit("inputchange", {
          bladeController: g,
          options: h.options,
          sender: this
        });
      }
      onDescendantLayout_(h) {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onDescendantInputChange_(h) {
        this.emitter.emit("inputchange", {
          bladeController: h.bladeController,
          options: h.options,
          sender: this
        });
      }
      onDescendantMonitorUpdate_(h) {
        this.emitter.emit("monitorupdate", {
          bladeController: h.bladeController,
          sender: this
        });
      }
      onBladePositionsChange_() {
        this.updatePositions_();
      }
    }
    class Yt extends fe {
      constructor(h, g) {
        super(Object.assign(Object.assign({}, g), { view: new we(h, {
          viewName: "brk",
          viewProps: g.viewProps
        }) })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
        const E = new Ct({
          blade: g.root ? void 0 : g.blade,
          viewProps: g.viewProps
        });
        E.emitter.on("add", this.onRackAdd_), E.emitter.on("remove", this.onRackRemove_), this.rack = E, this.viewProps.handleDispose(() => {
          for (let N = this.rack.children.length - 1; N >= 0; N--)
            this.rack.children[N].viewProps.set("disposed", !0);
        });
      }
      onRackAdd_(h) {
        !h.isRoot || me(this.view.element, h.bladeController.view.element, h.index);
      }
      onRackRemove_(h) {
        !h.isRoot || Ae(h.bladeController.view.element);
      }
    }
    const Ot = T("cnt");
    class tn {
      constructor(h, g) {
        var E;
        this.className_ = T((E = g.viewName) !== null && E !== void 0 ? E : "fld"), this.element = h.createElement("div"), this.element.classList.add(this.className_(), Ot()), g.viewProps.bindClassModifiers(this.element), this.foldable_ = g.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), k(this.foldable_, "completed", B(this.element, this.className_(void 0, "cpl")));
        const N = h.createElement("button");
        N.classList.add(this.className_("b")), k(g.props, "title", (Rt) => {
          p(Rt) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
        }), g.viewProps.bindDisabled(N), this.element.appendChild(N), this.buttonElement = N;
        const ne = h.createElement("div");
        ne.classList.add(this.className_("i")), this.element.appendChild(ne);
        const be = h.createElement("div");
        be.classList.add(this.className_("t")), Y(g.props.value("title"), be), this.buttonElement.appendChild(be), this.titleElement = be;
        const He = h.createElement("div");
        He.classList.add(this.className_("m")), this.buttonElement.appendChild(He);
        const mt = g.containerElement;
        mt.classList.add(this.className_("c")), this.element.appendChild(mt), this.containerElement = mt;
      }
    }
    class zn extends ge {
      constructor(h, g) {
        var E;
        const N = pe.create((E = g.expanded) !== null && E !== void 0 ? E : !0), ne = new Yt(h, {
          blade: g.blade,
          root: g.root,
          viewProps: g.viewProps
        });
        super(Object.assign(Object.assign({}, g), { rackController: ne, view: new tn(h, {
          containerElement: ne.view.element,
          foldable: N,
          props: g.props,
          viewName: g.root ? "rot" : void 0,
          viewProps: g.viewProps
        }) })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = g.props, this.foldable = N, tt(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
          this.foldable.cleanUpTransition();
        }), this.rackController.rack.emitter.on("remove", () => {
          this.foldable.cleanUpTransition();
        }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
      }
      get document() {
        return this.view.element.ownerDocument;
      }
      onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"));
      }
    }
    const ao = {
      id: "folder",
      type: "blade",
      accept(_) {
        const h = ye, g = Se(_, {
          title: h.required.string,
          view: h.required.constant("folder"),
          expanded: h.optional.boolean
        });
        return g ? { params: g } : null;
      },
      controller(_) {
        return new zn(_.document, {
          blade: _.blade,
          expanded: _.params.expanded,
          props: oe.fromObject({
            title: _.params.title
          }),
          viewProps: _.viewProps
        });
      },
      api(_) {
        return _.controller instanceof zn ? new X(_.controller, _.pool) : null;
      }
    };
    class Ki extends At {
      constructor(h, g) {
        const E = g.valueController.viewProps;
        super(Object.assign(Object.assign({}, g), { value: g.valueController.value, view: new ht(h, {
          props: g.props,
          viewProps: E
        }), viewProps: E })), this.props = g.props, this.valueController = g.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class lo extends r {
    }
    const Ji = T("spr");
    class hn {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(Ji()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("hr");
        E.classList.add(Ji("r")), this.element.appendChild(E);
      }
    }
    class co extends fe {
      constructor(h, g) {
        super(Object.assign(Object.assign({}, g), { view: new hn(h, {
          viewProps: g.viewProps
        }) }));
      }
    }
    const Qn = {
      id: "separator",
      type: "blade",
      accept(_) {
        const g = Se(_, {
          view: ye.required.constant("separator")
        });
        return g ? { params: g } : null;
      },
      controller(_) {
        return new co(_.document, {
          blade: _.blade,
          viewProps: _.viewProps
        });
      },
      api(_) {
        return _.controller instanceof co ? new lo(_.controller) : null;
      }
    }, vi = T("tbi");
    class ys {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(vi()), g.viewProps.bindClassModifiers(this.element), k(g.props, "selected", (ne) => {
          ne ? this.element.classList.add(vi(void 0, "sel")) : this.element.classList.remove(vi(void 0, "sel"));
        });
        const E = h.createElement("button");
        E.classList.add(vi("b")), g.viewProps.bindDisabled(E), this.element.appendChild(E), this.buttonElement = E;
        const N = h.createElement("div");
        N.classList.add(vi("t")), Y(g.props.value("title"), N), this.buttonElement.appendChild(N), this.titleElement = N;
      }
    }
    class Fo {
      constructor(h, g) {
        this.emitter = new C(), this.onClick_ = this.onClick_.bind(this), this.props = g.props, this.viewProps = g.viewProps, this.view = new ys(h, {
          props: g.props,
          viewProps: g.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class Ml {
      constructor(h, g) {
        this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new Fo(h, {
          props: g.itemProps,
          viewProps: st.create()
        }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new Yt(h, {
          blade: Bt(),
          viewProps: st.create()
        }), this.props = g.props, k(this.props, "selected", (E) => {
          this.itemController.props.set("selected", E), this.contentController.viewProps.set("hidden", !E);
        });
      }
      get itemController() {
        return this.ic_;
      }
      get contentController() {
        return this.cc_;
      }
      onItemClick_() {
        this.props.set("selected", !0);
      }
    }
    class Ci {
      constructor(h, g) {
        this.controller_ = h, this.rackApi_ = g;
      }
      get title() {
        var h;
        return (h = this.controller_.itemController.props.get("title")) !== null && h !== void 0 ? h : "";
      }
      set title(h) {
        this.controller_.itemController.props.set("title", h);
      }
      get selected() {
        return this.controller_.props.get("selected");
      }
      set selected(h) {
        this.controller_.props.set("selected", h);
      }
      get children() {
        return this.rackApi_.children;
      }
      addButton(h) {
        return this.rackApi_.addButton(h);
      }
      addFolder(h) {
        return this.rackApi_.addFolder(h);
      }
      addSeparator(h) {
        return this.rackApi_.addSeparator(h);
      }
      addTab(h) {
        return this.rackApi_.addTab(h);
      }
      add(h, g) {
        this.rackApi_.add(h, g);
      }
      remove(h) {
        this.rackApi_.remove(h);
      }
      addInput(h, g, E) {
        return this.rackApi_.addInput(h, g, E);
      }
      addMonitor(h, g, E) {
        return this.rackApi_.addMonitor(h, g, E);
      }
      addBlade(h) {
        return this.rackApi_.addBlade(h);
      }
    }
    class Hs extends Qe {
      constructor(h, g) {
        super(h, new wt(h.rackController, g)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new C(), this.pageApiMap_ = /* @__PURE__ */ new Map(), this.rackApi_.on("change", (E) => {
          this.emitter_.emit("change", {
            event: E
          });
        }), this.rackApi_.on("update", (E) => {
          this.emitter_.emit("update", {
            event: E
          });
        }), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((E) => {
          this.setUpPageApi_(E);
        });
      }
      get pages() {
        return this.controller_.pageSet.items.map((h) => {
          const g = this.pageApiMap_.get(h);
          if (!g)
            throw x.shouldNeverHappen();
          return g;
        });
      }
      addPage(h) {
        const g = this.controller_.view.element.ownerDocument, E = new Ml(g, {
          itemProps: oe.fromObject({
            selected: !1,
            title: h.title
          }),
          props: oe.fromObject({
            selected: !1
          })
        });
        this.controller_.add(E, h.index);
        const N = this.pageApiMap_.get(E);
        if (!N)
          throw x.shouldNeverHappen();
        return N;
      }
      removePage(h) {
        this.controller_.remove(h);
      }
      on(h, g) {
        const E = g.bind(this);
        return this.emitter_.on(h, (N) => {
          E(N.event);
        }), this;
      }
      setUpPageApi_(h) {
        const g = this.rackApi_.apiSet_.find((N) => N.controller_ === h.contentController);
        if (!g)
          throw x.shouldNeverHappen();
        const E = new Ci(h, g);
        this.pageApiMap_.set(h, E);
      }
      onPageAdd_(h) {
        this.setUpPageApi_(h.item);
      }
      onPageRemove_(h) {
        if (!this.pageApiMap_.get(h.item))
          throw x.shouldNeverHappen();
        this.pageApiMap_.delete(h.item);
      }
      onSelect_(h) {
        this.emitter_.emit("select", {
          event: new c(this, h.rawValue)
        });
      }
    }
    const El = -1;
    class Qi {
      constructor() {
        this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = se(!0), this.selectedIndex = se(El), this.items_ = [];
      }
      add(h, g) {
        const E = g != null ? g : this.items_.length;
        this.items_.splice(E, 0, h), h.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
      }
      remove(h) {
        const g = this.items_.indexOf(h);
        g < 0 || (this.items_.splice(g, 1), h.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
      }
      keepSelection_() {
        if (this.items_.length === 0) {
          this.selectedIndex.rawValue = El, this.empty.rawValue = !0;
          return;
        }
        const h = this.items_.findIndex((g) => g.rawValue);
        h < 0 ? (this.items_.forEach((g, E) => {
          g.rawValue = E === 0;
        }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((g, E) => {
          g.rawValue = E === h;
        }), this.selectedIndex.rawValue = h), this.empty.rawValue = !1;
      }
      onItemSelectedChange_(h) {
        if (h.rawValue) {
          const g = this.items_.findIndex((E) => E === h.sender);
          this.items_.forEach((E, N) => {
            E.rawValue = N === g;
          }), this.selectedIndex.rawValue = g;
        } else
          this.keepSelection_();
      }
    }
    const Gs = T("tab");
    class yh {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(Gs(), Ot()), g.viewProps.bindClassModifiers(this.element), I(g.empty, B(this.element, Gs(void 0, "nop")));
        const E = h.createElement("div");
        E.classList.add(Gs("t")), this.element.appendChild(E), this.itemsElement = E;
        const N = h.createElement("div");
        N.classList.add(Gs("i")), this.element.appendChild(N);
        const ne = g.contentsElement;
        ne.classList.add(Gs("c")), this.element.appendChild(ne), this.contentsElement = ne;
      }
    }
    class Ea extends ge {
      constructor(h, g) {
        const E = new Yt(h, {
          blade: g.blade,
          viewProps: g.viewProps
        }), N = new Qi();
        super({
          blade: g.blade,
          rackController: E,
          view: new yh(h, {
            contentsElement: E.view.element,
            empty: N.empty,
            viewProps: g.viewProps
          })
        }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new Sn(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = N;
      }
      get pageSet() {
        return this.pageSet_;
      }
      add(h, g) {
        this.pageSet_.add(h, g);
      }
      remove(h) {
        this.pageSet_.remove(this.pageSet_.items[h]);
      }
      onPageAdd_(h) {
        const g = h.item;
        me(this.view.itemsElement, g.itemController.view.element, h.index), g.itemController.viewProps.set("parent", this.viewProps), this.rackController.rack.add(g.contentController, h.index), this.tab.add(g.props.value("selected"));
      }
      onPageRemove_(h) {
        const g = h.item;
        Ae(g.itemController.view.element), g.itemController.viewProps.set("parent", null), this.rackController.rack.remove(g.contentController), this.tab.remove(g.props.value("selected"));
      }
    }
    const pg = {
      id: "tab",
      type: "blade",
      accept(_) {
        const h = ye, g = Se(_, {
          pages: h.required.array(h.required.object({ title: h.required.string })),
          view: h.required.constant("tab")
        });
        return !g || g.pages.length === 0 ? null : { params: g };
      },
      controller(_) {
        const h = new Ea(_.document, {
          blade: _.blade,
          viewProps: _.viewProps
        });
        return _.params.pages.forEach((g) => {
          const E = new Ml(_.document, {
            itemProps: oe.fromObject({
              selected: !1,
              title: g.title
            }),
            props: oe.fromObject({
              selected: !1
            })
          });
          h.add(E);
        }), h;
      },
      api(_) {
        return _.controller instanceof Ea ? new Hs(_.controller, _.pool) : null;
      }
    };
    function mg(_, h) {
      const g = _.accept(h.params);
      if (!g)
        return null;
      const E = ye.optional.boolean(h.params.disabled).value, N = ye.optional.boolean(h.params.hidden).value;
      return _.controller({
        blade: Bt(),
        document: h.document,
        params: Object.assign(Object.assign({}, g.params), { disabled: E, hidden: N }),
        viewProps: st.create({
          disabled: E,
          hidden: N
        })
      });
    }
    class xh {
      constructor() {
        this.disabled = !1, this.emitter = new C();
      }
      dispose() {
      }
      tick() {
        this.disabled || this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class vg {
      constructor(h, g) {
        this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = h, this.emitter = new C(), this.interval_ = g, this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(h) {
        this.disabled_ = h, this.disabled_ ? this.clearTimer_() : this.setTimer_();
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (this.timerId_ === null)
          return;
        const h = this.doc_.defaultView;
        h && h.clearInterval(this.timerId_), this.timerId_ = null;
      }
      setTimer_() {
        if (this.clearTimer_(), this.interval_ <= 0)
          return;
        const h = this.doc_.defaultView;
        h && (this.timerId_ = h.setInterval(this.onTick_, this.interval_));
      }
      onTick_() {
        this.disabled_ || this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class Tx {
      constructor(h) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.reader = h.reader, this.writer = h.writer, this.emitter = new C(), this.value = h.value, this.value.emitter.on("change", this.onValueChange_), this.target = h.target, this.read();
      }
      read() {
        const h = this.target.read();
        h !== void 0 && (this.value.rawValue = this.reader(h));
      }
      write_(h) {
        this.writer(this.target, h);
      }
      onValueChange_(h) {
        this.write_(h.rawValue), this.emitter.emit("change", {
          options: h.options,
          rawValue: h.rawValue,
          sender: this
        });
      }
    }
    function np(_, h) {
      for (; _.length < h; )
        _.push(void 0);
    }
    function gg(_) {
      const h = [];
      return np(h, _), se(h);
    }
    function ip(_) {
      const h = _.indexOf(void 0);
      return h < 0 ? _ : _.slice(0, h);
    }
    function Px(_, h) {
      const g = [...ip(_), h];
      return g.length > _.length ? g.splice(0, g.length - _.length) : np(g, _.length), g;
    }
    class _g {
      constructor(h) {
        this.onTick_ = this.onTick_.bind(this), this.reader_ = h.reader, this.target = h.target, this.emitter = new C(), this.value = h.value, this.ticker = h.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
      }
      dispose() {
        this.ticker.dispose();
      }
      read() {
        const h = this.target.read();
        if (h === void 0)
          return;
        const g = this.value.rawValue, E = this.reader_(h);
        this.value.rawValue = Px(g, E), this.emitter.emit("update", {
          rawValue: E,
          sender: this
        });
      }
      onTick_(h) {
        this.read();
      }
    }
    class Ca {
      constructor(h) {
        this.constraints = h;
      }
      constrain(h) {
        return this.constraints.reduce((g, E) => E.constrain(g), h);
      }
    }
    function xs(_, h) {
      if (_ instanceof h)
        return _;
      if (_ instanceof Ca) {
        const g = _.constraints.reduce((E, N) => E || (N instanceof h ? N : null), null);
        if (g)
          return g;
      }
      return null;
    }
    class ws {
      constructor(h) {
        this.values = oe.fromObject({
          max: h.max,
          min: h.min
        });
      }
      constrain(h) {
        const g = this.values.get("max"), E = this.values.get("min");
        return Math.min(Math.max(h, E), g);
      }
    }
    class Cl {
      constructor(h) {
        this.values = oe.fromObject({
          options: h
        });
      }
      get options() {
        return this.values.get("options");
      }
      constrain(h) {
        const g = this.values.get("options");
        return g.length === 0 || g.filter((N) => N.value === h).length > 0 ? h : g[0].value;
      }
    }
    class rp {
      constructor(h) {
        this.values = oe.fromObject({
          max: h.max,
          min: h.min
        });
      }
      get maxValue() {
        return this.values.get("max");
      }
      get minValue() {
        return this.values.get("min");
      }
      constrain(h) {
        const g = this.values.get("max"), E = this.values.get("min");
        let N = h;
        return p(E) || (N = Math.max(N, E)), p(g) || (N = Math.min(N, g)), N;
      }
    }
    class wh {
      constructor(h, g = 0) {
        this.step = h, this.origin = g;
      }
      constrain(h) {
        const g = this.origin % this.step, E = Math.round((h - g) / this.step);
        return g + E * this.step;
      }
    }
    const Sh = T("lst");
    class bg {
      constructor(h, g) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = g.props, this.element = h.createElement("div"), this.element.classList.add(Sh()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("select");
        E.classList.add(Sh("s")), k(this.props_, "options", (ne) => {
          Ve(E), ne.forEach((be, He) => {
            const mt = h.createElement("option");
            mt.dataset.index = String(He), mt.textContent = be.text, mt.value = String(be.value), E.appendChild(mt);
          });
        }), g.viewProps.bindDisabled(E), this.element.appendChild(E), this.selectElement = E;
        const N = h.createElement("div");
        N.classList.add(Sh("m")), N.appendChild(he(h, "dropdown")), this.element.appendChild(N), g.value.emitter.on("change", this.onValueChange_), this.value_ = g.value, this.update_();
      }
      update_() {
        this.selectElement.value = String(this.value_.rawValue);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Tl {
      constructor(h, g) {
        this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = g.props, this.value = g.value, this.viewProps = g.viewProps, this.view = new bg(h, {
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
      }
      onSelectChange_(h) {
        const E = h.currentTarget.selectedOptions.item(0);
        if (!E)
          return;
        const N = Number(E.dataset.index);
        this.value.rawValue = this.props.get("options")[N].value;
      }
    }
    const sp = T("pop");
    class Ax {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(sp()), g.viewProps.bindClassModifiers(this.element), I(g.shows, B(this.element, sp(void 0, "v")));
      }
    }
    class yg {
      constructor(h, g) {
        this.shows = se(!1), this.viewProps = g.viewProps, this.view = new Ax(h, {
          shows: this.shows,
          viewProps: this.viewProps
        });
      }
    }
    const xg = T("txt");
    class wg {
      constructor(h, g) {
        this.onChange_ = this.onChange_.bind(this), this.element = h.createElement("div"), this.element.classList.add(xg()), g.viewProps.bindClassModifiers(this.element), this.props_ = g.props, this.props_.emitter.on("change", this.onChange_);
        const E = h.createElement("input");
        E.classList.add(xg("i")), E.type = "text", g.viewProps.bindDisabled(E), this.element.appendChild(E), this.inputElement = E, g.value.emitter.on("change", this.onChange_), this.value_ = g.value, this.refresh();
      }
      refresh() {
        const h = this.props_.get("formatter");
        this.inputElement.value = h(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class Mh {
      constructor(h, g) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = g.parser, this.props = g.props, this.value = g.value, this.viewProps = g.viewProps, this.view = new wg(h, {
          props: g.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(h) {
        const E = h.currentTarget.value, N = this.parser_(E);
        p(N) || (this.value.rawValue = N), this.view.refresh();
      }
    }
    function Rx(_) {
      return String(_);
    }
    function Sg(_) {
      return _ === "false" ? !1 : !!_;
    }
    function Mg(_) {
      return Rx(_);
    }
    class op {
      constructor(h) {
        this.text = h;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const kx = {
      "**": (_, h) => Math.pow(_, h),
      "*": (_, h) => _ * h,
      "/": (_, h) => _ / h,
      "%": (_, h) => _ % h,
      "+": (_, h) => _ + h,
      "-": (_, h) => _ - h,
      "<<": (_, h) => _ << h,
      ">>": (_, h) => _ >> h,
      ">>>": (_, h) => _ >>> h,
      "&": (_, h) => _ & h,
      "^": (_, h) => _ ^ h,
      "|": (_, h) => _ | h
    };
    class Lx {
      constructor(h, g, E) {
        this.left = g, this.operator = h, this.right = E;
      }
      evaluate() {
        const h = kx[this.operator];
        if (!h)
          throw new Error(`unexpected binary operator: '${this.operator}`);
        return h(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return [
          "b(",
          this.left.toString(),
          this.operator,
          this.right.toString(),
          ")"
        ].join(" ");
      }
    }
    const Dx = {
      "+": (_) => _,
      "-": (_) => -_,
      "~": (_) => ~_
    };
    class Ix {
      constructor(h, g) {
        this.operator = h, this.expression = g;
      }
      evaluate() {
        const h = Dx[this.operator];
        if (!h)
          throw new Error(`unexpected unary operator: '${this.operator}`);
        return h(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function ap(_) {
      return (h, g) => {
        for (let E = 0; E < _.length; E++) {
          const N = _[E](h, g);
          if (N !== "")
            return N;
        }
        return "";
      };
    }
    function Mn(_, h) {
      var g;
      const E = _.substr(h).match(/^\s+/);
      return (g = E && E[0]) !== null && g !== void 0 ? g : "";
    }
    function Fn(_, h) {
      const g = _.substr(h, 1);
      return g.match(/^[1-9]$/) ? g : "";
    }
    function Nc(_, h) {
      var g;
      const E = _.substr(h).match(/^[0-9]+/);
      return (g = E && E[0]) !== null && g !== void 0 ? g : "";
    }
    function Ox(_, h) {
      const g = Nc(_, h);
      if (g !== "")
        return g;
      const E = _.substr(h, 1);
      if (h += 1, E !== "-" && E !== "+")
        return "";
      const N = Nc(_, h);
      return N === "" ? "" : E + N;
    }
    function lp(_, h) {
      const g = _.substr(h, 1);
      if (h += 1, g.toLowerCase() !== "e")
        return "";
      const E = Ox(_, h);
      return E === "" ? "" : g + E;
    }
    function Eg(_, h) {
      const g = _.substr(h, 1);
      if (g === "0")
        return g;
      const E = Fn(_, h);
      return h += E.length, E === "" ? "" : E + Nc(_, h);
    }
    function Nx(_, h) {
      const g = Eg(_, h);
      if (h += g.length, g === "")
        return "";
      const E = _.substr(h, 1);
      if (h += E.length, E !== ".")
        return "";
      const N = Nc(_, h);
      return h += N.length, g + E + N + lp(_, h);
    }
    function zx(_, h) {
      const g = _.substr(h, 1);
      if (h += g.length, g !== ".")
        return "";
      const E = Nc(_, h);
      return h += E.length, E === "" ? "" : g + E + lp(_, h);
    }
    function Cg(_, h) {
      const g = Eg(_, h);
      return h += g.length, g === "" ? "" : g + lp(_, h);
    }
    const Fx = ap([
      Nx,
      zx,
      Cg
    ]);
    function Ni(_, h) {
      var g;
      const E = _.substr(h).match(/^[01]+/);
      return (g = E && E[0]) !== null && g !== void 0 ? g : "";
    }
    function cp(_, h) {
      const g = _.substr(h, 2);
      if (h += g.length, g.toLowerCase() !== "0b")
        return "";
      const E = Ni(_, h);
      return E === "" ? "" : g + E;
    }
    function Ta(_, h) {
      var g;
      const E = _.substr(h).match(/^[0-7]+/);
      return (g = E && E[0]) !== null && g !== void 0 ? g : "";
    }
    function Tg(_, h) {
      const g = _.substr(h, 2);
      if (h += g.length, g.toLowerCase() !== "0o")
        return "";
      const E = Ta(_, h);
      return E === "" ? "" : g + E;
    }
    function up(_, h) {
      var g;
      const E = _.substr(h).match(/^[0-9a-f]+/i);
      return (g = E && E[0]) !== null && g !== void 0 ? g : "";
    }
    function ts(_, h) {
      const g = _.substr(h, 2);
      if (h += g.length, g.toLowerCase() !== "0x")
        return "";
      const E = up(_, h);
      return E === "" ? "" : g + E;
    }
    const Pg = ap([
      cp,
      Tg,
      ts
    ]), Ag = ap([
      Pg,
      Fx
    ]);
    function Rg(_, h) {
      const g = Ag(_, h);
      return h += g.length, g === "" ? null : {
        evaluable: new op(g),
        cursor: h
      };
    }
    function kg(_, h) {
      const g = _.substr(h, 1);
      if (h += g.length, g !== "(")
        return null;
      const E = Dg(_, h);
      if (!E)
        return null;
      h = E.cursor, h += Mn(_, h).length;
      const N = _.substr(h, 1);
      return h += N.length, N !== ")" ? null : {
        evaluable: E.evaluable,
        cursor: h
      };
    }
    function Lg(_, h) {
      var g;
      return (g = Rg(_, h)) !== null && g !== void 0 ? g : kg(_, h);
    }
    function hp(_, h) {
      const g = Lg(_, h);
      if (g)
        return g;
      const E = _.substr(h, 1);
      if (h += E.length, E !== "+" && E !== "-" && E !== "~")
        return null;
      const N = hp(_, h);
      return N ? (h = N.cursor, {
        cursor: h,
        evaluable: new Ix(E, N.evaluable)
      }) : null;
    }
    function Br(_, h, g) {
      g += Mn(h, g).length;
      const E = _.filter((N) => h.startsWith(N, g))[0];
      return E ? (g += E.length, g += Mn(h, g).length, {
        cursor: g,
        operator: E
      }) : null;
    }
    function Bx(_, h) {
      return (g, E) => {
        const N = _(g, E);
        if (!N)
          return null;
        E = N.cursor;
        let ne = N.evaluable;
        for (; ; ) {
          const be = Br(h, g, E);
          if (!be)
            break;
          E = be.cursor;
          const He = _(g, E);
          if (!He)
            return null;
          E = He.cursor, ne = new Lx(be.operator, ne, He.evaluable);
        }
        return ne ? {
          cursor: E,
          evaluable: ne
        } : null;
      };
    }
    const ns = [
      ["**"],
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>>", ">>"],
      ["&"],
      ["^"],
      ["|"]
    ].reduce((_, h) => Bx(_, h), hp);
    function Dg(_, h) {
      return h += Mn(_, h).length, ns(_, h);
    }
    function Ig(_) {
      const h = Dg(_, 0);
      return !h || h.cursor + Mn(_, h.cursor).length !== _.length ? null : h.evaluable;
    }
    function er(_) {
      var h;
      const g = Ig(_);
      return (h = g == null ? void 0 : g.evaluate()) !== null && h !== void 0 ? h : null;
    }
    function zc(_) {
      if (typeof _ == "number")
        return _;
      if (typeof _ == "string") {
        const h = er(_);
        if (!p(h))
          return h;
      }
      return 0;
    }
    function dp(_) {
      return String(_);
    }
    function Wt(_) {
      return (h) => h.toFixed(Math.max(Math.min(_, 20), 0));
    }
    const Bo = Wt(0);
    function Pl(_) {
      return Bo(_) + "%";
    }
    function Og(_) {
      return String(_);
    }
    function Fc(_) {
      return _;
    }
    function Bc({ primary: _, secondary: h, forward: g, backward: E }) {
      let N = !1;
      function ne(be) {
        N || (N = !0, be(), N = !1);
      }
      _.emitter.on("change", (be) => {
        ne(() => {
          h.setRawValue(g(_, h), be.options);
        });
      }), h.emitter.on("change", (be) => {
        ne(() => {
          _.setRawValue(E(_, h), be.options);
        }), ne(() => {
          h.setRawValue(g(_, h), be.options);
        });
      }), ne(() => {
        h.setRawValue(g(_, h), {
          forceEmit: !1,
          last: !0
        });
      });
    }
    function Pr(_, h) {
      const g = _ * (h.altKey ? 0.1 : 1) * (h.shiftKey ? 10 : 1);
      return h.upKey ? +g : h.downKey ? -g : 0;
    }
    function Uc(_) {
      return {
        altKey: _.altKey,
        downKey: _.key === "ArrowDown",
        shiftKey: _.shiftKey,
        upKey: _.key === "ArrowUp"
      };
    }
    function Ws(_) {
      return {
        altKey: _.altKey,
        downKey: _.key === "ArrowLeft",
        shiftKey: _.shiftKey,
        upKey: _.key === "ArrowRight"
      };
    }
    function Eh(_) {
      return _ === "ArrowUp" || _ === "ArrowDown";
    }
    function Pa(_) {
      return Eh(_) || _ === "ArrowLeft" || _ === "ArrowRight";
    }
    function fp(_, h) {
      var g, E;
      const N = h.ownerDocument.defaultView, ne = h.getBoundingClientRect();
      return {
        x: _.pageX - (((g = N && N.scrollX) !== null && g !== void 0 ? g : 0) + ne.left),
        y: _.pageY - (((E = N && N.scrollY) !== null && E !== void 0 ? E : 0) + ne.top)
      };
    }
    class Uo {
      constructor(h) {
        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = h, this.emitter = new C(), h.addEventListener("touchstart", this.onTouchStart_, {
          passive: !1
        }), h.addEventListener("touchmove", this.onTouchMove_, {
          passive: !0
        }), h.addEventListener("touchend", this.onTouchEnd_), h.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(h) {
        const g = this.elem_.getBoundingClientRect();
        return {
          bounds: {
            width: g.width,
            height: g.height
          },
          point: h ? {
            x: h.x,
            y: h.y
          } : null
        };
      }
      onMouseDown_(h) {
        var g;
        h.preventDefault(), (g = h.currentTarget) === null || g === void 0 || g.focus();
        const E = this.elem_.ownerDocument;
        E.addEventListener("mousemove", this.onDocumentMouseMove_), E.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
          altKey: h.altKey,
          data: this.computePosition_(fp(h, this.elem_)),
          sender: this,
          shiftKey: h.shiftKey
        });
      }
      onDocumentMouseMove_(h) {
        this.emitter.emit("move", {
          altKey: h.altKey,
          data: this.computePosition_(fp(h, this.elem_)),
          sender: this,
          shiftKey: h.shiftKey
        });
      }
      onDocumentMouseUp_(h) {
        const g = this.elem_.ownerDocument;
        g.removeEventListener("mousemove", this.onDocumentMouseMove_), g.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
          altKey: h.altKey,
          data: this.computePosition_(fp(h, this.elem_)),
          sender: this,
          shiftKey: h.shiftKey
        });
      }
      onTouchStart_(h) {
        h.preventDefault();
        const g = h.targetTouches.item(0), E = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
          altKey: h.altKey,
          data: this.computePosition_(g ? {
            x: g.clientX - E.left,
            y: g.clientY - E.top
          } : void 0),
          sender: this,
          shiftKey: h.shiftKey
        }), this.lastTouch_ = g;
      }
      onTouchMove_(h) {
        const g = h.targetTouches.item(0), E = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
          altKey: h.altKey,
          data: this.computePosition_(g ? {
            x: g.clientX - E.left,
            y: g.clientY - E.top
          } : void 0),
          sender: this,
          shiftKey: h.shiftKey
        }), this.lastTouch_ = g;
      }
      onTouchEnd_(h) {
        var g;
        const E = (g = h.targetTouches.item(0)) !== null && g !== void 0 ? g : this.lastTouch_, N = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
          altKey: h.altKey,
          data: this.computePosition_(E ? {
            x: E.clientX - N.left,
            y: E.clientY - N.top
          } : void 0),
          sender: this,
          shiftKey: h.shiftKey
        });
      }
    }
    function Wn(_, h, g, E, N) {
      const ne = (_ - h) / (g - h);
      return E + ne * (N - E);
    }
    function Ch(_) {
      return String(_.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
    }
    function oi(_, h, g) {
      return Math.min(Math.max(_, h), g);
    }
    function pp(_, h) {
      return (_ % h + h) % h;
    }
    const is = T("txt");
    class mp {
      constructor(h, g) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = g.props, this.props_.emitter.on("change", this.onChange_), this.element = h.createElement("div"), this.element.classList.add(is(), is(void 0, "num")), g.arrayPosition && this.element.classList.add(is(void 0, g.arrayPosition)), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("input");
        E.classList.add(is("i")), E.type = "text", g.viewProps.bindDisabled(E), this.element.appendChild(E), this.inputElement = E, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = g.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(is()), this.inputElement.classList.add(is("i"));
        const N = h.createElement("div");
        N.classList.add(is("k")), this.element.appendChild(N), this.knobElement = N;
        const ne = h.createElementNS(ae, "svg");
        ne.classList.add(is("g")), this.knobElement.appendChild(ne);
        const be = h.createElementNS(ae, "path");
        be.classList.add(is("gb")), ne.appendChild(be), this.guideBodyElem_ = be;
        const He = h.createElementNS(ae, "path");
        He.classList.add(is("gh")), ne.appendChild(He), this.guideHeadElem_ = He;
        const mt = h.createElement("div");
        mt.classList.add(T("tt")()), this.knobElement.appendChild(mt), this.tooltipElem_ = mt, g.value.emitter.on("change", this.onChange_), this.value = g.value, this.refresh();
      }
      onDraggingChange_(h) {
        if (h.rawValue === null) {
          this.element.classList.remove(is(void 0, "drg"));
          return;
        }
        this.element.classList.add(is(void 0, "drg"));
        const g = h.rawValue / this.props_.get("draggingScale"), E = g + (g > 0 ? -1 : g < 0 ? 1 : 0), N = oi(-E, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${E + N},0 L${E},4 L${E + N},8`, `M ${g},-1 L${g},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${g},4`);
        const ne = this.props_.get("formatter");
        this.tooltipElem_.textContent = ne(this.value.rawValue), this.tooltipElem_.style.left = `${g}px`;
      }
      refresh() {
        const h = this.props_.get("formatter");
        this.inputElement.value = h(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class Aa {
      constructor(h, g) {
        var E;
        this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = g.baseStep, this.parser_ = g.parser, this.props = g.props, this.sliderProps_ = (E = g.sliderProps) !== null && E !== void 0 ? E : null, this.value = g.value, this.viewProps = g.viewProps, this.dragging_ = se(null), this.view = new mp(h, {
          arrayPosition: g.arrayPosition,
          dragging: this.dragging_,
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const N = new Uo(this.view.knobElement);
        N.emitter.on("down", this.onPointerDown_), N.emitter.on("move", this.onPointerMove_), N.emitter.on("up", this.onPointerUp_);
      }
      constrainValue_(h) {
        var g, E;
        const N = (g = this.sliderProps_) === null || g === void 0 ? void 0 : g.get("minValue"), ne = (E = this.sliderProps_) === null || E === void 0 ? void 0 : E.get("maxValue");
        let be = h;
        return N !== void 0 && (be = Math.max(be, N)), ne !== void 0 && (be = Math.min(be, ne)), be;
      }
      onInputChange_(h) {
        const E = h.currentTarget.value, N = this.parser_(E);
        p(N) || (this.value.rawValue = this.constrainValue_(N)), this.view.refresh();
      }
      onInputKeyDown_(h) {
        const g = Pr(this.baseStep_, Uc(h));
        g !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + g), {
          forceEmit: !1,
          last: !1
        });
      }
      onInputKeyUp_(h) {
        Pr(this.baseStep_, Uc(h)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
      onPointerDown_() {
        this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
      }
      computeDraggingValue_(h) {
        if (!h.point)
          return null;
        const g = h.point.x - h.bounds.width / 2;
        return this.constrainValue_(this.originRawValue_ + g * this.props.get("draggingScale"));
      }
      onPointerMove_(h) {
        const g = this.computeDraggingValue_(h.data);
        g !== null && (this.value.setRawValue(g, {
          forceEmit: !1,
          last: !1
        }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
      }
      onPointerUp_(h) {
        const g = this.computeDraggingValue_(h.data);
        g !== null && (this.value.setRawValue(g, {
          forceEmit: !0,
          last: !0
        }), this.dragging_.rawValue = null);
      }
    }
    const vp = T("sld");
    class Ng {
      constructor(h, g) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = g.props, this.props_.emitter.on("change", this.onChange_), this.element = h.createElement("div"), this.element.classList.add(vp()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("div");
        E.classList.add(vp("t")), g.viewProps.bindTabIndex(E), this.element.appendChild(E), this.trackElement = E;
        const N = h.createElement("div");
        N.classList.add(vp("k")), this.trackElement.appendChild(N), this.knobElement = N, g.value.emitter.on("change", this.onChange_), this.value = g.value, this.update_();
      }
      update_() {
        const h = oi(Wn(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
        this.knobElement.style.width = `${h}%`;
      }
      onChange_() {
        this.update_();
      }
    }
    class Ur {
      constructor(h, g) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = g.baseStep, this.value = g.value, this.viewProps = g.viewProps, this.props = g.props, this.view = new Ng(h, {
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Uo(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(h, g) {
        !h.point || this.value.setRawValue(Wn(oi(h.point.x, 0, h.bounds.width), 0, h.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), g);
      }
      onPointerDownOrMove_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onKeyDown_(h) {
        const g = Pr(this.baseStep_, Ws(h));
        g !== 0 && this.value.setRawValue(this.value.rawValue + g, {
          forceEmit: !1,
          last: !1
        });
      }
      onKeyUp_(h) {
        Pr(this.baseStep_, Ws(h)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    const Vc = T("sldtxt");
    class Hc {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(Vc());
        const E = h.createElement("div");
        E.classList.add(Vc("s")), this.sliderView_ = g.sliderView, E.appendChild(this.sliderView_.element), this.element.appendChild(E);
        const N = h.createElement("div");
        N.classList.add(Vc("t")), this.textView_ = g.textView, N.appendChild(this.textView_.element), this.element.appendChild(N);
      }
    }
    class Th {
      constructor(h, g) {
        this.value = g.value, this.viewProps = g.viewProps, this.sliderC_ = new Ur(h, {
          baseStep: g.baseStep,
          props: g.sliderProps,
          value: g.value,
          viewProps: this.viewProps
        }), this.textC_ = new Aa(h, {
          baseStep: g.baseStep,
          parser: g.parser,
          props: g.textProps,
          sliderProps: g.sliderProps,
          value: g.value,
          viewProps: g.viewProps
        }), this.view = new Hc(h, {
          sliderView: this.sliderC_.view,
          textView: this.textC_.view
        });
      }
      get sliderController() {
        return this.sliderC_;
      }
      get textController() {
        return this.textC_;
      }
    }
    function Al(_, h) {
      _.write(h);
    }
    function Ph(_) {
      const h = ye;
      if (Array.isArray(_))
        return h.required.array(h.required.object({
          text: h.required.string,
          value: h.required.raw
        }))(_).value;
      if (typeof _ == "object")
        return h.required.raw(_).value;
    }
    function zg(_) {
      if (_ === "inline" || _ === "popup")
        return _;
    }
    function Vo(_) {
      const h = ye;
      return h.required.object({
        max: h.optional.number,
        min: h.optional.number,
        step: h.optional.number
      })(_).value;
    }
    function Fg(_) {
      if (Array.isArray(_))
        return _;
      const h = [];
      return Object.keys(_).forEach((g) => {
        h.push({ text: g, value: _[g] });
      }), h;
    }
    function gp(_) {
      return p(_) ? null : new Cl(Fg(_));
    }
    function Rl(_) {
      const h = _ ? xs(_, wh) : null;
      return h ? h.step : null;
    }
    function Ah(_, h) {
      const g = _ && xs(_, wh);
      return g ? Ch(g.step) : Math.max(Ch(h), 2);
    }
    function kl(_) {
      const h = Rl(_);
      return h != null ? h : 1;
    }
    function Ho(_, h) {
      var g;
      const E = _ && xs(_, wh), N = Math.abs((g = E == null ? void 0 : E.step) !== null && g !== void 0 ? g : h);
      return N === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(N)) - 1);
    }
    const Gc = T("ckb");
    class Go {
      constructor(h, g) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.element = h.createElement("div"), this.element.classList.add(Gc()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("label");
        E.classList.add(Gc("l")), this.element.appendChild(E);
        const N = h.createElement("input");
        N.classList.add(Gc("i")), N.type = "checkbox", E.appendChild(N), this.inputElement = N, g.viewProps.bindDisabled(this.inputElement);
        const ne = h.createElement("div");
        ne.classList.add(Gc("w")), E.appendChild(ne);
        const be = he(h, "check");
        ne.appendChild(be), g.value.emitter.on("change", this.onValueChange_), this.value = g.value, this.update_();
      }
      update_() {
        this.inputElement.checked = this.value.rawValue;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Rh {
      constructor(h, g) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.value = g.value, this.viewProps = g.viewProps, this.view = new Go(h, {
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(h) {
        const g = h.currentTarget;
        this.value.rawValue = g.checked;
      }
    }
    function Ux(_) {
      const h = [], g = gp(_.options);
      return g && h.push(g), new Ca(h);
    }
    const Vx = {
      id: "input-bool",
      type: "input",
      accept: (_, h) => {
        if (typeof _ != "boolean")
          return null;
        const E = Se(h, {
          options: ye.optional.custom(Ph)
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        reader: (_) => Sg,
        constraint: (_) => Ux(_.params),
        writer: (_) => Al
      },
      controller: (_) => {
        const h = _.document, g = _.value, E = _.constraint, N = E && xs(E, Cl);
        return N ? new Tl(h, {
          props: new oe({
            options: N.values.value("options")
          }),
          value: g,
          viewProps: _.viewProps
        }) : new Rh(h, {
          value: g,
          viewProps: _.viewProps
        });
      }
    }, Ra = T("col");
    class Ll {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(Ra()), g.foldable.bindExpandedClass(this.element, Ra(void 0, "expanded")), k(g.foldable, "completed", B(this.element, Ra(void 0, "cpl")));
        const E = h.createElement("div");
        E.classList.add(Ra("h")), this.element.appendChild(E);
        const N = h.createElement("div");
        N.classList.add(Ra("s")), E.appendChild(N), this.swatchElement = N;
        const ne = h.createElement("div");
        if (ne.classList.add(Ra("t")), E.appendChild(ne), this.textElement = ne, g.pickerLayout === "inline") {
          const be = h.createElement("div");
          be.classList.add(Ra("p")), this.element.appendChild(be), this.pickerElement = be;
        } else
          this.pickerElement = null;
      }
    }
    function Ss(_, h, g) {
      const E = oi(_ / 255, 0, 1), N = oi(h / 255, 0, 1), ne = oi(g / 255, 0, 1), be = Math.max(E, N, ne), He = Math.min(E, N, ne), mt = be - He;
      let Rt = 0, an = 0;
      const on = (He + be) / 2;
      return mt !== 0 && (an = mt / (1 - Math.abs(be + He - 1)), E === be ? Rt = (N - ne) / mt : N === be ? Rt = 2 + (ne - E) / mt : Rt = 4 + (E - N) / mt, Rt = Rt / 6 + (Rt < 0 ? 1 : 0)), [Rt * 360, an * 100, on * 100];
    }
    function Bg(_, h, g) {
      const E = (_ % 360 + 360) % 360, N = oi(h / 100, 0, 1), ne = oi(g / 100, 0, 1), be = (1 - Math.abs(2 * ne - 1)) * N, He = be * (1 - Math.abs(E / 60 % 2 - 1)), mt = ne - be / 2;
      let Rt, an, on;
      return E >= 0 && E < 60 ? [Rt, an, on] = [be, He, 0] : E >= 60 && E < 120 ? [Rt, an, on] = [He, be, 0] : E >= 120 && E < 180 ? [Rt, an, on] = [0, be, He] : E >= 180 && E < 240 ? [Rt, an, on] = [0, He, be] : E >= 240 && E < 300 ? [Rt, an, on] = [He, 0, be] : [Rt, an, on] = [be, 0, He], [(Rt + mt) * 255, (an + mt) * 255, (on + mt) * 255];
    }
    function Hx(_, h, g) {
      const E = oi(_ / 255, 0, 1), N = oi(h / 255, 0, 1), ne = oi(g / 255, 0, 1), be = Math.max(E, N, ne), He = Math.min(E, N, ne), mt = be - He;
      let Rt;
      mt === 0 ? Rt = 0 : be === E ? Rt = 60 * (((N - ne) / mt % 6 + 6) % 6) : be === N ? Rt = 60 * ((ne - E) / mt + 2) : Rt = 60 * ((E - N) / mt + 4);
      const an = be === 0 ? 0 : mt / be, on = be;
      return [Rt, an * 100, on * 100];
    }
    function Ug(_, h, g) {
      const E = pp(_, 360), N = oi(h / 100, 0, 1), ne = oi(g / 100, 0, 1), be = ne * N, He = be * (1 - Math.abs(E / 60 % 2 - 1)), mt = ne - be;
      let Rt, an, on;
      return E >= 0 && E < 60 ? [Rt, an, on] = [be, He, 0] : E >= 60 && E < 120 ? [Rt, an, on] = [He, be, 0] : E >= 120 && E < 180 ? [Rt, an, on] = [0, be, He] : E >= 180 && E < 240 ? [Rt, an, on] = [0, He, be] : E >= 240 && E < 300 ? [Rt, an, on] = [He, 0, be] : [Rt, an, on] = [be, 0, He], [(Rt + mt) * 255, (an + mt) * 255, (on + mt) * 255];
    }
    function Gx(_, h, g) {
      const E = g + h * (100 - Math.abs(2 * g - 100)) / 200;
      return [
        _,
        E !== 0 ? h * (100 - Math.abs(2 * g - 100)) / E : 0,
        g + h * (100 - Math.abs(2 * g - 100)) / (2 * 100)
      ];
    }
    function Wx(_, h, g) {
      const E = 100 - Math.abs(g * (200 - h) / 100 - 100);
      return [_, E !== 0 ? h * g / E : 0, g * (200 - h) / (2 * 100)];
    }
    function ka(_) {
      return [_[0], _[1], _[2]];
    }
    function La(_, h) {
      return [_[0], _[1], _[2], h];
    }
    const ve = {
      hsl: {
        hsl: (_, h, g) => [_, h, g],
        hsv: Gx,
        rgb: Bg
      },
      hsv: {
        hsl: Wx,
        hsv: (_, h, g) => [_, h, g],
        rgb: Ug
      },
      rgb: {
        hsl: Ss,
        hsv: Hx,
        rgb: (_, h, g) => [_, h, g]
      }
    };
    function Oe(_, h) {
      return [
        h === "float" ? 1 : _ === "rgb" ? 255 : 360,
        h === "float" ? 1 : _ === "rgb" ? 255 : 100,
        h === "float" ? 1 : _ === "rgb" ? 255 : 100
      ];
    }
    function Pe(_, h) {
      return _ === h ? h : pp(_, h);
    }
    function ut(_, h, g) {
      var E;
      const N = Oe(h, g);
      return [
        h === "rgb" ? oi(_[0], 0, N[0]) : Pe(_[0], N[0]),
        oi(_[1], 0, N[1]),
        oi(_[2], 0, N[2]),
        oi((E = _[3]) !== null && E !== void 0 ? E : 1, 0, 1)
      ];
    }
    function zt(_, h, g, E) {
      const N = Oe(h, g), ne = Oe(h, E);
      return _.map((be, He) => be / N[He] * ne[He]);
    }
    function mn(_, h, g) {
      const E = zt(_, h.mode, h.type, "int"), N = ve[h.mode][g.mode](...E);
      return zt(N, g.mode, "int", g.type);
    }
    function ei(_, h) {
      return typeof _ != "object" || p(_) ? !1 : h in _ && typeof _[h] == "number";
    }
    class pt {
      static black(h = "int") {
        return new pt([0, 0, 0], "rgb", h);
      }
      static fromObject(h, g = "int") {
        const E = "a" in h ? [h.r, h.g, h.b, h.a] : [h.r, h.g, h.b];
        return new pt(E, "rgb", g);
      }
      static toRgbaObject(h, g = "int") {
        return h.toRgbaObject(g);
      }
      static isRgbColorObject(h) {
        return ei(h, "r") && ei(h, "g") && ei(h, "b");
      }
      static isRgbaColorObject(h) {
        return this.isRgbColorObject(h) && ei(h, "a");
      }
      static isColorObject(h) {
        return this.isRgbColorObject(h);
      }
      static equals(h, g) {
        if (h.mode !== g.mode)
          return !1;
        const E = h.comps_, N = g.comps_;
        for (let ne = 0; ne < E.length; ne++)
          if (E[ne] !== N[ne])
            return !1;
        return !0;
      }
      constructor(h, g, E = "int") {
        this.mode = g, this.type = E, this.comps_ = ut(h, g, E);
      }
      getComponents(h, g = "int") {
        return La(mn(ka(this.comps_), { mode: this.mode, type: this.type }, { mode: h != null ? h : this.mode, type: g }), this.comps_[3]);
      }
      toRgbaObject(h = "int") {
        const g = this.getComponents("rgb", h);
        return {
          r: g[0],
          g: g[1],
          b: g[2],
          a: g[3]
        };
      }
    }
    const js = T("colp");
    class jx {
      constructor(h, g) {
        this.alphaViews_ = null, this.element = h.createElement("div"), this.element.classList.add(js()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("div");
        E.classList.add(js("hsv"));
        const N = h.createElement("div");
        N.classList.add(js("sv")), this.svPaletteView_ = g.svPaletteView, N.appendChild(this.svPaletteView_.element), E.appendChild(N);
        const ne = h.createElement("div");
        ne.classList.add(js("h")), this.hPaletteView_ = g.hPaletteView, ne.appendChild(this.hPaletteView_.element), E.appendChild(ne), this.element.appendChild(E);
        const be = h.createElement("div");
        if (be.classList.add(js("rgb")), this.textView_ = g.textView, be.appendChild(this.textView_.element), this.element.appendChild(be), g.alphaViews) {
          this.alphaViews_ = {
            palette: g.alphaViews.palette,
            text: g.alphaViews.text
          };
          const He = h.createElement("div");
          He.classList.add(js("a"));
          const mt = h.createElement("div");
          mt.classList.add(js("ap")), mt.appendChild(this.alphaViews_.palette.element), He.appendChild(mt);
          const Rt = h.createElement("div");
          Rt.classList.add(js("at")), Rt.appendChild(this.alphaViews_.text.element), He.appendChild(Rt), this.element.appendChild(He);
        }
      }
      get allFocusableElements() {
        const h = [
          this.svPaletteView_.element,
          this.hPaletteView_.element,
          this.textView_.modeSelectElement,
          ...this.textView_.textViews.map((g) => g.inputElement)
        ];
        return this.alphaViews_ && h.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), h;
      }
    }
    function rs(_) {
      return _ === "int" ? "int" : _ === "float" ? "float" : void 0;
    }
    function Dl(_) {
      const h = ye;
      return Se(_, {
        alpha: h.optional.boolean,
        color: h.optional.object({
          alpha: h.optional.boolean,
          type: h.optional.custom(rs)
        }),
        expanded: h.optional.boolean,
        picker: h.optional.custom(zg)
      });
    }
    function Da(_) {
      return _ ? 0.1 : 1;
    }
    function ss(_) {
      var h;
      return (h = _.color) === null || h === void 0 ? void 0 : h.type;
    }
    function kh(_, h) {
      return _.alpha === h.alpha && _.mode === h.mode && _.notation === h.notation && _.type === h.type;
    }
    function mr(_, h) {
      const g = _.match(/^(.+)%$/);
      return Math.min(g ? parseFloat(g[1]) * 0.01 * h : parseFloat(_), h);
    }
    const En = {
      deg: (_) => _,
      grad: (_) => _ * 360 / 400,
      rad: (_) => _ * 360 / (2 * Math.PI),
      turn: (_) => _ * 360
    };
    function Vg(_) {
      const h = _.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
      if (!h)
        return parseFloat(_);
      const g = parseFloat(h[1]), E = h[2];
      return En[E](g);
    }
    function _p(_) {
      const h = _.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!h)
        return null;
      const g = [
        mr(h[1], 255),
        mr(h[2], 255),
        mr(h[3], 255)
      ];
      return isNaN(g[0]) || isNaN(g[1]) || isNaN(g[2]) ? null : g;
    }
    function Wc(_) {
      return (h) => {
        const g = _p(h);
        return g ? new pt(g, "rgb", _) : null;
      };
    }
    function Hg(_) {
      const h = _.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!h)
        return null;
      const g = [
        mr(h[1], 255),
        mr(h[2], 255),
        mr(h[3], 255),
        mr(h[4], 1)
      ];
      return isNaN(g[0]) || isNaN(g[1]) || isNaN(g[2]) || isNaN(g[3]) ? null : g;
    }
    function Gg(_) {
      return (h) => {
        const g = Hg(h);
        return g ? new pt(g, "rgb", _) : null;
      };
    }
    function Wg(_) {
      const h = _.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!h)
        return null;
      const g = [
        Vg(h[1]),
        mr(h[2], 100),
        mr(h[3], 100)
      ];
      return isNaN(g[0]) || isNaN(g[1]) || isNaN(g[2]) ? null : g;
    }
    function jc(_) {
      return (h) => {
        const g = Wg(h);
        return g ? new pt(g, "hsl", _) : null;
      };
    }
    function uo(_) {
      const h = _.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!h)
        return null;
      const g = [
        Vg(h[1]),
        mr(h[2], 100),
        mr(h[3], 100),
        mr(h[4], 1)
      ];
      return isNaN(g[0]) || isNaN(g[1]) || isNaN(g[2]) || isNaN(g[3]) ? null : g;
    }
    function qc(_) {
      return (h) => {
        const g = uo(h);
        return g ? new pt(g, "hsl", _) : null;
      };
    }
    function bp(_) {
      const h = _.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (h)
        return [
          parseInt(h[1] + h[1], 16),
          parseInt(h[2] + h[2], 16),
          parseInt(h[3] + h[3], 16)
        ];
      const g = _.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return g ? [
        parseInt(g[1], 16),
        parseInt(g[2], 16),
        parseInt(g[3], 16)
      ] : null;
    }
    function Lh(_) {
      const h = bp(_);
      return h ? new pt(h, "rgb", "int") : null;
    }
    function yp(_) {
      const h = _.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (h)
        return [
          parseInt(h[1] + h[1], 16),
          parseInt(h[2] + h[2], 16),
          parseInt(h[3] + h[3], 16),
          Wn(parseInt(h[4] + h[4], 16), 0, 255, 0, 1)
        ];
      const g = _.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return g ? [
        parseInt(g[1], 16),
        parseInt(g[2], 16),
        parseInt(g[3], 16),
        Wn(parseInt(g[4], 16), 0, 255, 0, 1)
      ] : null;
    }
    function jg(_) {
      const h = yp(_);
      return h ? new pt(h, "rgb", "int") : null;
    }
    function Xc(_) {
      const h = _.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!h)
        return null;
      const g = [
        parseFloat(h[1]),
        parseFloat(h[2]),
        parseFloat(h[3])
      ];
      return isNaN(g[0]) || isNaN(g[1]) || isNaN(g[2]) ? null : g;
    }
    function xp(_) {
      return (h) => {
        const g = Xc(h);
        return g ? new pt(g, "rgb", _) : null;
      };
    }
    function Il(_) {
      const h = _.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!h)
        return null;
      const g = [
        parseFloat(h[1]),
        parseFloat(h[2]),
        parseFloat(h[3]),
        parseFloat(h[4])
      ];
      return isNaN(g[0]) || isNaN(g[1]) || isNaN(g[2]) || isNaN(g[3]) ? null : g;
    }
    function Wo(_) {
      return (h) => {
        const g = Il(h);
        return g ? new pt(g, "rgb", _) : null;
      };
    }
    const Dh = [
      {
        parser: bp,
        result: {
          alpha: !1,
          mode: "rgb",
          notation: "hex"
        }
      },
      {
        parser: yp,
        result: {
          alpha: !0,
          mode: "rgb",
          notation: "hex"
        }
      },
      {
        parser: _p,
        result: {
          alpha: !1,
          mode: "rgb",
          notation: "func"
        }
      },
      {
        parser: Hg,
        result: {
          alpha: !0,
          mode: "rgb",
          notation: "func"
        }
      },
      {
        parser: Wg,
        result: {
          alpha: !1,
          mode: "hsl",
          notation: "func"
        }
      },
      {
        parser: uo,
        result: {
          alpha: !0,
          mode: "hsl",
          notation: "func"
        }
      },
      {
        parser: Xc,
        result: {
          alpha: !1,
          mode: "rgb",
          notation: "object"
        }
      },
      {
        parser: Il,
        result: {
          alpha: !0,
          mode: "rgb",
          notation: "object"
        }
      }
    ];
    function qx(_) {
      return Dh.reduce((h, { parser: g, result: E }) => h || (g(_) ? E : null), null);
    }
    function wp(_, h = "int") {
      const g = qx(_);
      return g ? g.notation === "hex" && h !== "float" ? Object.assign(Object.assign({}, g), { type: "int" }) : g.notation === "func" ? Object.assign(Object.assign({}, g), { type: h }) : null : null;
    }
    const qg = {
      int: [
        Lh,
        jg,
        Wc("int"),
        Gg("int"),
        jc("int"),
        qc("int"),
        xp("int"),
        Wo("int")
      ],
      float: [
        Wc("float"),
        Gg("float"),
        jc("float"),
        qc("float"),
        xp("float"),
        Wo("float")
      ]
    };
    function Ih(_) {
      const h = qg[_];
      return (g) => {
        if (typeof g != "string")
          return pt.black(_);
        const E = h.reduce((N, ne) => N || ne(g), null);
        return E != null ? E : pt.black(_);
      };
    }
    function Ol(_) {
      const h = qg[_];
      return (g) => h.reduce((E, N) => E || N(g), null);
    }
    function Oh(_) {
      const h = oi(Math.floor(_), 0, 255).toString(16);
      return h.length === 1 ? `0${h}` : h;
    }
    function Xg(_, h = "#") {
      const g = ka(_.getComponents("rgb")).map(Oh).join("");
      return `${h}${g}`;
    }
    function Nh(_, h = "#") {
      const g = _.getComponents("rgb"), E = [g[0], g[1], g[2], g[3] * 255].map(Oh).join("");
      return `${h}${E}`;
    }
    function $g(_, h) {
      const g = Wt(h === "float" ? 2 : 0);
      return `rgb(${ka(_.getComponents("rgb", h)).map((N) => g(N)).join(", ")})`;
    }
    function Xx(_) {
      return (h) => $g(h, _);
    }
    function ti(_, h) {
      const g = Wt(2), E = Wt(h === "float" ? 2 : 0);
      return `rgba(${_.getComponents("rgb", h).map((ne, be) => (be === 3 ? g : E)(ne)).join(", ")})`;
    }
    function tr(_) {
      return (h) => ti(h, _);
    }
    function $x(_) {
      const h = [
        Wt(0),
        Pl,
        Pl
      ];
      return `hsl(${ka(_.getComponents("hsl")).map((E, N) => h[N](E)).join(", ")})`;
    }
    function Zx(_) {
      const h = [
        Wt(0),
        Pl,
        Pl,
        Wt(2)
      ];
      return `hsla(${_.getComponents("hsl").map((E, N) => h[N](E)).join(", ")})`;
    }
    function Sp(_, h) {
      const g = Wt(h === "float" ? 2 : 0), E = ["r", "g", "b"];
      return `{${ka(_.getComponents("rgb", h)).map((ne, be) => `${E[be]}: ${g(ne)}`).join(", ")}}`;
    }
    function Yx(_) {
      return (h) => Sp(h, _);
    }
    function zh(_, h) {
      const g = Wt(2), E = Wt(h === "float" ? 2 : 0), N = ["r", "g", "b", "a"];
      return `{${_.getComponents("rgb", h).map((be, He) => {
        const mt = He === 3 ? g : E;
        return `${N[He]}: ${mt(be)}`;
      }).join(", ")}}`;
    }
    function $c(_) {
      return (h) => zh(h, _);
    }
    const Mp = [
      {
        format: {
          alpha: !1,
          mode: "rgb",
          notation: "hex",
          type: "int"
        },
        stringifier: Xg
      },
      {
        format: {
          alpha: !0,
          mode: "rgb",
          notation: "hex",
          type: "int"
        },
        stringifier: Nh
      },
      {
        format: {
          alpha: !1,
          mode: "hsl",
          notation: "func",
          type: "int"
        },
        stringifier: $x
      },
      {
        format: {
          alpha: !0,
          mode: "hsl",
          notation: "func",
          type: "int"
        },
        stringifier: Zx
      },
      ...["int", "float"].reduce((_, h) => [
        ..._,
        {
          format: {
            alpha: !1,
            mode: "rgb",
            notation: "func",
            type: h
          },
          stringifier: Xx(h)
        },
        {
          format: {
            alpha: !0,
            mode: "rgb",
            notation: "func",
            type: h
          },
          stringifier: tr(h)
        },
        {
          format: {
            alpha: !1,
            mode: "rgb",
            notation: "object",
            type: h
          },
          stringifier: Yx(h)
        },
        {
          format: {
            alpha: !0,
            mode: "rgb",
            notation: "object",
            type: h
          },
          stringifier: $c(h)
        }
      ], [])
    ];
    function jo(_) {
      return Mp.reduce((h, g) => h || (kh(g.format, _) ? g.stringifier : null), null);
    }
    const ho = T("apl");
    class Zc {
      constructor(h, g) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = g.value, this.value.emitter.on("change", this.onValueChange_), this.element = h.createElement("div"), this.element.classList.add(ho()), g.viewProps.bindClassModifiers(this.element), g.viewProps.bindTabIndex(this.element);
        const E = h.createElement("div");
        E.classList.add(ho("b")), this.element.appendChild(E);
        const N = h.createElement("div");
        N.classList.add(ho("c")), E.appendChild(N), this.colorElem_ = N;
        const ne = h.createElement("div");
        ne.classList.add(ho("m")), this.element.appendChild(ne), this.markerElem_ = ne;
        const be = h.createElement("div");
        be.classList.add(ho("p")), this.markerElem_.appendChild(be), this.previewElem_ = be, this.update_();
      }
      update_() {
        const h = this.value.rawValue, g = h.getComponents("rgb"), E = new pt([g[0], g[1], g[2], 0], "rgb"), N = new pt([g[0], g[1], g[2], 255], "rgb"), ne = [
          "to right",
          ti(E),
          ti(N)
        ];
        this.colorElem_.style.background = `linear-gradient(${ne.join(",")})`, this.previewElem_.style.backgroundColor = ti(h);
        const be = Wn(g[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${be}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Fh {
      constructor(h, g) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = g.value, this.viewProps = g.viewProps, this.view = new Zc(h, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Uo(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(h, g) {
        if (!h.point)
          return;
        const E = h.point.x / h.bounds.width, N = this.value.rawValue, [ne, be, He] = N.getComponents("hsv");
        this.value.setRawValue(new pt([ne, be, He, E], "hsv"), g);
      }
      onPointerDown_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerMove_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onKeyDown_(h) {
        const g = Pr(Da(!0), Ws(h));
        if (g === 0)
          return;
        const E = this.value.rawValue, [N, ne, be, He] = E.getComponents("hsv");
        this.value.setRawValue(new pt([N, ne, be, He + g], "hsv"), {
          forceEmit: !1,
          last: !1
        });
      }
      onKeyUp_(h) {
        Pr(Da(!0), Ws(h)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    const Ms = T("coltxt");
    function Kx(_) {
      const h = _.createElement("select"), g = [
        { text: "RGB", value: "rgb" },
        { text: "HSL", value: "hsl" },
        { text: "HSV", value: "hsv" }
      ];
      return h.appendChild(g.reduce((E, N) => {
        const ne = _.createElement("option");
        return ne.textContent = N.text, ne.value = N.value, E.appendChild(ne), E;
      }, _.createDocumentFragment())), h;
    }
    class Jx {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(Ms()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("div");
        E.classList.add(Ms("m")), this.modeElem_ = Kx(h), this.modeElem_.classList.add(Ms("ms")), E.appendChild(this.modeSelectElement), g.viewProps.bindDisabled(this.modeElem_);
        const N = h.createElement("div");
        N.classList.add(Ms("mm")), N.appendChild(he(h, "dropdown")), E.appendChild(N), this.element.appendChild(E);
        const ne = h.createElement("div");
        ne.classList.add(Ms("w")), this.element.appendChild(ne), this.textsElem_ = ne, this.textViews_ = g.textViews, this.applyTextViews_(), I(g.colorMode, (be) => {
          this.modeElem_.value = be;
        });
      }
      get modeSelectElement() {
        return this.modeElem_;
      }
      get textViews() {
        return this.textViews_;
      }
      set textViews(h) {
        this.textViews_ = h, this.applyTextViews_();
      }
      applyTextViews_() {
        Ve(this.textsElem_);
        const h = this.element.ownerDocument;
        this.textViews_.forEach((g) => {
          const E = h.createElement("div");
          E.classList.add(Ms("c")), E.appendChild(g.element), this.textsElem_.appendChild(E);
        });
      }
    }
    function Qx(_) {
      return Wt(_ === "float" ? 2 : 0);
    }
    function ew(_, h, g) {
      const E = Oe(_, h)[g];
      return new ws({
        min: 0,
        max: E
      });
    }
    function Ep(_, h, g) {
      return new Aa(_, {
        arrayPosition: g === 0 ? "fst" : g === 3 - 1 ? "lst" : "mid",
        baseStep: Da(!1),
        parser: h.parser,
        props: oe.fromObject({
          draggingScale: h.colorType === "float" ? 0.01 : 1,
          formatter: Qx(h.colorType)
        }),
        value: se(0, {
          constraint: ew(h.colorMode, h.colorType, g)
        }),
        viewProps: h.viewProps
      });
    }
    class Bh {
      constructor(h, g) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = g.colorType, this.parser_ = g.parser, this.value = g.value, this.viewProps = g.viewProps, this.colorMode = se(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(h), this.view = new Jx(h, {
          colorMode: this.colorMode,
          textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
          viewProps: this.viewProps
        }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
      }
      createComponentControllers_(h) {
        const g = {
          colorMode: this.colorMode.rawValue,
          colorType: this.colorType_,
          parser: this.parser_,
          viewProps: this.viewProps
        }, E = [
          Ep(h, g, 0),
          Ep(h, g, 1),
          Ep(h, g, 2)
        ];
        return E.forEach((N, ne) => {
          Bc({
            primary: this.value,
            secondary: N.value,
            forward: (be) => be.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[ne],
            backward: (be, He) => {
              const mt = this.colorMode.rawValue, Rt = be.rawValue.getComponents(mt, this.colorType_);
              return Rt[ne] = He.rawValue, new pt(La(ka(Rt), Rt[3]), mt, this.colorType_);
            }
          });
        }), E;
      }
      onModeSelectChange_(h) {
        const g = h.currentTarget;
        this.colorMode.rawValue = g.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [
          this.ccs_[0].view,
          this.ccs_[1].view,
          this.ccs_[2].view
        ];
      }
    }
    const Ia = T("hpl");
    class Zg {
      constructor(h, g) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = g.value, this.value.emitter.on("change", this.onValueChange_), this.element = h.createElement("div"), this.element.classList.add(Ia()), g.viewProps.bindClassModifiers(this.element), g.viewProps.bindTabIndex(this.element);
        const E = h.createElement("div");
        E.classList.add(Ia("c")), this.element.appendChild(E);
        const N = h.createElement("div");
        N.classList.add(Ia("m")), this.element.appendChild(N), this.markerElem_ = N, this.update_();
      }
      update_() {
        const h = this.value.rawValue, [g] = h.getComponents("hsv");
        this.markerElem_.style.backgroundColor = $g(new pt([g, 100, 100], "hsv"));
        const E = Wn(g, 0, 360, 0, 100);
        this.markerElem_.style.left = `${E}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class W {
      constructor(h, g) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = g.value, this.viewProps = g.viewProps, this.view = new Zg(h, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Uo(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(h, g) {
        if (!h.point)
          return;
        const E = Wn(oi(h.point.x, 0, h.bounds.width), 0, h.bounds.width, 0, 360), N = this.value.rawValue, [, ne, be, He] = N.getComponents("hsv");
        this.value.setRawValue(new pt([E, ne, be, He], "hsv"), g);
      }
      onPointerDown_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerMove_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onKeyDown_(h) {
        const g = Pr(Da(!1), Ws(h));
        if (g === 0)
          return;
        const E = this.value.rawValue, [N, ne, be, He] = E.getComponents("hsv");
        this.value.setRawValue(new pt([N + g, ne, be, He], "hsv"), {
          forceEmit: !1,
          last: !1
        });
      }
      onKeyUp_(h) {
        Pr(Da(!1), Ws(h)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    const qo = T("svp"), Yc = 64;
    class os {
      constructor(h, g) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = g.value, this.value.emitter.on("change", this.onValueChange_), this.element = h.createElement("div"), this.element.classList.add(qo()), g.viewProps.bindClassModifiers(this.element), g.viewProps.bindTabIndex(this.element);
        const E = h.createElement("canvas");
        E.height = Yc, E.width = Yc, E.classList.add(qo("c")), this.element.appendChild(E), this.canvasElement = E;
        const N = h.createElement("div");
        N.classList.add(qo("m")), this.element.appendChild(N), this.markerElem_ = N, this.update_();
      }
      update_() {
        const h = F(this.canvasElement);
        if (!h)
          return;
        const E = this.value.rawValue.getComponents("hsv"), N = this.canvasElement.width, ne = this.canvasElement.height, be = h.getImageData(0, 0, N, ne), He = be.data;
        for (let an = 0; an < ne; an++)
          for (let on = 0; on < N; on++) {
            const Yo = Wn(on, 0, N, 0, 100), Ua = Wn(an, 0, ne, 100, 0), Bl = Ug(E[0], Yo, Ua), Ul = (an * N + on) * 4;
            He[Ul] = Bl[0], He[Ul + 1] = Bl[1], He[Ul + 2] = Bl[2], He[Ul + 3] = 255;
          }
        h.putImageData(be, 0, 0);
        const mt = Wn(E[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${mt}%`;
        const Rt = Wn(E[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${Rt}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Jt {
      constructor(h, g) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = g.value, this.viewProps = g.viewProps, this.view = new os(h, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Uo(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(h, g) {
        if (!h.point)
          return;
        const E = Wn(h.point.x, 0, h.bounds.width, 0, 100), N = Wn(h.point.y, 0, h.bounds.height, 100, 0), [ne, , , be] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new pt([ne, E, N, be], "hsv"), g);
      }
      onPointerDown_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerMove_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onKeyDown_(h) {
        Pa(h.key) && h.preventDefault();
        const [g, E, N, ne] = this.value.rawValue.getComponents("hsv"), be = Da(!1), He = Pr(be, Ws(h)), mt = Pr(be, Uc(h));
        He === 0 && mt === 0 || this.value.setRawValue(new pt([g, E + He, N + mt, ne], "hsv"), {
          forceEmit: !1,
          last: !1
        });
      }
      onKeyUp_(h) {
        const g = Da(!1), E = Pr(g, Ws(h)), N = Pr(g, Uc(h));
        E === 0 && N === 0 || this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    class tw {
      constructor(h, g) {
        this.value = g.value, this.viewProps = g.viewProps, this.hPaletteC_ = new W(h, {
          value: this.value,
          viewProps: this.viewProps
        }), this.svPaletteC_ = new Jt(h, {
          value: this.value,
          viewProps: this.viewProps
        }), this.alphaIcs_ = g.supportsAlpha ? {
          palette: new Fh(h, {
            value: this.value,
            viewProps: this.viewProps
          }),
          text: new Aa(h, {
            parser: er,
            baseStep: 0.1,
            props: oe.fromObject({
              draggingScale: 0.01,
              formatter: Wt(2)
            }),
            value: se(0, {
              constraint: new ws({ min: 0, max: 1 })
            }),
            viewProps: this.viewProps
          })
        } : null, this.alphaIcs_ && Bc({
          primary: this.value,
          secondary: this.alphaIcs_.text.value,
          forward: (E) => E.rawValue.getComponents()[3],
          backward: (E, N) => {
            const ne = E.rawValue.getComponents();
            return ne[3] = N.rawValue, new pt(ne, E.rawValue.mode);
          }
        }), this.textC_ = new Bh(h, {
          colorType: g.colorType,
          parser: er,
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new jx(h, {
          alphaViews: this.alphaIcs_ ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view
          } : null,
          hPaletteView: this.hPaletteC_.view,
          supportsAlpha: g.supportsAlpha,
          svPaletteView: this.svPaletteC_.view,
          textView: this.textC_.view,
          viewProps: this.viewProps
        });
      }
      get textController() {
        return this.textC_;
      }
    }
    const Cp = T("colsw");
    class nw {
      constructor(h, g) {
        this.onValueChange_ = this.onValueChange_.bind(this), g.value.emitter.on("change", this.onValueChange_), this.value = g.value, this.element = h.createElement("div"), this.element.classList.add(Cp()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("div");
        E.classList.add(Cp("sw")), this.element.appendChild(E), this.swatchElem_ = E;
        const N = h.createElement("button");
        N.classList.add(Cp("b")), g.viewProps.bindDisabled(N), this.element.appendChild(N), this.buttonElement = N, this.update_();
      }
      update_() {
        const h = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = Nh(h);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Oa {
      constructor(h, g) {
        this.value = g.value, this.viewProps = g.viewProps, this.view = new nw(h, {
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    class Tp {
      constructor(h, g) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = g.value, this.viewProps = g.viewProps, this.foldable_ = pe.create(g.expanded), this.swatchC_ = new Oa(h, {
          value: this.value,
          viewProps: this.viewProps
        });
        const E = this.swatchC_.view.buttonElement;
        E.addEventListener("blur", this.onButtonBlur_), E.addEventListener("click", this.onButtonClick_), this.textC_ = new Mh(h, {
          parser: g.parser,
          props: oe.fromObject({
            formatter: g.formatter
          }),
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new Ll(h, {
          foldable: this.foldable_,
          pickerLayout: g.pickerLayout
        }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = g.pickerLayout === "popup" ? new yg(h, {
          viewProps: this.viewProps
        }) : null;
        const N = new tw(h, {
          colorType: g.colorType,
          supportsAlpha: g.supportsAlpha,
          value: this.value,
          viewProps: this.viewProps
        });
        N.view.allFocusableElements.forEach((ne) => {
          ne.addEventListener("blur", this.onPopupChildBlur_), ne.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = N, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(N.view.element), Bc({
          primary: this.foldable_.value("expanded"),
          secondary: this.popC_.shows,
          forward: (ne) => ne.rawValue,
          backward: (ne, be) => be.rawValue
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), tt(this.foldable_, this.view.pickerElement));
      }
      get textController() {
        return this.textC_;
      }
      onButtonBlur_(h) {
        if (!this.popC_)
          return;
        const g = this.view.element, E = h.relatedTarget;
        (!E || !g.contains(E)) && (this.popC_.shows.rawValue = !1);
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(h) {
        if (!this.popC_)
          return;
        const g = this.popC_.view.element, E = Me(h);
        E && g.contains(E) || E && E === this.swatchC_.view.buttonElement && !re(g.ownerDocument) || (this.popC_.shows.rawValue = !1);
      }
      onPopupChildKeydown_(h) {
        this.popC_ ? h.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && h.key === "Escape" && this.swatchC_.view.buttonElement.focus();
      }
    }
    function iw(_, h) {
      return pt.isColorObject(_) ? pt.fromObject(_, h) : pt.black(h);
    }
    function rw(_) {
      return ka(_.getComponents("rgb")).reduce((h, g) => h << 8 | Math.floor(g) & 255, 0);
    }
    function sw(_) {
      return _.getComponents("rgb").reduce((h, g, E) => {
        const N = Math.floor(E === 3 ? g * 255 : g) & 255;
        return h << 8 | N;
      }, 0) >>> 0;
    }
    function ow(_) {
      return new pt([_ >> 16 & 255, _ >> 8 & 255, _ & 255], "rgb");
    }
    function fo(_) {
      return new pt([
        _ >> 24 & 255,
        _ >> 16 & 255,
        _ >> 8 & 255,
        Wn(_ & 255, 0, 255, 0, 1)
      ], "rgb");
    }
    function aw(_) {
      return typeof _ != "number" ? pt.black() : ow(_);
    }
    function lw(_) {
      return typeof _ != "number" ? pt.black() : fo(_);
    }
    function cw(_) {
      const h = jo(_);
      return h ? (g, E) => {
        Al(g, h(E));
      } : null;
    }
    function uw(_) {
      const h = _ ? sw : rw;
      return (g, E) => {
        Al(g, h(E));
      };
    }
    function hw(_, h, g) {
      const E = h.toRgbaObject(g);
      _.writeProperty("r", E.r), _.writeProperty("g", E.g), _.writeProperty("b", E.b), _.writeProperty("a", E.a);
    }
    function po(_, h, g) {
      const E = h.toRgbaObject(g);
      _.writeProperty("r", E.r), _.writeProperty("g", E.g), _.writeProperty("b", E.b);
    }
    function dw(_, h) {
      return (g, E) => {
        _ ? hw(g, E, h) : po(g, E, h);
      };
    }
    function Pp(_) {
      var h;
      return !!((_ == null ? void 0 : _.alpha) || ((h = _ == null ? void 0 : _.color) === null || h === void 0 ? void 0 : h.alpha));
    }
    function fw(_) {
      return _ ? (h) => Nh(h, "0x") : (h) => Xg(h, "0x");
    }
    function pw(_) {
      return "color" in _ || "view" in _ && _.view === "color";
    }
    const mw = {
      id: "input-color-number",
      type: "input",
      accept: (_, h) => {
        if (typeof _ != "number" || !pw(h))
          return null;
        const g = Dl(h);
        return g ? {
          initialValue: _,
          params: g
        } : null;
      },
      binding: {
        reader: (_) => Pp(_.params) ? lw : aw,
        equals: pt.equals,
        writer: (_) => uw(Pp(_.params))
      },
      controller: (_) => {
        const h = Pp(_.params), g = "expanded" in _.params ? _.params.expanded : void 0, E = "picker" in _.params ? _.params.picker : void 0;
        return new Tp(_.document, {
          colorType: "int",
          expanded: g != null ? g : !1,
          formatter: fw(h),
          parser: Ol("int"),
          pickerLayout: E != null ? E : "popup",
          supportsAlpha: h,
          value: _.value,
          viewProps: _.viewProps
        });
      }
    };
    function Na(_) {
      return pt.isRgbaColorObject(_);
    }
    function vw(_) {
      return (h) => iw(h, _);
    }
    function gw(_, h) {
      return (g) => _ ? zh(g, h) : Sp(g, h);
    }
    const Es = {
      id: "input-color-object",
      type: "input",
      accept: (_, h) => {
        if (!pt.isColorObject(_))
          return null;
        const g = Dl(h);
        return g ? {
          initialValue: _,
          params: g
        } : null;
      },
      binding: {
        reader: (_) => vw(ss(_.params)),
        equals: pt.equals,
        writer: (_) => dw(Na(_.initialValue), ss(_.params))
      },
      controller: (_) => {
        var h;
        const g = pt.isRgbaColorObject(_.initialValue), E = "expanded" in _.params ? _.params.expanded : void 0, N = "picker" in _.params ? _.params.picker : void 0, ne = (h = ss(_.params)) !== null && h !== void 0 ? h : "int";
        return new Tp(_.document, {
          colorType: ne,
          expanded: E != null ? E : !1,
          formatter: gw(g, ne),
          parser: Ol(ne),
          pickerLayout: N != null ? N : "popup",
          supportsAlpha: g,
          value: _.value,
          viewProps: _.viewProps
        });
      }
    }, _w = {
      id: "input-color-string",
      type: "input",
      accept: (_, h) => {
        if (typeof _ != "string" || "view" in h && h.view === "text")
          return null;
        const g = wp(_, ss(h));
        if (!g || !jo(g))
          return null;
        const N = Dl(h);
        return N ? {
          initialValue: _,
          params: N
        } : null;
      },
      binding: {
        reader: (_) => {
          var h;
          return Ih((h = ss(_.params)) !== null && h !== void 0 ? h : "int");
        },
        equals: pt.equals,
        writer: (_) => {
          const h = wp(_.initialValue, ss(_.params));
          if (!h)
            throw x.shouldNeverHappen();
          const g = cw(h);
          if (!g)
            throw x.notBindable();
          return g;
        }
      },
      controller: (_) => {
        const h = wp(_.initialValue, ss(_.params));
        if (!h)
          throw x.shouldNeverHappen();
        const g = jo(h);
        if (!g)
          throw x.shouldNeverHappen();
        const E = "expanded" in _.params ? _.params.expanded : void 0, N = "picker" in _.params ? _.params.picker : void 0;
        return new Tp(_.document, {
          colorType: h.type,
          expanded: E != null ? E : !1,
          formatter: g,
          parser: Ol(h.type),
          pickerLayout: N != null ? N : "popup",
          supportsAlpha: h.alpha,
          value: _.value,
          viewProps: _.viewProps
        });
      }
    };
    class Xo {
      constructor(h) {
        this.components = h.components, this.asm_ = h.assembly;
      }
      constrain(h) {
        const g = this.asm_.toComponents(h).map((E, N) => {
          var ne, be;
          return (be = (ne = this.components[N]) === null || ne === void 0 ? void 0 : ne.constrain(E)) !== null && be !== void 0 ? be : E;
        });
        return this.asm_.fromComponents(g);
      }
    }
    const Yg = T("pndtxt");
    class bw {
      constructor(h, g) {
        this.textViews = g.textViews, this.element = h.createElement("div"), this.element.classList.add(Yg()), this.textViews.forEach((E) => {
          const N = h.createElement("div");
          N.classList.add(Yg("a")), N.appendChild(E.element), this.element.appendChild(N);
        });
      }
    }
    function yw(_, h, g) {
      return new Aa(_, {
        arrayPosition: g === 0 ? "fst" : g === h.axes.length - 1 ? "lst" : "mid",
        baseStep: h.axes[g].baseStep,
        parser: h.parser,
        props: h.axes[g].textProps,
        value: se(0, {
          constraint: h.axes[g].constraint
        }),
        viewProps: h.viewProps
      });
    }
    class Uh {
      constructor(h, g) {
        this.value = g.value, this.viewProps = g.viewProps, this.acs_ = g.axes.map((E, N) => yw(h, g, N)), this.acs_.forEach((E, N) => {
          Bc({
            primary: this.value,
            secondary: E.value,
            forward: (ne) => g.assembly.toComponents(ne.rawValue)[N],
            backward: (ne, be) => {
              const He = g.assembly.toComponents(ne.rawValue);
              return He[N] = be.rawValue, g.assembly.fromComponents(He);
            }
          });
        }), this.view = new bw(h, {
          textViews: this.acs_.map((E) => E.view)
        });
      }
    }
    function Ap(_, h) {
      return "step" in _ && !p(_.step) ? new wh(_.step, h) : null;
    }
    function Kg(_) {
      return !p(_.max) && !p(_.min) ? new ws({
        max: _.max,
        min: _.min
      }) : !p(_.max) || !p(_.min) ? new rp({
        max: _.max,
        min: _.min
      }) : null;
    }
    function xw(_) {
      const h = xs(_, ws);
      if (h)
        return [h.values.get("min"), h.values.get("max")];
      const g = xs(_, rp);
      return g ? [g.minValue, g.maxValue] : [void 0, void 0];
    }
    function Rp(_, h) {
      const g = [], E = Ap(_, h);
      E && g.push(E);
      const N = Kg(_);
      N && g.push(N);
      const ne = gp(_.options);
      return ne && g.push(ne), new Ca(g);
    }
    const Kc = {
      id: "input-number",
      type: "input",
      accept: (_, h) => {
        if (typeof _ != "number")
          return null;
        const g = ye, E = Se(h, {
          format: g.optional.function,
          max: g.optional.number,
          min: g.optional.number,
          options: g.optional.custom(Ph),
          step: g.optional.number
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        reader: (_) => zc,
        constraint: (_) => Rp(_.params, _.initialValue),
        writer: (_) => Al
      },
      controller: (_) => {
        var h;
        const g = _.value, E = _.constraint, N = E && xs(E, Cl);
        if (N)
          return new Tl(_.document, {
            props: new oe({
              options: N.values.value("options")
            }),
            value: g,
            viewProps: _.viewProps
          });
        const ne = (h = "format" in _.params ? _.params.format : void 0) !== null && h !== void 0 ? h : Wt(Ah(E, g.rawValue)), be = E && xs(E, ws);
        return be ? new Th(_.document, {
          baseStep: kl(E),
          parser: er,
          sliderProps: new oe({
            maxValue: be.values.value("max"),
            minValue: be.values.value("min")
          }),
          textProps: oe.fromObject({
            draggingScale: Ho(E, g.rawValue),
            formatter: ne
          }),
          value: g,
          viewProps: _.viewProps
        }) : new Aa(_.document, {
          baseStep: kl(E),
          parser: er,
          props: oe.fromObject({
            draggingScale: Ho(E, g.rawValue),
            formatter: ne
          }),
          value: g,
          viewProps: _.viewProps
        });
      }
    };
    class Cs {
      constructor(h = 0, g = 0) {
        this.x = h, this.y = g;
      }
      getComponents() {
        return [this.x, this.y];
      }
      static isObject(h) {
        if (p(h))
          return !1;
        const g = h.x, E = h.y;
        return !(typeof g != "number" || typeof E != "number");
      }
      static equals(h, g) {
        return h.x === g.x && h.y === g.y;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y
        };
      }
    }
    const Jg = {
      toComponents: (_) => _.getComponents(),
      fromComponents: (_) => new Cs(..._)
    }, za = T("p2d");
    class ww {
      constructor(h, g) {
        this.element = h.createElement("div"), this.element.classList.add(za()), g.viewProps.bindClassModifiers(this.element), I(g.expanded, B(this.element, za(void 0, "expanded")));
        const E = h.createElement("div");
        E.classList.add(za("h")), this.element.appendChild(E);
        const N = h.createElement("button");
        N.classList.add(za("b")), N.appendChild(he(h, "p2dpad")), g.viewProps.bindDisabled(N), E.appendChild(N), this.buttonElement = N;
        const ne = h.createElement("div");
        if (ne.classList.add(za("t")), E.appendChild(ne), this.textElement = ne, g.pickerLayout === "inline") {
          const be = h.createElement("div");
          be.classList.add(za("p")), this.element.appendChild(be), this.pickerElement = be;
        } else
          this.pickerElement = null;
      }
    }
    const nr = T("p2dp");
    class kp {
      constructor(h, g) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = g.invertsY, this.maxValue_ = g.maxValue, this.element = h.createElement("div"), this.element.classList.add(nr()), g.layout === "popup" && this.element.classList.add(nr(void 0, "p")), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("div");
        E.classList.add(nr("p")), g.viewProps.bindTabIndex(E), this.element.appendChild(E), this.padElement = E;
        const N = h.createElementNS(ae, "svg");
        N.classList.add(nr("g")), this.padElement.appendChild(N), this.svgElem_ = N;
        const ne = h.createElementNS(ae, "line");
        ne.classList.add(nr("ax")), ne.setAttributeNS(null, "x1", "0"), ne.setAttributeNS(null, "y1", "50%"), ne.setAttributeNS(null, "x2", "100%"), ne.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(ne);
        const be = h.createElementNS(ae, "line");
        be.classList.add(nr("ax")), be.setAttributeNS(null, "x1", "50%"), be.setAttributeNS(null, "y1", "0"), be.setAttributeNS(null, "x2", "50%"), be.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(be);
        const He = h.createElementNS(ae, "line");
        He.classList.add(nr("l")), He.setAttributeNS(null, "x1", "50%"), He.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(He), this.lineElem_ = He;
        const mt = h.createElement("div");
        mt.classList.add(nr("m")), this.padElement.appendChild(mt), this.markerElem_ = mt, g.value.emitter.on("change", this.onValueChange_), this.value = g.value, this.update_();
      }
      get allFocusableElements() {
        return [this.padElement];
      }
      update_() {
        const [h, g] = this.value.rawValue.getComponents(), E = this.maxValue_, N = Wn(h, -E, +E, 0, 100), ne = Wn(g, -E, +E, 0, 100), be = this.invertsY_ ? 100 - ne : ne;
        this.lineElem_.setAttributeNS(null, "x2", `${N}%`), this.lineElem_.setAttributeNS(null, "y2", `${be}%`), this.markerElem_.style.left = `${N}%`, this.markerElem_.style.top = `${be}%`;
      }
      onValueChange_() {
        this.update_();
      }
      onFoldableChange_() {
        this.update_();
      }
    }
    function $o(_, h, g) {
      return [
        Pr(h[0], Ws(_)),
        Pr(h[1], Uc(_)) * (g ? 1 : -1)
      ];
    }
    class as {
      constructor(h, g) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = g.value, this.viewProps = g.viewProps, this.baseSteps_ = g.baseSteps, this.maxValue_ = g.maxValue, this.invertsY_ = g.invertsY, this.view = new kp(h, {
          invertsY: this.invertsY_,
          layout: g.layout,
          maxValue: this.maxValue_,
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new Uo(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
      }
      handlePointerEvent_(h, g) {
        if (!h.point)
          return;
        const E = this.maxValue_, N = Wn(h.point.x, 0, h.bounds.width, -E, +E), ne = Wn(this.invertsY_ ? h.bounds.height - h.point.y : h.point.y, 0, h.bounds.height, -E, +E);
        this.value.setRawValue(new Cs(N, ne), g);
      }
      onPointerDown_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerMove_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !1,
          last: !1
        });
      }
      onPointerUp_(h) {
        this.handlePointerEvent_(h.data, {
          forceEmit: !0,
          last: !0
        });
      }
      onPadKeyDown_(h) {
        Pa(h.key) && h.preventDefault();
        const [g, E] = $o(h, this.baseSteps_, this.invertsY_);
        g === 0 && E === 0 || this.value.setRawValue(new Cs(this.value.rawValue.x + g, this.value.rawValue.y + E), {
          forceEmit: !1,
          last: !1
        });
      }
      onPadKeyUp_(h) {
        const [g, E] = $o(h, this.baseSteps_, this.invertsY_);
        g === 0 && E === 0 || this.value.setRawValue(this.value.rawValue, {
          forceEmit: !0,
          last: !0
        });
      }
    }
    class Sw {
      constructor(h, g) {
        var E, N;
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = g.value, this.viewProps = g.viewProps, this.foldable_ = pe.create(g.expanded), this.popC_ = g.pickerLayout === "popup" ? new yg(h, {
          viewProps: this.viewProps
        }) : null;
        const ne = new as(h, {
          baseSteps: [g.axes[0].baseStep, g.axes[1].baseStep],
          invertsY: g.invertsY,
          layout: g.pickerLayout,
          maxValue: g.maxValue,
          value: this.value,
          viewProps: this.viewProps
        });
        ne.view.allFocusableElements.forEach((be) => {
          be.addEventListener("blur", this.onPopupChildBlur_), be.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = ne, this.textC_ = new Uh(h, {
          assembly: Jg,
          axes: g.axes,
          parser: g.parser,
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new ww(h, {
          expanded: this.foldable_.value("expanded"),
          pickerLayout: g.pickerLayout,
          viewProps: this.viewProps
        }), this.view.textElement.appendChild(this.textC_.view.element), (E = this.view.buttonElement) === null || E === void 0 || E.addEventListener("blur", this.onPadButtonBlur_), (N = this.view.buttonElement) === null || N === void 0 || N.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Bc({
          primary: this.foldable_.value("expanded"),
          secondary: this.popC_.shows,
          forward: (be) => be.rawValue,
          backward: (be, He) => He.rawValue
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), tt(this.foldable_, this.view.pickerElement));
      }
      onPadButtonBlur_(h) {
        if (!this.popC_)
          return;
        const g = this.view.element, E = h.relatedTarget;
        (!E || !g.contains(E)) && (this.popC_.shows.rawValue = !1);
      }
      onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(h) {
        if (!this.popC_)
          return;
        const g = this.popC_.view.element, E = Me(h);
        E && g.contains(E) || E && E === this.view.buttonElement && !re(g.ownerDocument) || (this.popC_.shows.rawValue = !1);
      }
      onPopupChildKeydown_(h) {
        this.popC_ ? h.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && h.key === "Escape" && this.view.buttonElement.focus();
      }
    }
    class Fa {
      constructor(h = 0, g = 0, E = 0) {
        this.x = h, this.y = g, this.z = E;
      }
      getComponents() {
        return [this.x, this.y, this.z];
      }
      static isObject(h) {
        if (p(h))
          return !1;
        const g = h.x, E = h.y, N = h.z;
        return !(typeof g != "number" || typeof E != "number" || typeof N != "number");
      }
      static equals(h, g) {
        return h.x === g.x && h.y === g.y && h.z === g.z;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y,
          z: this.z
        };
      }
    }
    const Lp = {
      toComponents: (_) => _.getComponents(),
      fromComponents: (_) => new Fa(..._)
    };
    function Jc(_) {
      return Fa.isObject(_) ? new Fa(_.x, _.y, _.z) : new Fa();
    }
    function Zo(_, h) {
      _.writeProperty("x", h.x), _.writeProperty("y", h.y), _.writeProperty("z", h.z);
    }
    function Qg(_, h) {
      return new Xo({
        assembly: Lp,
        components: [
          Xs("x" in _ ? _.x : void 0, h.x),
          Xs("y" in _ ? _.y : void 0, h.y),
          Xs("z" in _ ? _.z : void 0, h.z)
        ]
      });
    }
    function Dp(_, h) {
      return {
        baseStep: kl(h),
        constraint: h,
        textProps: oe.fromObject({
          draggingScale: Ho(h, _),
          formatter: Wt(Ah(h, _))
        })
      };
    }
    const Vh = {
      id: "input-point3d",
      type: "input",
      accept: (_, h) => {
        if (!Fa.isObject(_))
          return null;
        const g = ye, E = Se(h, {
          x: g.optional.custom(Vo),
          y: g.optional.custom(Vo),
          z: g.optional.custom(Vo)
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        reader: (_) => Jc,
        constraint: (_) => Qg(_.params, _.initialValue),
        equals: Fa.equals,
        writer: (_) => Zo
      },
      controller: (_) => {
        const h = _.value, g = _.constraint;
        if (!(g instanceof Xo))
          throw x.shouldNeverHappen();
        return new Uh(_.document, {
          assembly: Lp,
          axes: [
            Dp(h.rawValue.x, g.components[0]),
            Dp(h.rawValue.y, g.components[1]),
            Dp(h.rawValue.z, g.components[2])
          ],
          parser: er,
          value: h,
          viewProps: _.viewProps
        });
      }
    };
    class Nl {
      constructor(h = 0, g = 0, E = 0, N = 0) {
        this.x = h, this.y = g, this.z = E, this.w = N;
      }
      getComponents() {
        return [this.x, this.y, this.z, this.w];
      }
      static isObject(h) {
        if (p(h))
          return !1;
        const g = h.x, E = h.y, N = h.z, ne = h.w;
        return !(typeof g != "number" || typeof E != "number" || typeof N != "number" || typeof ne != "number");
      }
      static equals(h, g) {
        return h.x === g.x && h.y === g.y && h.z === g.z && h.w === g.w;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y,
          z: this.z,
          w: this.w
        };
      }
    }
    const Ip = {
      toComponents: (_) => _.getComponents(),
      fromComponents: (_) => new Nl(..._)
    };
    function zi(_) {
      return Nl.isObject(_) ? new Nl(_.x, _.y, _.z, _.w) : new Nl();
    }
    function Op(_, h) {
      _.writeProperty("x", h.x), _.writeProperty("y", h.y), _.writeProperty("z", h.z), _.writeProperty("w", h.w);
    }
    function e0(_, h) {
      return new Xo({
        assembly: Ip,
        components: [
          Xs("x" in _ ? _.x : void 0, h.x),
          Xs("y" in _ ? _.y : void 0, h.y),
          Xs("z" in _ ? _.z : void 0, h.z),
          Xs("w" in _ ? _.w : void 0, h.w)
        ]
      });
    }
    function qs(_, h) {
      return {
        baseStep: kl(h),
        constraint: h,
        textProps: oe.fromObject({
          draggingScale: Ho(h, _),
          formatter: Wt(Ah(h, _))
        })
      };
    }
    const Np = {
      id: "input-point4d",
      type: "input",
      accept: (_, h) => {
        if (!Nl.isObject(_))
          return null;
        const g = ye, E = Se(h, {
          x: g.optional.custom(Vo),
          y: g.optional.custom(Vo),
          z: g.optional.custom(Vo),
          w: g.optional.custom(Vo)
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        reader: (_) => zi,
        constraint: (_) => e0(_.params, _.initialValue),
        equals: Nl.equals,
        writer: (_) => Op
      },
      controller: (_) => {
        const h = _.value, g = _.constraint;
        if (!(g instanceof Xo))
          throw x.shouldNeverHappen();
        return new Uh(_.document, {
          assembly: Ip,
          axes: h.rawValue.getComponents().map((E, N) => qs(E, g.components[N])),
          parser: er,
          value: h,
          viewProps: _.viewProps
        });
      }
    };
    function Hh(_) {
      const h = [], g = gp(_.options);
      return g && h.push(g), new Ca(h);
    }
    const Ba = {
      id: "input-string",
      type: "input",
      accept: (_, h) => {
        if (typeof _ != "string")
          return null;
        const E = Se(h, {
          options: ye.optional.custom(Ph)
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        reader: (_) => Og,
        constraint: (_) => Hh(_.params),
        writer: (_) => Al
      },
      controller: (_) => {
        const h = _.document, g = _.value, E = _.constraint, N = E && xs(E, Cl);
        return N ? new Tl(h, {
          props: new oe({
            options: N.values.value("options")
          }),
          value: g,
          viewProps: _.viewProps
        }) : new Mh(h, {
          parser: (ne) => ne,
          props: oe.fromObject({
            formatter: Fc
          }),
          value: g,
          viewProps: _.viewProps
        });
      }
    }, zl = {
      monitor: {
        defaultInterval: 200,
        defaultLineCount: 3
      }
    }, ir = T("mll");
    class zp {
      constructor(h, g) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = g.formatter, this.element = h.createElement("div"), this.element.classList.add(ir()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("textarea");
        E.classList.add(ir("i")), E.style.height = `calc(var(--bld-us) * ${g.lineCount})`, E.readOnly = !0, g.viewProps.bindDisabled(E), this.element.appendChild(E), this.textareaElem_ = E, g.value.emitter.on("change", this.onValueUpdate_), this.value = g.value, this.update_();
      }
      update_() {
        const h = this.textareaElem_, g = h.scrollTop === h.scrollHeight - h.clientHeight, E = [];
        this.value.rawValue.forEach((N) => {
          N !== void 0 && E.push(this.formatter_(N));
        }), h.textContent = E.join(`
`), g && (h.scrollTop = h.scrollHeight);
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class Fp {
      constructor(h, g) {
        this.value = g.value, this.viewProps = g.viewProps, this.view = new zp(h, {
          formatter: g.formatter,
          lineCount: g.lineCount,
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    const t0 = T("sgl");
    class Mw {
      constructor(h, g) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = g.formatter, this.element = h.createElement("div"), this.element.classList.add(t0()), g.viewProps.bindClassModifiers(this.element);
        const E = h.createElement("input");
        E.classList.add(t0("i")), E.readOnly = !0, E.type = "text", g.viewProps.bindDisabled(E), this.element.appendChild(E), this.inputElement = E, g.value.emitter.on("change", this.onValueUpdate_), this.value = g.value, this.update_();
      }
      update_() {
        const h = this.value.rawValue, g = h[h.length - 1];
        this.inputElement.value = g !== void 0 ? this.formatter_(g) : "";
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class Qc {
      constructor(h, g) {
        this.value = g.value, this.viewProps = g.viewProps, this.view = new Mw(h, {
          formatter: g.formatter,
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    const Ew = {
      id: "monitor-bool",
      type: "monitor",
      accept: (_, h) => {
        if (typeof _ != "boolean")
          return null;
        const E = Se(h, {
          lineCount: ye.optional.number
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        reader: (_) => Sg
      },
      controller: (_) => {
        var h;
        return _.value.rawValue.length === 1 ? new Qc(_.document, {
          formatter: Mg,
          value: _.value,
          viewProps: _.viewProps
        }) : new Fp(_.document, {
          formatter: Mg,
          lineCount: (h = _.params.lineCount) !== null && h !== void 0 ? h : zl.monitor.defaultLineCount,
          value: _.value,
          viewProps: _.viewProps
        });
      }
    }, ls = T("grl");
    class n0 {
      constructor(h, g) {
        this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = h.createElement("div"), this.element.classList.add(ls()), g.viewProps.bindClassModifiers(this.element), this.formatter_ = g.formatter, this.props_ = g.props, this.cursor_ = g.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
        const E = h.createElementNS(ae, "svg");
        E.classList.add(ls("g")), E.style.height = `calc(var(--bld-us) * ${g.lineCount})`, this.element.appendChild(E), this.svgElem_ = E;
        const N = h.createElementNS(ae, "polyline");
        this.svgElem_.appendChild(N), this.lineElem_ = N;
        const ne = h.createElement("div");
        ne.classList.add(ls("t"), T("tt")()), this.element.appendChild(ne), this.tooltipElem_ = ne, g.value.emitter.on("change", this.onValueUpdate_), this.value = g.value, this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const h = this.svgElem_.getBoundingClientRect(), g = this.value.rawValue.length - 1, E = this.props_.get("minValue"), N = this.props_.get("maxValue"), ne = [];
        this.value.rawValue.forEach((an, on) => {
          if (an === void 0)
            return;
          const Yo = Wn(on, 0, g, 0, h.width), Ua = Wn(an, E, N, h.height, 0);
          ne.push([Yo, Ua].join(","));
        }), this.lineElem_.setAttributeNS(null, "points", ne.join(" "));
        const be = this.tooltipElem_, He = this.value.rawValue[this.cursor_.rawValue];
        if (He === void 0) {
          be.classList.remove(ls("t", "a"));
          return;
        }
        const mt = Wn(this.cursor_.rawValue, 0, g, 0, h.width), Rt = Wn(He, E, N, h.height, 0);
        be.style.left = `${mt}px`, be.style.top = `${Rt}px`, be.textContent = `${this.formatter_(He)}`, be.classList.contains(ls("t", "a")) || (be.classList.add(ls("t", "a"), ls("t", "in")), $(be), be.classList.remove(ls("t", "in")));
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class Cw {
      constructor(h, g) {
        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = g.props, this.value = g.value, this.viewProps = g.viewProps, this.cursor_ = se(-1), this.view = new n0(h, {
          cursor: this.cursor_,
          formatter: g.formatter,
          lineCount: g.lineCount,
          props: this.props_,
          value: this.value,
          viewProps: this.viewProps
        }), !re(h))
          this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
        else {
          const E = new Uo(this.view.element);
          E.emitter.on("down", this.onGraphPointerDown_), E.emitter.on("move", this.onGraphPointerMove_), E.emitter.on("up", this.onGraphPointerUp_);
        }
      }
      onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
      }
      onGraphMouseMove_(h) {
        const g = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(Wn(h.offsetX, 0, g.width, 0, this.value.rawValue.length));
      }
      onGraphPointerDown_(h) {
        this.onGraphPointerMove_(h);
      }
      onGraphPointerMove_(h) {
        if (!h.data.point) {
          this.cursor_.rawValue = -1;
          return;
        }
        this.cursor_.rawValue = Math.floor(Wn(h.data.point.x, 0, h.data.bounds.width, 0, this.value.rawValue.length));
      }
      onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
      }
    }
    function Bp(_) {
      return "format" in _ && !p(_.format) ? _.format : Wt(2);
    }
    function eu(_) {
      var h;
      return _.value.rawValue.length === 1 ? new Qc(_.document, {
        formatter: Bp(_.params),
        value: _.value,
        viewProps: _.viewProps
      }) : new Fp(_.document, {
        formatter: Bp(_.params),
        lineCount: (h = _.params.lineCount) !== null && h !== void 0 ? h : zl.monitor.defaultLineCount,
        value: _.value,
        viewProps: _.viewProps
      });
    }
    function Tw(_) {
      var h, g, E;
      return new Cw(_.document, {
        formatter: Bp(_.params),
        lineCount: (h = _.params.lineCount) !== null && h !== void 0 ? h : zl.monitor.defaultLineCount,
        props: oe.fromObject({
          maxValue: (g = "max" in _.params ? _.params.max : null) !== null && g !== void 0 ? g : 100,
          minValue: (E = "min" in _.params ? _.params.min : null) !== null && E !== void 0 ? E : 0
        }),
        value: _.value,
        viewProps: _.viewProps
      });
    }
    function i0(_) {
      return "view" in _ && _.view === "graph";
    }
    const Up = {
      id: "monitor-number",
      type: "monitor",
      accept: (_, h) => {
        if (typeof _ != "number")
          return null;
        const g = ye, E = Se(h, {
          format: g.optional.function,
          lineCount: g.optional.number,
          max: g.optional.number,
          min: g.optional.number,
          view: g.optional.string
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        defaultBufferSize: (_) => i0(_) ? 64 : 1,
        reader: (_) => zc
      },
      controller: (_) => i0(_.params) ? Tw(_) : eu(_)
    }, r0 = {
      id: "monitor-string",
      type: "monitor",
      accept: (_, h) => {
        if (typeof _ != "string")
          return null;
        const g = ye, E = Se(h, {
          lineCount: g.optional.number,
          multiline: g.optional.boolean
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        reader: (_) => Og
      },
      controller: (_) => {
        var h;
        const g = _.value;
        return g.rawValue.length > 1 || "multiline" in _.params && _.params.multiline ? new Fp(_.document, {
          formatter: Fc,
          lineCount: (h = _.params.lineCount) !== null && h !== void 0 ? h : zl.monitor.defaultLineCount,
          value: g,
          viewProps: _.viewProps
        }) : new Qc(_.document, {
          formatter: Fc,
          value: g,
          viewProps: _.viewProps
        });
      }
    };
    function Pw(_, h) {
      var g;
      const E = _.accept(h.target.read(), h.params);
      if (p(E))
        return null;
      const N = ye, ne = {
        target: h.target,
        initialValue: E.initialValue,
        params: E.params
      }, be = _.binding.reader(ne), He = _.binding.constraint ? _.binding.constraint(ne) : void 0, mt = se(be(E.initialValue), {
        constraint: He,
        equals: _.binding.equals
      }), Rt = new Tx({
        reader: be,
        target: h.target,
        value: mt,
        writer: _.binding.writer(ne)
      }), an = N.optional.boolean(h.params.disabled).value, on = N.optional.boolean(h.params.hidden).value, Yo = _.controller({
        constraint: He,
        document: h.document,
        initialValue: E.initialValue,
        params: E.params,
        value: Rt.value,
        viewProps: st.create({
          disabled: an,
          hidden: on
        })
      });
      return new Gn(h.document, {
        binding: Rt,
        blade: Bt(),
        props: oe.fromObject({
          label: "label" in h.params ? (g = N.optional.string(h.params.label).value) !== null && g !== void 0 ? g : null : h.target.key
        }),
        valueController: Yo
      });
    }
    function Aw(_, h) {
      return h === 0 ? new xh() : new vg(_, h != null ? h : zl.monitor.defaultInterval);
    }
    function Rw(_, h) {
      var g, E, N;
      const ne = ye, be = _.accept(h.target.read(), h.params);
      if (p(be))
        return null;
      const He = {
        target: h.target,
        initialValue: be.initialValue,
        params: be.params
      }, mt = _.binding.reader(He), Rt = (E = (g = ne.optional.number(h.params.bufferSize).value) !== null && g !== void 0 ? g : _.binding.defaultBufferSize && _.binding.defaultBufferSize(be.params)) !== null && E !== void 0 ? E : 1, an = ne.optional.number(h.params.interval).value, on = new _g({
        reader: mt,
        target: h.target,
        ticker: Aw(h.document, an),
        value: gg(Rt)
      }), Yo = ne.optional.boolean(h.params.disabled).value, Ua = ne.optional.boolean(h.params.hidden).value, Bl = _.controller({
        document: h.document,
        params: be.params,
        value: on.value,
        viewProps: st.create({
          disabled: Yo,
          hidden: Ua
        })
      });
      return new pr(h.document, {
        binding: on,
        blade: Bt(),
        props: oe.fromObject({
          label: "label" in h.params ? (N = ne.optional.string(h.params.label).value) !== null && N !== void 0 ? N : null : h.target.key
        }),
        valueController: Bl
      });
    }
    class s0 {
      constructor() {
        this.pluginsMap_ = {
          blades: [],
          inputs: [],
          monitors: []
        };
      }
      getAll() {
        return [
          ...this.pluginsMap_.blades,
          ...this.pluginsMap_.inputs,
          ...this.pluginsMap_.monitors
        ];
      }
      register(h) {
        h.type === "blade" ? this.pluginsMap_.blades.unshift(h) : h.type === "input" ? this.pluginsMap_.inputs.unshift(h) : h.type === "monitor" && this.pluginsMap_.monitors.unshift(h);
      }
      createInput(h, g, E) {
        const N = g.read();
        if (p(N))
          throw new x({
            context: {
              key: g.key
            },
            type: "nomatchingcontroller"
          });
        const ne = this.pluginsMap_.inputs.reduce((be, He) => be != null ? be : Pw(He, {
          document: h,
          target: g,
          params: E
        }), null);
        if (ne)
          return ne;
        throw new x({
          context: {
            key: g.key
          },
          type: "nomatchingcontroller"
        });
      }
      createMonitor(h, g, E) {
        const N = this.pluginsMap_.monitors.reduce((ne, be) => ne != null ? ne : Rw(be, {
          document: h,
          params: E,
          target: g
        }), null);
        if (N)
          return N;
        throw new x({
          context: {
            key: g.key
          },
          type: "nomatchingcontroller"
        });
      }
      createBlade(h, g) {
        const E = this.pluginsMap_.blades.reduce((N, ne) => N != null ? N : mg(ne, {
          document: h,
          params: g
        }), null);
        if (!E)
          throw new x({
            type: "nomatchingview",
            context: {
              params: g
            }
          });
        return E;
      }
      createBladeApi(h) {
        if (h instanceof Gn)
          return new Yi(h);
        if (h instanceof pr)
          return new Ma(h);
        if (h instanceof Yt)
          return new wt(h, this);
        const g = this.pluginsMap_.blades.reduce((E, N) => E != null ? E : N.api({
          controller: h,
          pool: this
        }), null);
        if (!g)
          throw x.shouldNeverHappen();
        return g;
      }
    }
    function Vp() {
      const _ = new s0();
      return [
        c0,
        Vh,
        Np,
        Ba,
        Kc,
        _w,
        Es,
        mw,
        Vx,
        Ew,
        r0,
        Up,
        Mt,
        ao,
        Qn,
        pg
      ].forEach((h) => {
        _.register(h);
      }), _;
    }
    function kw(_) {
      return Cs.isObject(_) ? new Cs(_.x, _.y) : new Cs();
    }
    function Hp(_, h) {
      _.writeProperty("x", h.x), _.writeProperty("y", h.y);
    }
    function Xs(_, h) {
      if (!_)
        return;
      const g = [], E = Ap(_, h);
      E && g.push(E);
      const N = Kg(_);
      return N && g.push(N), new Ca(g);
    }
    function o0(_, h) {
      return new Xo({
        assembly: Jg,
        components: [
          Xs("x" in _ ? _.x : void 0, h.x),
          Xs("y" in _ ? _.y : void 0, h.y)
        ]
      });
    }
    function Gp(_, h) {
      const [g, E] = _ ? xw(_) : [];
      if (!p(g) || !p(E))
        return Math.max(Math.abs(g != null ? g : 0), Math.abs(E != null ? E : 0));
      const N = kl(_);
      return Math.max(Math.abs(N) * 10, Math.abs(h) * 10);
    }
    function Gh(_, h) {
      const g = h instanceof Xo ? h.components[0] : void 0, E = h instanceof Xo ? h.components[1] : void 0, N = Gp(g, _.x), ne = Gp(E, _.y);
      return Math.max(N, ne);
    }
    function a0(_, h) {
      return {
        baseStep: kl(h),
        constraint: h,
        textProps: oe.fromObject({
          draggingScale: Ho(h, _),
          formatter: Wt(Ah(h, _))
        })
      };
    }
    function l0(_) {
      if (!("y" in _))
        return !1;
      const h = _.y;
      return h && "inverted" in h ? !!h.inverted : !1;
    }
    const c0 = {
      id: "input-point2d",
      type: "input",
      accept: (_, h) => {
        if (!Cs.isObject(_))
          return null;
        const g = ye, E = Se(h, {
          expanded: g.optional.boolean,
          picker: g.optional.custom(zg),
          x: g.optional.custom(Vo),
          y: g.optional.object({
            inverted: g.optional.boolean,
            max: g.optional.number,
            min: g.optional.number,
            step: g.optional.number
          })
        });
        return E ? {
          initialValue: _,
          params: E
        } : null;
      },
      binding: {
        reader: (_) => kw,
        constraint: (_) => o0(_.params, _.initialValue),
        equals: Cs.equals,
        writer: (_) => Hp
      },
      controller: (_) => {
        const h = _.document, g = _.value, E = _.constraint;
        if (!(E instanceof Xo))
          throw x.shouldNeverHappen();
        const N = "expanded" in _.params ? _.params.expanded : void 0, ne = "picker" in _.params ? _.params.picker : void 0;
        return new Sw(h, {
          axes: [
            a0(g.rawValue.x, E.components[0]),
            a0(g.rawValue.y, E.components[1])
          ],
          expanded: N != null ? N : !1,
          invertsY: l0(_.params),
          maxValue: Gh(g.rawValue, E),
          parser: er,
          pickerLayout: ne != null ? ne : "popup",
          value: g,
          viewProps: _.viewProps
        });
      }
    };
    class u0 extends r {
      constructor(h) {
        super(h), this.emitter_ = new C(), this.controller_.valueController.value.emitter.on("change", (g) => {
          this.emitter_.emit("change", {
            event: new o(this, g.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(h) {
        this.controller_.props.set("label", h);
      }
      get options() {
        return this.controller_.valueController.props.get("options");
      }
      set options(h) {
        this.controller_.valueController.props.set("options", h);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(h) {
        this.controller_.valueController.value.rawValue = h;
      }
      on(h, g) {
        const E = g.bind(this);
        return this.emitter_.on(h, (N) => {
          E(N.event);
        }), this;
      }
    }
    class Wp extends r {
      constructor(h) {
        super(h), this.emitter_ = new C(), this.controller_.valueController.value.emitter.on("change", (g) => {
          this.emitter_.emit("change", {
            event: new o(this, g.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(h) {
        this.controller_.props.set("label", h);
      }
      get maxValue() {
        return this.controller_.valueController.sliderController.props.get("maxValue");
      }
      set maxValue(h) {
        this.controller_.valueController.sliderController.props.set("maxValue", h);
      }
      get minValue() {
        return this.controller_.valueController.sliderController.props.get("minValue");
      }
      set minValue(h) {
        this.controller_.valueController.sliderController.props.set("minValue", h);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(h) {
        this.controller_.valueController.value.rawValue = h;
      }
      on(h, g) {
        const E = g.bind(this);
        return this.emitter_.on(h, (N) => {
          E(N.event);
        }), this;
      }
    }
    class h0 extends r {
      constructor(h) {
        super(h), this.emitter_ = new C(), this.controller_.valueController.value.emitter.on("change", (g) => {
          this.emitter_.emit("change", {
            event: new o(this, g.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(h) {
        this.controller_.props.set("label", h);
      }
      get formatter() {
        return this.controller_.valueController.props.get("formatter");
      }
      set formatter(h) {
        this.controller_.valueController.props.set("formatter", h);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(h) {
        this.controller_.valueController.value.rawValue = h;
      }
      on(h, g) {
        const E = g.bind(this);
        return this.emitter_.on(h, (N) => {
          E(N.event);
        }), this;
      }
    }
    const jp = function() {
      return {
        id: "list",
        type: "blade",
        accept(_) {
          const h = ye, g = Se(_, {
            options: h.required.custom(Ph),
            value: h.required.raw,
            view: h.required.constant("list"),
            label: h.optional.string
          });
          return g ? { params: g } : null;
        },
        controller(_) {
          const h = new Cl(Fg(_.params.options)), g = se(_.params.value, {
            constraint: h
          }), E = new Tl(_.document, {
            props: new oe({
              options: h.values.value("options")
            }),
            value: g,
            viewProps: _.viewProps
          });
          return new Ki(_.document, {
            blade: _.blade,
            props: oe.fromObject({
              label: _.params.label
            }),
            valueController: E
          });
        },
        api(_) {
          return !(_.controller instanceof Ki) || !(_.controller.valueController instanceof Tl) ? null : new u0(_.controller);
        }
      };
    }();
    function d0(_) {
      return _.reduce((h, g) => Object.assign(h, {
        [g.presetKey]: g.read()
      }), {});
    }
    function qp(_, h) {
      _.forEach((g) => {
        const E = h[g.target.presetKey];
        E !== void 0 && g.writer(g.target, g.reader(E));
      });
    }
    class Lw extends X {
      constructor(h, g) {
        super(h, g);
      }
      get element() {
        return this.controller_.view.element;
      }
      importPreset(h) {
        const g = this.controller_.rackController.rack.find(Gn).map((E) => E.binding);
        qp(g, h), this.refresh();
      }
      exportPreset() {
        const h = this.controller_.rackController.rack.find(Gn).map((g) => g.binding.target);
        return d0(h);
      }
      refresh() {
        this.controller_.rackController.rack.find(Gn).forEach((h) => {
          h.binding.read();
        }), this.controller_.rackController.rack.find(pr).forEach((h) => {
          h.binding.read();
        });
      }
    }
    class Xp extends zn {
      constructor(h, g) {
        super(h, {
          expanded: g.expanded,
          blade: g.blade,
          props: g.props,
          root: !0,
          viewProps: g.viewProps
        });
      }
    }
    const qt = {
      id: "slider",
      type: "blade",
      accept(_) {
        const h = ye, g = Se(_, {
          max: h.required.number,
          min: h.required.number,
          view: h.required.constant("slider"),
          format: h.optional.function,
          label: h.optional.string,
          value: h.optional.number
        });
        return g ? { params: g } : null;
      },
      controller(_) {
        var h, g;
        const E = (h = _.params.value) !== null && h !== void 0 ? h : 0, N = new ws({
          max: _.params.max,
          min: _.params.min
        }), ne = new Th(_.document, {
          baseStep: 1,
          parser: er,
          sliderProps: new oe({
            maxValue: N.values.value("max"),
            minValue: N.values.value("min")
          }),
          textProps: oe.fromObject({
            draggingScale: Ho(void 0, E),
            formatter: (g = _.params.format) !== null && g !== void 0 ? g : dp
          }),
          value: se(E, {
            constraint: N
          }),
          viewProps: _.viewProps
        });
        return new Ki(_.document, {
          blade: _.blade,
          props: oe.fromObject({
            label: _.params.label
          }),
          valueController: ne
        });
      },
      api(_) {
        return !(_.controller instanceof Ki) || !(_.controller.valueController instanceof Th) ? null : new Wp(_.controller);
      }
    }, Dw = function() {
      return {
        id: "text",
        type: "blade",
        accept(_) {
          const h = ye, g = Se(_, {
            parse: h.required.function,
            value: h.required.raw,
            view: h.required.constant("text"),
            format: h.optional.function,
            label: h.optional.string
          });
          return g ? { params: g } : null;
        },
        controller(_) {
          var h;
          const g = new Mh(_.document, {
            parser: _.params.parse,
            props: oe.fromObject({
              formatter: (h = _.params.format) !== null && h !== void 0 ? h : (E) => String(E)
            }),
            value: se(_.params.value),
            viewProps: _.viewProps
          });
          return new Ki(_.document, {
            blade: _.blade,
            props: oe.fromObject({
              label: _.params.label
            }),
            valueController: g
          });
        },
        api(_) {
          return !(_.controller instanceof Ki) || !(_.controller.valueController instanceof Mh) ? null : new h0(_.controller);
        }
      };
    }();
    function Iw(_) {
      const h = _.createElement("div");
      return h.classList.add(T("dfw")()), _.body && _.body.appendChild(h), h;
    }
    function Fl(_, h, g) {
      if (_.querySelector(`style[data-tp-style=${h}]`))
        return;
      const E = _.createElement("style");
      E.dataset.tpStyle = h, E.textContent = g, _.head.appendChild(E);
    }
    class f0 extends Lw {
      constructor(h) {
        var g, E;
        const N = h != null ? h : {}, ne = (g = N.document) !== null && g !== void 0 ? g : Ce(), be = Vp(), He = new Xp(ne, {
          expanded: N.expanded,
          blade: Bt(),
          props: oe.fromObject({
            title: N.title
          }),
          viewProps: st.create()
        });
        super(He, be), this.pool_ = be, this.containerElem_ = (E = N.container) !== null && E !== void 0 ? E : Iw(ne), this.containerElem_.appendChild(this.element), this.doc_ = ne, this.usesDefaultWrapper_ = !N.container, this.setUpDefaultPlugins_();
      }
      get document() {
        if (!this.doc_)
          throw x.alreadyDisposed();
        return this.doc_;
      }
      dispose() {
        const h = this.containerElem_;
        if (!h)
          throw x.alreadyDisposed();
        if (this.usesDefaultWrapper_) {
          const g = h.parentElement;
          g && g.removeChild(h);
        }
        this.containerElem_ = null, this.doc_ = null, super.dispose();
      }
      registerPlugin(h) {
        ("plugin" in h ? [h.plugin] : "plugins" in h ? h.plugins : []).forEach((E) => {
          this.pool_.register(E), this.embedPluginStyle_(E);
        });
      }
      embedPluginStyle_(h) {
        h.css && Fl(this.document, `plugin-${h.id}`, h.css);
      }
      setUpDefaultPlugins_() {
        Fl(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((h) => {
          this.embedPluginStyle_(h);
        }), this.registerPlugin({
          plugins: [
            qt,
            jp,
            pg,
            Dw
          ]
        });
      }
    }
    const Ow = new i("3.1.7");
    t.BladeApi = r, t.ButtonApi = S, t.FolderApi = X, t.InputBindingApi = Yi, t.ListApi = u0, t.MonitorBindingApi = Ma, t.Pane = f0, t.SeparatorApi = lo, t.SliderApi = Wp, t.TabApi = Hs, t.TabPageApi = Ci, t.TextApi = h0, t.TpChangeEvent = o, t.VERSION = Ow, Object.defineProperty(t, "__esModule", { value: !0 });
  });
})(WM, WM.exports);
let hz = !1, o2 = !0;
nE(
  () => {
    hz = o2, o2 = !o2;
  },
  100,
  "both"
);
const _m = (n) => typeof n == "number" ? Number(n.toFixed(2)) : n, mue = (n, e, t, i) => {
  const r = n.addFolder({ title: e }), s = {};
  for (const [o, a] of Object.entries(t))
    switch (typeof a) {
      case "undefined":
        t[o] = "";
        break;
      case "number":
        t[o] = _m(a);
        break;
      case "object":
        if (Array.isArray(a)) {
          t[o] = JSON.stringify(a);
          break;
        }
        if ("values" in a) {
          t[o] = a.value, s[o] = {
            options: Object.fromEntries(
              a.values.map((l) => [l, l])
            )
          };
          break;
        }
        typeof (a == null ? void 0 : a.x) == "number" && (a.x = _m(a.x)), typeof (a == null ? void 0 : a.y) == "number" && (a.y = _m(a.y)), typeof (a == null ? void 0 : a.z) == "number" && (a.z = _m(a.z));
        break;
    }
  return Object.fromEntries(
    Object.keys(t).map((o) => {
      const a = r.addInput(t, o, s[o]);
      return a.on("change", ({ value: l }) => {
        if (!hz) {
          if (typeof l == "string") {
            if (l === "true" || l === "false") {
              i(o, l === "true");
              return;
            }
            const c = parseFloat(l);
            if (!Number.isNaN(c)) {
              i(o, c);
              return;
            }
          }
          i(o, _m(l));
        }
      }), [o, a];
    })
  );
}, vue = () => {
  const n = zr(null);
  return Tv(() => {
    const e = n.current;
    if (!e)
      return;
    const t = (i) => i.stopPropagation();
    return e.addEventListener("mousedown", t), e.addEventListener("pointerdown", t), e.addEventListener("touchstart", t), e.addEventListener("keydown", t), () => {
      e.removeEventListener("mousedown", t), e.removeEventListener("pointerdown", t), e.removeEventListener("touchstart", t), e.removeEventListener("keydown", t);
    };
  }, []), n;
}, Pde = ({
  children: n,
  style: e,
  className: t
}) => {
  const i = vue(), r = Array.isArray(n) ? n : [n];
  return Tv(() => {
    const s = i.current;
    if (!s || !r.length)
      return;
    const o = new WM.exports.Pane({
      container: s
    }), a = Object.fromEntries(r.filter((c) => {
      var d;
      return (d = c.props) == null ? void 0 : d.name;
    }).map((c) => [c.props.name, c.props.values ? c.props : c.props.value])), l = Object.fromEntries(r.filter((c) => {
      var d;
      return (d = c.props) == null ? void 0 : d.name;
    }).map((c) => [c.props.name, c.props.onChange]));
    return mue(o, "inputs", a, (c, d) => {
      var p;
      return (p = l[c]) == null ? void 0 : p.call(l, d);
    }), () => {
      o.dispose();
    };
  }, [r.length]), /* @__PURE__ */ H("div", {
    ref: i,
    className: "lingo3d-ui " + (t != null ? t : ""),
    style: {
      width: 300,
      background: "rgb(40, 41, 46)",
      position: "absolute",
      top: 0,
      right: 0,
      zIndex: 1,
      ...e
    }
  });
}, Ade = (n) => null, gue = ({
  mode: n = "fps"
}) => {
  const e = zr(null);
  return In(() => {
    const t = e.current;
    if (!t)
      return;
    const i = new gue();
    i.showPanel(n === "fps" ? 0 : n === "time" ? 1 : 2), t.appendChild(i.dom);
    const r = Pn(() => i.begin()), s = Ec(() => i.end());
    return () => {
      r.cancel(), s.cancel();
    };
  }, []), /* @__PURE__ */ H("div", {
    ref: e
  });
}, Rde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Gu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), kde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Lu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), _ue = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Bu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Lde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, gs);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Dde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Zd);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Ide = Gt.forwardRef((n, e) => {
  const t = sn(n, e, zu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Ode = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Kd), i = zr(null);
  return In(() => {
    t.element = i.current;
  }, []), /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: /* @__PURE__ */ H("div", {
      ref: i,
      children: n.children
    })
  });
}), Nde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, ef);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), zde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, tf);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Fde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Nu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), Bde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Ou);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), Ude = Gt.forwardRef((n, e) => {
  const t = sn(n, e, gc);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Vde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, rf);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), Hde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, sf);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Gde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, of);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), Wde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, af);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), jde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Iu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), qde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, lf);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Xde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, ax);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), $de = Gt.forwardRef((n, e) => {
  const t = sn(n, e, cf);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Zde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, uf);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Yde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Uu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Kde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, hf);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Jde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Vu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), Qde = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Hu);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), efe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Xd);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), tfe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, tx);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), nfe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, qy);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), ife = Gt.forwardRef((n, e) => {
  const t = sn(n, e, nx);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), rfe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, ix);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), sfe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, qd);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), ofe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, ex);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), afe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, sx);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), lfe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, ox);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t,
    children: n.children
  });
}), cfe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Jd);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), ufe = Gt.forwardRef((n, e) => {
  const t = sn(n, e, Qd);
  return /* @__PURE__ */ H(jt.Provider, {
    value: t
  });
}), hfe = ({
  children: n
}) => {
  const e = cy(jt), t = zr(null);
  return In(() => {
    const i = t.current;
    if (!i || !e)
      return;
    let r = !1;
    const s = Ec(() => {
      const {
        frustumVisible: o
      } = e;
      o !== r && (i.style.display = o ? "block" : "none"), r = o, o && (i.style.transform = `translateX(${e.clientX}px) translateY(${e.clientY}px)`);
    });
    return () => {
      s.cancel();
    };
  }, [e]), SL.createPortal(/* @__PURE__ */ H("div", {
    ref: t,
    style: {
      display: "none"
    },
    children: /* @__PURE__ */ H("div", {
      style: {
        position: "absolute",
        transform: "translateX(-50%) translateY(-50%)",
        left: 0,
        top: 0
      },
      children: n
    })
  }), dx);
}, dfe = ({
  children: n
}) => SL.createPortal(/* @__PURE__ */ H("div", {
  style: {
    pointerEvents: "all",
    position: "static"
  },
  children: n
}), dx), ffe = Gt.forwardRef(({
  name: n,
  onLoad: e,
  ...t
}, i) => {
  const r = cy(jt), [s, o] = Yr();
  In(() => {
    if (!(!r || !n)) {
      if ("loaded" in r) {
        const c = r.loaded.then(() => {
          o(r.find(n));
        });
        return () => {
          c.cancel();
        };
      }
      o(r.find(n));
    }
  }, [r, n]);
  const [a, l] = UC(t, !s);
  return s && HC(s, a, l), In(() => {
    !i || !s || (typeof i == "function" ? i(s) : i.current = s);
  }, [i, s]), In(() => {
    s && (e == null || e(s));
  }, [s]), /* @__PURE__ */ H(jt.Provider, {
    value: s,
    children: t.children
  });
}), pfe = Gt.forwardRef(({
  name: n,
  onLoad: e,
  ...t
}, i) => {
  const r = cy(jt), [s, o] = Yr();
  In(() => {
    if (!(!r || !n)) {
      if ("loaded" in r) {
        const c = r.loaded.then(() => {
          o(r.findAll(n));
        });
        return () => {
          c.cancel();
        };
      }
      o(r.findAll(n));
    }
  }, [r]);
  const [a, l] = UC(t, !s);
  if (s)
    for (const c of s)
      HC(c, a, l);
  return In(() => {
    !i || !s || (typeof i == "function" ? i(s) : i.current = s);
  }, [i, s]), In(() => {
    s && (e == null || e(s));
  }, [s]), null;
}), mfe = ({
  children: n,
  className: e,
  style: t,
  distance: i = 500
}) => {
  const r = zr(null), s = zr(null);
  return In(() => {
    const o = r.current, a = s.current;
    if (!o || !a)
      return;
    const l = Pn(() => {
      const {
        left: c,
        top: d,
        width: p,
        height: m
      } = o.getBoundingClientRect(), v = c + p * 0.5, b = d + m * 0.5;
      a.placeAt(FC(v, b, i));
    });
    return () => {
      l.cancel();
    };
  }, [i]), /* @__PURE__ */ H("div", {
    ref: r,
    className: e,
    style: t,
    children: /* @__PURE__ */ H(_ue, {
      ref: s,
      children: n
    })
  });
}, vfe = (n) => {
  const e = zr(!1), t = T6(
    () => /* @__PURE__ */ new Set(),
    void 0,
    () => e.current = !0
  ), [i, r] = Yr([]);
  return [i, (o) => {
    var l;
    if (e.current)
      return;
    const a = { ...n, ...o };
    (l = a.id) != null || (a.id = XD()), t.add(a), r([...t]), a.lifetime && setTimeout(() => {
      e.current || (t.delete(a), r([...t]));
    }, a.lifetime);
  }];
};
function dz(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}
var u3 = function() {
}, Ev = function() {
};
process.env.NODE_ENV !== "production" && (u3 = function(n, e) {
  !n && typeof console < "u" && console.warn(e);
}, Ev = function(n, e) {
  if (!n)
    throw new Error(e);
});
const jM = (n, e, t) => Math.min(Math.max(t, n), e), a2 = 1e-3, bue = 0.01, mL = 10, yue = 0.05, xue = 1;
function wue({ duration: n = 800, bounce: e = 0.25, velocity: t = 0, mass: i = 1 }) {
  let r, s;
  u3(n <= mL * 1e3, "Spring duration must be 10 seconds or less");
  let o = 1 - e;
  o = jM(yue, xue, o), n = jM(bue, mL, n / 1e3), o < 1 ? (r = (c) => {
    const d = c * o, p = d * n, m = d - t, v = qM(c, o), b = Math.exp(-p);
    return a2 - m / v * b;
  }, s = (c) => {
    const p = c * o * n, m = p * t + t, v = Math.pow(o, 2) * Math.pow(c, 2) * n, b = Math.exp(-p), x = qM(Math.pow(c, 2), o);
    return (-r(c) + a2 > 0 ? -1 : 1) * ((m - v) * b) / x;
  }) : (r = (c) => {
    const d = Math.exp(-c * n), p = (c - t) * n + 1;
    return -a2 + d * p;
  }, s = (c) => {
    const d = Math.exp(-c * n), p = (t - c) * (n * n);
    return d * p;
  });
  const a = 5 / n, l = Mue(r, s, a);
  if (n = n * 1e3, isNaN(l))
    return {
      stiffness: 100,
      damping: 10,
      duration: n
    };
  {
    const c = Math.pow(l, 2) * i;
    return {
      stiffness: c,
      damping: o * 2 * Math.sqrt(i * c),
      duration: n
    };
  }
}
const Sue = 12;
function Mue(n, e, t) {
  let i = t;
  for (let r = 1; r < Sue; r++)
    i = i - n(i) / e(i);
  return i;
}
function qM(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const Eue = ["duration", "bounce"], Cue = ["stiffness", "damping", "mass"];
function vL(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function Tue(n) {
  let e = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1 }, n);
  if (!vL(n, Cue) && vL(n, Eue)) {
    const t = wue(n);
    e = Object.assign(Object.assign(Object.assign({}, e), t), { velocity: 0, mass: 1 }), e.isResolvedFromDuration = !0;
  }
  return e;
}
function wx(n) {
  var { from: e = 0, to: t = 1, restSpeed: i = 2, restDelta: r } = n, s = dz(n, ["from", "to", "restSpeed", "restDelta"]);
  const o = { done: !1, value: e };
  let { stiffness: a, damping: l, mass: c, velocity: d, duration: p, isResolvedFromDuration: m } = Tue(s), v = gL, b = gL;
  function x() {
    const y = d ? -(d / 1e3) : 0, S = t - e, C = l / (2 * Math.sqrt(a * c)), M = Math.sqrt(a / c) / 1e3;
    if (r === void 0 && (r = Math.min(Math.abs(t - e) / 100, 0.4)), C < 1) {
      const T = qM(M, C);
      v = (P) => {
        const D = Math.exp(-C * M * P);
        return t - D * ((y + C * M * S) / T * Math.sin(T * P) + S * Math.cos(T * P));
      }, b = (P) => {
        const D = Math.exp(-C * M * P);
        return C * M * D * (Math.sin(T * P) * (y + C * M * S) / T + S * Math.cos(T * P)) - D * (Math.cos(T * P) * (y + C * M * S) - T * S * Math.sin(T * P));
      };
    } else if (C === 1)
      v = (T) => t - Math.exp(-M * T) * (S + (y + M * S) * T);
    else {
      const T = M * Math.sqrt(C * C - 1);
      v = (P) => {
        const D = Math.exp(-C * M * P), I = Math.min(T * P, 300);
        return t - D * ((y + C * M * S) * Math.sinh(I) + T * S * Math.cosh(I)) / T;
      };
    }
  }
  return x(), {
    next: (y) => {
      const S = v(y);
      if (m)
        o.done = y >= p;
      else {
        const C = b(y) * 1e3, M = Math.abs(C) <= i, T = Math.abs(t - S) <= r;
        o.done = M && T;
      }
      return o.value = o.done ? t : S, o;
    },
    flipTarget: () => {
      d = -d, [e, t] = [t, e], x();
    }
  };
}
wx.needsInterpolation = (n, e) => typeof n == "string" || typeof e == "string";
const gL = (n) => 0, fz = (n, e, t) => {
  const i = e - n;
  return i === 0 ? 1 : (t - n) / i;
}, h3 = (n, e, t) => -t * n + t * e + n, pz = (n, e) => (t) => Math.max(Math.min(t, e), n), Gm = (n) => n % 1 ? Number(n.toFixed(5)) : n, ly = /(-)?([\d]*\.?[\d])+/g, XM = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, Pue = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function dg(n) {
  return typeof n == "string";
}
const Sx = {
  test: (n) => typeof n == "number",
  parse: parseFloat,
  transform: (n) => n
}, mz = Object.assign(Object.assign({}, Sx), { transform: pz(0, 1) });
Object.assign(Object.assign({}, Sx), { default: 1 });
const Aue = (n) => ({
  test: (e) => dg(e) && e.endsWith(n) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${n}`
}), Wm = Aue("%");
Object.assign(Object.assign({}, Wm), { parse: (n) => Wm.parse(n) / 100, transform: (n) => Wm.transform(n * 100) });
const d3 = (n, e) => (t) => Boolean(dg(t) && Pue.test(t) && t.startsWith(n) || e && Object.prototype.hasOwnProperty.call(t, e)), vz = (n, e, t) => (i) => {
  if (!dg(i))
    return i;
  const [r, s, o, a] = i.match(ly);
  return {
    [n]: parseFloat(r),
    [e]: parseFloat(s),
    [t]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, Cu = {
  test: d3("hsl", "hue"),
  parse: vz("hue", "saturation", "lightness"),
  transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) => "hsla(" + Math.round(n) + ", " + Wm.transform(Gm(e)) + ", " + Wm.transform(Gm(t)) + ", " + Gm(mz.transform(i)) + ")"
}, Rue = pz(0, 255), l2 = Object.assign(Object.assign({}, Sx), { transform: (n) => Math.round(Rue(n)) }), fc = {
  test: d3("rgb", "red"),
  parse: vz("red", "green", "blue"),
  transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) => "rgba(" + l2.transform(n) + ", " + l2.transform(e) + ", " + l2.transform(t) + ", " + Gm(mz.transform(i)) + ")"
};
function kue(n) {
  let e = "", t = "", i = "", r = "";
  return n.length > 5 ? (e = n.substr(1, 2), t = n.substr(3, 2), i = n.substr(5, 2), r = n.substr(7, 2)) : (e = n.substr(1, 1), t = n.substr(2, 1), i = n.substr(3, 1), r = n.substr(4, 1), e += e, t += t, i += i, r += r), {
    red: parseInt(e, 16),
    green: parseInt(t, 16),
    blue: parseInt(i, 16),
    alpha: r ? parseInt(r, 16) / 255 : 1
  };
}
const $M = {
  test: d3("#"),
  parse: kue,
  transform: fc.transform
}, Mx = {
  test: (n) => fc.test(n) || $M.test(n) || Cu.test(n),
  parse: (n) => fc.test(n) ? fc.parse(n) : Cu.test(n) ? Cu.parse(n) : $M.parse(n),
  transform: (n) => dg(n) ? n : n.hasOwnProperty("red") ? fc.transform(n) : Cu.transform(n)
}, gz = "${c}", _z = "${n}";
function Lue(n) {
  var e, t, i, r;
  return isNaN(n) && dg(n) && ((t = (e = n.match(ly)) === null || e === void 0 ? void 0 : e.length) !== null && t !== void 0 ? t : 0) + ((r = (i = n.match(XM)) === null || i === void 0 ? void 0 : i.length) !== null && r !== void 0 ? r : 0) > 0;
}
function bz(n) {
  typeof n == "number" && (n = `${n}`);
  const e = [];
  let t = 0;
  const i = n.match(XM);
  i && (t = i.length, n = n.replace(XM, gz), e.push(...i.map(Mx.parse)));
  const r = n.match(ly);
  return r && (n = n.replace(ly, _z), e.push(...r.map(Sx.parse))), { values: e, numColors: t, tokenised: n };
}
function yz(n) {
  return bz(n).values;
}
function xz(n) {
  const { values: e, numColors: t, tokenised: i } = bz(n), r = e.length;
  return (s) => {
    let o = i;
    for (let a = 0; a < r; a++)
      o = o.replace(a < t ? gz : _z, a < t ? Mx.transform(s[a]) : Gm(s[a]));
    return o;
  };
}
const Due = (n) => typeof n == "number" ? 0 : n;
function Iue(n) {
  const e = yz(n);
  return xz(n)(e.map(Due));
}
const wz = { test: Lue, parse: yz, createTransformer: xz, getAnimatableNone: Iue };
function c2(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function _L({ hue: n, saturation: e, lightness: t, alpha: i }) {
  n /= 360, e /= 100, t /= 100;
  let r = 0, s = 0, o = 0;
  if (!e)
    r = s = o = t;
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e, l = 2 * t - a;
    r = c2(l, a, n + 1 / 3), s = c2(l, a, n), o = c2(l, a, n - 1 / 3);
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: i
  };
}
const Oue = (n, e, t) => {
  const i = n * n, r = e * e;
  return Math.sqrt(Math.max(0, t * (r - i) + i));
}, Nue = [$M, fc, Cu], bL = (n) => Nue.find((e) => e.test(n)), yL = (n) => `'${n}' is not an animatable color. Use the equivalent color code instead.`, Sz = (n, e) => {
  let t = bL(n), i = bL(e);
  Ev(!!t, yL(n)), Ev(!!i, yL(e));
  let r = t.parse(n), s = i.parse(e);
  t === Cu && (r = _L(r), t = fc), i === Cu && (s = _L(s), i = fc);
  const o = Object.assign({}, r);
  return (a) => {
    for (const l in o)
      l !== "alpha" && (o[l] = Oue(r[l], s[l], a));
    return o.alpha = h3(r.alpha, s.alpha, a), t.transform(o);
  };
}, zue = (n) => typeof n == "number", Fue = (n, e) => (t) => e(n(t)), Mz = (...n) => n.reduce(Fue);
function Ez(n, e) {
  return zue(n) ? (t) => h3(n, e, t) : Mx.test(n) ? Sz(n, e) : Tz(n, e);
}
const Cz = (n, e) => {
  const t = [...n], i = t.length, r = n.map((s, o) => Ez(s, e[o]));
  return (s) => {
    for (let o = 0; o < i; o++)
      t[o] = r[o](s);
    return t;
  };
}, Bue = (n, e) => {
  const t = Object.assign(Object.assign({}, n), e), i = {};
  for (const r in t)
    n[r] !== void 0 && e[r] !== void 0 && (i[r] = Ez(n[r], e[r]));
  return (r) => {
    for (const s in i)
      t[s] = i[s](r);
    return t;
  };
};
function xL(n) {
  const e = wz.parse(n), t = e.length;
  let i = 0, r = 0, s = 0;
  for (let o = 0; o < t; o++)
    i || typeof e[o] == "number" ? i++ : e[o].hue !== void 0 ? s++ : r++;
  return { parsed: e, numNumbers: i, numRGB: r, numHSL: s };
}
const Tz = (n, e) => {
  const t = wz.createTransformer(e), i = xL(n), r = xL(e);
  return i.numHSL === r.numHSL && i.numRGB === r.numRGB && i.numNumbers >= r.numNumbers ? Mz(Cz(i.parsed, r.parsed), t) : (u3(!0, `Complex values '${n}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), (o) => `${o > 0 ? e : n}`);
}, Uue = (n, e) => (t) => h3(n, e, t);
function Vue(n) {
  if (typeof n == "number")
    return Uue;
  if (typeof n == "string")
    return Mx.test(n) ? Sz : Tz;
  if (Array.isArray(n))
    return Cz;
  if (typeof n == "object")
    return Bue;
}
function Hue(n, e, t) {
  const i = [], r = t || Vue(n[0]), s = n.length - 1;
  for (let o = 0; o < s; o++) {
    let a = r(n[o], n[o + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[o] : e;
      a = Mz(l, a);
    }
    i.push(a);
  }
  return i;
}
function Gue([n, e], [t]) {
  return (i) => t(fz(n, e, i));
}
function Wue(n, e) {
  const t = n.length, i = t - 1;
  return (r) => {
    let s = 0, o = !1;
    if (r <= n[0] ? o = !0 : r >= n[i] && (s = i - 1, o = !0), !o) {
      let l = 1;
      for (; l < t && !(n[l] > r || l === i); l++)
        ;
      s = l - 1;
    }
    const a = fz(n[s], n[s + 1], r);
    return e[s](a);
  };
}
function Pz(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length;
  Ev(s === e.length, "Both input and output ranges must be the same length"), Ev(!i || !Array.isArray(i) || i.length === s - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values."), n[0] > n[s - 1] && (n = [].concat(n), e = [].concat(e), n.reverse(), e.reverse());
  const o = Hue(e, i, r), a = s === 2 ? Gue(n, o) : Wue(n, o);
  return t ? (l) => a(jM(n[0], n[s - 1], l)) : a;
}
const Ex = (n) => (e) => 1 - n(1 - e), f3 = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2, jue = (n) => (e) => Math.pow(e, n), Az = (n) => (e) => e * e * ((n + 1) * e - n), que = (n) => {
  const e = Az(n);
  return (t) => (t *= 2) < 1 ? 0.5 * e(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1)));
}, Rz = 1.525, Xue = 4 / 11, $ue = 8 / 11, Zue = 9 / 10, kz = jue(2);
Ex(kz);
const Yue = f3(kz), Kue = (n) => 1 - Math.sin(Math.acos(n)), Jue = Ex(Kue);
f3(Jue);
const Lz = Az(Rz);
Ex(Lz);
f3(Lz);
que(Rz);
const Que = 4356 / 361, ehe = 35442 / 1805, the = 16061 / 1805, nhe = (n) => {
  if (n === 1 || n === 0)
    return n;
  const e = n * n;
  return n < Xue ? 7.5625 * e : n < $ue ? 9.075 * e - 9.9 * n + 3.4 : n < Zue ? Que * e - ehe * n + the : 10.8 * n * n - 20.52 * n + 10.72;
};
Ex(nhe);
function ihe(n, e) {
  return n.map(() => e || Yue).splice(0, n.length - 1);
}
function rhe(n) {
  const e = n.length;
  return n.map((t, i) => i !== 0 ? i / (e - 1) : 0);
}
function she(n, e) {
  return n.map((t) => t * e);
}
function db({ from: n = 0, to: e = 1, ease: t, offset: i, duration: r = 300 }) {
  const s = { done: !1, value: n }, o = Array.isArray(e) ? e : [n, e], a = she(i && i.length === o.length ? i : rhe(o), r);
  function l() {
    return Pz(a, o, {
      ease: Array.isArray(t) ? t : ihe(o, t)
    });
  }
  let c = l();
  return {
    next: (d) => (s.value = c(d), s.done = d >= r, s),
    flipTarget: () => {
      o.reverse(), c = l();
    }
  };
}
function ohe({ velocity: n = 0, from: e = 0, power: t = 0.8, timeConstant: i = 350, restDelta: r = 0.5, modifyTarget: s }) {
  const o = { done: !1, value: e };
  let a = t * n;
  const l = e + a, c = s === void 0 ? l : s(l);
  return c !== l && (a = c - e), {
    next: (d) => {
      const p = -a * Math.exp(-d / i);
      return o.done = !(p > r || p < -r), o.value = o.done ? c : c + p, o;
    },
    flipTarget: () => {
    }
  };
}
const wL = { keyframes: db, spring: wx, decay: ohe };
function ahe(n) {
  if (Array.isArray(n.to))
    return db;
  if (wL[n.type])
    return wL[n.type];
  const e = new Set(Object.keys(n));
  return e.has("ease") || e.has("duration") && !e.has("dampingRatio") ? db : e.has("dampingRatio") || e.has("stiffness") || e.has("mass") || e.has("damping") || e.has("restSpeed") || e.has("restDelta") ? wx : db;
}
const Dz = 1 / 60 * 1e3, lhe = typeof performance < "u" ? () => performance.now() : () => Date.now(), Iz = typeof window < "u" ? (n) => window.requestAnimationFrame(n) : (n) => setTimeout(() => n(lhe()), Dz);
function che(n) {
  let e = [], t = [], i = 0, r = !1, s = !1;
  const o = /* @__PURE__ */ new WeakSet(), a = {
    schedule: (l, c = !1, d = !1) => {
      const p = d && r, m = p ? e : t;
      return c && o.add(l), m.indexOf(l) === -1 && (m.push(l), p && r && (i = e.length)), l;
    },
    cancel: (l) => {
      const c = t.indexOf(l);
      c !== -1 && t.splice(c, 1), o.delete(l);
    },
    process: (l) => {
      if (r) {
        s = !0;
        return;
      }
      if (r = !0, [e, t] = [t, e], t.length = 0, i = e.length, i)
        for (let c = 0; c < i; c++) {
          const d = e[c];
          d(l), o.has(d) && (a.schedule(d), n());
        }
      r = !1, s && (s = !1, a.process(l));
    }
  };
  return a;
}
const uhe = 40;
let ZM = !0, Cv = !1, YM = !1;
const jm = {
  delta: 0,
  timestamp: 0
}, fg = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], Cx = fg.reduce((n, e) => (n[e] = che(() => Cv = !0), n), {}), hhe = fg.reduce((n, e) => {
  const t = Cx[e];
  return n[e] = (i, r = !1, s = !1) => (Cv || phe(), t.schedule(i, r, s)), n;
}, {}), dhe = fg.reduce((n, e) => (n[e] = Cx[e].cancel, n), {});
fg.reduce((n, e) => (n[e] = () => Cx[e].process(jm), n), {});
const fhe = (n) => Cx[n].process(jm), Oz = (n) => {
  Cv = !1, jm.delta = ZM ? Dz : Math.max(Math.min(n - jm.timestamp, uhe), 1), jm.timestamp = n, YM = !0, fg.forEach(fhe), YM = !1, Cv && (ZM = !1, Iz(Oz));
}, phe = () => {
  Cv = !0, ZM = !0, YM || Iz(Oz);
};
function Nz(n, e, t = 0) {
  return n - e - t;
}
function mhe(n, e, t = 0, i = !0) {
  return i ? Nz(e + -n, e, t) : e - (n - e) + t;
}
function vhe(n, e, t, i) {
  return i ? n >= e + t : n <= -t;
}
const ghe = (n) => {
  const e = ({ delta: t }) => n(t);
  return {
    start: () => hhe.update(e, !0),
    stop: () => dhe.update(e)
  };
};
function _he(n) {
  var e, t, { from: i, autoplay: r = !0, driver: s = ghe, elapsed: o = 0, repeat: a = 0, repeatType: l = "loop", repeatDelay: c = 0, onPlay: d, onStop: p, onComplete: m, onRepeat: v, onUpdate: b } = n, x = dz(n, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to: y } = x, S, C = 0, M = x.duration, T, P = !1, D = !0, I;
  const k = ahe(x);
  !((t = (e = k).needsInterpolation) === null || t === void 0) && t.call(e, i, y) && (I = Pz([0, 100], [i, y], {
    clamp: !1
  }), i = 0, y = 100);
  const O = k(Object.assign(Object.assign({}, x), { from: i, to: y }));
  function B() {
    C++, l === "reverse" ? (D = C % 2 === 0, o = mhe(o, M, c, D)) : (o = Nz(o, M, c), l === "mirror" && O.flipTarget()), P = !1, v && v();
  }
  function Y() {
    S.stop(), m && m();
  }
  function G(A) {
    if (D || (A = -A), o += A, !P) {
      const J = O.next(Math.max(0, o));
      T = J.value, I && (T = I(T)), P = D ? J.done : o <= 0;
    }
    b == null || b(T), P && (C === 0 && (M != null || (M = o)), C < a ? vhe(o, M, c, D) && B() : Y());
  }
  function K() {
    d == null || d(), S = s(G), S.start();
  }
  return r && K(), {
    stop: () => {
      p == null || p(), S.stop();
    }
  };
}
class bhe extends Je {
  constructor() {
    super(...arguments);
    V(this, "restart");
  }
}
const zz = (n) => {
  const e = KM(() => {
    var i, r, s;
    const t = typeof (n == null ? void 0 : n.from) == "function" ? n.from() : (i = n == null ? void 0 : n.from) != null ? i : 0;
    return new bhe((s = (r = n == null ? void 0 : n.map) == null ? void 0 : r.call(n, t)) != null ? s : t);
  }, []);
  return In(() => {
    if (typeof (n == null ? void 0 : n.from) != "function")
      return;
    const { map: t } = n;
    if (t) {
      const r = n.from((s) => e.set(t(s)));
      return () => {
        r.cancel();
      };
    }
    const i = n.from(e.set);
    return () => {
      i.cancel();
    };
  }, []), In(() => {
    const t = n == null ? void 0 : n.step;
    if (!t)
      return;
    const i = e.get(t);
    return () => {
      i.cancel();
    };
  }, []), e;
}, gfe = (n) => {
  const {
    to: e,
    from: t = e,
    step: i,
    delay: r,
    ...s
  } = typeof n == "number" ? { to: n } : n, o = zz({ from: t, step: i }), [a, l] = Yr({}), c = P6(a);
  return o.restart = () => l({}), In(() => {
    const d = new Xn();
    return (async () => {
      if (await new Promise((v) => setTimeout(v, r)), d.done)
        return;
      const p = wx({
        from: c === a ? o.get() : t,
        to: e,
        ...s
      }), m = Date.now();
      d.watch(
        ku(() => {
          const { value: v, done: b } = p.next(Date.now() - m);
          if (o.set(v), b) {
            d.cancel();
            return;
          }
        })
      );
    })(), () => {
      d.cancel();
    };
  }, [e, a]), o;
}, _fe = ({
  from: n,
  to: e,
  duration: t = 1e3,
  stopped: i,
  step: r,
  ...s
}) => {
  const o = zz({ from: n, step: r }), [a, l] = Yr({}), c = P6(a);
  return o.restart = () => l({}), In(() => {
    if (i)
      return;
    const d = _he({
      from: c === a ? o.get() : n,
      to: e,
      duration: t,
      ...s,
      onUpdate: o.set
    });
    return () => {
      d.stop();
    };
  }, [e, i, a]), o;
}, bfe = (n, e = !0) => {
  const t = VC(n);
  In(() => {
    if (!e)
      return;
    const i = ku(() => t.current());
    return () => {
      i.cancel();
    };
  }, [e]);
}, yfe = () => {
  const n = zr({ isDown: !1 }), [, e] = Yr({});
  return In(() => {
    const t = new Lu();
    return t.onMouseDown = () => {
      n.current.isDown = !0, e({});
    }, t.onMouseUp = () => {
      n.current.isDown = !1, e({});
    }, () => {
      t.dispose();
    };
  }, []), n.current;
}, xfe = (n) => {
  const [e, t] = Yr(""), i = VC(n);
  return In(() => {
    const r = new Gu();
    let s = "";
    return r.onKeyDown = (o) => {
      s !== o && (s = o, t([...jr].join(" ")));
    }, r.onKeyUp = () => {
      s = "", t([...jr].join(" "));
    }, r.onKeyPress = (o) => {
      var a;
      return (a = i.current) == null ? void 0 : a.call(i, o);
    }, () => {
      r.dispose();
    };
  }, []), e;
}, yhe = (n, e) => {
  const t = zr(n), i = zr(), r = zr();
  In(() => {
    var o;
    let s = !1;
    if (!i.current)
      s = !0;
    else
      for (let a = 0; a < i.current.length; a++)
        i.current[a] !== e[a] && (s = !0);
    i.current = e, s && ((o = r.current) == null || o.call(r), r.current = t.current());
  });
}, wfe = (n, e) => {
  const [t, i] = Yr(0);
  return yhe(() => {
    DC(n, e, (r) => i(r)).then(() => i(100));
  }, []), t;
}, Sfe = (n, e, t, i = !0) => {
  const r = VC(t);
  In(() => {
    if (!i)
      return;
    const s = Py(n, e, () => r.current());
    return () => {
      s.cancel();
    };
  }, [i, n, e]);
}, Mfe = () => {
  const [n, e] = Yr({
    width: window.innerWidth,
    height: window.innerHeight
  });
  return In(() => {
    const t = () => e({ width: window.innerWidth, height: window.innerHeight });
    return window.addEventListener("resize", t), () => {
      window.removeEventListener("resize", t);
    };
  }, []), n;
}, Efe = () => {
  const [n, e] = Yr({ x: window.scrollX, y: window.scrollY });
  return In(() => {
    const t = () => e({ x: window.scrollX, y: window.scrollY });
    return document.addEventListener("scroll", t, { passive: !0 }), () => {
      document.removeEventListener("scroll", t);
    };
  }, []), n;
}, Cfe = () => {
  const [n, e] = Yr(() => Ln());
  return In(() => {
    const t = Ln((i) => {
      e(i);
    });
    return () => {
      t.cancel();
    };
  }, []), n;
}, Tfe = () => bt, Pfe = (n, e) => {
  const [t, i] = Yr([]), r = n && "current" in n ? n.current : n;
  return Tv(() => {
    if (!!r) {
      if ("loaded" in r) {
        const s = r.loaded.then(() => {
          i(r.findAll(e));
        });
        return () => {
          s.cancel();
        };
      }
      i(r.findAll(e));
    }
  }, [r]), t;
};
export {
  fD as $,
  Fq as A,
  Uj as B,
  _a as C,
  ID as D,
  oh as E,
  km as F,
  ul as G,
  Ry as H,
  jhe as I,
  Uf as J,
  Ro as K,
  ch as L,
  CD as M,
  Qm as N,
  wn as O,
  vn as P,
  Gi as Q,
  qu as R,
  Iq as S,
  DD as T,
  tD as U,
  gn as V,
  ze as W,
  Dhe as X,
  Phe as Y,
  Ohe as Z,
  Vi as _,
  Z as a,
  Yn as a$,
  aa as a0,
  Zt as a1,
  Pv as a2,
  Hj as a3,
  zo as a4,
  Js as a5,
  vy as a6,
  Rv as a7,
  Ahe as a8,
  Rhe as a9,
  qL as aA,
  Qs as aB,
  $r as aC,
  Ff as aD,
  q9 as aE,
  nO as aF,
  Ln as aG,
  gde as aH,
  zd as aI,
  Nhe as aJ,
  W_ as aK,
  x2 as aL,
  zhe as aM,
  Av as aN,
  Ut as aO,
  Fj as aP,
  pD as aQ,
  Lhe as aR,
  Mhe as aS,
  gu as aT,
  On as aU,
  hD as aV,
  Pu as aW,
  jL as aX,
  NE as aY,
  gy as aZ,
  Ke as a_,
  yb as aa,
  Che as ab,
  kn as ac,
  zT as ad,
  p9 as ae,
  FT as af,
  d2 as ag,
  bb as ah,
  ju as ai,
  Ehe as aj,
  so as ak,
  sh as al,
  Ey as am,
  khe as an,
  Mi as ao,
  wr as ap,
  jT as aq,
  sP as ar,
  WT as as,
  VT as at,
  f1 as au,
  C9 as av,
  GT as aw,
  BT as ax,
  u1 as ay,
  XL as az,
  Ihe as b,
  _ue as b$,
  ft as b0,
  Pn as b1,
  mde as b2,
  rI as b3,
  Ud as b4,
  Vhe as b5,
  Jn as b6,
  Fhe as b7,
  Be as b8,
  nh as b9,
  Dn as bA,
  ta as bB,
  Bhe as bC,
  mh as bD,
  tC as bE,
  _de as bF,
  bde as bG,
  Iie as bH,
  KO as bI,
  hI as bJ,
  Rie as bK,
  Qie as bL,
  ku as bM,
  Xr as bN,
  are as bO,
  yde as bP,
  xde as bQ,
  Sde as bR,
  Mde as bS,
  Ede as bT,
  Cde as bU,
  Tde as bV,
  Pde as bW,
  Ade as bX,
  gue as bY,
  Rde as bZ,
  kde as b_,
  ih as ba,
  WL as bb,
  f_ as bc,
  OV as bd,
  sl as be,
  nt as bf,
  eK as bg,
  pn as bh,
  xr as bi,
  ma as bj,
  Ghe as bk,
  BD as bl,
  ia as bm,
  cr as bn,
  Li as bo,
  Us as bp,
  ef as bq,
  g5 as br,
  bt as bs,
  Xn as bt,
  cee as bu,
  hee as bv,
  ml as bw,
  MA as bx,
  PR as by,
  Uhe as bz,
  qr as c,
  Lde as c0,
  Dde as c1,
  Ide as c2,
  Ode as c3,
  Nde as c4,
  zde as c5,
  Fde as c6,
  Bde as c7,
  kre as c8,
  Ude as c9,
  ffe as cA,
  pfe as cB,
  mfe as cC,
  vfe as cD,
  gfe as cE,
  _fe as cF,
  zz as cG,
  bfe as cH,
  yfe as cI,
  xfe as cJ,
  wfe as cK,
  Sfe as cL,
  Mfe as cM,
  Efe as cN,
  Cfe as cO,
  Tfe as cP,
  Pfe as cQ,
  Vde as ca,
  Hde as cb,
  Gde as cc,
  Wde as cd,
  jde as ce,
  qde as cf,
  Xde as cg,
  $de as ch,
  Zde as ci,
  Yde as cj,
  Kde as ck,
  Jde as cl,
  Qde as cm,
  efe as cn,
  tfe as co,
  nfe as cp,
  ife as cq,
  rfe as cr,
  sfe as cs,
  ofe as ct,
  afe as cu,
  lfe as cv,
  cfe as cw,
  ufe as cx,
  hfe as cy,
  dfe as cz,
  Wi as d,
  xt as e,
  _b as f,
  Pt as g,
  uE as h,
  ni as i,
  Nq as j,
  Pm as k,
  The as l,
  wi as m,
  kc as n,
  xy as o,
  vD as p,
  qn as q,
  en as r,
  ur as s,
  M2 as t,
  Mb as u,
  kv as v,
  Mr as w,
  ky as x,
  Tt as y,
  Ly as z
};
